[{"title":"第五章","path":"/2024/04/20/inside object mode3/","content":"构造、析构、拷贝语意学 不要在纯虚基类里声明成员变量！ 这是《effective c++》里的一条忠告，现在我们回顾一下。 下面是个漏洞百出的例子，并且围绕漏洞会有所讨论： 12345678910class Abstract_base&#123;public:\tvirtual ~Abstract_base() = 0;\tvirtual void interface() const = 0;\tvirtual const char* mumble() const &#123;return _mumble;&#125;protected:\tchar* _mumble; // damn bug...&#125;; //这个类需要一个显式的构造函数初始化mumble，否则后续使用很容易出问题 可能你想的是后续子类能完成初始化工作。这样想的话，纯虚基类还是要提供一个接口：带有参数的构造函数（最好还是 protected 权限）。 123Abstract_base:: Abstract_base(char* mumble_value = 0) //like this\t:_mumble(mumble_value)&#123;&#125; 真是有够麻烦的……不要再提后面的使用者或修改者忘记赋值之类的问题了。。 最实用的观点还是：不要在纯虚基类里声明成员变量。 但在某些情况下，把子类共享的数据放到基类里也算是一种自然的想法和设计。 纯虚函数的存在 虽然和设计初衷相违背，但纯虚函数确实可以在虚基类里定义甚至调用。 1234567891011121314inline voidAbstract_base:: interface() const&#123;\tfunction\t//...&#125; inline voidConcrete_derived::interface() const&#123;\t//静态调用\t//调用一个pure virtual function\tAbstract_base::interface(); //调用的方式是静态调用而非虚拟机制特有的执行期动态调用。&#125; Pure Virtual destruction 例外是纯虚析构。你必须定义它。 因为析构“树”的存在，子类对象的析构连带着其父类的所有析构，到纯虚基类这里不能缺席啊。 准确来说：静态子类析构会被编译器扩张，静态调用其基类（包括虚基类）的析构函数。析构函数的缺失会导致链接失败。 纯虚函数定义的可能性，使编译器不会在面对纯虚析构函数时停止执行。 另外，编译器不能像默认构造函数那样自动合成纯虚析构函数。 因为编译器对可执行文件采取“分离编译模型”。编译器是看不到那些必要的信息的。 这里的结论秉承上文：不要把虚析构声明成纯虚函数。 虚拟准则（virtual specification） 所谓“虚构准则”：不要把所有成员函数都一刀切的声明为虚函数，并妄想编译器的优化操作能去除非必要的virtual-invocation。 像上例中只是返回成员变量的 Abstract_base::mumble： 因为函数定义内容和继承类型无关，完全没必要 virtual 。 它的non-virtual函数实例是个inline函数，常常调用会拉低效率。 理论上，编译器如果发现整个继承体系中只有这一个virtual函数，是否能将其调用操作转换为静态调用，并允许其调用操作的 inline expansion 呢？ 这么做以后，新的 class 加入又包含了这个单一virtual函数的虚构函数，就会破坏这个优化：函数会被重新编译，产生第二个 virtual 函数实例来配合多态。 (实例能够以二进制形式存放在 library 中) 啊，别把这些麻烦事推给编译器了，记住这句话： 不要为了图省事把所有函数声明为 virtual 。 虚拟准则中 对 const 的态度 注意：语境为虚拟继承体系中 态度：&#x3D;&#x3D;别用const&#x3D;&#x3D; 决定虚函数是否用const 使用const：预期子类对象中的 subclass object 会被使用无数次。 不适用const：该函数将不能获得一个 const 引用和指针。 真正的难题：声明为const，但发现子类对象又要修改相关成员变量。 别用const。 重新考虑 class 的声明 上例的最终版本如下： 1234567891011class Abstract_base&#123;public:\tvirtual ~Abstract_base(); //不再是pure\tvirtual void interface() const = 0; //不再是const const char* mumble() const &#123;return _mumble;&#125; //不再是virtualprotected:\tAbstract_base(char* pc = 0); //新增一个带唯一参数的constructor\tchar* _mumble;&#125;; 5.1 “无继承”情况下的对象构造下面展示产生不同对象的方式 12345678910Point global; //global 内存配置Point foobar()&#123;\tPoint local; //local内存配置\tPoint *heap = new point; //heap内存配置\t*heap = local; //把一个类对象指定给另一个（拷贝赋值） //...stuff... delete heap; //显式 delete 删除 heap object\treturn local;&#125; 注意:这里出现的 Point 数据类型尚未定义，因为接下来会根据不同情况进行分析。 情况1：质朴的C struct1234typedef struct&#123;\tfloat x, y, z;&#125;Point; 普及一个概念：POD —— Plain OI’ Data ，可以理解为与C兼容的 c++ 数据类型。 这里的 Point 便是 POD 。 用C++编译器编译这个POD时： 观念上Point的trival constructor和destructor都会被产生出来并被调用，constructor在程序起始处被调用而destructor在程序的exit()处被调用（exit()是由系统产生的，放在main()结束之前）。然而，事实上那些trival members要不是没被定义，就是没被调用。表现和C编译器没什么区别。 local变量 作为POD没有被构造也没有必要析构，但这里没有初始化 heap object 123Point *heap = new Point;//会被转换为Point *head = __new(sizeof(Point)); //空间而已 没有默认构造函数调用在 new 出来的 Point 对象上。 拷贝赋值 local 如果被初始化了就当然没问题，但没初始化的话问题也不大：local 对象是个POD，所以赋值操作只是简单的C风格的二进制码位搬移。 delete 操作 123delete heap;//转换为__delete(heap); 这个操作理应触发编译器产生的 trival destructor，但析构函数要么没被产生要么没被调用。 函数最后通过传值方式把local传回，这也理应触发 trival constructor，但这里 return 仅仅是个位拷贝操作，因为对象是个POD。 注意例外：global 变量 —— 在C中被视为临时定义：因为它没有显式初始化操作，所以可在程序中定义多次。 定义多次的实例会被链接器折叠起来，只留下单独一个实例，存储在程序 data segment 中一个空间中。 这个空间“特别保留给未初始化的全局对象使用”，称作BBS（Block Started by Symbol）。 在C++中被视为完全定义（它会阻止第二个或更多个定义）。C++根本不支持临时定义，因为class构造行为的应用。 C和C++的一个差异就在于：C++的所有全局对象都被以“初始化过的数据”来对待。 BBS对c++来说没那么重要。 即使C++有能力判断这个类是 class object 还是 POD。 情况2：抽象数据类型1234567class Point &#123;pubblic:\tPoint(float x = 0.0, float y = 0.0, float z = 0.0) : _x(x), _y(y), _z(z) &#123;&#125;private:\tfloat _x, _y, _z;&#125;; 情况3：为继承做准备12345678class Point &#123;public:\tPoint(float x = 0.0, float y = 0.0) : _x(x), _y(y)&#123;&#125;\tvirtual float z();protected:\tfloat _x, _y;&#125;; 5.2 继承体系下的对象构造当我们定义了一个object，如： 1T object 除了会调用其构造函数外，还可能伴随大量的隐藏码：这些隐藏代码由编译器扩充。扩充程度要看 class T的继承体系。 扩充操作如下： &#x3D;&#x3D;初始化列表&#x3D;&#x3D;：在成员初始化列表中的成员变量初始化操作会被放进构造函数本体，并以成员的声明顺序为顺序。 我个人对“以成员的声明顺序为顺序“ 存疑 &#x3D;&#x3D;成员构造函数&#x3D;&#x3D;：成员如果没有被初始化，而它本身有个默认构造函数，这个默认构造函数会被强制调用。 &#x3D;&#x3D;虚表指针（vptr)&#x3D;&#x3D;:如果类对象里有虚表指针，编译器会为其设定初值来指向适当的虚表。 &#x3D;&#x3D;基类构造函数&#x3D;&#x3D;：父辈的基类构造函数会按声明顺序(和成员初始化列表无关)被调用。 如果基类在成员初始化列表中，就应把需要显式指定的参数都传递过去 基类没有在成员初始化列表中，但它有默认构造函数(默认 memberwise 拷贝构造也行)，就调用。 如果基类是多重继承下，第二或后继的基类，this 指针就要有所调整。 调用所有虚基类构造函数（从左到右，从深到浅）： 如果类在成员初始化列表中，就把需要显式指定的参数都传递过去，没有就调用默认构造函数。 类中的虚基类子对象的偏移量，要能在执行期存取。 如果类处于继承体系中最底层，其构造函数会可能被调用，所以其调用机制也要由编译器放进来。 下面结合实际例子，来看看这些扩充机制的必要性。 以Point为例（增加了拷贝函数和虚析构）: 12345678910111213141516class Point &#123;\tPoint(float x = 0.0, float y = 0.0);\tPoint(const Point&amp;);\tPoint&amp; operator=(const Point&amp;);\tvirtual ~Point();\tvirtual float z() &#123; return 0.0; &#125;protected:\tfloat _x, _y;&#125;;class Line &#123;\tPoint _begin, _end; //它由两个点构成~public:\tLine(float = 0.0, float = 0.0, float = 0.0, float = 0.0);\tLine(const Point&amp;, const Point&amp;);\tvoid draw();&#125;； 先看看 line class 的扩充结果： 每一个显式构造函数都会扩充和调用其两个成员类对象(Point)的构造函数。 123Line::Line(const Point &amp;begin, const Point &amp;end)\t:_end(end), _begin(begin)&#123;&#125; 会被编译器扩充为 123456Line* Line::Line(Line *this, const Point &amp;bebgin, const Point &amp;end)&#123;\tthis-&gt;_begin.Point::Point(begin);\tthis-&gt;_end.Point::Point(end);\treturn this;&#125; 于Point声明了一个copy constructor、一个copy operator，以及一个destructor，所以Line class的implicit copy constructor、copy operator和destructor都将是有具体效用的，即non-trivial。 (trivial是没意义的杂项) 再看一个例子： 1Line a; implicit Line copy destructor会被合成出来，同时会调用其成员类对象的析构函数(以构造的相反顺序)。 123456// C++伪代码:合成出来的Line destructorinline void Line::~Line(Line *this) &#123;\tthis-&gt;_end.Point::~Point(); //虽然Point::~Point()是virtual\tthis-&gt;_begin.Point::~Point();//其调用操作仍然会静态决议，在containing class destructor中&#125;//如果Point的析构是inline函数，则会在调用地点扩展。 同理 1234line b = a;//mplicit line copy constructor会被合成出来，成为一个inline public member。a = b;//mplicit copy assignment operator会被合成出来，成为一个inline public member。 最后，多数编译器会缺少对自我指派情况的处理。 1if(this == &amp;rhs) return *this; //like this 然而很多时候都要考虑这种情况，像拷贝操作时忘记： 12345678// 使用者供应的copy assignment operator// 忘记提供一个自我拷贝时的筛选String &amp;String::operator=(const String &amp;rhs) &#123;\t// 这里需要筛选(在释放资源之前) //if(this == &amp;rhs) return *this;\tdelete []str;\tstr = new char[strlen(rhs.str) + 1];&#125; 虚拟继承虚拟继承，啊，还是继承我们的Point class 吧。 123456789101112class Point3d : public virtual Point &#123;public:\tPoint3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point(x, y), _z(z)\t&#123;&#125;\tPoint3d(const Point3d &amp;rhs) : Point(rhs), _z(rhs._z)\t&#123;&#125;\t~Point3d();\tPoint3d &amp;operator=(const Point3d &amp;);\tvirtual float z() &#123; return _z; &#125;protected:\tfloat _z;&#125;; 传统的”constructor扩充现象”并没有用,这是因为 virtual base class 的”共享性”的缘故: 12345678// C++伪代码:不合法的constructor扩充内容Point3d *Point3d::Point3d(Point3d *this, float x, float y, float z) &#123;\tthis-&gt;Point::Point(x, y);\tthis-&gt;__vptr_Point3d = __vtbl_Point3d;\tthis-&gt;__vptr_Point3d__Point = __vtbl_Point3d_Point;\tthis-&gt;_z = rhs._z;\treturn this;&#125; Point3d constructor 扩充内容有错误，这里卖个关子。 现在对不同继承层次对象的初始化策略 12345678//看看这三种派生情况class Vertex : virtual public Point &#123; ... &#125;;//Vertex的constructor必须也调用Point的constructor。class Vertex3d : public Point3d, public Vertex &#123; ... &#125;; //holly shit double inherit//当Point3d和Vertex同为Vertex3d的subobjects时,它们对Point constructor的调用操作一定不可以发生,取而代之的是,作为一个最底层的class,Vertex3d有责任将Point初始化。class PVertex : public Vertex3d &#123; ... &#125;;//更往下的继承,则由PVertex(不再是Vertex3d)来负责完成&quot;被共享的Point subobject&quot;的构造。 传统的初始化策略 传统的初始化策略如果要支持初始化虚基类,会导致constructor中有更多的扩充内容,用以指示 virtual base class constructors应不应该被调用。 constructor的函数本身因而必须尝试测试传进来的参数,然后决定调用或不调用相关的 virtual base class constructors。 下面是Point3d的扩充内容（伪码） 123456789// C++伪代码:在virtual base class情况下的constructor扩充内容Point3d *Point3d::Point3d(Point3d *this, bool __most_derived, float x, float y, float z) &#123;\tif (__most_derived != false) this-&gt;Point::Point(x, y);\tthis-&gt;__vptr_Point3d = __vtbl_Point3d;\tthis-&gt;__vptr_Point3d_Point = __vtbl_Point3d__Point;\tthis-&gt;_z = rhs._z;\treturn this;&#125; 在更深层的继承情况下,例如Vertex3d, 当调用Point3d和Vertex的constructor时,总是会把__most_derived参数设为 false,于是就压制了两个constructors中对Point constructor的调用操作。 123456789101112// C++伪代码:在virtual base class情况下的constructor扩充内容Vertex3d *Vertex3d::Vertex3d(Vertex3d *this, bool __most_derived, float x, float y, float z) &#123;\tif (__most_derived != false) this-&gt;Point::Point(x, y);\t// 调用上一层base classes\t// 设定__most_derived为false\tthis-&gt;Point3d:::Point3d(false, x, y, z);\tthis-&gt;Vertex::Vertex(false, x, y);\t// 设定vptrs\t// 插入user mode\treturn this;&#125; 这样的策略得以保持语意的正确无误.例如, 当定义: Point3d origin 时， Point3d constructor可以正确地调用其Point virtual base class subobject 当定义：Vertex3d cv时， Vertex3d constructor正确地调用Point constructor.Point3d和Vertex的constructor会做每一件该做的事情——对Point的调用操作除外。 &#x3D;&#x3D;结论&#x3D;&#x3D;：只有当一个完整的类对象被定义出来（origin)，虚基类构造函数才会被调用。 如果object 只是个子对象，就不会调用。 某些新的编译器，为了产生更有效率的构造函数，将每个构造函数一分为二： 一个针对完整的object：“完整object”版无条件地调用virtual base constructor，设定所有的vptrs等。 **一个针对 subobject **：“subobject”版则不调用virtual base constructors，也可能不设定vptrs等。 vptr初始化语意学 继承体系下，构造函数的调用顺序 以 PVertex 对象为例，它的构造函数调用顺序： 12345Point();Point3d();Vertex();Vertex3d();PVertex(); 假设每个class都定义了一个virtual function size();返回该class的大小。 我们来看看定义的PVertex constructor： 123456PVertex::Pvertex(float x, float y, float z) : _next(0), Vertex3d(x, y, z), Point(x, y) &#123; if(spyOn)//每个构造函数内含一个调用操作 cerr &lt;&lt; &quot;Within Pvertex::PVertex()&quot; &lt;&lt; &quot;size: &quot; &lt;&lt; size() &lt;&lt; endl;&#125; 在一个类的构造函数或析构函数中，通过构造对象来调用一个虚函数，其函数实例应该是在此类中真正有作用的那个。（本例中“该类”为Point3d） 在Point3d 构造函数中调用的 size() 函数，必须被决议为 Point3d::size() 而非PVertex::size()。 基类构造函数执行时，子类还没有构造起来： Pvertex构造函数没完成前，Pvertex还不是完整对象； Point3d构造函数执行完毕后，紧紧意味着Point3d的子对象构造完毕了 构造函数顺序：由父到子，由内而外。 如何保证适当的重名函数被调用 上面的实现很妥帖，因为每个Pvertex 基类构造函数被调用时，编译器保证了适当的size函数被调用。 如何实现呢？ 静态决议每个调用操作 既然静态决议了，就不要用虚拟机制。 在Point3d 的构造函数里，就调用Point3d 的size()。 如果size()里又调用虚函数，这个调用必须决议为Point3d的函数实例。 其他情况下，这个调用会视作virtual，要通过正常虚拟机制决定执行。也就是说虚拟机制本身要知道这个调用源来不来自一个构造函数中。 在构造函数&#x2F;析构函数中设立一个标志 标志的作用是判断是否要以静态方式决议。 但更好的设计是执行构造函数后，让可能要调用的虚函数数量少些。 决定虚函数数量的关键是虚表。决定虚表如何处理的关键是vptr。 vptr ：决定虚函数调用的关键 vptr的决定效果来自初始化和设定操作。这些操作是编译器的责任，程序员不用瞎操心。 但还是要看看编译器怎么做到的: vptr 什么时候初始化？无非三个情况：1.在其他任何操作前 2.在基类构造函数调用后，但还没进行成员初始化。3.所有操作后 情况2 更好。 令每一个base class constructor设定其对象的vptr，使它指向相关的virtual table之后，构造中的对象就可以严格而正确地变成“构造过程所幻化出来的每一个class”的对象。 一个PVertex对象会先形成一个Point对象、一个Point3d对象、一个Vertex对象、一个Vertex3d对象，然后才成为一个PVeretex对象。 在每一个base class constructors中，对象可以与constructors’s class 的完整对象作比较。对于对象而言，“个体发生学”概况了“系统发生学”。 我的理解是“一个接一个”进化到了“整体”。 constructor的执行步骤： 在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructors会被调用 上述完成之后，对象的vptrs被初始化，指向相关的virtual tables 如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。 最后，执行程序员所提供的代码 12345678910111213141516171819202122232425262728293031323334PVertex::PVertex(float x, float y, float z)_next(0), Vertex3d(x, y, z), Point(x, y)&#123;if(spyOn)&#123;cerr &lt;&lt; “Within PVertex::PVertex()”&lt;&lt; &quot;size: &quot; &lt;&lt; size() &lt;&lt; endl;&#125;&#125;//它可能被扩展为：PVertex* PVertex::PVertex(PVertex *this, bool _most_derived,float x, float y, float z)&#123;//条件式调用virtual base constructorif(_most_derived != false)this-&gt;Point::Point(x, y);//无条件地调用上一层basethis-&gt;Vertex3d::Vertex3d(x, y, z);//将相关的vptr初始化this-&gt;_vptr_PVertex = _vtbl_PVertex;this-&gt;_vptr_Point_PVertex = _vtbl_Point_PVertex;//程序员缩写代码if(spyOn)&#123; cerr &lt;&lt; &quot;Within PVertex::PVertex()&quot; Point3d::Point3d(), &lt;&lt; &quot;size: &quot; &lt;&lt; (*this-&gt;_vptr_PVertex[3].faddr)(this) &lt;&lt; endl;&#125;//传回被构造的对象return this; vptr 的初始化 下面是vptr必须被设定的两种情况： 当一个完整的对象被构造起来时，如果我们声明一个Point对象，Point constructor必须设定其vptr。 当一个subobject constructor调用了一个virtual function(不管是直接调用还是间接调用时)。 如果我们声明一个PVertex对象，然后由于我们对其base class constructors的最新定义，其vptr将不再需要在每一个base class constructors中被设定。 解决之道是把constructor分裂为一个完整的object实体和一个subobject实体。在subobject实体中，vptr的设定可以省略(如果可以的话)。 这样能回答两个问题： 1.类的构造函数的成员初始化列表调用类的虚拟函数，安全吗？ 编译器使 vptr 能保证在成员列表初始化前设定好，挺安全； 函数本身可能会依赖没有设定初值的成员，语意上不太安全。 2.什么时候给基类构造函数一个参数？这种情况，问题1情况还安全吗？ 不安全。vptr 还没设定好或者指向错误的类。该函数存取的任何类成员数据一定还未初始化。 5.3对象复制 对象复制，即研究 copy assignment operator 的语意，看看它们怎么被塑造出来。 bitwise copy 所谓bitwise copy 和 memberwise copy 即深拷贝和浅拷贝。 深拷贝（memberwise copy）和浅拷贝（bitwise copy）的区别在于： 深拷贝(对象拷贝)是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 浅拷贝（按位拷贝）在拷贝指针、引用时，按位拷贝会导致拷贝的指针和原指针指向了同一地址。 利用Point class 来讨论。 1234567class Point &#123;public: Point(float x= 0.0, float y = 0.0); // ... 没有virtual functionprotected: float _x, _y;&#125;; 关于拷贝赋值操作，先看看默认生成的拷贝行为是否够用。 如果够用，那么默认拷贝操作将更有效率，不需要再画蛇添足，重写为新的拷贝操作 默认行为不够用，甚至可能导致一些不安全、不正确的操作，需要自己设计一个 copy assginment operator 。拿上面的Point class来说，默认的 memberwise copy，编译器不会产生示例（类似拷贝构造的情况），因为该类已经有了 bitwise copy 语意(这个 class 人畜无害，没有指针也没有多态)，所以隐式拷贝赋值操作没什么意义。 一个 class 对于默认的copy assignment operator,在下面情况不会表现出bitwise copy语意: 当 class 内带一个member object,而其 class 有一个copy assignment operator时. 当一个 class 的base class 有一个copy assignment operator时. 当一个 class 声明了任何 virtual functions (一定不可以拷贝右端 class object的vptr地址,由于它可能是一个derived class object). 当 class 继承自一个 virtual base class(不论此base class 有没有copy operator)时。 C++ Standard上说copy assignment operators并不表示 bitwise copy semantics 是 nontrivial 。 实际上,只有存在nontrivial instances时才会被合成出来。 123Point a, b;a = b;//其间并没有copy assignment operator被调用. 进行按位拷贝,把Point b拷贝给Point a。 注意: 我们还是可能提供一个copy constructor,来配合 name return value (NRV) 的优化。 copy constructor的出现不应该暗示出也一定要提供一个copy assignment operator 。 继承下的拷贝构造行为 现在导入一个拷贝赋值操作，来说明该操作在继承下的行为 123456789101112inline Point &amp;Point::operator=(const Point &amp;p) &#123; _x = p._x; _y = p._y; return *this&#125;//虚继承class Point3d : virtual public Point &#123;public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0);protected: float _z;&#125;; 如果没有声明拷贝赋值函数，编译器就会合成类似下面的代码： 123456789// C++伪代码:被合成的copy assignment operatorinline Point3d &amp;Point3d::operator=(Point3d *const this, const Point3d &amp;p) &#123; //调用base class的函数实体 this-&gt;Point::operator=(p); // memberwise copy the derived class members _z = p._z; return *this;&#125; 这时，拷贝赋值操作有一个不太理想的情况：缺乏成员初始化列表。 这导致下面的情况将不存在： 1234567// C++伪代码,下面性质并不支持inline Point3d &amp;Point3d::operator=(const Point3d &amp;p3d) : Point(p3d), z(p3d._z)&#123;&#125;//取而代之的是Point::operator=(p3d);//或(*(Point *)this) = p3d; 缺乏初始化列表，在继承体系中该如何阻止基类的拷贝操作 为什么要阻止呢？ a 看下面的例子： 1234567891011// class Vertex : virtual public Pointinline Vertex &amp;Vertex::operator=(const Vertex &amp;v) &#123; this-&gt;Point::operator(v); _next = v._next; return *this;&#125;inline Vertex3d &amp;Vertex3d::operator=(const Vertex3d &amp;v) &#123; this-&gt;Point::operator=(v); this-&gt;Point3d::operator(v); this-&gt;Vertex::operator=(v);&#125; 传统的 constructor 解决方案：附加额外参数 附加额外参数没用，因为：取拷贝赋值函数地址是合法的，下面的使用将推翻拷贝赋值函数的设计。 123typedef Point3d &amp;(Point3d::*pmfPoint3d) (const Point3d &amp;);pmfPoint3d pmf = &amp;Point3d::operator=;(x.*pmf)(x); 仍然需要根据其独特的继承体系,插入任何可能数目的参数给copy assignment operator 为copy assignment operator 产生分化函数（split function) 产生后，希望函数能支持这个类成为中间基类或最底层子类。 最好让编译器借助分化函数产生拷贝赋值操作。class-defined user 亲自操刀，可能面临某些函数很难分化的困境： 123inline Vertex3d &amp;Vertex3d::operator=(const Vertex3d &amp;v) &#123; init_bases(v);//甚至让它成为虚函数&#125; copy assignment operator在虚拟继承情况下很复杂,需要特别小心地设计和说明. 如果使用一个以语言为基础的解决方法,那么应该为copy assignment operator提供一个附加的**”member copy list”**。 简单地说,任何解决方案如果是以程序操作为基础,将导致较高的复杂度和较大的错误倾向. 一般公认,这是语言的一个弱点,也是应该小心检验程序代码的地方(当使用 virtual base classes时). 语言为基础的方法：在子类拷贝函数示例最后调用那个 operator 在derived class 的copy assignment operator函数实体的最后,明确地调用那个operator 123456inline Vertex3d &amp;Vertex3d::operator=(const Vertex3d &amp;v) &#123; this-&gt;Point3d::operator=(v); this-&gt;Vertex:;operator=(v); // must place this last if your compiler dose not suppress intermediate class invocations this-&gt;Point::operator=(v);&#125; 这并不能省略subobjects的多重拷贝,但却可以保证语意正确.另一个解决方案要求把 virtual subobjects拷贝到一个分离的函数中,并根据call path条件化调用它。 最好的办法是 尽可能不要允许一个 virtual base class 的拷贝操作。 甚至有一个奇怪的方法是: 不要在任何 virtual base class 中声明数据 5.4对象的效能（略）略 5.5析构语意学析构函数不是所有情况都是必要的 如果class没有定义destructor，那么只有在class内含的member object(或者是class自己的base class)拥有destructor的情况下，编译器才会合成出一个来。 否则，destructor被视为不需要，也就不需要被合成（当然更不需要被调用）。 下面举出一个没有合成析构函数的 class （它甚至还有个虚函数） 12345678 class Point &#123;public:\tPoint(float x = 0.0, float y = 0.0);\tPoint(const Point&amp;);\tvirtual float z();private:\tfloat _x, _y;&#125;; 类似的道理，如果把两个Point对象组合成一个Line class: 123456class Line &#123;public:Line(const Point&amp;, const Point&amp;); virtual draw();protected:\tPoint _begin, _end;&#125;; Line也不会拥有一个被合成出来的destructor，因为Point并没有destructor。 当我们从Point派生出Point3d(即使是一种虚拟派生关系)时，如果我们没有声明一个destructor，编译器也就没必要合成一个destructor。 你应该拒绝某种强迫症：你已经定义了一个constructor，所以你觉得提供一个destructor是天经地义的事情。事实上，程序员应该根据需要而非感觉来选择是否提供destructor。 怎么判断 class 是否需要一个程序层面的析构函数&#x2F;构造函数考虑标准： 保证对象完整性 类对象生命周期的起点和终点 析构函数顺序： 一个程序员定义的析构函数的扩展方式与构造函数方式相同，但顺序相反: destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设（reset）。 如果class拥有member class objects，而后者拥有destructors，那么它们会以声明顺序的相反顺序被调用。 如果object内含一个vptr，那么首先重设（reset）vptr来指向相关的virtual table。 如果有任何直接的（上一层）nonvirtual base classes拥有destructor，它们会以其声明顺序的相反顺序被调用。 如果有任何virtual base classes拥有destructor，到目前讨论的这个class的最尾端（most-derived）的class，那么它们会以其原来的构造顺序的相反顺序被调用。 析构函数的最佳实现策略和5.2章节最后，构造函数采取的“一分为二”法一样： 就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实例：1、一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructors。2、一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。 一个object的生命结束于其destructor开始执行之时。由于每一个base class destructor都轮番被调用，所以derived object实际上变成了一个完整的object。 例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象，一个Point3d对象，最后成为一个Point对象。 当我们在destructor中调用member functions时，对象的蜕变会因为vptr的重新设定（在每一个destructor中，在程序员所供应的代码执行之前）而受到影响。 举个例子： 1234567&#123;\tPoint pt;\tPoint *p = new Point3d;\tfoo(&amp;pt, p); ...\tdelete p;&#125; pt 、 p 作为参数之前，要初始化为坐标值，通过构造函数或显式提供坐标值。 类使用者没法检验local或heap变量是否需要初始化。 所以构造函数很有必要。 那么显式delete掉 p 是否需要提前处理呢？ 1p-&gt;x(0);p-&gt;y(0); //like this 没必要。没有任何理由说在delete一个对象之前先得将其内容清除干净。 如果确保在结束pt和p的生命之前，没有任何和该 class 有关的程序操作是必要的，往往不一定会需要一个destructor。 例外情况 ：delete 存在“结束前和该 class 有关的程序操作” 考虑Vertex class，它维护了一个由紧邻的顶点所形成的链表，并且当一个顶点的生命结束时，在链表上来回移动以完成删除操作。如果这正是程序员所需要的，那么这就是Vertex destructor的工作。 这个delete 存在“结束前和该 class 有关的程序操作” 当我们从Point3d和Vertex派生出Vertex3d时，如果我们不供应一个explicit Vertex3d destructor，那么我们还是希望Vertex destructor被调用，以结束一个Vertex3d object。 因此编译器必须合成一个Vertex3d destructor，其唯一任务就是调用Vertex destructor。 如果我们提供一个Vertex3d destructor，编译器会扩展它，使它调用Vertex destructor(在我们所供应的程序代码之后)。","tags":["cpp"]},{"title":"第四章","path":"/2024/04/20/inside object mode2/","content":"第四章 Function 语意学 (The Semantics of Function)前言： 12345678910111213141516float Point3d::magnitude()const &#123;\treturn sqrt(_x*_x + _y*_y + _z*_z);&#125;Point3d Point3d::normalize()const &#123;\t/*\t用register说明的局部变量称为寄存器变量，该变量将可能以寄存器作为存储空间。\tregister说明仅能建议（而非强制）系统使用寄存器，这是因为寄存器虽然存取速\t度快，但个数有限，当寄存器不够用时，该变量仍按auto变量处理。\t*/\tregister float mag = magnitude();\tPoint3d normal;\tnormal._x = _x / mag;\tnormal._y = _y / mag;\tnormal._z = _z / mag;\treturn normal;&#125; 下面我们进行操作： 12345Point3d obj;Point3d *ptr=&amp;obj;//What Will Happen?obj.normalize();ptr-&gt;normalize(); 这里还无法确定实际的操作。 C++支持三种函数调用：static func , nontatic func , virtual func 。 每种方式都不同，也是我们接下来要区分的。 这里可以确定 normalize() 和 magnitude() 两函数绝不是 staic。 原因： 可以直接存取 nonstatic 数据 它被声明为了const 注释：static 数据没有隐式 this 指针，同理 static 成员不是任何对象的成分（元素），没有 const 对应的“不修改所属对象的成员属性”一说。 4.1Member 的三种调用方式Nonstatic Member Function1.nonstatic 成员函数至少和 nonmember function 有相同效率 达成这个效果，是因为编译器内部已将 成员函数 转换成了对等的 non-member 函数 举个例子吧： 123float magnitude3d(const Point3d *_this) &#123;\treturn sqrt(_this-&gt;_x*_this-&gt;_x + _this-&gt;_y*_this-&gt;_y + _this-&gt;_z*_this-&gt;_z);&#125; 反差：利用 this 指针 不断间接取用坐标成员好像降低了效率，不同于非成员函数的直接取用。 转化步骤： 改写函数原型（signature)，安插一个 this指针 作为额外参数到成员函数中，从而使类对象被直接调用。 const 成员函数，其额外参数 this 指针同样是 const *this pointer。 将后续操作中涉及存取 nonstatic data member 的，改为通过 this 指针存取。 123return sqrt(_this-&gt;_x*_this-&gt;_x + _this-&gt;_y*_this-&gt;_y + _this-&gt;_z*_this-&gt;_z); 将成员函数重新写成一个外部函数 为了防止重名，函数名会经过 mangling 处理，成为绝不会重名的词。 1extern magnitude__7Point3dFv( register Point3d *const this); 成员函数转换为外部函数，意味着调用操作也完成了转换： obj.magnitude();变成了magnitude__7Point3dFv(&amp;obj); ptr-&gt;magnitude();变成了magnitude__7Point3dFv(ptr); 这时回到原题：normalize函数的调用问题。 12345678910//伪码void normalize__7Point3dFv(register const Point3d *const this,\tPoint3d &amp;__result) &#123;\tregister float mag = this-&gt;magnitude();\t__result.Point3d::Point3d();//default constructor\t__result._x = this-&gt; _x / mag;\t__result._x = this-&gt; _x / mag;\t__result._x = this-&gt; _x / mag;\treturn;&#125; 这是转变情况之一。 另外一种情况是利用Point3d的构造函数构造匿名对象简化操作： 1234Point3d::Point3d::normalize()const &#123;\tregister float mag = magnitude();\treturn Point3d(_x / mag, _y / mag, _z / mag);&#125; 转化(假设拷贝构造相关操作已完成，NRV优化^1也已实现)： 12345void normalize__7Point3dFv(register const Point3d *const this, Point3d &amp;__result) &#123;\t//调用拷贝构造函数\t__result.Point3d::Point3d(this-&gt;_x / mag, this-&gt;_y / mag, this-&gt;_z / mag);\treturn;&#125; 节省了默认构造初始化的额外负担。 2.名称的特殊处理（Name Mangling) 编译器的处理下，通常成员名称前会被加上类名称。 123class Bar&#123;public: int ival;&#125;//成员 ival 经过Name Mangling 后的可能结果：ival_3Bar Name Mangling的原因：便于区分重名变量。 1.子类继承时重名 1class Foo:public Bar&#123;public:int ival;&#125; 子类Foo和父类发生成员变量重名的情况；编译器为了区分会处理名称： 12345class Foo &#123;public: int ival_3Bar; int ival_3Foo;&#125; 2.成员函数重载时重名 12345class Point &#123;public:\tvoid x(float newX);\tfloat x();&#125;; 简单转换为 123456789101112class Point &#123;public:\tvoid x__5Point(float newX); float x__5Point(); &#125;;//会导致被重载的函数实例拥有相同名称。//为了区分，还需要加上它们的参数链表，同时把参数类型也编码进去，就能够防止重复。class Point &#123;public:\tvoid x__5PointFf(float newX);\tfloat x__5PointFv();&#125;; 这就是cfront的编码方法。目前还没有Name Mangling 的工业标准统一这一行为。 Name Mangling 能实现有限的类型检验： 声明和定义两部分参数类型不一致的函数，会产生不同的编码名称，这就会导致链接时期无法 resolved 而失败。 有限之处在于它只能涉足函数签名（signature），不能检测返回值。 拓展： 现在的编译系统中，有一种 demangling 工具，能把编码后的名称转换回去。这个系统内会存储两种名称：”mangled 之前“和”mangled 之后”。 这会导致一种误导行为：编译器错误信息提示时，使用源码名称；链接器却使用编码后的内部名称。 把内部名称（mangled 编码后）给 user 看会让 user 一头雾水。 Virtual Member Function第三章讲过，如果normalize()是个虚拟成员函数: 1234567ptr-&gt;normalize()//converse to (*ptr-&gt;vptr[1])(ptr);register float mag = (*this-&gt;vptr[2])(this);//converse to register float mag = (*this-&gt;vptr[2])(this); vptr : 指向 virtual table 的指针，由编译器产生安插在 virtual function -involved class 中。 vptr也会被 name mangling 处理。 1 是 virtual table slot 索引值，关联到 normalize 第二个 ptr 表示 this 指针。 这里还不是最终版本，因为这段代码还有值得优化的地方： 在上面的 code segmeng 中，magnitude() 是在 normalize() 中被调用的，后者由虚拟机制 resolved 后，可以直接显式调用 Point3d 实例中的 magnitude 函数。 大家都在一个类中，我又处在你的作用域里。 12register float mag=Point3d::magnitude();//直接调用算了，这能回避不必要的虚拟机织重复调用操作 还可以继续优化：将 magnitude() 声明为 inline 函数。这样一来代码会变成： 1reginster float mag = magnitude__7Point3dFv(this); //mangled name！ 通过 this 指针指出对象所在位置的同时调用虚函数，resolve 的状态会和非静态成员函数一样！ 另外，对于函数 obj.normalize()转换成(* obj.vptr[1])(&amp;obj)的意义不大。 因为这个情况中的类对象并不支持多态，所以通过 obj 实例调用的函数只能是 Point3d::normalize()。 通过类对象调用虚函数，会被编译器如同对待非静态成员函数一样，迅速完成 resolved ，成为带对象参数的普通函数调用。 此时，这个虚函数还成为了 inlined function 实例，能够在后续应用中广泛扩展，提高效率。 123obj.normalize(); //not to (* obj.vptr[1])(&amp;obj) //converse to normalize__7Point3dFv(&amp;obj); Static Member Function123456789//如果Point3d::normalize()是一个static member function，以下两个调用操作：obj.normalize();ptr-&gt;normalize();//将被转换为一般的nonmember函数调用，//obj.normalize()↓normalize__7Point3dSFv();//ptr-&gt;normalize()↓normalize__7Point3dSFv(); 对静态成员函数的处理，要分为“引入静态成员函数前”（cfront2.0引入）和引入后。 1.引入前的处理： 抛开上面的例子，看一个很有特点的函数形式： 12((Point3d*) 0 )-&gt;object_count();//嗯，这个 object_count 只是简单传回 _object_count 这个简单静态成员变量。 这种函数形式出现的原因： 引入…前，CPP要求所有的成员函数都必须通过对应类的实例对象来调用。 这也是 this 指针的重要作用之一 this 指针把 &#x3D;&#x3D;在成员函数中存取的非静态成员&#x3D;&#x3D; 绑定在了 &#x3D;&#x3D;类对象内的相应成员&#x3D;&#x3D;上。 但事实上： 只有当成员函数中，存在非静态成员变量的存取时，才需要类对象。 其他情况根本用不到 class object 。 成员函数如果没有成员被存取，那么它压根就不需要 this 指针。也没有必要强行要求通过一个类对象的实例来调用这个成员函数。 这种情况下，如果设计者把静态成员变量声明为 非public ，他就必须提供很多成员函数来存取这个成员变量。 这时，即使静态成员变量不需要类对象去存取，可对应的存取函数还是需要类对象，这就是一种无奈的绑定关系。 所以脱离类对象的一些存取操作还是很重要的。上面的奇葩函数形式就是这种脱离需求下的产物： 123((Point3d*) 0 )-&gt;object_count();//将 0 强转为一个类指针，来提供一个略显生硬的 this指针实例。//（生硬之处：还是在费尽心机去贴合成员和对象间的绑定关系。） 这时，为了让独立于类对象的一些存取函数操作更自然：静态成员函数引入了。 2.引入后的处理 我们来看看引入的静态成员函数特性： 没有 this 指针。 不能直接存取所属类中的非静态成员。 不能被声明为 const、volatile、virtual。 不需要通过类成员去调用。 首先关于静态成员函数的“.”语法（打官腔叫“member selection”），编译器是这样处理的： 1234567891011//类成员实例的直接调用：Point3d p3;if(p3.object_count() &gt; 1) ...//converse to if(Point3d::object_count() &gt; 1) ... //通过表达式获得类成员的调用if(foo().object_count() &gt; 1) ...//converse to(void) foo();//foo()函数还是被调用了，只是没有蹩脚的返回值而已。if(Point3d::object_count() &gt; 1)... name mangled 效果： 12345678unsigned int Point3d::object_count() &#123;\treturn _object_count;&#125;//converse to unsigned int object_count__5Point3dSFv() &#123;//额，这里的SFv表示它是一个static member function,拥有一个void(空白)的参数\treturn _object_count__5Point3d;&#125; 取地址 如果此时你想取一个 静态成员函数 的地址，将获得其在内存中的地址。 这和其类成员实例无关，且类型不是指向类成员函数的指针(它和this指针已经没有关系)，而是一个实实在在的&#x3D;&#x3D;非成员函数指针&#x3D;&#x3D;。 12345&amp;Point3d::object_count();//会得到一个数值，类型是unsigned int(*)(); // right!//而不是unsigned int(Point3d::*)(); //wrong. 静态成员函数没有了this指针束缚，效果几乎等同于非成员函数了。 扩展： 一个意想不到的好处：static member function 成为了一个回调函数（callback func）。 这有利于CPP和 C-based X Window 系统的兼容，也可以自然的应用在线程(thread)函数上。 4.2 虚拟成员函数这一章我们会从头到尾过一遍设计虚函数模型的过程。 老生常谈的模型：一个类，里面有虚表，虚表里存储着虚函数的地址。该类的每个实例对象都会自带一个虚指针，指向这个虚表，来完成多态调用。 执行期多态的实现 既然是虚函数，那么看到这个操作： 1ptr-&gt;z(); 你面对的第一个问题便是执行期类型判断（runtime type resolution）。 先从编译期多态的尝试走起： 尝试把信息绑定在函数指针上 判断方式里，最自然的想法是将帮助判断对象的信息绑定在ptr身上。 这种策略下，通常一个指针需要的信息有： 它所指向的对象地址 对象类型的编码或者结构信息的地址。 Ps：结构信息是用来分辨对象函数实例的，即help resolved to z()。 这种策略的问题： 空间负担 和C程序的链接不再兼容。 如果这些额外信息不和指针放在一起，那就只能放在对象(class&#x2F;struct)的身上了。 类似这种形式：struct data&#123; int m,d,y; &#125; （这种形式没有摆脱把信息与指针绑定的弊端） 如果为了C兼容性，而要求这种策略只针对class，也不能解决问题。 因为 struct 可能会发生多态，而 class 可能并不需要这些冗余信息。 执行期 尝试半天，这个责任还是落到了执行期。所以执行期多态到底怎么实现呢？ 多态的定义： 在C++中，多态表示以一个public base class的指针（或引用），寻址出一个derived class object的意思。 123Point *ptr;ptr = new Point2d;ptr = new Point3d; 消极多态： 让ptr扮演输送机制的角色，仅仅让基类指针指向子类对象，而没有其他操作。 积极多态： 指出的对象通过指针被使用。 12345//1.ptr-&gt;z(); //ptr指向了子类//2.Point3d *p3d=dynamic_cast&lt;Point3d *&gt;(ptr)p3d-&gt;z();//这就说明是Point3d的_z函数 仅仅是这种操作还不够。因为我们无从知晓ptr指向的是基类还是子类或者它有没有实现多态。 结论： 识别一个class是否支持多态，只能看它&#x3D;&#x3D;是否有虚函数&#x3D;&#x3D;。只要要虚函数，它就需要额外的执行期信息。 存储的额外信息什么？ 现在我们知晓了一个类要实现多态，需要执行期信息来完成正确多态操作。 需要的信息： ptr所指对象的真实类型，方便找到正确的实例（如z() 对象实例的位置，方便ptr调用 实现： 一个字符串或数字来表示类的类型 一个指向表格的指针，该表格存储虚函数执行期地址 这时，vptr和 virtual table 很自然的出现了。 剩下的问题是，虚表怎么找到并构建这些地址？ 找到地址：虚函数地址在编译期就能通过类对象找到。而且这些地址固定不变，不需要执行期介入。 存储建构： 由编译器在每个类对象中安插一个指针指向该表格。 每个虚函数生成一个表格索引值，帮助表格寻找地址。 PS：表类似一个数组，索引值即下标，元素是虚函数地址。 (编译器立大功。) 这些都是编译期工作。执行期只是通过 virtual table slot (那些索引)找到地址，然后触发虚函数。 关于虚表的详细探讨： 一个class 只有一个虚表，每个表里有积极虚函数实例地址。 积极虚函数(active virtual func): 这一class所定义的函数实例。它会改写一个可能存在的base class virtual function函数实例 继承自base class的函数实例。这是在derived class决定不改写virtual function时才会出现的情况（也就是单纯的继承） 一个pure_virtual_called()函数实例（纯虚函数，没有内容），可以用来保存纯虚函数的空间，或当作执行期的异常处理函数等。 举个例子： 1234567891011class Point &#123;public:\tvirtual ~Point();\tvirtual Point&amp; mult(float) = 0;\tfloat x()const &#123; return _x; &#125;\tvirtual float y() const &#123; return 0; &#125;\tvirtual float z() const &#123; return 0; &#125;protected:\tPoint(float x = 0.0);\tfloat _x;&#125;; 解释：虚析构函数生成 slot 1，mult() 生成 2，y() 和 z() 分别为 slot3 slot4。 x()不是虚函数，没有slot。 PS：mult()作为纯虚函数，没有定义。如果意外调用，直接结束掉。 继续深入一下，找个 class 继承 Point 会是什么结构呢？ 1234567891011class Point2d :public Point &#123;public:\tPoint2d(float x = 0.0, float y = 0.0) :Point(x), _y(x) &#123;&#125;\t~Point2d();\t//改写base class virtual functions\tPoint2d&amp; mult(float);\tfloat y()const &#123; return _y; &#125;protected:\tfloat _y;&#125;; 一共又三种可能性： 1.它可以继承base class所声明的virtual functions的函数实例。正确地说是，该函数实例的地址会被拷贝到derived table的相对应slot之中。比如上图中的#4位置 2.它可以使用自己的函数实例，也就是在base class中的virtual function上做改变了。这表示它自己的函数实例地址必须放在对应的slot之中。比如上图中的#2、#3位置 3.它可以加入一个新的virtual function。这时候virtual table的尺寸会增大slot，而新的函数实例地址则会被放入该slot之中 ( Point2d的virtual table在slot1中指出析构函数，而在slot2中指出mult()(取代纯虚函数)。它自己的y()函数实例放在slot 3中，继承自Point的z()函数实例地址则被放在slot 4中。 ) 继续继承： 1234567891011class Point3d :public Point2d &#123;public:\tPoint3d(float x = 0.0, float y = 0.0, float z = 0.0) :Point2d(x, y), _z(z) &#123;&#125;\t~Point3d();\t//改写babse class virtual functions\tPoint3d&amp; mult(float);\tfloat z()const &#123; return _z; &#125;protected:\tfloat _z;&#125;; 其virtual table中的slot 1位置放置Point3d的destructor，slot 2放置Point3d::mult()函数地址，slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z()函数地址。 现在，让我们再次面对ptr-&gt;z(); 如何在编译期设定虚函数的调用？ 可以解答如下了： 1.一般而言，在每次调用z()时，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table。 2虽然我不知道哪一个z()函数实例会被调用，但我知道每一个z()函数地址都被放在slot4中，从上面的图可以看出来。 由这两条信息使得编译器可以将该调用转化为： 123（*ptr-&gt;vptr[4]）(ptr);//编译期工作：vptr指向vitrual table，生成编号 slot4//执行期工作：知道 slot 4 指向的那个z()示例 这是单一继承下，虚函数的实现过程。 多重继承下的虚函数 编译期实现多态的困境 多重继承中虚函数的复杂度，主要来源于第二个或后续基类和执行期 this 指针的调整。 示例： 1234567891011121314151617181920212223242526class Base1 &#123;public:\tBase1();\tvirtual ~Base1();\tvirtual void speakClearly();\tvirtual Base1 *clone() const;protected:\tfloat data_Base1;&#125;;class Base2 &#123;public:\tBase2();\tvirtual ~Base2();\tvirtual void mumble();\tvirtual Base2 *chone() const;protected:\tfloat data_Base2;&#125;;class Derived :public Base1, public Base2 &#123;public:\tDerived();\tvirtual ~Derived();\tvirtual Derived *clone() const;protected:\tfloat data_Derived;&#125;; 让 Derived 支持虚函数困难度落在了 Base2 子对象上。 这里我的理解是，Base1和Derived的指针位置是一样的，都为0；而Base2指针的指向地址则&gt;是0 + sizeof(base1)。这时我们面前有三个问题：1.虚析构2.继承而来的Base2::mumble()3.一组clone()函数实例。 这时，我们尝试多态操作： 指针赋值 12345Base2 *pbase2 = new Derived;//编译期的代码会变成这样：Derived* temp = new Derived;Base2 *pbase2 = temp?temp + sizeof(Base1) : 0;//这里的思想第三章有阐释（例如不这样做，相关 base2 调用会失败） 删除 1delete pbase2; 这里出现了问题：指针必须再次调整，因为要指向Derived对象的起始处。但这个指向涉及的偏移量操作已经不能在编译期设定，因为 pbase2 指向的真正对象根本确定不了（该死的多态），除非在执行期。 1、这里是开头所说的问题之一：虚析构。 delete pbase2的时候Derived,Base1,Base2的析构函数都要被调用。 因为一个Derived对象中含有Base1和Base2的subobject，所以也需要调用它们的析构函数销毁它们的对象并释放内存空间(当然只有析构函数是这样）。 父类子对象可能有很多种多态情况，因此我们无法确定其指向的真正对象，（不同对象的偏移量不同），所以不能在编译期准确调用其析构函数。 1234567//本例中的多态就有两种情况//两个new返回的都是首地址：子类子对象在地址0处，父类子对象在0+sizeof(Base2)处Base2 *pbase2 = new Derived; //该情况不需要偏移（甚至不需要this）Base2 *pbase2 = new Base2; //该情况需要偏移//于是编译器处理的两种结果不同(*pbase2-&gt;vptr[1])(pbase2 + offset???) 而且有无偏移量是一种情况，偏移量是多少又是一种情况（比如后续基类的Base3，Base4 …） 另外，调用虚析构函数时 this 指针发生了偏移(指向pbase2 到 指向 derived ，因为你需要调用人家的函数)。我既需要调整后的derived对象的起始地址，我又需要调整前的pbase2::vptr，来指向子类析构函数实际地址。 这里出现矛盾：我同时需要调整前后的信息。编译器如何实现的情况，我的理解是： 1.调整前先通过pbase2找到vptr中Derived的析构函数地址， 2.隐式地传this指针时才会调整指回整个Derived对象的起始地址，像这样： 12(*pbase2-&gt;vptr[1])(pbase2+offset);\t//pbase2-sizeof(Base1)//左括号调整前，右括号调整后 执行期解决方案：替代加大虚表的方法：&#x3D;&#x3D;thunk设计&#x3D;&#x3D; 执行期解决的一般的思路是，通过第二或后续的基类指针调用子类虚函数。 该操作必需的“this指针调整”操作，必须在执行期完成。 这意味着，操作的信息：offset的大小，以及把offset加上this指针的那一小段代码必须由编译器安插在某个地方。 问题是，在那个地方？ 最自然（最笨）的方法是，都塞到虚表里，把虚表加大，来容纳这些偏移信息和地址。 虚表的 slot 也从整型之类的数字类型变成了结构体。 1234(pbase2-&gt;vptr[1])(pbase2);//改变为：(*pbase2-&gt;vptr[1].faddr) (pabse2 + pbase2-&gt;vptr[1].offset) 毫无疑问，太大了。不需要这些信息的空间也被塞满了。 thunk：主角登场 thunk是一小段汇编代码，实现：1.调整this指针偏移量 2.跳到目标虚函数中 123pbase2_dtor_thunk: this += sizeof(base1); Derived::~Derived(this); 所以可以暂时将thunk理解成一个函数，它是对上述两点操作的封装（调整this指针和调用对应的函数），只不过它是用汇编语言写才有效率可言。 thunk 让 虚表 slot 内含一个简单指针，要么指向虚函数，要么指向一个thunk（也就是要调整this指针时）。 但一个问题是，就如我们分析编译期局限性时一样，可能有多个不同继承层级的对象来调用同一个析构函数，这时的偏移量是不同的，对应slot也不同。 最高层级且处于最左侧的类对象，甚至不需要偏移量——它和子类对象的起始地址一样。这时slot直接放真正的调用函数地址就好了。 多重继承下，一个派生类内含n-1个额外的虚函数表，n表示上一层基类的数目(因此单一继承不会有额外的虚函数表)。如果子类有额外的虚函数，会存放在第一个基类的虚函数表里。 对本例Derived而言，编译器会产生有两个虚函数表。 分别对应 Base1 和 Base2 。针对每个虚表，子类对象都会有专门的 vptr ，且这些 vptr 会在构造函数中被赋初值（编译器的工作喽） 于是子类对象地址赋给子类指针或父类指针，就会产生多态效果——根据不同的类型，用不同表格来处理。 执行期链接器处理符号链接这种东西可能有点慢。一个思路是将多个虚表连接成一个：次要表格（次要仅从继承顺序上说）的获取只需要主要表格地址加上偏移量。 后续基类影响虚函数运行的&#x3D;&#x3D;三种情况&#x3D;&#x3D; 这三种情况在上面的图里有所反映 通过指向同层、次级父类的指针，调用子类虚函数 1234Base2 *ptr = new Derived;//调用Derived::~Derived//ptr要减去sizeof(Base1)个bytesdelete ptr; 之前已经讨论过，为了正确执行，ptr必须调整指向子类对象的起始处 （整个对象地址的 0） 通过指向子类对象的指针，调用同层、次级父类继承而来的父类自己的虚函数 1234Derived *pder = new Derived;//调用Base2::mumble()//pder要加上sizeof(Base1)个bytespder-&gt;mumble(); 第一种情况的逆向。到父类子对象那里调用父类的虚函数 允许一个virtual function的返回值类型有所变化，可能成为base type，也可能是publicly derived type。 1234Base2 *pb1=new Derived;//调用Derived* Derived::clone()//返回值必须被调整，以指向Base2 subobjectBase2 *pb2=pb1-&gt;clone(); Derived::clone()传回一个Derived类指针，改写了它的两个基类的函数体。当我们通过指向第二个基类的指针来调用clone()时，this指针的offset问题就会产生： 当进行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址，所以调用的是Derived::clone()。它会传回一个指针，指向一个新的Derived对象，该对象的地址在被指定给pb2前，必须先经过调整，以指向Base2 subobject。 书中还提供了两种提高效率的方法，一种是sun编译器的”split function”，一种是微软的“address points” 虚继承下的虚函数1234567891011121314151617class Point2d &#123;public:\tPoint2d(float = 0.0, float = 0.0);\tvirtual ~Point2d();\tvirtual void mumble();\tvirtual float z();protected:\tfloat _x, _y; //纯纯毒瘤&#125;;class Point3d : public virtual Point2d &#123;public:\tPoint3d(float = 0.0, float = 0.0, float = 0.0);\t~Point3d();\tfloat z();protected:\tfloat _z;&#125;; 图右下角的两个vtbls内容有错。至少mumble()应该是Point2d::mumble 而不是 Point3d::mumble。 此例反映出的唯一有用的信息便是虚继承下的内存空间排布和正常继承不一样，并且一旦虚基类中虚继承了另一个虚基类，整个内存空间会非常混乱。this 指针的调整就会复杂难辨。 所以我们的启示只有一个：不要再虚基类里声明 nonstatic data members 。 指向成员函数的指针 nonstatic 成员函数 和 nonstatic 成员变量与类对象的绑定 取非静态成员变量的地址，是它在类中的相对byte位置（可能+1），这个offset需要类对象的地址，也就是绑定关系。 取非静态成员函数的地址，如果函数为non-virtual，它就和成员变量一样，是个绑定在类对象上的offset 地址。 对象地址来自 this指针 。 指向成员函数的指针 1234567891011121314//double是返回值类型//Point::*说明是Point类成员，pmf是成员指针名//最后的()是参数列表double (Point::*pmf)();\t//两种方法定义并初始化该指针的两种方法：double (Point::*coord)() = &amp;Point::x;coord=&amp;Point::y;//调用的两种方法：(origin.*coord)();(ptr-&gt;*coord)();//分别会被转换成（C++伪码）(coord)(&amp;origin);(coord)(ptr); 指向成员函数的指针的声明语法，以及指向“member selection”运算符（-&gt;或 .）的指针，这两部分的作用是为this指针保留空间。 所以静态成员函数的类型是函数指针，因为他们不需要 member selection ，更不需要 this指针。 在没有虚函数，多重继承，虚拟继承的情况下，编译器可以让 使用成员函数的指针与使用非成员函数的指针 的&#x3D;&#x3D;效率相同&#x3D;&#x3D;。 支持“指向虚拟成员函数”的指针 需求场景 123456//z()是个虚函数(Point::*pmf)()=&amp;Point::z;Point *ptr=new Point3d;ptr-&gt;z();\t//调用Point3d::z()(ptr-&gt;*pmf)(); //调用Point3d::z() ptr 调用 z()，被调用的是 Point 3d::z()； ptr 通过 pmf 调用z（）,被调用的还能是 Point3d 中的 z 吗？ 答案是肯定的。 实现方法 首先，虚函数真正地址在编译期未知，只能知道它的 virtual table slot。 1234567891011121314class Point&#123;\tpublic: virtual ~Point(); float x(); float y(); virtual float z();&#125;;&amp;Point::~Point; //得到虚函数表里的索引1&amp;Point::x();\t//得到内存地址&amp;Point::y(); //得到内存地址&amp;Point::z();\t//得到虚函数表里的索引2//通过 pmf 调用 z()，会被内部转化为编译期的式子：(*ptr-&gt;vptr[(int)pmf])(ptr); //大概是这个样子了 于是函数指针就有了两个意义：普通成员函数的内存地址和虚函数的slot专属版。 12//pmf内部定义float(Point::*pmf)(); 这个函数要具备能寻址两种类型的成员函数的能力： 123float Point::x() &#123; return _x;&#125; //一长串吧float Point::z() &#123; return 0;&#125; //小串//都可以指定给 pmf 于是pmf有两个功能： 能持有两种数值（注意不是同时) 能区分这个数值是内存地址还是虚表索引值 cfront2.0的解决办法： 12345(((int)pmf)&amp;~127) ?(*pmf)(ptr):(*ptr-&gt;vptr[(int)pmf](ptr)); 这个实现只能应用在继承体系中最多只有128个虚函数的情况。 多重继承下，指向成员函数的指针如题，怎样让指向成员函数的指针在多重继承下可行？ Stroustrup的方法： 12345678910111213141516struct __mptr &#123;\tint delta;\tint index; //表现 虚表索引 （用不到就设为-1）\tunion &#123; ptrtofunc faddr; //表现 成员函数 int v_offset;\t&#125;;&#125;;(ptr-&gt;*pmf)();//转换为(pmf.index &lt; 0) ? //non-virtual\t(*pmf.faddr)(ptr) :\t//virtual\t(*ptr-&gt;vptr[pmf.index](ptr)); 缺点： 检查成本高 Microsoft把这项检查拿掉，导入一个它所谓的vcall thunk。 在此策略下，faddr被指定的要不就是真正的member function(如果函数是nonvirtual的话)，要不就是vcall thunk的地址。 于是virtual或nonvirtual函数的调用操作透明化，vcall thunk会选出并调用相关virtual table中适当的slot。 传递一个不变值指针给成员函数时，它需要产生一个临时对象 举例子： 123456789extern Point3d foo(const Point3d&amp; , Point3d (Point3d::*)());void bar(const Point3d&amp; p )&#123; Point3d pt = foo(p,&amp;Point3d::normal );&#125;//&amp;Point3d::normal 的值类似这样：&#123;0 , -1 , 10727417&#125;//需要产生临时对象，有明确初值_mptr temp = &#123;0 , -1 , 10727417&#125; //伪码foo(p,temp); 回到开始的那个结构体： delta字段表示this指针的offset指针，而v_offset字段放的是一个virtual base class（或多重继承中的第二个、第三个等等）的vptr位置。 如果vptr被编译器放在class对象的起头处，这个字段就没什么必要了：这些字段在多重继承或虚拟继承的情况下才有必要性。 有许多编译器在自身内部根据不同的classes特性提供多种指向member functions的指针形式，例如Microsoft就供应了三种针对： 一个单一继承实例(其中带有vcall thunk地址或是函数地址) 一个多重继承实例(其中带有faddr和delta两个members) 一个虚拟继承实例(其中带有四个members) 内联函数 加了inline关键字，函数不一定就是内联函数。 编译器真的相信它可以扩展成inline函数时，其执行成本比一般函数调用和返回机制带来的负荷要低。 编译器处理inline函数，有两个阶段： 分析函数定义和复杂度，编译器会判断能否成为inline函数。 如果函数成不了inline ，就会转成一个static函数，并在被编译模块内产生对应函数定义。 真正的inline函数扩展操作是在调用的那一点上，这会带来参数的求值操作以及临时性对象的管理。 Formal argumentsinline 函数扩展期间，形参会被实参替代。 但无脑替代实参决定是有副作用的，比如一些表达式的重复求值之类的。 123456789101112131415161718inline int min(int i,int j)&#123;\treturn i&lt;j?i:j;&#125;inline int bar()&#123;\tint minval;\tint val1=1024;\tint val2=2048;\tminval=min(val1,val2);\t//参数直接替换，会扩展成 minval=val1&lt;val2?val1:val2;\tminval=min(1024,2048);\t//计算常量表达式1024&lt;2048?1024:2048得出结果1024，直接使用常量minval=1024\tminval=min(foo(),bar()+1)\t//有副作用，导入临时对象,避免重复求值\t//int t1,t2;\t//minval=(t1=foo()),(t2=bar()+1),t1&lt;t2?t1:t2;\treturn minval;&#125; Local variables加入一个局部变量，类似int minval 1234567891011121314151617181920inline int min(int i,intt j)&#123;\tint minval=i&lt;j?i:j;\treturn minval;&#125;//如果这样调用&#123;\tint local_val;\tint minval;\t//...\tminval=min(val1,val2);&#125;// inline函数扩展后的局部变量可能变成下面的样子&#123;\tint local_val;\tint minval;\t//将inline函数的局部变量mangling\tint __min_lv_minval;\tminval=(__min_lv_minval=val1&lt;val2?val1:val2),__min_lv_minval;&#125; 如果 inline 函数以单一表达式扩展多次，则每次扩展都需要自己的一组局部变量。 inline 函数以分离的多个式子被扩展多次，那么只需要一组局部变量求值就能重复使用。 inline 函数扩展后的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生，特别是它以单一表达式被扩展多次的话，例如： 123456789101112131415161718192021//例如：minval=min(val1,val2)+min(foo(),foo()+1);//可能扩展成：//为局部变量产生临时变量int __min_lv_minval_00;int __min_lv_minval_01;//为放置副作用值而产生临时变量 （副作用值即要重复计算的值）int t1;int t2;minval= ((__min_lv_minval_00 = val1 &lt; val2 ? val1:val2), __min_lv_minval_00) + ((__min_lv_minval_01= (t1=foo()), (t2=foo()+1), t1 &lt; t2 ? t1:t2), __min_lv_minval_01 );&#125; 两个特性 inline 函数可以有效存取封装于class中的nonpublic数据，同时也是#define的一个安全代替品。 但其弊端是，一个inline函数如果被调用太多次，会产生大量的扩展码，使程序的大小暴涨。 inline里再有inline可能因为连锁复杂度扩展不出来。 所以你需要小心处理 inline 函数 返回一个即将销毁的局部对象，像这样： 123456X bar()&#123; X xx; ... return xx;&#125;//bar 的返回值怎么从局部对象 xx 中拷贝回来。 cfront做法： 加上一个类型为类对象引用的额外参数，用来放置拷贝构造出的返回值。 return 前穿插一个拷贝构造的操作：利用传回值(例子中的xx )初始化上面增加的额外参数。 于是我们希望得到的局部对象值，在真正的返回值返回通过额外参数返回了；而真正的返回值呢？ 12345678void bar(X&amp; __result) //额外参数&#123; X xx xx.X::X(); //默认构造 __result.X::XX(xx); //拷贝构造 return ; //真正的返回值什么都不返回（注意函数类型) &#125; 接下来转换每个bar()调用操作： 1234567891011121314X xx = bar(); //转化为X xx; bar(xx); //不必实行默认构造bar().memfunc();//可能转化为X __temp0(bar(__temp0),__temp0).memfunc();X (*pf)();pf = bar;//转化为void (*pf)(X&amp;);pf = bar; 概括来说：用一个载体来 copy 对象（已经有载体了就作为参数）。","tags":["cpp"]},{"title":"第三章","path":"/2024/04/20/inside object mode/","content":"第3章 Data语意学（The Semantics of Data）一个 library1234class X&#123; &#125;;class Y : public virtual X &#123; &#125;;class Z : public virtual X &#123; &#125;;class A : public Y, public Z &#123; &#125;; 在这个继承体系下，X 、Y 、Z 、A 各自的大小不是0，而分别是：1、8 、 8 、12（byte）。 原因： 对于X：X大小为1，是因为编译器不允许&#x3D;&#x3D;独立&#x3D;&#x3D; class 占用内存为0。它在 class X 中偷偷插入了一个 char 指针。 对于Y、Z： 语言本身的 overhead ：为了支持 virtual base class , 类内会插入一个 vptr 指针来指向相关 virtual table。 table 里存放 virtual base class subobject 的偏移地址或实际地址。 X 的 char 指针被偷偷继承了，此时子类大小为 1+4 &#x3D; 5 byte 。 这里许多编译器会对这个char指针进行优化，但该例中没有。 Alignment 齐位要求导致 5-&gt;8 byte。 32位计算机的内存齐位大小：4byte 许多编译器对继承来的 空白基类char指针会进行优化。 （优化后，Y和Z 只剩一个指针的大小为 4 byte） 优化方式：EBO ，让空白虚基类作为子类对象开头的一部分（不花费任何空间） 对于 A：virtual base class 不会让A的内存变成简单的 8+8&#x3D;16。 至于为何变成12： 虚基类的subobject（子内容）占 1 byte。 Base class Y 和 Z 减去了vptr 的大小为4 byte，4+4&#x3D;8byte class A 自己的大小为 0 齐位要求：9-&gt;12 byte 。 如果编译器有EBO，大小则为 8 byte。 （如果虚基类里本身有数据（一个以上），EBO就会失效，两种编译器的对象布局会完全相同） 另外 C++Standard 不强制规定 base class subobject 的排列顺序或 不同存取层级的 data member 顺序。 它也不规定 virtual function 或 virtual base class 的实现细节。它认为这些应该交给厂商决定 这一章中有两个关键点：class中的 data members 和 class hierarchy 。 class.data members能够表现 class 的状态： Nonstatic data member 放置的是针对个别 object 的数据。数据和对象的内存在一起。 static data member 放置的是针对整个类（共享）的数据。数据被放置在 global data segment 中。它永远只有一份实例。 即使 class 没有任何 object ，static data 也存在。这一点在template class 中稍有不同。 Nonstatic data 的设计考虑到了与 C-struct 的兼容。 编译器为实现 virtual 等会加上许多额外 data member ，加上边界需要，内存往往比想象中更大。 3.1 The Binding of a Data Member 从编译器角度探索代码实现的一些过程 1234567891011121314//某个foo.h头文件extern float x;\t//x在别处被定义，此处被引用。这里x是声明不是定义，定义是要分配存储空间的。//Point3d.h文件class Point3d&#123;\tpublic: Point3d(float,float,float); //问题：被回传和设定的x是哪一个x呢？ float X()const &#123;return x;&#125; void X(float new_x)const &#123; x=new_x; &#125; //...\tprivate: float x,y,z;&#125;; 在今天的编译器下，point::X()传回 class 内部的x。早期编译器为了防止指向 global x object ，有两种设计思路。 所有data member 放在开头，来确保正确绑定。 123456class Point3d&#123; float x,y,z; //看到它们了public: float X() const &#123;return x;&#125; //不怕被外部引入调用了！&#125; 把所有 inline function 放到类的声明之外。 12345678910classs Point3d&#123;public: Point3d(); float X() const; void X(float) const; //编译器只看到了声明，看到下面的内部变量后再去实现 ...&#125;inline float Point3d::X() const &#123;return x;&#125;放到实现外... 这两个古老思路被称为 member rewriting rule ,不允许 inline 函数实体在 class 声明被完全看见之前去进行 evaluate。 C++ Standard 以 member scope resolution rules 来更好完成 rewriting rule 。 效果：inline function 在class声明后被立刻定义，仍然对其评估求值。 123456789extern float x;\tclass Point3d&#123;\tpublic: ...\tvoid X(float new_x)const &#123; x=new_x; &#125;\t//对于函数本体的分析将延迟到编译器发现 class 的 “&#125;” 时\tprivate: float x,y,z;&#125;; 对member function 的本体分析，直到整个 class 声明都出现才开始。这时不需要把所有类内部函数实现转移到类外部了。 特殊情况：member function 的 argument list 1234567891011typedef int length; //重命名类型了class Point3d&#123;\tpublic: ...\tvoid X(length val)const &#123; _val=val; &#125; // argument 1 length mumble()&#123; return _val;&#125; // argument 2\t//对于函数本体的分析将延迟到编译器发现 class 的 “&#125;” 时\tprivate: typedef float length; length _val;&#125;; 非我们所愿的数据绑定情况在两个参数第一次被编译器看到时，仍然会发生。上面的两个 length 类型 都被 resolve 成 global typedef 了。 这样一来，后续在去 nested - typedef length，就会导致编译器报错并定义最早的绑定不合法。 所以，把嵌套的 typedef 放到 class 起始处吧。 3.2 Data Member Layout12345678910class Point3d&#123;\tpublic: //...\tprivate: float x; static List&lt;Point3d*&gt; *freeList; float y; static const int chunkSize=250; float z;&#125;; non-static data member 在 class object 中的排列顺序和其被声明的顺序一样。 任何中间介入例如freeList和chunkSize的static数据成员 都不会被放进对象的布局之中。 在上述例子中，每一个Point3d的对象由3个float组成，次序是x,y,z static数据成员存放在程序的数据段中，属于整个类，不属于某个对象。 C++ Standard要求，在同一个access section（也就是private,public,protected等区段）中，只需要满足“较晚出现的数据成员在对象中有较高的地址”即可。 即在同一个acess section中，次序按照声明的次序，但是不一定连续，可能因为齐位调整(alignment)或者编译器自动合成的一些内部使用的数据成员，如虚函数表指针vptr插入到这些数据成员到中间。 （传统的编译器会把vptr放到所有明确声明的数据成员最后，当然也有编译器放在对象的最前端。总之C++ Standard 对这种布局很宽松啦） 对于不同access section的情况： 123456789101112class Point3d&#123;\tpublic: //...\tprivate:\t//一个acess section float x; static List&lt;Point3d*&gt; *freeList;\tprivate:\t//另一个acess section float y; static const int chunkSize=250;\tprivate //另一个acess section float z;&#125;; 大小和组成同先前的一样。排列顺序由编译器决定。 主流想法是：把一个以上的 access section 连锁在一起，按照声明顺序形成连续区块。 Access section 的多寡没有额外负担。8个section中的8个member 和1个 section 中的8个 member 大小一样。 拓展 一个能判断谁先出现在 class object中的 template function。 (两个 member 都是不同的 access section 中第一被声明者，此函数就可以用来判断哪一个 section 先出现) 1234567891011template&lt; class class_type, class data_type1, class data_type2 &gt;char* access_order(data_type1 class_type::*mem1, data_type2 class_type::*mem2)&#123; assert (mem != mem2 ); return mem1 &lt; mem2 ? &quot;member 1 occurs first&quot; : &quot;member 2 occurs first&quot; &#125; 123access_order(&amp;Point3d::z , &amp;Point3d::y);//class_type == Point3d//data_type1 == data_type2 == float 3.3 Data Member的存取12Point3d origin;origin.x = 0.0; 下面来根据根据不同情况分析 x 的存取成本。 分析前的一个问题 123Point3d origin, *pt = &amp;origin;origin.x = 0.0;pt-&gt;x = 0.0; 通过 origin 存取和 通过 pt 存取 有什么差别吗？ 稍后会回答。 Static Data Members 前面讲过，每一个static成员只存在一个实体，存放在程序的data segment数据段中，被视为一个global变量（只在class存在范围内可见） 1234origin.chunkSize=250;\t//这样调用，内部转化为：//Point3d::chunkSize=250;\tpt-&gt;chunkSize=250;\t//这样调用，内部转化为：//Point3d::chunkSize=250; 通过 member selection operators（“.”运算符）对 静态成员变量进行操作只是语法上的简便操作。实际上static-member 并不在 class 对象中。所以存取 static member 并不需要通过 class 对象。 chunksize是继承来的member 各种复杂关系，比如虚基类的虚基类那里继承而来。。。 不会发生任何变化。static-member 仍然在栈里等待着。 static data member 通过函数调用 一种可能的转化（不同标准不同处理） 123foobar().chunkSize=250;\t//这样调用，内部转化为：//(void)foobar();//Point3d.chunkSize = 250; 取静态成员变量地址 因为 static member 不内含在 class 对象里，取其地址不会得到指向对应 class member 的指针，而会得到指向其本身数据类型的指针。 12&amp;Point3d::chunkSize; //得到 const int* 类型的内存地址 //而不是Point3d::*类型的地址（指向类对象成员的指针）。 对于静态成员冲突： 如果一个程序里定义了两个类，两个类都声明了一个static成员，且两个static成员同名，那么都存放在程序的数据段中时会引起同名冲突。 编译器会暗中对每一个static成员编码，得到一个独一无二的程序识别代码(一起扔到某个表格之类的东西里)，这种手法叫name-mangling（不同编译器编码不同）。主要做两件事： 1、一种算法，推导出独一无二的名称 2、推导出的名称能够还原(万一编译系统（或环境工具）必须与使用者交谈，那么那些独一无二的名称 可以轻易被推导回原来的名称) Nonstatic Data Member non-static成员存在于每一个对象中，必须通过显示的或者隐式的对象才能对non-static成员进行存取。 只要程序员在成员函数里直接处理non-static成员，隐式的对象就会出现（它就是被编译器隐藏的家伙）。 1234567891011Point3d::translate(const Point3d &amp;pt)&#123;\tx+=pt.x;\ty+=pt.y;\tz+=pt.z;&#125;//内部转化为：(编译器在参数列表上加了this指针)Point3d::translate(Point3d *const this,const Point3d &amp;pt)&#123; //第一个参数 this 是隐藏的！\tthis-&gt;x+=pt.x;\t//this指针就是上述的隐式的对象\tthis-&gt;y+=pt.y;\tthis-&gt;z+=pt.z;&#125; implicit class object 由 this 指针表达。 对 nonstatic data member 进行存取操作时，编译器会要求 class object 的起始地址 + offset(data member)偏移地址 。 123origin.y = 0.0;//即&amp;origin + (&amp;Point3d::y-1); -1是为了让系统区分指向成员变量的指针中，空指针和指向第一个变量的指针（两者都是0） nonstaic 成员变量的offset在编译期就能得知。即使该 member 属于 base class subobject（继承来的子内容）。因此存取效率和 C struct 成员 或独立类中的 成员 是一样的。 虚拟继承 1234Point3d origin;Point3d *pt = &amp;origin;origin.x=0.0;pt-&gt;x=0.0; 虚拟继承使 base class subobject 存取 class members 增加了新的间接性。 （指针的间接性 + virtual vptr 间接性） 当然，x 在作为 struct 成员，独立类成员、普通继承（非virtual）成员的效率都相同。但在作为我们当前讨论的 virtual base class 时，存取速度会稍慢。 这时就回到了该节开头的那个问题：以上两个存取方式有什么重大差别？ 答案：当Point3d为子类，继承过一个 virtual base class，而 member（如x）又属于这个虚基类时，差别就会很大： pt由于间接性，不能确定指向哪一种 class type ，于是在编译期就无从知晓该成员的偏移位置。所以这个存取操作被转移到了运行期（通过额外的间接索引来解决）。 origin 不会存在pt的问题，他的类型很明确，即 Point3d class。即使它继承自虚基类，成员偏移量也能够在编译期固定。 戏份更多的编译器甚至能通过 origin 静态解决掉对x的存取操作。 3.4 继承与 Data MemberCPP继承模型中，一个子类对象表现出来的东西，是 derived class member 和 base class member 的总和。但这两者的排列顺序并没有明确规定。 通常 base class members 先出现，属于virtual base class 的部分除外。 123456789101112class Point2d&#123;\tpuiblic: //functions\tprivate: float x,y;&#125;class Point3d&#123;\tpuiblic: //functions\tprivate: float x,y,z;&#125; 下面我们将在以上两个独立类之间的关系上做文章，分别讨论：“单一继承且不含 virtual function”、“单一继承并含virtual functions”、“多重继承”、“虚拟继承”的情况。 先看下独立类时的状态（non-virtual function） 和 C struct 完全一样 只要继承不要多态现在从Point2d派生出Point3d，于是Point3d将继承x和y坐标的一切（包括数据实体和操作方法），使Point无论2d或3d都可以共享数据本身和数据的处理方法。 一般而言，非虚拟继承并不会增加空间或存取时间上的额外负担。 1234567891011121314151617181920212223242526272829303132class Point2d&#123;\tpublic: Point2d(float x=0.0,float y=0.0):_x(x),_y(y)&#123;&#125;; float x()&#123;return _x;&#125; float y()&#123;return _y;&#125; void x(float newX)&#123; _x=newX; &#125; void y(float newY)&#123; _y=newY; &#125; void operator+-(const Point2d&amp; rhs)&#123; _x += rhs.x(); _y += rhs.y(); &#125; //...\tprotected: float _x,_y;&#125;;class Point3d:public Point2d&#123;\tpublic: Point3d(float x=0.0,float y=0.0,float z=0.0): Point2d(x,y),_z(z)&#123;&#125;; float z()&#123;return _z;&#125; void z(float newZ)&#123; _z=newZ; &#125; void operator+-(const Point3d&amp; rhs)&#123; Point2d::operator+=(rhs); _z += rhs.z(); &#125; //...\tprotected: float _z;&#125;; 普通继承的好处是负责坐标点的程序代码能够局部化，同时能够表现出两个 class 的紧密关系。即使两个类独立出来，也不需要改变声明和使用。 但这种设计有两个坑： 这种继承关系需要选择某些函数作为 inline 函数，否则就会出现相同操作的函数重复出现。 如示例中的 operator +&#x3D; 和 constructor 函数： Point3d object 的初始化和加法操作，需要部分point2d 和 部分 point3d 作为成本。 将一个类拆分成两层或者更多层的类时，为了表现”类体系的抽象化“而造成空间膨胀。 以 concrete 类为例 1234567class Concrete&#123;\tprivate: int val; char c1; char c2; char c3;&#125;; 空间分析（32bit）：val - 4byte , c1 , c2 ,c3 各占用 1byte；齐位要求：4+3→8byte 这个案例中如果有以下应用场景：将 concrete 分裂成三层结构 12345678910111213class Concrete1&#123;\tprivate: int val; char bit1;&#125;;class Concrete2:public Concrete1&#123;\tprivate: char bit2;&#125;;class Concrete3:public Concrete2&#123;\tprivate: char bit3;&#125;; 空间膨胀喽：三次齐位要求造成内存为 8+4+4 &#x3D; 16 byte 不要想当然认为 concrete::nonstatic data member bit2 会填补 concrete1的空间。齐位填充会提前发生。 那么这种提前填充，或者说没有把子类和父类子对象填充在一起的设计用意何在呢？ 看看这个例子： 12&gt;Concrete2 *pc2;&gt;Concrete1 *pc1_1 , *pc1_2; //这俩可以指向上述三种classes object。 发生下述操作时： 1&gt;*pc1_2 = *pc1_1; 应该执行一个默认的 memberwise 复制操作，来一个一个复制 Concrete1的member 。 如果pc1_1 指向一个 Concrete2 object 或 Concrete3 object 的话，上述指针赋值操作应将复制内容指定为 Concrete1 subobject。 但如果子类成员和父类子对象捆绑在一起，来填补空间的话，就会发生意外： 1234&gt;//pc1_1和pc2:既有基类子对象，又有自身成员属性。但两者绑定在了一起&gt;//pc1_2&gt;pc1_1 = pc2; //令 pc1_1 指向 Concrete2 对象&gt;*pc1_1=*pc1_2; // pc1_1 的 derived class subobject 会被覆盖，使bit2被覆盖产生非预期 上述操作会把Concrete1对象逐对象拷贝，包括&#x3D;&#x3D;原本应该&#x3D;&#x3D;padding的三个字节，于是实际pc1_1指向的Concrete2对象的bit2会被覆盖掉，出现一个无法确定的值。 下图为绑定后的过程 ： 在子类中的 base class subobject 的原样性被破坏后，会导致 copy 时 Concrete 1 的子对象复制给 Concrete2， 破坏了 Concrete 2 (捆绑后) 的成员。 加上多态多态嘛，处理一个坐标点而不在乎它是 Point2d 还是 Point3d ，在继承关系中提供一个 virtual function 接口。 12345678910111213141516171819class Point2d&#123;\tpublic: Point2d(float x=0.0,float y=0.0):_x(x),_y(y)&#123;&#125;; float x()&#123;return _x;&#125; float y()&#123;return _y;&#125; void x(float newX)&#123; _x=newX; &#125; void y(float newY)&#123; _y=newY; &#125; //修改1：加上z的保留空间，当前什么也没做，2d的z点返回0.0也是合理的(只是为扩展性存在) virtual float z()&#123;return 0.0;&#125; virtual void z(float)&#123;&#125; //修改2：设定下面的运算符操作为virtual virtual void operator+=(const Point2d&amp; rhs)&#123; _x += rhs.x(); _y += rhs.y(); &#125; //...\tprotected: float _x,_y;&#125;; 既然多态，导入一个 virtual 接口才显得合理。 12345void foo(Point2d &amp;p1,Point2d &amp;p2)&#123;\t//...\tp1+=p2; //p1 可能是2d，可能是3d\t//...&#125; Point3d： 1234567891011121314151617181920class Point3d:public Point2d&#123;\tpublic: Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z)&#123;&#125;; float z()&#123;return _z;&#125; void z(float newZ)&#123; _z=newZ; &#125; //修改：参数改成const Point2d&amp; rhs（原来是Point3d&amp;） void operator+=(const Point2d&amp; rhs)&#123; Point2d::operator+=(rhs); _z += rhs.z(); &#125; //...\tprotected: float _z;&#125;;//修改后最大的好处就是可以把operator+=运用在一个Point3d对象和Point2d对象上Point2d p2d(2.1,2.2);Point3d p3d(3.1,3.2,3.3);p3d+=p2d;//得到的p3d新值为(5.2,5.4,3.3) 两个 z() member function 和 operator+&#x3D;()运算符 都成了 virtual function 每一个Point3d class object 内含一个额外的 vptr member（from Point2d） 面向对象的弹性会带来相应的实现负担： 导入一个和Point2d有关的虚函数表，存放声明的虚函数地址，还有支持runtime type identification相关的东西。 每一个类对象要加一个虚函数表指针vptr，提供执行期的链接，使得每一个对象都能找到相应的虚函数表。 构造函数需要为vptr提供初始值，让它指向类对应的虚函数表。这可能意味着所有派生类和基类的构造函数都要重新设定vptr的值。 这些操作都是编译器偷偷做出的。 析构函数需要消除vptr。vptr很可能已经在派生类析构函数中被设定为派生类的虚函数表地址，析构函数的调用次序反向的，从派生类到基类。 负担程度视“被处理的Point2d objects 的个数和生命期”而定。同时也要考虑“多态设计取得的收益”。 vptr位置问题 编译器领域有一个讨论点：vptr 放置在 class object 的哪个位置。 放在尾端 1234567891011Struct no_virts&#123;\tint d1,d2;&#125;;class has_virts:public no_virts&#123;\tpublic: virtual void foo(); //...\tprivate: int d3;&#125;no_virts *p = new has_virts; 好处：与 base class C struct 对象布局相兼容。 上例中，带有虚函数的继承布局（vptr在尾端） 放开头 vptr 在 class object 前端，对于多重继承场景，通过指针(指向类成员)调用虚函数有帮助： class object 起始点开始测量计算的 offset 不需要在运行期准备了；与 class vptr 间的 offset 也不需要在运行期准备。 缺点：丧失了C语言兼容性。 老实说，这种兼容无关痛痒，谁会在 C struct 上派生出多态 class 呢？ 多重继承 自然多态（natural polymorphism）:单一继承中，父类和子类转换很自然，因为它们的继承对象起始地址相同，所以父类指针指向子类对象时，不需要编译器参与调整地址，效率很高。 non-virtual 基类下如果存在一个子类有 virtual function，就会失去单一继承的自然多态。这时，子类转为基类，就需要编译器介入来调整地址（因为vptr插入到了 class object 的起始处)。 多重继承中，子类和基类的关系并不那么“自然”。 123456789101112131415161718192021222324252627class Point2d&#123;\tpublic: //有虚函数，所以Point2d对象中有vptr\tprotected: float _x,_y;&#125;;class Point3d&#123;\tpublic: //...\tprotected: float _z;&#125;;class Vertex&#123;\tpublic: //有虚函数，所以Vertex对象中有vptr\tprotected: Vertex *next;&#125;;class Vertex3d:public Point3d,public Vertex&#123;\tpublic: //...\tprotected: float mumble;&#125;; 对于这种多重派生对象，将其地址指定给最上层的 base class 指针时，情况和单一继承相同（父子指向相同地址，成本只有指定地址的操作）。 后续子类的地址指定操作，则需要手动调整地址。 12345678910111213141516171819Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;\t//Point3d的定义看回上一小节pv=&amp;v3d;\t//内部转化为：pv=(Vertex*)(((char*)&amp;v3d)+sizeof(Point3d)); //Point3d 包含 Point 2d。p2d=&amp;v3d;\t//这两个操作只需要简单地拷贝地址就行了p3d=&amp;v3d;\t//因为Point2d和Point3d和Vertex3d的对象起始地址都相同Vertex3d *pv3d;Vertex *pv;pv=pv3d;//不能简单地转换成下面这样，因为如果p3d为0，那么将获得sizeof(Point3d)的值，这是错误的pv=(Vertex*)(char*)v3d+sizeof(Point3d);\t//错误//应该加个条件判断应付空指针情况，如果是引用则不需要加这个判断pv=pv3d ? (Vertex*)(char*)v3d+sizeof(Point3d):0;\t//正确 C++ Standard 并未要求Vertex3d 中的 base class Point3d 和 Vertex 有特定排列顺序。 CFront 和许多编译器，按照声明顺序排列继承的基类：Point3d subobject + Vertex subobject + Vertex 3d subobject 依次存储。 （加上虚拟继承就不一样了） 存取第二层以上的基类的 data member ，只是一个简单的 offset 运算。 虚拟继承虚拟继承的应用场景很狭窄，几乎是为解决多重继承的重复副本而生的。 12345678910//多重继承class ios&#123;//...&#125;;class istream:public ios&#123;//...&#125;;class ostream:public ios&#123;//...&#125;;class iostream:public istream,public ostream&#123;//...&#125;;//虚拟继承class ios&#123;//...&#125;;class istream:virtual public ios&#123;//...&#125;;class ostream:virtual public ios&#123;//...&#125;;class iostream:public istream,public ostream&#123;//...&#125;; iostream 继承 istream 和 ostream 时，只需要一个 ios subobject。解决方法即虚继承。 虚拟继承的实现需要将 两个基类各自维护的一个 ios subobject 折叠成一个由共同子类维护的单一 subobject，同时保存好基类和子类各自的指针(引用)间的多态指定操作。 Class 继承体系出现 virtual base class subobject 后，会分割成两部分： 不变区域：这里的数据不管后续继承的变化如何，拥有固定 offset （从 object 开头），可直接存取。 共享区域：即virtual base class subobject 部分的数据，其位置随着每次的派生操作都会有变化，只能间接存取。 各编译器对间接存取的实现技术不同。 以下是三种 v-base-class-s 的间接存取策略。 指针实现 12345678910111213141516171819202122232425262728class Point2d&#123;\tpublic: //...\tprotected: float _x,_y;&#125;;class Vertex:public virtual Point2d&#123;\tpublic: //...\tprotected: Vertex *next;&#125;;class Point3d:public virtual Point2d&#123;\tpublic: //...\tprotected: float _z;&#125;;class Vertex3d:public Vertex,public Point3d&#123;\tpublic: //...\tprotected: float mumble;&#125;; 一般的布局策略是先安排好派生类中不变的部分，再建立共享部分。cfront编译器会在每一个派生类对象中安插一些指针，每个指针指向一个虚基类。要存取继承得来的虚基类成员，可以使用相关指针间接完成。 1234567891011121314151617void Point3d::operator+=(const Point3d &amp;rhs)&#123;\t_x+=rhs._x;\t_y+=rhs._y;\t_z+=rhs._z;&#125;;//在cfront的策略下，这个运算符会被内部转化为：//c++伪码_vbcPoint2d-&gt;_x += rhs_vbcPoint2d-&gt;_x;\t//vbc 即virtual base class_vbcPoint2d-&gt;_y += rhs_vbcPoint2d-&gt;_y;_z+=rhs._z;//一个派生类和基类的实例之间的转换：Point2d *p2d=pv3d;//在cfront的实现模型下，会变成：//c++伪码Point2d *p2d=pv3d？pv3d-&gt;_vbcPoint2d:0; 每一个对象必须针对每一个虚基类背负一个额外的指针，但是我们希望每一个类对象的大小是固定的，不因为其虚基类的数量而变化。 解决方法： 1、微软的编译器里会引入虚基类表（类似于虚函数表），在继承虚基类的子类对象中，通过一个虚基类表指针指向虚基类表（虚基类指针存放在这些表格中）。2、在虚函数表中放置虚基类的offset（而不是地址）。 (作者实现时，将虚基类偏移地址和虚函数入口混杂在一起，通过正负值索引区分虚函数表中的地址：正数索引到虚函数，负数所引导虚基类) 下图显示了这种base class offset实现模型： 1234567 &gt;void Point3d::operator+=(const Point3d &amp;rhs)&#123;//这里_vptr_Point3d[-1]存放的是虚基类距离对象起始地址的offset//this是对象起始地址，所以加起来就是虚基类的subobject(this+_vptr_Point3d[-1])-&gt;_x += (&amp;rhs + rhs._vptr_Point3d[-1])-&gt;_x;(this+_vptr_Point3d[-1])-&gt;_y += (&amp;rhs + rhs._vptr_Point3d[-1])-&gt;_y;_z+=rhs._z; &gt;&#125;;//为了可读性，没有做类型转换，也没有先执行对效率有帮助的地址预先计算操作 这种功能的成本只会在member使用的过程中消耗，所以属于局部性成本（虽然本身有点昂贵）。 示例： 123&gt;Point2d *p2d=pv3d;&gt;//在上述实现模型下变成：&gt;Point2d *p2d=pv3d?pv3d+pv3d-&gt;_vptr_Point3d[-1]:0; 每有一层虚拟继承，间接存取的层次就会加一层（三层继承，就要通过三个 virtual base class 指针进行三次间接存取）。我们希望每次存取时间都是固定的，不因为虚拟派生的深度而改变。 通过拷贝操作取得所有嵌套虚基类指针，将之放到子类对象中，这样就不用间接存取了，用空间换时间。下图显示了这种模型的实现： 区分 非多态的 class object 存取继承而来的 virtual base class 的成员： 123Point3d origin;...origin._x; 可直接被优化为直接存取，在这次存取和下一次存取的过程中间，对象类型不可改变。 如同对象调用虚函数可以在编译器完成。 一般而言，虚基类最有效的一种运用方式就是：一个抽象的虚基类，没有任何数据成员。 3.5 对象成员的效率1、直接存取对象成员和使用inline的Get和Set函数存取对象成员经过优化后效率一样。2、除了虚拟继承情况外，1中的效率一样（包括单一继承的情况）。随着虚拟继承层数增加，1中存取对象的时间增大。 3.6指向数据成员的指针123456789101112131415161718192021222324#include &quot;pch.h&quot;#include &lt;iostream&gt;using namespace std;class Point3d &#123;\tpublic: ~Point3d(); void static getOffsetOfZ() &#123; printf(&quot;%d &quot;, &amp;Point3d::z);\t//8 //因为同一个acess section里的成员要按声明次序排列，z前面有x和y //一个float是4 bytes，这里是8说明vptr放在尾端，如果是放在头端这里的输出应该是12 bytes cout &lt;&lt; &amp;Point3d::z &lt;&lt; endl;\t//1,因为Point3D没有定义&lt;&lt;操作，所以编译器这里自 // 己偷偷进行转化，输出结果就为1 &#125; //... protected: static Point3d origin; float x, y, z;\t&#125;;int main() &#123;\tPoint3d::getOffsetOfZ();&#125; 实际上 offset 往往比 正常地址位置 多1，也就是说，如果vptr放在对象头端，三个坐标值在对象布局中的offset分别是1,5,9；如果vptr放在对象尾端，三个坐标值在对象布局中的offset分别是5,9,13。 （原因和3.3中non-static成员中-1的原因一样）：为了区别一个类数据成员类型的指针是空指针和指向第一个offset为0的成员时的情形. 理解了指向成员变量的指针后，就可以明确下 &amp; Point3d::z 和 &amp; origin.z 的差别了。 取 nonstatic data member 的地址：得到它在类中的 offset 取 绑定在特定实例对象身上的成员地址： 得到它在内存中的真正 address &amp;origin.z 减 z 偏移量 同时 加 1 ，即origin起始地址 &amp; origin.z 返回类型为 float* 而不是 float Point3d::* 在多重继承下，如果要将第二个或者后继的基类指针和一个“与派生类对象绑定”的成员结合起来，会在偏移量的问题上变得比较复杂： 12345678910111213141516171819202122232425#include &quot;pch.h&quot;#include &lt;iostream&gt;using namespace std;struct Base1 &#123; int val1; &#125;;struct Base2 &#123; int val2; &#125;;struct Derived :Base1, Base2 &#123;&#125;;void func1(int Derived::*dmp, Derived *pd) &#123;\t//第一个参数期待传入的是指向 Derived的成员 的指针\t//但是如果传进来的是指向 基类的成员的 指针呢？\tprintf(&quot;%d &quot;, pd-&gt;*dmp);\t//-858993460&#125;void func2(Derived *pd) &#123;\tint Base2::* bmp = &amp;Base2::val2; //注意这里特意设置为 base2指针而非base1 pointer\tprintf(&quot;%d &quot;, bmp); //0，pffset为0没问题(注意，这里算上偏移量，bmp为0+1=1)\t//但是在Derived中，val2的offset是4 (额，offset便是4+1=5)\tfunc1(bmp, pd);&#125;int main() &#123;\tDerived d;\tfunc2(&amp;d);&#125; 当 (指向base2成员) 变量的bmp被作为func1()的第一个参数时，它的值就必须因介入的Base1 class的大小而调整，否则pd-&gt;*dmp将存取到Base1::val1，而不是希望的Base1:val2，要解决这个问题，必须经过以下过程： 1234//经由编译器内部转换func1(bmp+sizeof(Base1),pd);//还要防范bmp==0func1(bmp?(bmp+sizeof(Base1)):0 ,pd);","tags":["cpp"]},{"path":"/2024/04/19/信息流/","content":"梳理后记：我们所处时代的信息真是应接不暇！根本不缺获取信息的渠道，而在挖掘信息和摄取信息的差别。这个时代是属于自学者的时代。学习能力强、兴趣高的朋友将如鱼得水！ 这几天总结下我觉得不错的信息流，方便以后闲得无聊时，减少摄取优质信息的步骤，能快速上手看看。 诸位如有什么机缘巧合能看到此文，希望能不吝推荐好的信息源，来者不拒、不胜感激！ 小红书、微博、抖音、贴吧、天涯。 这五个平台出于各种原因没有深耕。不好说。 豆瓣偏个人兴趣，私人程度高，不说。 片子综艺：十三邀、圆桌派 纪录片 ：河西走廊 电影 ：高山下的花环 电视剧 ：天道 知乎：用户9qadg ：逻辑碾压，知识量庞大，极度自洽，健壮的认知体系。 invalid s ：理工视角的世界观与方法论。 小庄：毛选 梦溪笔谈：宗教。主要看这一篇：“有哪位大神系统梳理过佛学、哲学、心理学的异曲同工之处？” 墨子连山 ：论语、老子五十讲，世界观，人情世故 收藏夹东西堆的太多了，要一点一点看 微信公众号：思维&#x2F;认知&#x2F;观念：遨游之舟：辩证法，毛选 达尔斯顿王：毛选 灵性&#x2F;开脱&#x2F;箴言：禅窗 视野&#x2F;知识类单读：文学人物访谈+社评 读宋史的赵大胖：宋史+人性 加氢文化：社评 看客inSight：聚焦小人物，引申至社会现象 南都观察家：社评 张家玮 人情世故：谋略那些事：《资治通鉴》 悟事：《资治通鉴》 b站：思维&#x2F;认知&#x2F;观念：硬核的HeyMatt 马林思维 戎震 许倬云：许老也许是服务于短视频平台？知识输出少，碎片化的认知多。 灵性&#x2F;开脱&#x2F;箴言：萨古鲁 克里希那穆提 吴悠morefree 视野&#x2F;知识类马督工 ：键政。对社会问题的看法。 AI-Talk ：AI技术展示倒在其次，AI 自动生成的对话非常有趣。乔布斯和列农，老子和苏格拉底等。 国仁全球大讲堂： 主要讲师是温铁军，偏学术类型的社会问题和世界历史遗留问题探讨。 衣戈猜想 ：知识普及，人有意思。 人情世故老付聊职场 生活方式有山先生 ：大俗即大雅，兼容 付航脱口秀 ：幽默，急智，表达，情商 黄龄：音乐的美感。趣味。表现欲。 人类白景琦：老子天下第一！大男子主义，独立自强。 朴树 ： （不了解） 宋冬野 ：（不了解，但受朋友影响感兴趣） 迈克尔乔丹 ：精神力，意志力。身体素质 费曼 ：学习能力 罗翔 ：内省，审慎，求知 余华 ：幽默感 金凯瑞 ：灵修，表演欲望，幽默感 李小龙 ：英气，自信，精气神， 迈克尔杰克逊 ：音乐、才华、悲天悯人和神性 乔布斯：科学人文的交汇，创造力，自我 陈丹青： 俞敏洪：生命如一泓清水 何多苓：松弛感 叶嘉莹：诗词，敏感，“脆弱里坚强” 杨祐宁：穿搭，更精致的生活方式 蒋劲夫：健身 九重奏（知乎用户）：INTP 王小波：有趣 曾国藩：“老实人的心眼子” 汪曾祺：“ 夫唯不争，故天下莫能与之争 ” 百度百科360收藏夹太多了 书《南怀瑾讲论语》《道德经》《亲密关系》 《古文观止》 后记：总有一些时候，我们也要刷刷好笑好哭的短视频。这也是拓展视野的一种方式。 正如吃多了鸡胸肉西兰花，总要有一天放纵日。 再记：人情世故和灵修的信息流都少了。"},{"title":"心钝","path":"/2024/04/19/心钝/","content":"心钝首先阐明词义：何为心钝？ 我的理解：心钝乃是 好奇心模型和成长模型 不足带来的麻木和懒惰。 举个例子：问你最近对生活的新发现，有趣的事物，偶然悟出的妙理，跳出舒适区的新体验等等，如果你不能自如回答，信手拈来。我想你在这一类问题上的认知模型是匮乏的。 为什么是好奇心和成长两个模型？ 好奇心保证你能在表面上古井不波、枯燥无味的环境里发掘出各种信息。 如果生命是海，我们总希望生活是轰轰烈烈、汹涌澎湃的。“乘风破浪会有时”、“乱石穿空、惊涛拍岸”云云。可多数时间里大海都是一览无余的平静。 这里引用李银河老师的一句话：所有暂时的热闹都只不过是海水撞击岩石时溅出的浪花,生命的本质却永远像海洋深处一样的沉寂。 所以如何在平静的海面上找到属于自己的快乐呢？这就需要好奇心。只有在好奇的状态下，你才会近乎本能的去看，去做，去体验。你才能感受到隐藏在生活之下，汹涌澎湃、钟鼓齐鸣的灵感音符。 这种力量是任何强制力、功利心、攀比虚荣都难以企及的。 就像饿了吃饭、渴了喝水、困了睡觉一样自然。 仅仅是由着性子去体验。还有比这更美妙的事情吗？ 这也将人的生活分成“三六九等”。艺术家的生活大喜大悲；逻辑学家的生活狡黠思辨；音乐家的生活富于韵律而美食家的生活充满芳香。不过注意哦，某某家完全不靠某个职业身份证书的认定；而仅仅在于你是否乐于去做—— 每个人都具备“多面手”的潜力。大脑的发育完全支持我们做到这一点。你总能在不经意间做十分钟的乐手、二十分钟的厨师。 乐趣源自哪里？好奇心。 如果你觉得吃饭只是求饱，说话只是你好。那你不仅丢掉了让自己的生活丰富多彩、有滋有味的天然权利， 还将迟早面临被功利心反噬的风险。 下面看一个实例。 问你最近对自己的生活有什么想说的想表达的，这个同学是一时半会说不出来的。就你会沉浸在这样一种状态：这个事没什么好说的，这个事没什么好惊讶的，今天也没什么好讲的，我的生活是平平无奇的。 仅从情商上讲，举个比方：今天周五，你在北京打车去见一个客户。 这个客户的办公室很大但是人很少，不知道客户去哪了。 今天北京的天气很好，阳光明媚，没有沙尘暴也没有雾霾。 你下午两点打的车，路上很堵 这个客户的办公桌上摆了一堆绿萝、绿植。 今天周五。 上面五条是一个素材，至少从这五条里，你和素未谋面的客户并不是无话可说的，不是吗？ 无非是你观察力不细致，或者你觉得办公室人少没什么好说的，天气好没什么好说的，等等等等。 这种观察力的缺失就会带动思考力、表达力的缺失，就像一个心智上的“过滤器”。抱着这种心态，我再问你今天周五感觉如何，你便会迟钝麻木，无话可说。 这里给大家一个建议：“仰观宇宙之大，俯察品类之盛。”也就是善于敏于乐于观察生活中的细节，这样你才不会自怨自艾觉得四面无趣，你才能到任何环境都能保持好奇心，你的眼睛才有光。 有了这个能力，你就能吸收到很多一般人看不到的细节和信息。吸收信息抽象来看是个输入的过程。那输入了这么多的信息，咱们要做的就是整理。就像吃完饭还要把营养吸收掉，去粗取精。这里用到的认知模型是“费曼学习法”，即教就是最好的学，输出带动输入。 上述内容来自b站up主广智的销售宇宙,我只是略微整理、打些比方而已。 好奇心的重要性咱聊完了。接下来说说成长。 如果说好奇心是生活美好所在的敲门砖，那成长意识就是敲开门后的金刚钻。 种下一颗种子意味着你要身披四季风雨冷暖，呵护挂念它直至开花结果。 好奇心只是让你有了种下种子的动机。而要达到收获果实的目的，靠的是汗水的灌溉 —— 汗水的源泉即成长意识。 拥有成长意识，你才能站在全局出发，跳出现有的视角框架，去为自己的目标理想而奋斗。而对自怨自艾、妄自菲薄天然的嗤之以鼻：“我tm忙活半天到底是为了什么，我为什么天天折磨自己，躺床上它不香吗巴拉巴啦……”。 这也是区分强者弱者，智者愚者，乐者苦者的关键所在 —— 成长意识下的大格局、大视野、大框架。 兴趣的多少只是决定了你能开始这段成长旅程，以及旅程之中的难易程度、趣味多少而已。 至于好奇心延伸出的勇气、学习能力（又名信息整合能力）、革命性、思辨力、包容度等，以及成长意识下延伸出的吃苦耐劳、定力韧性等等等等，这里受限于篇幅笔力，不再赘述，有缘补充。 两者共同决定了你生命的质感，你生活的乐趣程度。 私货：也不怪乎人的境界与厚度分三六九等，酒囊饭袋、声色犬马之徒和格物修身之辈的矛盾天然不可调和，兼顾也只是落个礼节。两类人住的完全不是一个地球。 修行人性和顺从欲望的差别就如同猪狗与人的差别。不过区分点并不是爱不爱喝酒，爱不爱做爱这类表面事情。而是观其心。但大家知道想摸透别人的心，得到的只有偏见。唯有观自己的心才是十拿九稳。 观自在，诚意正心，格物致知，修身齐家。 “所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善，而著其善。　人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。” ————《大学》 自己是什么货色伸手便知喽。 好奇心保证广度，成长保证深度。深广兼备，博学多才、遍地开花，趣味横生、喜不胜收。 仰观宇宙之大、俯察品类之盛，且歌且行、快雪时晴。 这里说的有些雅了。补一句：懒逼不配幸福，无论精神身体理论实践。一言以蔽之。 颗粒度好奇心和成长属性说了很多。 在两者的趋势下，我们已经建立了不错的认知模型了。接下来的一步呢？ 在健康向上积极自洽的认知地基上，不断的打磨自己，愈加成熟。 “如切如磋，如琢如磨” “君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉” 打磨的本质便是实践。 按孔老的话说，你如果把你想的那些事都大大方方的做出来，你就上道儿了。 修身功夫越深的朋友，他的生活颗粒度会越细。开始刚刚有了信仰的雏形，每天只能付诸于一件事，坚持一两天。慢慢的，能够付诸两件事、三件事，直到生活的方方面面，持续恒久。 这是颗粒度细了，所谓生活精致是也。 干净卫生，摆放有序的人至少能说明一点：在物件规划这件事上，他是极其有功力的。这已经十分宝贵了。 颗粒度粗糙的朋友，会不可避免的在新手期持续打脸。发现自己总是在某个节点失败。 程序员有句话：发现问题是解决问题的一半。 如果你敢于承认自己对待生活的粗糙，那你就已经开始走向了精致。 这个节点极易出现一种神经官能症：即理想与现实的不统一。 这里的理论来自卡尔霍尼的《我们内心的冲突》，极端严重推荐的好书。地基级别思想建构且简单好懂。 简单说就是自己主动打自己的脸。 举个例子： 我可以得到很高的分数，但我就是不学。 我是一个干净人，但我就是不收拾。 我很专一，只是敏感多情而已。 这类朋友的矛盾是很明显的，除了自己以外，基本身边深入接触的人都可以察觉。 但社交距离感决定了其他人没有任何义务指明你的缺点。最好的修正方式是自我革命，即自己针对自己的纠察反省审视总结。 奥，遇到指正你缺点的朋友多加珍惜吧。当然，他甚至可能是你的“敌人”。 当你不断反思和进步，你的生活会不可避免的精致起来。 就像一栋结实的房子，不断装修、翻新、收拾，理所当然变得更加宜居。 醉心理论甚至幻想，心有余温而不实行是成长的大忌。诸位共勉。 一些典型语录： “不在意这些细节” “可以做但没必要” “状态不好以后再说（然后没下文）” 这里还可以补充一个知乎博主9qadg(john hexa)的文章：（较真这种性格好吗？在什么情况下需要较真？- q9adg的回答 - 知乎）https://www.zhihu.com/question/27111858/answer/2588179268奥对了，对一些事情较真是雕琢颗粒度的表现 这里可以引申另一个话题，什么时候较真什么时候不较真。 但能判断不较真是最好的解决方案的前提是，你较真过“啥时候不较真”这个问题。 较真才是能力的分水岭。 甚至较真后的结果是躺床上。这些无所谓。只要判断合理。 有始有终。没有开始，何来最终？有了开始，请用心走到终点。 走路就是实践啦。 前方坦途，诸位慢走。 敏锐如果具备前文的好奇心和成长意识。 并且已经不但打磨了自己的生活颗粒度的话：你将在颗粒度高的这个方向，有远高于常人的敏锐性。 那回归到一个人身上，表现出了即为气质 到这一步，长时间雕琢于一件爱好的气质已经藏不住了，你身上的方方面面都会被你常常做的事情所熏陶，形成一种文化气息。这种看不清、摸不着但“触目所及”的东西就是文化啦。 那文化有哪些表现形式呢？ 歌曲背后的风格、节奏、编曲、乐器； 画作背后的背景、创作心态、技法； 美食背后的营养、步骤、选材； 衣服背后的面料、量裁、版型； … 文化背景有了，交织起来，你这个人不就鲜活了吗？ 一个人的体态、神态、心态会合力展示出此人的生活状态。 这里的合力就像物理不同方向不同大小的力作用到同一件物品上的最终呈现。 这也是磁场相同的人互相吸引的原理。 有了文化底蕴，你也能从根本上避免媚俗这件事。 弱者才会本能的寄希望于依附更强大的力量。 弱：指文化属性上的弱，或者说精神力的弱小。无褒贬含义，乃必经之路。 孔老讲话了：“己欲立而立人，己欲达而达人” 强大自我没错的。 从这个角度来看，处于“认识你自己”阶段的朋友，个性一点是无可厚非的啦，开心就好。 只要不违法乱纪、不波及他人、不伤害生命健康。 所以无论如何： 敏锐是建立在兴趣与爱好之上的生活的人，本身的一种很自然的表现。 此处的延伸话题：痛苦&#x2F;挫折之上的趣味怎样发觉？（暂不赘述） 你会对所有事物感兴趣，眼睛滴溜溜的转，小脑袋瓜里的灵气也会越来越浓。 所谓灵气、天赋当然有靠先天带来，但后天的培养更加重要。相信我。 并且这种东西并不是一成不变的，相反它是随时变化的。 “众人皆是佛” 你的正向思维模型如同“造轮子”一样，不断的推动你进步。你的力量会越来越强大： 表达能力、 沟通能力、艺术理解力、共情能力(情商)、学习接收能力，表现力，精神意志力，体力，思考力，行动力 …… 人生百味。 知行合一 到这里，该表达的已经表达完了。能读到这里是我们两个人的缘分。笔者随时欢迎各位任何形式的沟通，以及沟通之上的挑战、质疑、批评。 最后希望大家能够理论与实践相统一，认识自己，发现自己，爱上自己，最后成就自己。 最后分享一个小心得： 人这一辈子，将始终在不同领域扮演“弱者”。不要害怕弱小，不要担心无助。自渡者天渡之，时来天地皆同力。天地有正气，杂然赋流形。希望我们都能在兴趣中探索新的体验，在反思总结中收获成长。 逆境沉淀积累，顺境乘势而上。 “ 惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色,取之无禁,用之不竭,是造物者之无尽藏也 。” 最后用教员的话结尾吧: “1917年4月，毛泽东在《新青年》发表《体育之研究》一文，其中论及“体育之效”时指出：人的身体会天天变化。目不明可以明，耳不聪可以聪。生而强者如果滥用其强，即使是至强者，最终也许会转为至弱；而弱者如果勤自锻炼，增益其所不能，久之也会变而为强。因此，“生而强者不必自喜也，生而弱者不必自悲也。吾生而弱乎，或者天之诱我以至于强，未可知也”。 “"},{"path":"/2024/04/19/我对情商里“和稀泥”的理解/","content":"我对情商里“和稀泥”的理解今天吃完早饭，和好朋友发生了一场颇为受益的对话，特此记录，供自己玩味，也分享给各位。 引用语料： b站up主 戎震 （《社交能力决定你阶级跃升的速度，想要变得受欢迎》） 《论语别裁》 《中国哲学简史》 知乎博主：墨子连山 （专栏【三十年来《道德经》实践总结】） 朋友问：你怎么理解情商？ 我个人的观点： 情商的中心思想是“礼之用，和为贵” 《论语·学而》：“有子曰：‘礼之用，和为贵，先王之道，斯为美，小大由之。有所不行，知和而和，不以礼节之，亦不可行也。 阐述礼之用，和为贵。礼是行为，和是状态。既然有和，那肯定就有不和。和与不和是“情商”这一矛盾的两个方面，是情商两面性的体现。可以说我们在待人做事时的初衷都是“以和为美”。这是我们的大方针。当彼此的矛盾难以协调，出现分歧时，就需要完成两者相互转化的过程，通过不和而成其和，把问题摊开分析再去解决。这是一个斗争的过程，也是情商这一矛盾对立统一的体现。 对于两个人之间的小和，我们可以说“和气”“和平共处”； 对于群体或者系统之间的大和，我们可以说“和谐”“和顺”。 举例：舍友行为习惯不好，睡眠时间咣啷当啷，不尊重其他舍友。他影响了你的睡眠，你认为他很傻X。 这时就需要打破“和气”的假象，实事求是的和舍友进行沟通，把双方的利益诉求说清楚，达成一致。这个协商过程双方是对立的，协商完成则完成统一，也就是“不和成其和”的完成。 转化之后，舍友得到了你的尊重，不再有不尊重他人的愚蠢行为；你发泄了不满，也有了更好的睡眠环境。 行为的理想与否是分场景的（中庸），不同场景，礼仪要求不同，故有所不行。就像书上中西古今场景混为一谈的反例。 但只讲目的，不讲方法，又容易矫枉过正(亦不可为)；方法就是合乎场景的礼节（或者某种处世哲学），通过方法，春风化雨，以礼节之，达到调和均衡，大家开心的目的。 [礼源于天理，是天理的具化，对人言语行为的约束，人人真诚的遵守礼节，则人与人关系就能和谐，这其间真诚很重要，否则就是在演戏，所谓的和便成了一种假象。] 意诚而后心正，心正而后身修；真诚是人的生活中的基底，是’道’层面的坚守。相对来说，对他人真诚也是对自己真诚。而且真诚不一定是盲目跟从客观叙事，而应是一种心底的动机，行为的源泉。这样说来，倒不怕因真诚而犯错或者被误会了。不患人之不己知，患不知人应该也是这种感觉吧。而且由道生术，在学习成长上也可以联想到知之为知之，不知为不知，是知也。基本功不好，再花哨的动作也外强中干，成了一种假象（骗人也骗己）。 冲突：主要矛盾和次要矛盾人生来便有立场，在社会中就有其地位以及阶级，也就有自身所代表的利益。 在各种纷繁交错的社交关系和社会章程中，必然会出现利益矛盾、利益冲突。这时就要分析清楚主要矛盾和次要矛盾，进行合理的协调和取舍。 网上有个段子说：“我说我杀人不眨眼，你问我眼睛干不干”。面对一个人杀人的行为时，我们当然不会研究这个人的姿态优不优雅，发力标不标准。而是思考这个人杀人的动机，背景。这是因为杀人者的目的往往不是“杀人”，而是另有原因。 同样的，分析问题时，要区分好主要矛盾和次要矛盾，认死理是书生气的表现，也是做事的大忌。 和稀泥的合理性和稀泥，顾名思义就是不认死理，难得糊涂。 小里说，当是非对错的追究已经不能达成更大层面的“和”，满足大部分人的利益时，对错&#x2F;真相就已经失去了它的效力，不再是主要矛盾了。 大里说，我们要反对本本主义，不唯上不唯书只为实。而实际事态的情况变量极多，很多情况需要我们有所侧重，一定程度上忽视次要矛盾。这也是一种“和稀泥”的表现。 这里的大部分人并非是狭隘绝对的少数服从多数。而是指在对于整个系统而言，在人群之中代表最大利益占比的一方。也就是让整个系统和局面和谐共生、和顺运转的“主要矛盾”。 也是现实中坚定不移跟党走的论据之一。 书接上文，我们在学校里待多了，形式逻辑的训练过量甚至溢出了，就容易“瘸腿”，只知道搞标准答案，不知道对于很多人生课题的答卷，根本没有标准答案，只有局部最优答案。甚至科学知识里的真理也是不断修正变化的。 处理人情世故和做事这类混沌系统时尤其如此。和稀泥往往也是解决问题的一种方案，就好比沉默也是一种表达。 或者说，我们在面对生活琐碎小事的很多决策时，都是下意识采取和稀泥的方式而不自知。因为人的神经元毕竟优先，需要把精力放在更重要的事情上。 所以不管是和稀泥也好，还是把事情分析明白、表达明白也好，都要“实事求是”，一切以时间地点条件为转移，从实际出发，抓住主要矛盾，解决主要问题，让项目或事态顺利推进下去。 一个很鲜明的例子就是“酒场”。 酒本身是很单纯的，分析酒作为饮料时大家是不是爱喝没有意义。我们需要分析的是“酒场”，也就是当酒在人群中作为一种社交媒介时的意义。 对于酒桌文化，现在网上有很多人一棍子打死，觉得是彻底的糟粕，就像数十年前“打倒孔家店”的批孔潮流一样。这类思想实际是很偏激片面的，没有辩证看待酒桌文化，只看到其坏处没看到其好处。 酒从主观生理上能让人放下戒备，更加感性。客观上又能提供一个媒介，以酒为引子推进两个人的谈话沟通。 一个具备酒文化素质的朋友，能够在维护自己基本利益的基础上，和对方达成最大程度的合作。 这是酒的好的一面。 当然，凡事有度，物极必反。酒多误事，借酒欺人的形象也存在。所以我们也要具备一些酒文化的知识理论基础。（况且酒没有意识，有意识的是人，酒的作用全在人的操作下） 其中的尺寸拿捏是酒文化的落地实践方法论，本文不予赘述。 下面是对“和稀泥”和“礼之用，和为贵”情商思想的延伸讨论：为什么会形成这种处世方式和情商体系？ 中西方的文化差异地理和经济&#x3D;&#x3D;地理：&#x3D;&#x3D; “子曰：知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。”（雍也）中国是大陆国家。古代中国人以为，他们的国土就是世界。汉语中有两个词语都可以译成“世界”：一个是“天下”，另一个是“四海之内”。 海洋国家的人，如希腊人，也许不能理解这几个词语竟然是同义的。但是这种事就发生在汉语里，而且是不无道理的。从孔子的时代到上世纪末，中国思想家没有一个人有过到公海冒险的经历。如果我们用现代标准看距离，孔子、孟子住的地方离海都不远，可是《论语》中孔子只有一次提到海。他的话是：“道不行，乘桴浮于海。从我者其由与。”（《论语·公冶长》） 孟子提到海的话，同样也简短。他说：“观于海者难为水，游于圣人之门者难为言。”（《孟子·尽心上》）孟子一点也不比孔子强，孔子也只仅仅想到“浮于海”。 所以，生活在海洋国家而周游各岛的苏格拉底、柏拉图、亚里士多德该是多么不同！ 古代的中国士子们，所赖以触发灵感的自然环境都和土地有关。这一文化特征也表现在了经济形式上。 &#x3D;&#x3D;经济：&#x3D;&#x3D; 古代中国和希腊的哲学家不仅生活于不同的地理条件，也生活于不同的经济条件。由于中国是大陆国家，中华民族只有以农业为生。甚至今天中国人口中从事农业的估计占百分之七十至百分之八十。在农业国，土地是财富的根本基础。 所以贯穿在中国历史中，社会、经济的思想和政策的中心总是围绕着土地的利用和分配。 中国哲学家的社会、经济思想中，有他们所谓的“本”“末”之别。“本”指农业，“末”指商业。区别本末的理由是，农业关系到生产，而商业只关系到交换。在能有交换之前，必须先有生产。在农业国家里，农业是生产的主要形式。 所以贯穿在中国历史中，社会、经济的理论、政策都是企图“重本轻末”。 “士”虽然本身并不实际耕种土地，可是由于他们通常是地主，他们的命运也系于农业。收成的好坏意味着他们命运的好坏，所以士子们对宇宙的反应，对生活的看法，在本质上就是“农”的反应和看法。加上他们所受的教育，他们就有表达能力，把实际耕种的“农”所感受而自己不会表达的东西表达出来。这种表达采取了中国的哲学、文学、艺术的形式。 从生产方式的角度看： 具体到一个农户，中国农民的传统形象是“面朝黄土背朝天”，是“足蒸暑土气，背灼炎天光。力尽不知热，但惜夏日长。” 所以村子里最棒的人，不是坐在地头上夸夸其谈、巧言令色的人，而是踏踏实实，低头一门心思耕种的人。 “你不要说话，不要像没用的；踏踏实实的干活，把今天活儿干完了。一家子就指着这块地了！” 耕种好了，粮食收获了，这一年的收成就有了，大家就不挨饿了，能“过日子”，好好活着了。 《士兵突击》许三多：有意义就是好好活，好好活就是有意义。 不好好耕地，说大话的人，不管怎么信口开河、妙语连珠，搞不出粮食就是白搭。 所以大家对于表达是很含蓄的，我们父母这一代，能面对面，不扭捏几下说出来“我爱你”的，都算是极开明的父母了。 实际上这也算是传统中国人含蓄品质的一个小由来吧。并不严谨，仅供各位玩味。 实际上这种协作农耕的生产方式，也是中国人情社会的一个缩影。这里不再赘述。 综上而言：所以“农”的眼界不仅限制着中国哲学的内容，例如“反者道之动”，而且更为重要的是，还限制着中国哲学的方法论。 社会有四个传统的阶级，即士、农、工、商，“商”是其中最后最下的一个。“士”通常就是地主，“农”就是实际耕种土地的农民。在中国，这是两种光荣的职业。一个家庭若能“耕读传家”，那是值得自豪的。 至于表达的具体特征，我们可以通过中西方的语言特点来体会。 语言和经济背景的联系&#x3D;&#x3D;先聊下祖先，也就是东方自然语言：&#x3D;&#x3D; 现在聊到文言文，都是古籍里的语言了。但在新文化运动前，我们日常所说的还是“白话”，不是正统的书面文。 同样的，在古代也有白话。但古代的文字记录成本太高。最早时纸还没有出现，传播语言的形式是甲骨文，在龟壳上雕刻。或者在竹简上刻字。这两个形式都不是动动手，敲敲键盘就能完成的简单功夫。 所以古人在书面上写字成为一件很奢侈的事。人力物力的条件必须要求先贤们“惜字如金”，追求文字的简洁，即“书面文言文”。 恰好，汉字的一个极大的优势就在于单个字的潜力。一个“道”字能阐述出来多少世界观、方法论，无穷无尽，回味无穷！ 同样的，在对这些言简意赅的文字的揣摩中，自然语言的一大精髓“境界”便出来了。 这是追求境界的数学语言力所不殆的。 &#x3D;&#x3D;对于西方的朋友，也就是西方数学语言：&#x3D;&#x3D; 希腊人生活在海洋国家，靠商业维持其繁荣。他们根本上是商人。商人要打交道的首先是用于商业账目的抽象数字。然后才是具体东西，只有通过这些数字才能直接掌握这些具体东西。这样的数字，就是诺思罗普所谓的用假设得到的概念。于是希腊哲学家也照样以这种用假设得到的概念为其出发点。他们发展了数学和数理推理。为什么他们有知识论问题，为什么他们的语言如此明晰，原因就在此。 而对于海洋国家的人，不要说他们心肠坏、诡计多，换成说他们很精细、很聪明。我们还可以套用孔子的话，说海洋国家的人是知者，大陆国家的人是仁者，然后照孔子的话说：“知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。” 结论——语言表达的特点诺思罗普(Northrop)教授说过，概念的主要类型有两种：一种是用直觉得到的，一种是用假设得到的。 他说：“用直觉得到的概念，是这样一种概念，它表示某种直接领悟的东西，它的全部意义是某种直接领悟的东西给予的。 举个例子： ‘蓝’，作为感觉到的颜色，就是一个用直觉得到的概念。 ‘蓝’，在电磁理论中波长数目的意义上，就是一个用假设得到的概念。” （用假设得到的概念，是这样一种概念，它出现在某个演绎理论中，它的全部意义是由这个演绎理论的各个假设所指定的。） 往往从假设的概念出发的哲学家就偏爱有区别的，从直觉的价值出发的哲学家则偏爱无区别的。 所以“农”的眼界不仅限制着中国哲学的内容，例如“反者道之动”，而且更为重要的是，还限制着中国哲学的方法论。 从语言上的表现更是如此。 所以先说结论： 东方自然语言优势在于深度、广度，讲究“言有尽而意无穷”，“只可意会不可言传”。劣势是逻辑推理中的精度有所欠缺。 西方数学语言优势在于精密、清晰，讲究“环环论证，逻辑严谨，正确答案，一加一只能得二”。劣势是难以描述混沌系统。 所谓哲学，实际上是人类使用自然语言]对宇宙万事万物进行的建模，建模的过程也就是对语言潜力的挖掘过程。 人类自然演化和社会演化过程中，势必要对眼前的事物运转规律有所认知，在这个认知的过程中，有两个切入角度：一个是科学，一个是玄学。 在混沌系统中，针对客观存在的事物对象，想要了解对象的运转规律，就需要我们不断通过实验验证和理论推敲，来得到事物背后的规律。在这一认知体系里诞生了科学，从逻辑角度区分就是&#x3D;&#x3D;形式逻辑&#x3D;&#x3D;。 形式逻辑是自然语言内生的一套体系，任何成熟的语言都必然包含了形式逻辑系统，这是人类自然演化和社会演化的必然结果。 同时，针对那些从未遇见也没有必要存在的对象，也就是在客观事物之后“涌现”出来的东西，例如“本体”，“自由”，“道” 甚至人的色声香味触法等等，哲学所研究的对象正是他们，也就是形式逻辑、数学语言难以描述的东西。 当哲学模型无法精确表述他所研究的内容，形式逻辑已经捉襟见肘时，只能退而求其次求诸于语言中不那么精确的部分，也就是&#x3D;&#x3D;朴素逻辑&#x3D;&#x3D;。这一逻辑的主要描述方法是类比法。说他朴素，其实一点也不朴素，这恰恰是自然语言的精髓，是自然语言的“境界”担当。 正是因为有了朴素逻辑，人类才能够描述“美”以及上面提到那些高度抽象的“涌现”。 综上所述，两者所属的领域用一句中国古话概括：“形而上者谓之道，形而下者谓之器”。 道者，所有规律的总称，是整体，是客观存在；德&#x2F;器，具体事物的规律、本性，是个别，是主观存在。 何以得德？由乎道也。何以得道？格物致知、知行合一。 当知行合一的极致体验多了以后，做事的方法论就出来了。方法论精进后，便接近这个世界的本质、规律了。 这也能解释为什么哲学总是强调「阅读经典原著」，而科学却没有类似要求。 因为数学语言的本质是形式逻辑，是绝对精确的，因此数学模型在传播过程中也不会出现以讹传讹的情况。无非是一些基础假设和数学公式。 至于实验验证，简单的我们可以自己动手实验，例如浮力实验，稍微复杂点儿的我们则只能相信科学共同体的结论，例如引力波探测。 而自然语言的本质是朴素逻辑，讲究懂的都懂，所以更容易发生以讹传讹。于是为了避免传播造成的歪曲，我们最好去读读原著。 例如“存在即合理”，“我思故我在”，“他人即地狱”，绝大多数人对他们的理解与作者原意相去甚远，有些甚至背道而驰。 延伸一下：对于直觉，诺思罗普还说，用直觉得到的概念又有三种可能的类型： 已区分的审美连续体的概念。 不定的或未区分的审美连续体的概念。 区分的概念。 照他的说法，我们可以有一个新的角度来看待中国文化中两大学说：儒家和道家。 儒家学说可以定义为一种心灵状态，于是不确定的直觉到的多方面的概念移入思想背景了，而具体区分其相对的、人道的、短暂的‘来来往往’则构成了哲学内容”。 道家学说中，“则是不定的或未区分的审美连续体的概念构成了哲学内容” 再回到统一的中华文化中来说，已区分的审美连续体的概念，由此而来的未区分的审美连续体的概念以及区分的概念，基本上是“农”的概念。 “农”所要对付的，例如田地和庄稼，一切都是他们直接领悟的。他们淳朴而天真，珍贵他们如此直接领悟的东西。这就难怪他们的哲学家也一样，以对于事物的直接领悟作为他们哲学的出发点了。 这一点也可以解释，为什么在中国哲学里，知识论从来没有发展起来。我看见我面前的桌子，它是真实的还是虚幻的，它是仅仅在我心中的一个观念还是占有客观的空间，中国哲学家们从来没有认真考虑。 这样的知识论问题在中国哲学（除开佛学，它来自印度）里是找不到的，因为知识论问题的提出，只有在强调区别主观和客观的时候。而在审美连续体中没有这样的区别。在审美连续体中认识者和被认识的是一个整体。 这一点同样可以解释，为什么中国哲学所用的语言，富于暗示而不很明晰。它不很明晰，因为它并不表示任何演绎推理中的概念。可在体验过很多看不见、摸不着的体验和经验后，哲学家不过是把他所见的告诉我们。正因为如此，他所说的也就文约义丰。正因为如此，他的话才富于暗示，不必明确。 像道德经全文，是由关令尹喜记录，老子口授的。原话我们无从知晓，而为了增加我们理解的正确率，只能通过不断重复、反复印证同一个意思来增加容错率。 形式逻辑和朴素逻辑于是形式逻辑和朴素逻辑的两个思维方式的区分就很明显了。 或许我们这一代的义务教育里，理科和文科的切分太粗糙了。好像彼此之间水火不容一样。 实际上这两种逻辑也是相互配合的。 例如：通过黄金分割率，通过形式逻辑描述一种自然审美。这种审美又需要我们用朴素逻辑去感知。 所以我觉得一个精神健壮的人可以跳过这些标签的掣肘，不要习惯性的对抗，守着某个阵营的牌坊和另一阵营，这太小气了。 为我所学，为我所用。江上之清风，山间之明月，耳得之而为声，目遇之而成色；取之无禁，用之不竭。是造物者之无尽藏也，吾与子之所共适。 让自己成为一个全面发展、博闻强识的有趣的人。 一个合理优质的教育环境对人的塑造是极其惊人的。当今的教育体系综合各方经济、文化以及制度的权衡，只能让孩子们先在一条路上往深里走。但学校教育最多持续二十余年，剩下的八十年还要靠我们自己的后天教育。 我和朋友聊天时提到一个观点，我们对很多事情的考虑还停留在初高中教育模式带来的思维惯性上。 很多人看到数学就觉得望而生畏。实际这是应试教育体制给孩子们打上的思想烙印而已。当我们放下考试和分数，在闲暇时间仅仅为了有趣和探索，去慢慢的、缓缓的体验数学，或许也能得到“知识的快乐”吧。 所以无论是文科理科、男性标签和女性标签（传统意义上）、形式逻辑还是朴素逻辑，我们都可以接受，然后将其营养内化于心。 潘石屹给自己的生日礼物是学python。 君子不器，周而不比。博学之，审问之，慎思之，明辨之，笃行之。在实践和意识的相互强化中，波浪式前进，螺旋式上升。 和大家共勉。"},{"title":"内卷的本质","path":"/2024/04/19/内卷的本质/","content":"内卷的本质 在一个剧场里，大家都在看戏。每个人都有座位，大家都能看到演员的演出。忽然，为了看的更清楚，有一个观众站起来看戏了。他这一站挡住了别人的视线，于是别人也得站起来看。、于是，周围的人为了看到演出，也被迫站起来看戏。 最后全场的观众都从坐着看戏变成了站着看戏。 内卷本质上是一种零和博弈。大家同时往前迈一步，彼此的“相对差距”实际上是不变的。于是大家一起白受累。 两个人摽着膀子一起干，那不叫内卷。因为那确实是让双方受益，激发出了彼此的潜能。这是正和博弈。 有意思的是，当第一个站起来的观众出现时，他作为一个火种，将点燃整个群体的火焰。 教育制度里，一个超级中学的出现，意味着整个社会的教育产业都要快马加鞭了。 内卷的表现有句话叫“上赶得不是买卖”，你知道为啥吗？ 因为当你所处的生态圈到达一定层次，大家都会有点欲望、野心，都不缺上进心。 没有收集足够的信息，正确分析出眼前的形势，就埋头往前冲，等待你的只有懊悔。注意，不一定是失败。你可能会收获旁人眼光中的成功和”收获“，但目的地未必会是你的初心所想。 因为你压根没想清楚为什么要这么干。你只是觉得自己应该冲，像一头绕着石磨盘埋头冲刺的驴一样。这个情况下，溢出的上进心和匮乏的分析能力共同作用下，这头驴甚至还会透支身体，咬牙让自己再往前顶顶。 最可怕的是眼前真的有个胡萝卜在驱使着你，欲望！ 这里有个段子：如果努力是最有价值的属性，那世界首富应该是一头驴。 所以内卷的本质是零和博弈，表现之一则是焦虑。 对一个内卷的朋友来说，焦虑和负罪感是最好的动力！ 拿一个应试教育的例子吧： “这个学生很可能不知道，他的困境有潜在的根本原因。他最终接受了世界对他的评判：他是愚蠢的、迟钝的，或者是懒惰的。这是一个失败的循环，会削弱学生的自尊心，让他最后因气馁或羞愧而自暴自弃。 这个观点非常重要。一个正在困境中挣扎的孩子不会说：“这个不称职的老师根本不了解大脑功能的状态依赖，也不知道创伤正在影响我的学习能力。他应该帮助我进行调节，而不是对我进行错误的指责。”孩子只会说：’我一定是个笨蛋、懒狗。’” 焦虑和负罪感压根不是什么可维持动力。你就看吧，那些行色匆匆，恨不得独与天地往来的朋友，一旦那段“厚积薄发、励精图治”的过程结束，什么考研考公，减肥健身，学艺求知的过程结束，他们整个人都会垮掉。 那段过程的结束，才是人的最真实写照。 是本自具足，收获美满，意犹未尽； 还是咬牙切齿，唯恐避之不及？ 这个问题和内卷的朋友不好讨论。因为他们会选择性忽视。想问的尖锐一些，还不如问问他们是否在“自我感动”。 因为他们根本不是为自己而做。他们所依赖的，只是欲望、“别人目光里透露的期许”、虚荣心、“大家都这么干”等根本形不成“长期可持续且有趣的动力”的乱七八糟的东西。 醒醒吧！ 忙活半天，发现你的ROI不成正比，你会焦虑；焦虑半天，你会觉得是自己不够努力。 于是恶性循环：上进心、欲望、”干不死就死里干“这一套继续像名为“焦虑”的贪婪恶魔一样，逼着你鼓起最后一份勇气，榨干最后一丝力气。 当你实现目标以后，发现并没达到自己的期望，又重新向恶魔签订契约，投身到无休止的内耗中去。 这就是手脚勤快、脑子懒惰的结果。这就是战略定力和战略思维不匹配的后果。 所以内卷的表现之二：思维反刍(chu) 内卷高手都是自我 PUA 大师。 思维反刍的表现则是不自洽。 那些无端重复的大量负面情绪是不自洽的最好声明。 注意：这里的重点不是负面情绪，是无端重复。 无端，意味着你没有意识到为什么会产生这次负面情绪，更不知晓怎么排解这次负面情绪。 重复，意味着你的思维体系有一些恶性循环没有及时解决，还在拉低你的能量。 强调一下，这是个充分不必要条件：内卷和思维反刍会让你不自洽，但不自洽不意味着你思维反刍和内卷。 因为实际上不自洽是极度正常的。我们的阅历见识是有限的，思考能力也自然有其局限性。 不自洽本身不是什么问题，实事求是，勇于自我革命，把知行体系里不自洽的部分改掉就是了。 最后，我作为一个计算机专业的学习者，写一段话勉励自己，也供大家玩味： 大家太在意一个结果，而忽视了真正的底层竞争力。 我看到学长大二开始三级跳，就把眼睛盯在实习上。但完成跳跃的原因是比所有人快，比所有人赶吗？ 并不是，那只是急于求成，追名逐利的表象。核心是他的兴趣 ，让他即使完不成三级跳，也能在兴趣中不断提高技术竞争力。这才是“真本领”。 有路不走的另一阐释 ，即最笨拙的方法反而是捷径。这是注重结果的我们所看不到的。 即使在速成功夫中拿到了短暂成就，也会在后续的工作中地基不稳、摇摇晃晃。这些是找到好工作考上研后大家所看不到的故事。也是唯结果论的目光不及之处。 大环境不洗牌的情况下，真本事才是硬道理。 破局先说结论：关键在于&#x3D;&#x3D;选择&#x3D;&#x3D;。 选择无非就两点：挖掘个人价值，满足社会需求。 个人价值：当你的个人价值够大，即使社会受众面小，需要你的人少，你也能得到巨大收益。因为你的价值让你牢牢把握住了属于你的生态位。你的一亩八分地，别人是轻易抢不走的 —— 这个不可替代性也会让需要你的人难以离开你。 非遗继承人，高精尖技术人才，艺术领域开创者。 社会需求：可能你的个人价值并不大。但你满足了社会需求，尤其是翘首以待、生态位空缺的需求，也能被社会群体推着往上走，继而创造大的价值。 小里说，房地产新兴的土木，互联网泡沫的程序员，经济上行时的金融，都是红极一时，”五陵年少争缠头“到”门前冷落鞍马稀“的主。 大里说，丁针珍珠和16年开发出抖音的字节跳动，都是满足社会需求，被时势的浪潮推到人民群众的眼前的。 挖掘个人价值&#x3D;&#x3D;收集信息：认识你自己&#x3D;&#x3D; 希腊圣城德尔斐神殿上的一句著名箴言：Σεαυτον ισθι 英文叫 Be Yourself or Know Yourself ，中文是 “认识你自己”。 认识你自己。我的理解是认识并延伸自己的长板，补齐自己的短板。 短板： 负面情绪：负面情绪的产生是思维体系不完善的体现。当你通过分析实践让引发负面情绪的事情不会再传递给你负能量，甚至能一笑置之，这一部分就自洽了，你也变强大了。 行为习惯：坏的习惯要改正。站没站相，坐没坐相，体态猥琐，卫生邋遢。都是要改的。你的形象是你个人的第一张名片，也是展现你内心世界的第一个窗口。 强化者，甚至可以管理自己神态举止。应时而用。 拧巴：做一些事拧巴、不自然的时候，那必是不自洽了。脑子里有什么阴影、创伤之类的自我保护机制在作祟。找到源头，让自己大大方方的接受或拒绝去做。 疲劳：气血不足，心力匮乏，身体柔弱，双眼无神，精气神扁塌，都是要克服的疲劳表现。不过疲劳相比行为习惯的改善，要更细腻一些。 一言以蔽之：花一定的时间让自己自洽，补全思维体系，观念认知，让自己的精神内在和身体外在上都能相比昨天更健壮。 长板： 兴趣热爱：你最容易产生兴趣的事情往往藏着你最擅长的事情。“游戏、手机”这类事情也未尝不可尝试。比如玩一天的游戏，玩一天的手机。如果有所产出并且不累，甚至能余味无穷。那么恭喜你，你非常幸运的找到了自己的热爱。 思考方式：这其实有点天赋的意思。不过不是高下之分，是水平面上侧重点不同。找到最适合你思考习惯的事情，往往也能事半功倍，更容易创造价值。 像逻辑性比较强的天生适合理论上的玩意儿。数学逻辑里的 数学、编程、机械、电工等。情绪感知敏锐，信息综合能力强的适合文史经法社。 外貌举止：我没开玩笑。颜值确实有高低之分，但这种比较对我们的成长没有意义。我们要纵向和自己比较。结合自己的优势、特点甚至文化背景、审美偏好，去让自己的外形举止和自己的内心统一。这算是知行合一，内外协调的小小实践。也能增强你对生活的掌控力（本人实测）。 认知：一定要搞清楚自己有必要做什么、没必要做什么。努力获取优质的，进步的信息。避免垃圾信息，快餐信息。 正向习惯的培养：太极生两仪，两仪生四象，四象生八卦，八卦定吉凶，吉凶生大业。人和人之间的差距无非就是习惯不同。 时间问题，暂时想到这些。 概括一下：保持自己的和谐与自洽，完成认知和行为的统一。全面的发展自己的精神和肉体，在发展中感受生活、体会生活。 自信：认知和行为的统一，知道自己该干什么，不该干什么，对局面保持乐观。 &#x3D;&#x3D;整合信息：完善你自己&#x3D;&#x3D; 悟已往之不谏，知来者之可追。 信息已经收集完了。你大概知道自己是个什么成色了。于是可以保持对自我的把握，自然的敬畏了。 此时，就可以默默的发育完善自己，让自己变得健壮强大。 择其善者而从之，其不善者改之。 朋友也是很重要的能量来源，一个敢于面刺的朋友更是极其稀缺，只是我们通常为了自己愚蠢的自尊心，把握不住这种诤友。 不断精进自己的思维模型和行为模型，掌控宏观上的认知模型和心理上的微观表征，知行合一。 在不断实践和感受反思中，找到自己的价值所在。这一点其实不容易做到，因为一件事的周期最少也得按月来算。 达到极致体验就得论年。而我们的机会窗口期可能就那么一段时间。 所以我说，能早早找到自己价值所在，兴趣所在的人是极其幸运的。 所以：找到你自己的本领，找到那个能解决他人问题的同时，自己又能不断成长的能力。利用网络资源博观约取。 当你的价值交换能力增强，为社会提供价值，自然获取相应回报。同时脱离了少数人的评价系统。 多数人都在数目极其有限的少数人的反馈上进行生活。自己的心情、奋斗、动力都由别人掌控。 分清可控和不可控的，把可控的事装入做事的内存条（值得投入精力的地方）。增强系统的可控性，心境平和、抱朴归真。 可控当然不是保守。冒险和勇气也是增强可控性的源泉。因为你敢于去面对挑战。 &#x3D;&#x3D;发展你自己&#x3D;&#x3D; 这时，你就能收获有效实践带来的自我价值感，通过积累量变达到质而形成一片片的方法论——认知高度与践行厚度。 方法论多了，手里的神兵利器就会越来越锋利。培养好习惯的成本就会越低，实践过程中遇到什么困难都能砍瓜切菜，一笑而过。 于是好习惯越多，越不容易自毁自责。攒下足够的能量和气血，你的吸引力、生命力也会逐渐变强。 于是不被短期内的利益所动摇，不被慌张、焦虑、急于答卷的人事物所迷惑。因为你站在全局的角度，比其他人多了一个维度——时间，对过去的理解，对未来的判断，对当下的把握。 发展眼光看问题： 这是我们在回过头来看高中政治课本必修四，里面的发展眼光看问题—— 前途是光明的、道路是曲折的。 新事物是符合客观规律，具有强大的生命力和远大前途的事物。对我们自己而言，则是自我革命之后的自洽稳定的和谐状态，一个更加强大有力的精神内核。 新事物成长总要经历一个由小到大、由不完善到比较完善的过程。人对新事物的认识也有一个过程。旧事物在开始时往往比较强大，因而总是顽强抵抗和竭力扼杀新事物。 事物的发展是前进性和曲折性的统一事物发展的前途是光明的，道路是曲折的；对未来的信心和热情支持着新事物的成长。做事时，我们要做好充分的思想准备，不断克服困难，勇敢接受考验。 是不是没那么空洞了？ 所以长期主义看，完成比完美更重要。 有恒比有力更重要。 举个刚刚学到的例子： 事例一： 1927年大革命失败后，国内政治局势急剧逆转，原来生机勃勃的中国南部一片腥风血雨。蒋介石在南京建立政权后，经过一系列新军阀混战，建立起在全国范围内的统治。这个政权对外实行反苏、亲帝的政策，对内竭力维护官僚买办资产阶级和封建地主阶级的利益，限制和压制民族资本主义的发展，残酷地镇压、屠杀共产党人和革命群众。因此，同北洋军阀一样，它仍然是一个代表大地主大资产阶级利益的独裁专制政权。在这样的政权统治下，中国共产党必须继续进行反帝反封建的民主革命，首先必须直接反抗国民党的反动统治。然而，这时的党却遇到了前所未有的困难。据不完全统计，从1927年3月到1928年上半年，被杀害的共产党员和革命群众达31万多人，其中共产党员2.6万多人。在极其险恶的局势下，党内思想异常混乱，一些同志和不坚定分子离开党的队伍，党员数量急剧减少到1万多人。与此同时，工农运动走向低沉，相当多的中间人士同共产党拉开了距离。事实表明:中国革命已进入低潮。 事例二： 国民党军采取堡垒主义的新战略发起“围剿”，红军仓促应战。1933年初，日军大举入侵华北，中华民族危机日益严重，然而国民党政府主席蒋介石却置民族危亡于不顾，仍然坚持推行“攘外必先安内”的反动方针，决心消灭共产党及其领导的红军。从1933年9月25日至1934年10月间，蒋介石调集约100万兵力，采取“堡垒主义”新战略，对中央革命根据地进行大规模“围剿”。这时，王明“左”倾教条主义在红军中占据了统治地位，拒不接受毛泽东的正确建议，用阵地战代替游击战和运动战，用所谓“正规”战争代替人民战争，使红军完全陷于被动地位。经过一年苦战，终未取得反“围剿”的胜利。最后于1934年10月仓促命令中央领导机关和红军主力退出根据地，突围转移，开始长征 。 柳暗花明又一村 党曾两次经受严峻的考验:一次是大革命的失败，一次是第五次反“围剿”的失败。在常人难以想象的险恶环境中，中国共产党人不屈不挠，埋头苦干，度过最黑暗的时刻，奇迹般地开创出新的局面。 满足社会需求本人未经社会洗礼，诚惶诚恐不敢妄言社会之事。此处需各位前行路上慢慢玩味求索。 信息源&#x3D;&#x3D;信息素材&#x3D;&#x3D; 平台： b站up主：matt，戎震 公众号专栏 历史： 以教员为例：了解他的生平事迹和相关党史，然后看他的著作（《毛选》），从高能量人身上获得能量。 学人： 第一个阶段： 先认可，了解这个脉络，譬如要学习毛爷爷的著作时，需要了解毛爷爷的生平，看到毛爷爷的传记，以及当时国内的现状，还是他人传记中关于毛爷爷的事迹，尽一切之可能分析其招数背后的哲学观。“有道无术，术尚可求”“见路非路即见如来，见相非相即因果”。 第二个阶段，看的时候更在乎他著作的一个思想连贯性，再譬如毛爷爷，他的论持久战里面实际包含了他的实践论，他的矛盾论，乃至湖南农民运动考察报告的思想。一片文章一本书的问世，结合了作者吸取希望经验阅历融合后对当下的思考。思考的高度综合化。 第三个阶段个人的世界观已经形成并丰富。他在发表一些文字，都会透露出浓浓的形象他世界观思想的味道。 学历史: “时间流序与地缘空间结合，这样的立体模型就出来了”“任何事情置于此种模型下来分析，就更全面立体深刻透彻”“我们的分析，就是把事物的各种可能性转化成现实性的边界条件界定出来，然后再分析现实环境，看满足哪一个条件，从而预判事物的发展趋向。”“我们是三维的，置身历史之中应该了认为是四维。 能够从时间，区位来看待事物的演变，就约等于让自己站在了五维的角度来看待。 这个五维角度，或可以称作上帝视角。就是毛爷爷著作中，一直都是中俯瞰众生的视野，气魄之宏达，令人澎湃。”大致是这个意思。这可能是读史书的意义所在，而并非仅仅是那个“可怜北邙山”，也并非“早生华发，一尊还酹江月”“兴百姓苦亡百姓苦”的喟叹。 我们都知道资治通鉴的作者司马光，他在评价王莽，包括商鞅时都并不是赞扬其开拓精神的观点，这个涉及到司马光对于王安石的一个态度。这个是客观存在德。 好了有了这个思维，我们再回头看汉王项羽之争的时候，就不会被陷入到就史论史，上演“关公战秦琼”的戏码了。 拓宽思维深读以及广度，能够理智判断分析一些案例，并能够指导自己当下的境遇，遇见更好的未来。这大概是我们读书的一个追求吧。 ————以上选自小马哥的聊天记录，知乎名：凌江之鹤 书： 《我们内心的冲突》 《当代为什么要读马克思》 《被讨厌的勇气》 《像阿德勒一样生活和思考》 《大学》《中庸》 &#x3D;&#x3D;基本素质&#x3D;&#x3D; 这里的素质每一个都能大谈特谈，作者在现实中和网络平台上也基本聊了无数遍了。所以这里只是罗列，不再赘述。 情绪管理、时间管理、精力管理：最重要的是情绪管理。 身体健康意识：健身、好的生活作息、生活规律。对妨碍健康的事情“如恶恶臭”。 全局意识：不被一城一池的丢失&#x2F;得到而动摇，不在意短期的负面形势变化。 谈判协商能力：分辨出有效谈话和无效谈话，有把握对话的意识。 对世界万物的热忱：仰观宇宙之大，俯察品类之盛。好奇心之上的兴趣是最好的驱动力。 兴趣是最大的利器，在争辩哪一个工具是最好用最优雅的时候，有的人已经在磨刀了。 仰头急于求成的多，低头踏实打磨的少。 注意哦——不要被思维惯性打扰。我可没说低头打磨就一定是做什么事。我反倒觉得你应该在做之前分析清楚，做之后保持定力（习惯），做之时不断优化迭代。 记录能力：写作或视频记录自己的收获和总结。甚至一个人对着镜子录音都行。 激发主动思考，展示自己。 费曼学习法：通过输出带动输入。感受主动思考带来的快感 , 而非痛感。 内容输出铁三角:、阅读、写作、表达 思维能力: 文字:文字本身的意义 观察-大样本观察:较多的样本和表象 反思-洞察:抽象出客观规律 执行:思维和行为的日常化（想通了） &#x3D;&#x3D;人物素材：&#x3D;&#x3D; 费曼：just for fun。兴趣驱动，费曼学习法。 马斯克：SpaceX，脱离低级趣味，理想驱动实践。 乔布斯：自我意识，周围人都是NPC，勇于跳出舒适区。 毛教员：主观能动性，叛逆，格格不入，混不在乎，高能量 赶走校长，为灾民和祖父辩论 &#x3D;&#x3D;方法论素材：&#x3D;&#x3D; 《大学》 大学之道，在明明德，在亲民，在止于至善。 知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天了以至于底人，壹是皆以修身为本。其本乱而末治者，否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。(部分版本无此段)完善 知止而后有定：你知道自己应该做什么，掌握信息分析清楚之后，决定要做了，就能保持定力放开手脚去做。（包括玩乐放松） 定而后能静：有了定力了，你的心就能静下来。因为你不用再纠结“我这么做不对呀”，我想干别的事呀等等 静而后能安：不纠结，就既来之则安之，先按着惯性走喽。遇到问题再及时修正。 安而后能虑：在做事的过程中，你知道你自己为什么要做这件事。踏实了，不慌张不焦虑了。就可以总结反思、优化迭代，不断变强。 例子：健身领域，我的运动笔记记录了我从小白到入门的过程。 虑而后能得：通过不断的总结反思，知行合一，实践和意识的相互强化，你就能得到成长，有所收获了。更重要的是，你培养出了一个好习惯，获得了一段极致体验，通过这个体验你能看到别人看不到的风景，从而洞悉到深层次的规律。 物有本末，事有终始。知所先后，则近道矣。 当你平衡好战略思维和战略定力，知道自己为什么要做，把握好主要矛盾和次要矛盾后（物有本末），你就能收获一段完整的旅程体验，也就是事有终始。 有了这段经历 —— 注意不是那种别人逼着你做，或者你不情愿去做，更甚至你做完了深恶痛绝避之不及的经历，不是这种经历！这是无效经历 —— 你就有了一段个人在特定领域的极致体验，知道了一个好习惯，一个领域的知识，一个事情从想法到完成的先后顺序和门道。你就能在这个过程中完善你的方法论，也就是了解到做所有事的一些规律。这叫”则近道矣“。 然后你就能凭借这个方法论指导你做其他事情。 用我上篇文章的话概括下： 道者，所有规律的总称，是整体，是客观存在；德&#x2F;器，具体事物的规律、本性，是个别，是主观存在 何以得德？由乎道也。何以得道？格物致知、知行合一。 当知行合一的极致体验多了以后，做事的方法论就出来了。方法论精进后，便接近这个世界的本质、规律了。 写于1.6.2024 9：55~11：30"},{"title":"扫雪有感","path":"/2024/04/18/扫雪有感/","content":"早晨八点起床，浑浑噩噩，浑身不得劲。正上愁怎么醒过来呢，老妈掀开门叫我扫雪。 晃晃悠悠，前半小时扫雪扫地拖泥带水，有摸鱼之嫌。后续热身开了，把家门口的雪三下五除二扫干净了。 村里大喇叭又喊着让我们去扫北街。 我们村只有两条大街，公路上对应两个入口。一个北当街，一个南当街。因为大队，也就是村委会在北街。所以村里的半大中年男人戏称其为干部街，因为有什么好事都先想着北街（宣传、布景、扫雪）。 所以你看啊。村子就是这样。即使一个村有两条街，两街间隔20米，也要分南北，喝酒的时候也要以南北为由划成两个阵营。 村里人的界限感很强的。村子里是南街北街、东头西头，出村就是这村人实在那村人刁，这村人长得丑那村人精。 在这种界限感下，是大家对“附近”这一概念的敏感。“邻里乡亲的，要什么钱啊还。” “一个村的，别要那么多啦”。“几十年前一个生产队的，就把礼物收下吧。” 只要絮叨几句，上老下幼都能攀上关系。所以大家也好“面”。村子里基建少，唯一发达于城市的便是情报中心——乡村老年俱乐部。 一个不冷不热太阳正好的晴天，某个宽敞的台阶上，会坐着一排的老人，在那或者发呆，或者聊完天发呆。这时如果你是归乡的学生，即使眼神如水一样清澈，经过的时候也能作为谈资被老人们聊上几句。 在城市里生活的人，单位是原子式的小家庭。在村子里生活的人，单位则是一个网。你的叔伯姨婶，表姐堂弟都距离彼此不远的地方，下一代也会在你通过辛苦挣钱垒起的房子里安家养老。所以村子极讲究“人多势众”，讲究人情往来，见面招呼。小孩子们也会在懵懂的年纪结拜，组成一个村里的小团体，方便日后红白事帮忙、撑场。 不过上面那段话的场景已经日渐消弭了，字里行间也遍布着旧时代的余晖。现在村里的朋友不会一口气生六七个孩子，通过最简单粗暴的概率望子成龙，以保证晚年的天伦之乐；也不会强行给儿女说媳妇说婆家，早早盖起那个“又村又土”的砖房。排排坐着的老人很难再遇到干一天活出一身汗回家的年轻人，一群群小孩围在一起的秘密基地也不是田野大洼，而是某家有wifi的空调屋 —— 那些玻璃球、玉米秸秆远远不如变化万千的手机有意思。 到了北街，一堆堆雪已经整整齐齐码在路的两边了。眼前是来来往往的三轮车，三五人站在雪堆旁边，哗哗地往三轮翻斗里装雪。不时有人呢喃着“别的村子没这个力量啊”“整个镇的人也到不了这个程度”，嘴里说着，眼睛眯着，身上洋溢着满满的乡村自豪感。这让我感到了集体生活的魅力。 想起刚听到村长在喇叭里吆喝大家帮忙，我趋利避害、着眼自我利益的本性让我迟疑，劝我别卖那个傻力气。但到了地方，干了活，看着一个个乡亲们通力协作，来来往往，我忽然觉得自己好像经历了一个奇迹 —— 源自上古时代，人与人之间的默契和信任。这时我才发现自己的狭隘。我亲身感受了“众人拾柴火焰高”和“独行快、众行远”的意义。 干了一早晨的活，到大队里吃馒头就肉菜。菜是暖和的，馒头是香甜的。这也是劳动的魅力。我想起来了士兵突击里老马对许三多说：“你现在混日子,小心将来日子混了你。” 勤快实际上是一种生活态度，一种面对嘈杂纷乱的专注，一种勇于改造生活的精致。我觉得生活里，脑子和手脚总得有一个是勤快的。如果你通过思考认为自己该休息了，给身心充充电，即使手脚懒散，也仍然是一种实事求是的向好态势。不知道以后自己在村子里，能不能有一亩八分地，像韩少功一样吃到自己亲手种的蔬菜，看到自己散养的花草长出来。 吃完饭回家睡大觉了。最后要感叹一句“年轻真好”。扫一早晨的雪，睡一个午觉就能缓过来，不知道什么叫累。每个人珍惜青春的方式不同，我切身体会最深的，便是青春年华里，一个小小的契机，总能让我在有钱有闲的时光里，培养出新的习惯，开启一段颇为有趣的历程。乔布斯说生命里的每一个点都会最终连成线。我不指望自己以后会有多大的成就，但我能保证一点：我从始至终都在培养新的习惯，在自己感兴趣的各个领域里实践着，在实践中收获着各种各样有趣的体验，在体验中找到了自己处世的意义和章法。"},{"title":"《程序是怎么跑起来的》笔记","path":"/2024/04/18/程序是怎么跑起来的/","content":"前言一个小原理 CPU在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指令从内存或I&#x2F;O中把数据输入到CPU中，在CPU内部进行运算，再把运算结果输出到内存或I&#x2F;O中。无论是小型微型计算机，还是个人的高性能计算机，原理都基本相同。 计算机的三个根本基础 &#x3D;&#x3D;计算机是执行输入、运算、输出的机器&#x3D;&#x3D;。 计算机的硬件由大量集成电路 IC(intergrated Circuit) 组成。每块 IC 上都有很多引脚。 无论多么复杂的程序，最终都是由一个个 “输入、运算、输出” 组合出的流程单位实现的。 三者必须成套出现，缺一不可。 &#x3D;&#x3D;程序是指令和数据的集合&#x3D;&#x3D; 指令：控制计算机进行输入、运算、输出的命令。 数据：分两类。一类作为指令执行对象的输入数据，一类是从指令的执行结果得到的输出数据。 &#x3D;&#x3D;计算机的处理方式和人们的思维习惯不同&#x3D;&#x3D; “汉诺塔”问题 硬件和软件，好比小霸王游戏机和插入游戏机的游戏卡一样。 也可以比作人的肉体和精神。缺一不可，相辅相成。 应用 根据三大原则理解一项“不好理解”的话： 2020年2月14日 微软公司率先提出了作为新一代互联网平台的*.NET*技术。作为.NET核心的XML Web服务使用通用技术SOAP、XML,促使企业间的计算机协同工作。 三大原则的理解： 计算机只是个执行程序的机器，程序是指令和数据的集合。 指令：SOAP是关于调用指令的规范， 数据：XML是定义数据格式的规范， 更方便执行程序：部署在其他计算机上能执行某种运算的程序叫做 XML Web 服务。 TCP&#x2F;IP 网络的简单理解TCP&#x2F;IP：传输控制协议和网际协议：Transmission Control Protocol&#x2F;Internet Protocol。 LAN ：Local Area Network （局域网）把办公室内的小规模网络称作LAN； WAN：Wide Area Network (广域网) 把互联网一样联结企业和企业的大规模网络叫做WAN。 以家用路由器为例，WAN口连光猫，从而连接到网络。LAN口连电脑之类的电子设备，即有线网络。 MAC : Media Access Control：标识网卡的编号。 几乎所有网卡上市前都分配了一个不可变更的 MAC 地址。 网卡 NIC Network Interface Card ：每一块网卡的ROM（Read Only Memory 只读存储器）里，都预先烧录了唯一的MAC地址。 由制造厂商的编号和产品编号两部分组成，所以独一无二。 服务器 Server ：服务的提供者。 客户端 Client ：服务的利用者。 在服务器上运行的程序为客户端提供服务。 集线器 Hub：把各台计算机的网线相互连接在一起的集线设备。 路由器 Router：把局部区域内的网络和互联网连接起来的设备。 路由器则负责把LAN接入到WAN上：一端连接互联网提供商的路由器，服务商继续将他们的路由器连接到其他地方，直到汇入互联网主干线缆上。 以企业内的LAN为一个基本单位，通过服务提供商的路由器把他们和其他企业的LAN互连起来，共同组成互联网。 光猫 Optical Network Unit，ONU：通常由网络服务提供商提供给用户。它充当了将光纤信号转换为电信号的桥梁，以便我们可以连接到宽带互联网。 光猫通常与光纤入户（FTTH）连接，并将光信号转换为以太网信号，以供我们使用。 IP 地址：MAC地址花样繁多，查找效率太慢。因此必须对计算机进行分组管理，除了硬件上的MAC地址，还需要设定一个软件编号，即IP 地址。 设定好 IP 地址的计算机为 ”主机(Host)“ 。路由器也是计算机，也有IP地址。IP地址的值也是独一无二的。 IP 地址中，把表示分组（LAN）的部分叫做”网络地址“，把表示计算机的部分叫做“主机地址”。 子网掩码：标识出 32 byte 的IP地址里，哪一位到哪一位是网络地址，哪一位到哪一位是主机地址。 转换成二进制后，值为1的则是网络地址，值为0的即主机地址。 DHCP ：Dynamic Host Configuration Protocol（动态主机设置协议） 记录着可以被分配到 LAN 内计算机的 IP 地址范围和子网掩码的值 默认网关 Gateway：通常把路由器 IP 地址设置在网关上。可以说 路由器就是从 LAN 通往互联网世界的入口（网关）。 路由器的 IP 地址也可以从 DHCP 服务器获取。 向路由器更进一步路由器是决定数据传输路径的设备。 分组管理下，IP 地址中的网络地址部分能代表一个 LAN 中的全体计算机。 互联网则是路由器把多个LAN连接起来的大网。 路由器的工作原理是查看附加到数据上的IP地址中的网络地址部分。 不属于LAN内计算机的ip地址，会被附加到数据的发送目的地字段上。这会被LAN内计算机忽略，但不会被路由器忽略。 只要不是发给LAN内的，就发送到LAN外。 分布在世界各地的 LAN 中的路由器交换着信息。这种信息叫做“路由表”，用来记录数据应该转发到哪里。 路由器的路由表中只会记录通往相邻路由器的路径，而不会记录世界上所有传输路径。 几条命令： 1route print #输出路径 该指令将输出五列： Network Destination 网络目标 Netmask 子网掩码 Gateway Interface 接口 Metric 跃点数（权值） 数据发送的目的地 区分网络地址&#x2F;主机地址 路由器IP地址 路由器要转发的目的端口 路径权重，由算法决定选择传输最优路径 如果目的地的IP就在本LAN中，则无需路由器转发，直接到达。 1tracert &lt;host_name&gt; #追踪路由转发过程,主机名是一个网址/计算机名 可以看到互联网服务商到本计算机LAN内的过程。 DNS服务器DNS ：Domain Name System 域名系统。 FQDN ：Fully Qualified Domain Name 完整限定域名：把主机名和域名结合起来的域名。 DNS 如同助记符一样，代替了难以记忆的 IP 地址。DNS 服务器能够自动把 FQDN 解析为 IP 地址（此过程为域名解析）。 DNS 服务器通常部署在各个 LAN 中，里面记录着 FQDN 和 IP 地址的对应关系表。 世界范围内，各个DNS服务器是相互合作的，一台DNS服务器解析不了，就会询问另一台。询问成功后就会存储在本地DNS服务器中。 通常《主机名.域名》即FQDN。 1nlookup #询问DNS服务器 默认输出本机 LAN 内的 FQDN 和 IP 地址。 也可以查询其他域名的 FQDN 和IP。 IP 地址和 MAC 地址的对应关系作为被标识为最终接收者的网卡是MAC。 IP地址转换到MAC地址，需要一个程序：ARP（Address Resolution Protocol 地址解析协议） ARP会向所有LAN内计算机广播（broadcast）询问，如果有某台计算机回复了 MAC 地址，则该计算机的 IP 和 MAC 对应明确了。 为提高查询效率，ARP会缓存。缓存构成的表叫ARP缓存表。 1arp -a #查询ARP缓存表 TCP 的作用以及 TCP&#x2F;IP网络的层级模型IP 协议：指定数据发送目的地的IP地址 以及通过路由器转发数据。 TCP 协议：通过数据发送者和接收者相互回应对方发来的确认信息，可靠的传输数据。（握手 handshake） TCP协议还有一个规定是先把原始的大数据分割成以“包”（packet）为单位的数据单元，然后再发送。接受者则需要把收到的包重新拼装在一起还原原始数据。 计算机发送的数据，是以包为单位的，附加了各种各样信息的数据。 硬件上发送数据的是网卡，网卡之上是设备驱动程序（控制网卡这类硬件的程序），驱动程序之上是实现了IP协议的程序，IP程序之上是实现TCP协议的程序，再往上才是应用程序。 TCP协议使用TCP端口号识别上层应用程序，并且预先定义好了一些端口用于专门用途。 基本概念的阐述概念： 机器语言：用0和1两个二进制数书写的编程语言。 最贴合硬件。机器语言相同，不同的CPU类型会得到不同的结果。 汇编语言：亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或数字代替指令或操作数的地址 人类所能读懂的，最贴合底层的语言。设备不同，机器语言指令集也不同。 语法：标签，操作码，操作数。 标签为某行代码对应的内存地址起名字。 操作码是 做什么 的指令。 操作数是 指令执行对象。 编译：把 C语言 等编程语言编写的文件（源文件）转换成用机器语言（原生代码）编写的文件。 编码：计算机用数字表示一切。 以字符举例：计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫做“字符编码”。 面向组件编程：通过将组件（程序零件）组装到一起完成程序； 面向对象编程：对现实世界的业务进行建模，再把模型搬到程序中。 IC 卡：IC card。计算机内部主要由各种 IC 元件 组成。 功能各异的 IC 主要有三种：CPU、内存、I&#x2F;O 。 CPU（central processing unit）中央处理器 : 运算数据并控制内存和I&#x2F;O。（解释执行程序内容） 内存：存储指令和数据 I&#x2F;O：负责数据的输入和输出工作。 时钟信号: 含义 是 由内含晶振的、被称为时钟发生器的元件发出的滴答滴答的电信号。 作用 是 作为计时器，保证电子组件同步运作。 单位 是 Hz 频率。即时钟发生器发送给 CPU 的电信号的频率。 把发出一次滴答的时间称作一个时钟周期。 频率大小可以衡量CPU的运转速度。 XML定义xml：Extensible Markup Language 可扩展标记语言 ：用于定义任意标记语言的元语言 html：HyperText Markup Language 超文本标记语言 ：一般用来标记编写网页 把通过添加标签为数据赋予意义的行为称为 ”标记“。为标记定义规则的语言 即标记语言。 html用于编写网页，或者说决定了可用于编写网页的标签。 优势可使用的标签种类决定了标记语言的规范及用途。 web浏览器会对html的标签进行解析，把由它们标记的信息渲染成我们乐于阅读的网页。 XML 的最大优越性便是，其使用者可以随心所欲的创造标签，这也是它作为元语言的根本。 XML 仅仅限定了进行标记时标签的书写格式，其数据是纯文本格式的，只包含字符。 遵循xml约束所写的文件就是xml文件。 现在的web服务器都集成了xml解析器，可以用这个功能来检查xml文件的书写格式。 xml主要用途：为在互联网上交换的信息赋予意义。 W3C的推荐标准是不依赖于特定厂商的通用规范。XML即是一种通用的数据交换格式。 万维网联盟（World Wide Web Consortium，简称 W3C）创建于1994年，是Web技术领域具有权威和影响力的国际中立性技术标准机构。 CSV也是通用的数据交换格式之一。 缺点：因为创造了标签，xml文件的尺寸也往往更大。 结构命名空间 标签名字相同，每个人赋予它的意义并不一定相同。所以一个W3C推荐标准是 XML命名空间（Namespace in XML）。 命名空间通常是一个能代表企业或个人的字符串，用于修饰限定标签的名字。 1xmlns=&lt;&quot;namespace_name&quot;&gt; 完整的XML文档有三个部分：XML声明、XML实例、DTD（Document Type Definition 文档类型描述） XML声明形如： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_jIS&quot;?&gt; XML实例是文档中通过标签被标记的部分 DTD负责定义XML实例的结构 形如： 123&lt;!DOCTYPE xxx[一些格式要求]&gt; 可以省略。 解析XML的组件 DOM（Document Object Model，文档对象模型） SAX（Simple API for XML) 分布式计算 SOAP（Simple Object Access Protocol，简单对象访问协议）可用于 分布式计算。 分布式计算：把程序分散部署在用网络连接起来的多台计算机上，相互协作，发挥整体计算能力 调用程序时所需的参数信息 和 程序执行后的返回结果 都可以用通用数据格式 XML 标识。 往往多台计算机协作使用时，XML这种通用传输协议会非常实用。 就好比上大学遇到五湖四海的朋友时，普通话沟通往往最有效率。"},{"path":"/2024/04/18/Crash Course CS/","content":"二进制byte 在电脑中的单位换算： kilobyte 千字节megabyte 兆字节gigabyte 千兆字节 1kb&#x3D;2^10^bit &#x3D; 1024byte &#x3D;1000b 1Mb &#x3D; 2^20^bit &#x3D; 1024kb 1Gb &#x3D; 2^30^bit 1TB&#x3D;1000GB 1GB&#x3D;十亿字节&#x3D;1000MB&#x3D;10^6KB Gb 和 GB 一般而言GB用于文件，Gb用于通信。B代表Byte，b代表比特bit，两者是八倍的关系。如果考虑到通信过程中的校验码等信息，这个实际关系差距是在十倍。 1GBps的传输速率＝ 8Gbps 100MBps ＝ 800Mbps 运营商所谓的百兆宽带，千兆宽带，也都是b结尾。百兆宽带，实际上只有12.5MB每秒的文件传输速度。 32 位与 64 位电脑的区别 32 位的最大数为 43 亿左右 32 位能表示的数字：0——2的32次方-1，一共2的32次方个数 64 位的最大数为 9.2*10^18 浮点数（Floating Point Numbers）： 定义：小数点可在数字间浮动的数（非整数） 表示方法：IEEE 754 标准下 用类似科学计数法的方式，存储十进制数值 浮点数&#x3D;有效位数*指数 32 位数字中：第 1 位表示正负，第 2-9 位存指数。剩下 23 位存有效位数 eg.625.9&#x3D;0.6259（有效位数）*10^3（指数） 美国信息交换标准代码-ASCⅡ，用来表示字符 1 全称：美国信息交换标准代码 2 作用：用数字给英文字母及符号编号 3 内容：7 位代码，可存放 128 个不同的值。 4 图示： UNICODE，统一所有字符编码的标准 1 诞生背景：1992 诞生，随着计算机在亚洲兴起，需要解决 ASCⅡ不够表达所有语言的问题。 为提高代码的互用性，而诞生的编码标准。 2 内容：UNICODE 为 17 组的 16 位数字，有超过 100 万个位置，可满足所有语言的字符需求。 算术逻辑单元 ALU背景 表示和存储数字是计算机的重要功能，但真正的目标是计算，有意义的处理数字 —— 比如把两个数字相加。 这些操作由计算机的”算术逻辑单元”处理，即ALU（Arithmetic and Logical Unit）。 ALU即计算机里负责运算的组件。 Intel 74181 ：1970 年发布时，它是第一个封装在单个芯片内的完整 ALU。 本章我们用前面的布尔逻辑门，做一个和 74181 功能一样的 ALU 电路。 介绍 ALU有2个单元： 算术单元(Arithmetic Unit) ：算术单元负责数字操作 逻辑单元(Logic Unit) ：逻辑单元执行逻辑操作 算术单元算术单元负责计算机里的所有数字操作 像加减法，还有增量运算（给某个变量+1） 实现加减法可以用单个晶体管一个个拼，做成电路。但那太麻烦了，这里用更高层的抽象，即逻辑门来做。 逻辑门有： AND 、OR、XOR、NOT 半加器 通过观察单个1和0之间的运算，发现异或可以满足前三个输入输出，第四个1+1的输出需要进位。 所以需要一根额外的进位线。让组件满足只有输入是1和1时，进位才是“True”。 发现这个条件，AND 门刚好能满足。于是加入电路中，组成半加器。 半加器：个人理解，完成加法的一半，也就是一位的运算以及进位。 多位计算需要全加器。 全加器 将半加器抽象为名为 HALF ADDER 的单独组件，进行更高层抽象：处理超过1+1的运算，需要全加器。 全加器表格： 最大的数是1 + 1 +1 ，总和是1，进位也是1 。 即两条输出线：SUM CARRY。 利用半加器组装全加器。 先输入A+B到一个半加器上，然后把C输入到第二个半加器上。最后用一个OR门检查进位是不是True。 8位加法器 把全加器进行更高一层抽象，也就是作为一个独立组件 Full Adder，三个输入 ABC，输出总和和进位。 前两位数A0、B0的加和用一个半加器 Half Adder 就好。因为前两位肯定没有进位。 A0和B0 的和即 输出的第一位。 将两者的进位，作为全加器的一个输入A。而输入B、C则是第三、第四位数据A1、B1的加和。 第三位开始有进位了。 然后将A1和B1的进位连接到A2和B2的输入A中，如此循环往复…… 注意每个进位是怎么连到下一个全加器的，所以叫“8位行波进位加法器(8-bit ripple carry adder)。 如果最后两位加和后还有进位，就不需要连接了。 因为出现了 溢出 Overflow 现象，8位已经不足以表示更高位的结果了。 这种加法器的缺点： 表达的位数越多，需要的全加器越多。 每次进位都要一点时间，虽然因为电子移动很快用不了多少时间，但还是承受不了当今几十亿次运算的量级。 所以，现代计算机用的加法电路有点不同：使用的是更快的超前进位加法器Carry-Look-Ahead Adder 。 ALU的算术单元也支持做一些其他的运算，一般都支持这8个操作： 加法、带进位加法、减法、带进位减法， 增量、减量：+1，-1 PASS THROUGH：All bits of A are passed through unmodified NEGATE：A is subtracted from zero, flipping its sign(from-to +,or +to -) 简单ALU不会专门为加法减法设计，而是通过循环加法或循环减法来实现。 例如电视遥控、恒温器、微波炉 有些ALU为了运算速度，会有专门的乘除法ALU。只是需要的逻辑门更多。 电脑、手机。 逻辑单元逻辑单元执行逻辑操作。 例如AND，OR 和 NOT 操作，或者一些简单的数值测试：是不是负数？ 示例：下面是一个检查输出结果是不是负数的电路。 以上即ALU的全部内容。 值得一提的是，Inter 74181 只能处理4位输入。所以你刚刚做了一个比 74181 还好的 CPU！ 74181 用了大概 70 个逻辑门，但不能执行乘除,但它向小型化迈出了一大步。 工程师在使用ALU时，不需要理解ALU内部构造。所以用一个大V字来表示。 图中的8位ALU有两个8位输入。通过操作代码OPERATION CODE来告知ALU将进行哪种操作。 例如，1000代表加法，1100代表减法。输出结果也是8位。 好了。你已经掌握了ALU的大致内容了，也能够了解计算机里一批批单晶管是怎样协作运算数据的。 但制作一个CPU不仅要会运算，还要能记忆。 下一章我们将学习存储功能的实现。 寄存器&amp;内存ALU能执行算术(Arithmetic)和逻辑(Logic)运算，ALU 里的 A 和L因此得名。 但是结果算出来不能仍掉，还需要找地方存储。这就需要内存了。 前置知识 只能存 0 的ALU。 只能存 1 的ALU。 两个合体，变成锁存器：能存储 1 &#x2F; 0 的ALU。 锁存器 门锁 和锁存器区别： 锁存器的“RESET复位”还不能达到“是否允许写入”的要求。 例如 : Set 为1 时，Reset 的改变会导致结果的改变。而门锁就能避免这种情况。 下面两次取反： 数据输入不变，改变允许写入时，结果不变； 数据输入改变，允许写入为 0 时，结果不变； 数据输入改变，允许写入为 1 时，结果改变； 实现了“只有允许写入改变为1后，数据输入的改变才有效。” 其他情况结果不变：如允许写入线改变，允许写入线为 0 时的数据输入改变。 所以从命名也可以看出来： Reset 复位 可以看成是重置输出为0，且锁定为0； WRITE ENABLE 允许写入 自身的改变不影响输出，只影响数据的输入是否改变输出。 这里也能看出下面两个连续取反的ALU的意义： ①当允许写入为0，结果锁定； ②当允许写入为1，数据输入为1，结果为1；数据输入为0，结果为0。 一个门锁只能存1bit数据。8个并列的门锁能存储8位的信息。 一组这样的锁存器就是寄存器。 寄存器能存一个数字，这个数字有多少位，叫”位宽。 早期电脑用 8 位寄存器，然后是16 位，32 位。如今许多计算机都有 64 位宽的寄存器。 我们可以用一根线连接所有”允许输入线”，把它设为 1。 接着用8 条数据线发送数据，然后将“允许写线”设回0。 这样，一个8位信息就被记录好了。 矩阵 但很显然，上面那种并排门锁的8位寄存器还远远不够用。64 位寄存器要 64 根数据线，64 根输出线，还有一根允许输入线。这样加起来也有129根。如果存 256 位要 513 条线。 解决方法就是矩阵。 通过“门锁矩阵”能节省很多线，表达更多的位数。 “12行 8列”可以写成 11001000 例如 16x16 &#x3D; 256 位，只需要 16 根行线 + 16 根 列线 + 1根数据线 + 1根允许输入线 + 1根允许读取线 &#x3D; 35 根线。 256个门锁构成 256-bit 寄存器，但八个输入接口通过十六位多路复用器(multiplexer)，每次只能激活其中一个门锁。也就是一次只能存储256位中的一位，不能并行处理了。 两个多路复用器分别处理行和列。 把上面的能表示256位的内存抽象成 “256-BIT MEMORY”。通过8个内存并列实现8位数字的存储。 为了实现8位数字的存储，数字的每一位依次由其中一个256-BIT 内存存取。 由于每个内存只能表示一位，所以我们同时给 8 个 256 位内存一样的地址，让他们各取一位就好了。 这意味着这里总共能存 256 个字节(byte)。 256 bit x 8个 &#x3D; 256 byte 一个8位的二进制数分别被写入到8个内存的同一二进制位来记录，8个256位内存则可以存储256个8位二进制数。 或者说，一byte的数据分八bit存八个memory里面，读写时地址共用（8个register 都是同一二进制位），就到一起了 再次抽象，不看作是一堆独立的存储模块和电路，而是看成一个整体的可寻址内存。 这就构成了一个能存储 256B 的内存条。 实例： 这是一条真的内存，上面焊了8个内存模块。 打开其中一个，然后放大： 可以看到32个内存方块。 放大其中的一个方块，可以看到还有4个小块。 四个小块再放大，就可以看到矩阵了。 这个矩阵是128位x64位，总共8192位。 每个方格 4 个矩阵，所以一个方格有 32768 个位(8192x4&#x3D;32768) 每个内存模块32个方格，所以一个内存模块大约有 100 万位。 RAM有8个内存模块，所以大概能存储800万位。 800万位大概1MB左右吧。 1GB的内存，能存数十亿字节。 我们用锁存器做了一块 SRAM(静态随机存取存储器)。还有其他类型的 RAM，如 DRAM，肉存和 NVRAM。它们功能上相似，但用不同电路存单个位。比如用不同的逻辑门，电容器，电荷捕获或忆阻器（logicgates,capacitors, charge traps, or memristors.） 但根本这些技术都是矩阵层层嵌套，来存储大量信息 就像计算机中的很多事情，底层其实都很简单，难以理解的只是一层层的抽象。 CPU 中央处理器指令程序由一个个操作，也就是指令构成。 数学指令，CPU会让ALU进行数学运算 内存指令，CPU会和内存通信，然后读&#x2F;写值 通过指令表可以了解到指令名、对应描述、4位操作码和需要的地址&#x2F;寄存器。 也就是说，计算机给CPU支持的所有指令都分配一个ID，实现区分。 本例中指令的前4位为操作码(opcode)，后4位代表数据来自哪里。 CPU结构下面CPU结构中的线只是所有必须线路的抽象，即“微体系架构(microarchitecture)” 示例中的地址有一个16位置，每个位置能存8位的内存，还有四个8位寄存器。 还有两个帮助操作的寄存器，一个追踪程序运行地址的&#x3D;&#x3D;指令地址寄存器&#x3D;&#x3D;，一个存当前指令的&#x3D;&#x3D;指令寄存器PC&#x3D;&#x3D;。 当启动计算机时，所有寄存器从0开始。 运行命令CPU的运行共三个阶段：取指令、解码、执行。 以LOAD_A 为例: Read RAM location into register A 取指令阶段：本阶段负责拿到指令 将 指令地址寄存器 连接到 RAM 。 寄存器地址值为0，因此 RAM 返回地址 0的值。 可以看到地址0的数据 00101110会复制到 指令寄存器 里 解码阶段：解释指令内容 前4位0010是 LOAD A 指令。通过指令表可知，能将RAM的值放入寄存器A。 后4位1110是 RAM 的地址，十进制为14. 区分指令内容后，由控制单元（Control Unit） 解码，识别指令，检查操作码。 控制单元同样由很多逻辑门组成。(不是很多啦)。 控制单元指挥着CPU的所有组件 执行阶段 用控制单元中”检查是否是 LOAD A 指令的电路”，可以打开 RAM 的&#x3D;&#x3D;允许读取线&#x3D;&#x3D;，把地址 14 传过去。RAM 拿到值，0000 0011，十进制的 3。 因为是 LOAD_A指令，所以把读取到的值 3 只放到寄存器 A ，其他寄存器不受影响。 此时问题来了：需要一根线，把 RAM 连接到4个寄存器，让我们传值过去！ 还是用控制单元中”检查是否是 LOAD A 指令的电路”，连接启动寄存器A的&#x3D;&#x3D;允许写入线&#x3D;&#x3D;。 于是把 14 放到了寄存器A中，LOAD_A 14 指令执行完成 收尾：关掉所有线路，去拿下一条指令（也就是指令地址寄存器+1) 以ADD为例：Add two registers , store result into second register. 取指令: 指令地址寄存器指向2,读取 10000100到指令寄存器中。 解码： 前四位 : 1000 ADD命令 后四位 : 0100 , 01 为寄存器B，00为寄存器A。 通过控制单元，解码，识别指令，检查操作码。 执行：把 register B的值加到 register A 中。 启动寄存器B，作为ALU的第一个输入；启动寄存器A，作为ALU的第二个输入。 ALU可以执行不同操作，所以控制单元必须传递ADD操作码告诉它要做什么 最后，结果存到寄存器A。 **注意:**不能直接写入寄存器A，因为寄存器A此时正在作为输入，写入后新值会进入ALU，导致A不断和自己相加。 因此，控制单元用一个自己的寄存器暂时保存结果，关闭ALU，然后把值写入正确的寄存器。再由寄存器赋值到寄存器 A。 收尾：关掉所有线路，去拿下一条指令（也就是指令地址寄存器+1) 以store A 为例：Write from register A into RAM location 取指令: 指令地址寄存器指向3,读取 01001101到指令寄存器中。 解码： 前四位 : 0100 STORE A 指令 后四位 : 1101 , 01 为寄存器B，00为寄存器A。 通过控制单元，解码，识别指令，检查操作码。 执行： 把地址传给RAM，这次不是允许读取，而是允许写入。 同时打开寄存器A的允许读取，这样可以把寄存器A的值传给RAM。 完成了！ 总结： 1.通过上例可以了解，CPU运行指令，通过RAM和寄存器之间的数据传输，以及控制单元和ALU的检验、运算，从而完成一次操作。 2.RAM有配合控制单元的 允许写入线、允许读取线、地址输入线； 还有配合数据寄存器以及指令寄存器的 DATA 线。 寄存器也有允许写入线、允许读取线。 时钟时钟负责管理CPU的节奏，区分每一步操作。 时钟以精确的间隔触发电信号，控制单元会用这个信号，推进 CPU 的内部操作，确保一切按步骤进行。 CPU”取指令一解码一执行”的速度叫 时钟速度。 单位是赫兹。 赫兹是用来表示频率的单位。1 赫兹代表一秒1个周期 超频： 意思是修改时钟速度，加快 CPU 的速度。芯片制造商经常给CPU 留一点余地，可以接受一点超频。但超频大多会让CPU 过热，或产生乱码，因为信号跟不上时钟。 降频: 有时没必要让处理器全速运行。把 CPU 的速度降下来，可以省很多电。 为了省电，很多现代处理器可以按需求 加快或减慢时钟速度，这叫动态调整频率。 高级CPU设计 从前面几章，我们从一秒一次的运算，到现在有千赫甚至兆赫CPU。现在的单位是GHz，1秒10亿次运算。多么大的计算量！ 为 CPU 提升速度早期计算机到现代计算机厂商和科学家们发明了各种新技术来提高性能。 减少晶体管切换时间 早期提速的方式便是减少晶体管的切换时间，使晶体管组成了逻辑门，ALU 以及前几集的其他部件。 这种提速方法会遇到瓶颈。于是处理器厂商不仅让简单指令运行更快，还让它能支持更复杂的运算。 利用复杂电路实现算法 例如除法和乘法需要程序多次运行减法和加法，为了省去循环的功夫，现代 cpu 直接在硬件层面上设计了除法等复杂电路以节省某些运算。这让ALU更大更复杂，但也加快了运行速度。 复杂度和速度的矛盾一直存在。 举例，现代处理器有专门电路来处理图形操作，解码压缩视频,加密文档 等等。如果用标准操作来实现，要很多个时钟周期。 某些处理器有 MMX, 3DNOW, SSE，他们就拥有额外电路用于处理游戏和加密等场景。 随着指令不断增加，为了兼容旧指令集，指令数量越来越多。 英特尔4004,第一个集成CPU，有 46 条指令,足够做一台计算机。 现代处理器有上干条指令和更多巧妙复杂的电路。 给 CPU 增加缓存 超高的时钟速度带来另一个问题：如何快速传递数据给 CPU？ 就像有强大的蒸汽机 但无法快速加煤。 RAM成了瓶颈。RAM 是 CPU 之外的独立组件，意味着数据要用线来传递，叫”总线“。总线就几厘米，而电信号传输接近光速。 但CPU每秒可以处理上亿条指令，两者执行任务的速度还是过于悬殊。一条”从内存读数据”的指令可能要多个时钟周期，CPU只能苦苦等待。 RAM 是 CPU 之外的独立组件，通过总线 (Bus) 传递数据，为了避免数据传输带来的延迟，解决的方法是为 CPU 增加一点RAM作为缓存。 读取时 RAM 将一批数据提前传入 CPU 缓存，这样处理的时候 CPU 直接从离得近的缓存中获取数据就比从 RAM 中获取数据要快。 处理器空间不大，缓存一般只有KB或MB。 于是数据传输单位从一个变成了一批。 缓存命中 如果想要的数据已存在缓存中则叫做缓存命中，否则叫做缓存未命中。 同步更新： 缓存也可以作为临时空间存储一些运算过程中的中间值，适合长 &#x2F; 复杂的运算。但是计算完后的值想要存储会先存入缓存中，而缓存中的值可能还有运算的中间值导致缓存和 RAM 内数据不一致，因此缓存里的数据要对 RAM 里的数据进行同步更新。 脏位： 对此缓存里的每块空间都有一个叫做脏位的标记声明该数据是否修改过。同步更新一般是发生在缓存满了，又需要缓存时。这时会检查缓存中的脏位，如果是脏的就将数据写回 RAM 中。 另一种提升性能的方法：instruction pipelining 指令流水线。 可以通过不同的指令运行方式以提升 CPU 速度。 顺序串行执行 严格按照顺序上一条命令结束才执行下一条命令 顺序并行执行 在上一条指令执行时就处理下一个指令的解码步骤，下下条指令的读取步骤。 乱序执行 第一个问题：指令之间的依赖性 问题举例：在读取的同时，正在执行的指令在改这个数据。 这种情况需要搞清楚数据之间的依赖性，必要时停止流水线，避免出问题。 解决： 高端CPU会通过动态调整，进一步动态排序有依赖关系的指令。最小化流水线的停工时间。这叫乱序执行。 电路复杂，但很高效。几乎每个现代处理器都有流水线。 推测执行 | 分支预测 第二个问题：条件跳转 这些指令会改变程序的执行流。简单的流水线处理器，看到 JUMP 指令会停一会儿，等待条件值确定下来。但空等会有延迟。所以高端CPU会用一些技巧： 解决： 遇到岔路口时，猜测 JUMP 指令走哪条路的可能性更大一些，然后提前把指令放进流水线，这叫“推测执行。 猜对了可以直接执行，猜错则要清空流水线（就像走错路掉头）。 为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法来猜测：分支预测。 现代 CPU 的正确率超过 90%！ 超标量处理器SUPERCALAR PROCESSOR 理想情况下，流水线一个时钟周期完成1个指令。 即便有流水线设计，在指令执行阶段,处理器里有些区域还是可能会空闲。 比如，执行一个“从内存取值”指令期间，ALU会闲置。 所以一次性处理多条指令(取指令+解码) 会更好,如果多条指令要 CPU 的不同部分，就多条同时执行。 借助超标量处理器SUPERCALAR PROCESSOR 一次性处理多条指令 (类似多线程)。为出现频率很高的指令加多几个相同的电路，ALU 执行。 目前说过的方法，都是优化1个指令流的吞吐量。 另一个思路是运行多个指令流，也就是多核处理器。 CPU 芯片内的多个独立处理单元 (多核) 就像有多个 CPU 能够合作运算 (共用一个 CPU 的缓存)。如果多核还不够就用多个 cpu。 集成电路 在大概50年里，软件从纸带打孔变成面向对象编程语言，在集成开发环境中写程序，没有硬件的大幅度进步，软件不可能做到这些。 回到电子计算机的诞生年代： 电子管大约 1940年代~1960年代中期这段时间里 ， 计算机都由独立部件组成。这些独立部件叫”分立元件” ，然后不同组件再用线连在一起 举例, ENIAC 有1万7千多个真空管, 7万个电阻 , 1万个电容器, 7千个二极管, 5百万个手工焊点 如果想提升性能，就要加更多部件。 这导致更多电线，更复杂；这个问题叫 “数字暴政’’。 晶体管 1950 年代中期，晶体管开始商业化（市场上买得到） \\N 开始用在计算机里。晶体管比电子管 更小更快更可靠。但晶体管依然是分立元件 1959年，IBM 把 709 计算机从原本的电子管全部换成晶体管。诞生的新机器 IBM 7090 速度快 6 倍，价格只有一半！ 晶体管标志着”计算 2.0 时代”的到来。 虽然更快更小 但晶体管的出现 还是没有解决”数字暴政”的问题。 有几十万个独立元件的计算机不但难设计，而且难生产。 集成电路 1960 年代，这个问题的严重性达到顶点 电脑内部常常一大堆电线缠绕在一起。看看这个 1965 年 PDP-8 计算机的内部： 解决办法是封装复杂性：也就是电路的所有组件都集成在一起。 与其努力把多个独立部件用电线连起来，拼装出计算机，还不如专注于把多个组件包在一起，变成一个新的独立组件。 这就是 集成电路（Integrated Circuit）的诞生。 几个月后，在1959年 Robert Noyce 的仙童半导体 ，让集成电路变为了现实。Kilby 用锗来做集成电路，锗很稀少而且不稳定。仙童半导体公司用硅 \\N 硅的蕴藏量丰富，占地壳四分之一，也更稳定可靠。所以 Noyce 被公认为现代集成电路之父，他开创了电子时代，创造了硅谷（仙童公司所在地） 起初，一个 IC 只有几个晶体管。例如这块早期样品，由西屋公司制造： 即使只有几个品体管也可以把简单电路，第 3 集的逻辑门，能封装成单独组件。 IC就像电脑工程师的乐高积木，可以组合出无数种设计。 印刷电路板 PCB Printed Circuit Board 为了解决集成电路仍需通过电路连接制造计算机的问题，工程师们制造了印刷电路板PCB，PCB 可以大规模生产而无需焊接或用一大堆线，它通过蚀刻金属线的方式将零件连接到一起。 把 PCB 和 IC 结合使用 \\N 可以大幅减少独立组件和电线，但做到相同的功能。 而且更小，更便宜，更可靠. 三赢！ 许多早期 IC 都是把很小的分立元件 \\N 封装成一个独立单元，例如这块 1964 年的IBM样品： 光刻 不过，即使组件很小 , 塞5个以上的晶体管还是很困难。为了实现更复杂的设计，需要全新的制作工艺 \\N “光刻”登场！ 光刻简单说就是把复杂图案印到如半导体等材料上，可以通过这种技术将复杂金属电路印在半导体上面以集成个多的元件制造复杂电路。 光刻机光刻电路的流程： 首先是一块硅 (晶圆)： 硅很特别。它有时导电，有时不导电。我们可以控制利用其特性控制导电时机。 我们可以用晶圆做基础，把复杂金属电路放上面，集成所有东西 。 在硅片顶部加一层薄薄的氧化层,作为保护层。 加一层特殊化学品，叫”光刻胶”。 光刻胶被光照射后 会变得可溶。可以用一种特殊化学药剂洗掉。 把光掩膜盖到晶圆上，用强光照射。挡住光的地方，光刻胶不会变化。光照到的地方，光刻胶会发生化学变化洗掉它之后，暴露出氧化层。 用另一种化学物质·通常是一种酸，可以洗掉”氧化层”露出的部分，蚀刻到硅层。 注意，氧化层被光刻胶保护住了。 为了清理光刻胶，我们用另一种化学药品洗掉它 现在硅又露出来了。我们想修改硅露出来的区域 ，让它导电性更好。 所以用一种化学过程来改变它，叫”掺杂” “掺杂”通常用高温气体来做，比如磷渗透进暴露出的硅，改变电学性质。 但我们还需要几轮光刻法 来做晶体管。 过程基本一样，先盖氧化层，再盖光刻胶。然后用新的光掩膜，这次图案不同。 在掺杂区域上方开一个缺口，洗掉光刻胶，然后用另一种气体掺杂把一部分硅转成另一种形式。 为了控制深度，时机很重要我们不想超过之前的区域。 最后一步，在氧化层上做通道这样可以用细小金属导线，连接不同品体管。再次用光刻胶和光掩膜蚀刻岀小通道。 现在用新的处理方法 叫”金属化”放一民道道的全属，比如铝或铜。 但我们不想用金属盖住所有东西我们想蚀刻出具体的电路。 所以又是类似的步骤：用光刻胶+光掩膜，然后溶掉暴露的光刻胶，暴露的金属 我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节。 一片晶圆可以做很多IC整块都做完后，可以切割然后包进微型芯片。 微型芯片就是在电子设备中那些小长方体 。 记住，芯片的核心都是一小片IC&gt; 芯片放大： 摩尔定律1965 年，摩尔看到了趋势：每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍数量的晶体管。这叫摩尔定律。芯片的价格也不断下降。即集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍 但是摩尔定律现在也在接近极限，进一步做小，会面临两个问题。 用光掩膜把图案加到晶圆上，因为光的波长，精度已经达到极限。 当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，叫量子隧道贯穿效应 控制单元（Control Unit) : 负责程序的流程管理。正如工厂的物流分配部门，控制单元是整个CPU的指挥控制中心，由指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)三个部件组成，对协调整个电脑有序工作极为重要。 控制单元可以作为CPU的一部分，也可以安装于CPU外部。"},{"title":"啊啊？","path":"/2024/04/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/essay-md/敏锐：聪明到成事的临门一脚.html","content":"敏锐:聪明到成事的临门一脚fancy 敝帚自珍以宽慰自娱解闷是也 2023-07-24 00:03 河北 心钝首先阐明词义：何为心钝？ 我的理解：心钝乃是 好奇心模型和成长模型 不足带来的麻木和懒惰。 举个例子：问你最近对生活的新发现，有趣的事物，偶然悟出的妙理，跳出舒适区的新体验等等，如果你不能自如回答，信手拈来。我想你在这一类问题上的认知模型是匮乏的。 为什么是好奇心和成长两个模型？ 好奇心保证你能在表面上古井不波、枯燥无味的环境里发掘出各种信息。 如果生命是海，我们总希望生活是轰轰烈烈、汹涌澎湃的。“乘风破浪会有时”、“乱石穿空、惊涛拍岸”云云。可多数时间里大海都是一览无余的平静。 这里引用李银河老师的一句话：所有暂时的热闹都只不过是海水撞击岩石时溅出的浪花,生命的本质却永远像海洋深处一样的沉寂。 所以如何在平静的海面上找到属于自己的快乐呢？这就需要好奇心。只有在好奇的状态下，你才会近乎本能的去看，去做，去体验。你才能感受到隐藏在生活之下，汹涌澎湃、钟鼓齐鸣的灵感音符。 这种力量是任何强制力、功利心、攀比虚荣都难以企及的。 就像饿了吃饭、渴了喝水、困了睡觉一样自然。 仅仅是由着性子去体验。还有比这更美妙的事情吗？ 这也将人的生活分成“三六九等”。艺术家的生活大喜大悲；逻辑学家的生活狡黠思辨；音乐家的生活富于韵律而美食家的生活充满芳香。不过注意哦，某某家完全不靠某个职业身份证书的认定；而仅仅在于你是否乐于去做—— 每个人都具备“多面手”的潜力。大脑的发育完全支持我们做到这一点。你总能在不经意间做十分钟的乐手、二十分钟的厨师。 乐趣源自哪里？好奇心。 如果你觉得吃饭只是求饱，说话只是你好。那你不仅丢掉了让自己的生活丰富多彩、有滋有味的天然权利， 还将迟早面临被功利心反噬的风险。 下面看一个实例。 问你最近对自己的生活有什么想说的想表达的，这个同学是一时半会说不出来的。就你会沉浸在这样一种状态：这个事没什么好说的，这个事没什么好惊讶的，今天也没什么好讲的，我的生活是平平无奇的。 仅从情商上讲，举个比方：今天周五，你在北京打车去见一个客户。 这个客户的办公室很大但是人很少，不知道客户去哪了。 今天北京的天气很好，阳光明媚，没有沙尘暴也没有雾霾。 你下午两点打的车，路上很堵 这个客户的办公桌上摆了一堆绿萝、绿植。 今天周五。 上面五条是一个素材，至少从这五条里，你和素未谋面的客户并不是无话可说的，不是吗？ 无非是你观察力不细致，或者你觉得办公室人少没什么好说的，天气好没什么好说的，等等等等。 这种观察力的缺失就会带动思考力、表达力的缺失，就像一个心智上的“过滤器”。抱着这种心态，我再问你今天周五感觉如何，你便会迟钝麻木，无话可说。 这里给大家一个建议：“仰观宇宙之大，俯察品类之盛。”也就是善于敏于乐于观察生活中的细节，这样你才不会自怨自艾觉得四面无趣，你才能到任何环境都能保持好奇心，你的眼睛才有光。 有了这个能力，你就能吸收到很多一般人看不到的细节和信息。吸收信息抽象来看是个输入的过程。那输入了这么多的信息，咱们要做的就是整理。就像吃完饭还要把营养吸收掉，去粗取精。这里用到的认知模型是“费曼学习法”，即教就是最好的学，输出带动输入。 上述内容来自b站up主广智的销售宇宙,我只是略微整理、打些比方而已。 好奇心的重要性咱聊完了。接下来说说成长。 如果说好奇心是生活美好所在的敲门砖，那成长意识就是敲开门后的金刚钻。 种下一颗种子意味着你要身披四季风雨冷暖，呵护挂念它直至开花结果。 好奇心只是让你有了种下种子的动机。达到最终收获果实的目的，靠的是汗水的灌溉 —— 汗水的源泉即成长意识。 拥有成长意识，你才能站在全局出发，跳出现有的视角框架，去为自己的目标理想而奋斗。而对自怨自艾、妄自菲薄天然的嗤之以鼻：“我tm忙活半天到底是为了什么，我为什么天天折磨自己，躺床上它不香吗巴拉巴啦……”。 这也是区分强者弱者，智者愚者，乐者苦者的关键所在 —— 成长意识下的大格局、大视野、大框架。 兴趣的多少只是决定了你能开始这段成长旅程，以及旅程之中的难易程度、趣味多少而已。 至于好奇心延伸出的勇气、学习能力（又名信息整合能力）、革命性、思辨力、包容度等，以及成长意识下延伸出的吃苦耐劳、定力韧性等等等等，这里受限于篇幅笔力，不再赘述，有缘补充。 两者共同决定了你生命的质感，你生活的乐趣程度。 私货：也不怪乎人的境界与厚度分三六九等，酒囊饭袋、声色犬马之徒和格物修身之辈的矛盾天然不可调和，兼顾也只是落个礼节。两类人住的完全不是一个地球。 修行人性和顺从欲望的差别就如同猪狗与人的差别。不过区分点并不是爱不爱喝酒，爱不爱做爱这类表面事情。而是观其心。但大家知道想摸透别人的心，得到的只有偏见。唯有观自己的心才是十拿九稳。 观自在，诚意正心，格物致知，修身齐家。 “所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善，而著其善。　人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。” ————《大学》 自己是什么货色伸手便知喽。 好奇心保证广度，成长保证深度。深广兼备，博学多才、遍地开花，趣味横生、喜不胜收。 仰观宇宙之大、俯察品类之盛，且歌且行、快雪时晴。 这里说的有些雅了。补一句：懒逼不配幸福，无论精神身体理论实践。一言以蔽之。 颗粒度好奇心和成长属性说了很多。 在两者的趋势下，我们已经建立了不错的认知模型了。接下来的一步呢？ 在健康向上积极自洽的认知地基上，不断的打磨自己，愈加成熟。 “如切如磋，如琢如磨” “君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉” 打磨的本质便是实践。 按孔老的话说，你如果把你想的那些事都大大方方的做出来，你就上道儿了。 修身功夫越深的朋友，他的生活颗粒度会越细。开始一个信仰，开始只能付诸于一件事，坚持一两天。慢慢的，能够付诸两件事、三件事，知道生活的方方面面，持续恒久。 这是颗粒度细了，所谓生活精致是也。 干净卫生，摆放有序的人至少能说明一点：在物件规划这件事上，他是极其有功力的。这已经十分宝贵了。 颗粒度粗糙的朋友，会不可避免的在新手期持续打脸。发现自己总是在某个节点失败。 程序员有句话：发现问题是解决问题的一半。 如果你敢于承认自己对待生活的粗糙，那你就已经开始走向了精致。 这个节点极易出现一种神经官能症：即理想与现实的不统一。 这里的理论来自卡尔霍尼的《我们内心的冲突》，极端严重推荐的好书。地基级别思想建构且简单好懂。 简单说就是自己主动打自己的脸。 举个例子： 我可以得到很高的分数，但我就是不学。 我是一个干净人，但我就是不收拾。 我很专一，只是敏感多情而已。 这类朋友的矛盾是很明显的，除了自己以外，基本身边深入接触的人都可以察觉。 但距离感决定了其他人没有任何义务指明你的缺点。最好的修正方式是自我革命，即自己针对自己的纠察反省审视总结。 奥，遇到指正你缺点的朋友多加珍惜吧。当然，他甚至可能是你的“敌人”。 当你不断反思和进步，你的生活会不可避免的精致起来。 就像一栋结实的房子，不断装修、翻新、收拾，理所当然变得更加宜居。 醉心理论甚至幻想，心有余温而不实行是成长的大忌。诸位共勉。 一些典型语录： “不在意这些细节” “可以做但没必要” “状态不好以后再说（然后没下文）” 这里还可以补充一个知乎博主9qadg(john hexa)的文章：（较真这种性格好吗？在什么情况下需要较真？- q9adg的回答 - 知乎）https://www.zhihu.com/question/27111858/answer/2588179268奥对了，对一些事情较真是雕琢颗粒度的表现 这里可以引申另一个话题，什么时候较真什么时候不较真。 但能判断不较真是最好的解决方案的前提是，你较真过“啥时候不较真”这个问题。 较真才是能力的分水岭。 甚至较真后的结果是躺床上。这些无所谓。只要判断合理。 有始有终。没有开始，何来最终？有了开始，请用心走到终点。 走路就是实践啦。 前方坦途，诸位慢走。 敏锐如果具备前文的好奇心和成长意识。 并且已经不但打磨了自己的生活颗粒度的话：你将在颗粒度高的这个方向，有远高于常人的敏锐性。 那回归到一个人身上，即为气质。气质背后是文化。文化有哪些表现形式呢？ 歌曲背后的风格、节奏、编曲、乐器； 画作背后的背景、创作心态、技法； 美食背后的营养、步骤、选材； 衣服背后的面料、量裁、版型； … 到这一步，长时间雕琢于一件爱好的气质已经藏不住了，你身上的方方面面都会被你常常做的事情所熏陶，形成一种文化气息。这种看不清、摸不着但“触目所及”的东西就是文化啦。 一个人的体态、神态、心态会合力展示出此人的生活状态。 这里的合力就像物理不同方向不同大小的力作用到同一件物品上的最终呈现。 文化背景有了，交织起来，你这个人不就鲜活了吗？ 这也是磁场相同的人互相吸引的原理。 有了文化底蕴，你也能从根本上避免媚俗这件事。 弱者才会本能的寄希望于依附更强大的力量。 弱：指文化属性上的弱，或者说精神力的弱小。无褒贬含义，乃必经之路。 孔老讲话了：“己欲立而立人，己欲达而达人” 强大自我没错的。 从这个角度来看，处于“认识你自己”阶段的朋友，个性一点是无可厚非的啦，开心就好。 只要不违法乱纪、不波及他人、不伤害生命健康。 所以无论如何： 敏锐是建立在兴趣与爱好之上的生活的人，的一种很自然的表现。 此处的延伸话题：痛苦&#x2F;挫折之上的趣味怎样发觉？（暂不赘述） 你会对所有事物感兴趣，眼睛滴溜溜的转，小脑袋瓜里的灵气也会越来越浓。 所谓灵气、天赋当然有靠先天带来，但后天的培养更加重要。相信我。 并且这种东西并不是一成不变的，相反它是随时变化的。 “众人皆是佛” 你正向思维模型如同“造轮子”一样，不断的推动你进步，你的力量会越来越强大： 表达能力、 沟通能力、艺术理解力、共情能力(情商)、学习接收能力，表现力，精神意志力，体力，思考力，行动力 …… 人生百味。 知行合一 到这里，该表达的已经表达完了。能读到这里是我们两个人的缘分。笔者随时欢迎各位任何形式的沟通，以及沟通之上的挑战、质疑、批评。 最后希望大家能够理论与实践相统一，认识自己，发现自己，爱上自己，最后成就自己。 最后分享一个小心得： 人这一辈子将永远在新事物上成为一个“弱者”。不要害怕弱小，不要担心无助。自渡者天渡之，时来天地皆同力。天地有正气，杂然赋流形。希望我们都能在兴趣中探索新的体验，在反思总结中收获成长。 逆境沉淀积累，顺景乘势而上。 “ 惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色,取之无禁,用之不竭,是造物者之无尽藏也 。” 最后用教员的话结尾吧: “1917年4月，毛泽东在《新青年》发表《体育之研究》一文，其中论及“体育之效”时指出：人的身体会天天变化。目不明可以明，耳不聪可以聪。生而强者如果滥用其强，即使是至强者，最终也许会转为至弱；而弱者如果勤自锻炼，增益其所不能，久之也会变而为强。因此，“生而强者不必自喜也，生而弱者不必自悲也。吾生而弱乎，或者天之诱我以至于强，未可知也”。 “"},{"title":"孔子","path":"/essay-md/孔子及其身后的道儒法墨.html","content":"引用语料： 《中国哲学简史》第四章 孔子，第五章 墨子 墨子连山《孔子一生致力于维护和恢复周礼的原因到底是什么？》《韩非子》 墨子连山《道德经第二十一章、三十八章、四十一章、四十二章、四十六章》（专栏【三十年来《道德经》实践总结】） 孔子其人先看看孔先生的背景吧。 孔子姓孔名丘，公元前551年生于鲁国，位于中国东部的现在的山东省。 他的祖先是宋国贵族成员，宋国贵族是商朝王室的后代，商朝是周朝的前一个朝代。 在孔子出生以前，他的家由于政治纠纷已经失去贵族地位，迁到鲁国。 孔子一生事迹详见《史记》的《孔子世家》。 从这篇“世家”我们知道孔子年轻时很穷，五十岁时进入了鲁国政府，后来做了高官。 一场政治阴谋逼他下台，离乡背井。此后十三年他周游列国，总希望找到机会，实现他的政治、社会改革的理想。 可是一处也没有找到，他年老了，最后回到鲁国，过了三年就死了，死于公元前479年。 孔子是儒家创始人，刘歆说儒家“游文于《六经》之中，留意于仁义之际”。六经即《易》、《诗》、《书》、《礼》、《乐》（今佚）、《春秋》。孔子与六经的关系现在尚有争论。而按照冯友兰先生的观点，孔子是中国的第一位私人教师，而不是中国的第一位私人著作家。六经大概率不是孔子的著作，他本人在《论语》中，也未曾流露过亲自为后代著作的想法。 “子曰：‘述而不作，信而好古，窃比于我老彭。“ 孔子说自己”述而不作“，这里暂且浅显的理解为只是交流分享前人的知识，而没有写作记录的打算。 所以在孔子的时代以前已经有了《六经》。《六经》是过去的文化遗产。 《六经》又叫做“六艺”，是周代封建制前期数百年中贵族教育的基础。 可是大约从公元前7世纪开始，随着封建制的解体，贵族的教师们，甚至有些贵族本人——他们已经丧失爵位，但是熟悉典籍——流散在庶民之中。前一章说过，他们这时靠教授典籍为生，还靠在婚丧祭祀及其他典礼中“相礼”为生。这一种人就叫做“儒”。 孔子毫无疑问是精通六经的。大小六艺，礼乐射御书数，诗书礼乐易春秋。会的不但多，而且精，样样都出类拔萃。 传说孔子身高九尺六，自己作为徒弟们的射箭教练兼战车驾驶教练。所有孔子门人，射、御是必修课。孔子带着弟子练射箭，是会被围观的。 孔子出生于武将世家，他爹身高一丈，曾经单人力举城门，救出半只部队。这老爷子平时配剑，当时兵荒马乱，不配也不行。你想想这个遗传基因。孔子还特别爱吃肉，听说过“三月不知肉味”吧？那首先得是吃了三个月的肉。一个猛将之子、一米九大个、专业运动员的身板、配着剑、顿顿吃肉，说他是老师，反差是不是有点大？ 孔子做过中都宰，相当于市长兼市委书记；坐过大司空，相当于建设部长；坐过大司寇，相当于公安、司法部长；最高做到大司空涉相事，就是代理总理了。当然了，与他真正的事业相比，这些政治成就可以忽略不计： 有教无类、因材施教、学而时习之、温故而知新、举一反三等等教育理念，直到现在也没有跳出他的框架，教育才是孔子真正的道路；弟子三千，贤者七十二，这是他的实践，万世师表，为教师这个伟大行业树立了标杆。 孔子其道在道家的著作《庄子》中，可以看到道家的人常常嘲笑孔子，说他把自己局限于仁义道德之中，只知道道德价值，不知道超道德价值。表面上看，他们是对的，实际上他们错了。 请看孔子谈到自己精神修养发展过程时所说的话吧，他说：“吾十有五，而志于学。三十而立。四十而不惑。五十而知天命。六十而耳顺。七十而从心所欲，不逾矩。”孔子一生，到了三十四十，也许仅只是认识到道德价值。但是到了五十、六十，他就认识到天命了，并且能够顺乎天命。换句话说，他到这时候也认识到超道德价值 小一辈的孔子曾专门拜访、请教过老子，更关键的是，他们读的书都是一样的，礼记、尚书、诗经、易经等等，而且老子就在周的图书馆，这些书都是周书。所以，他可能比孔子看过的书还多。从后来孔子的思想中，能看出他继承了很大一部分老子思想。但关于超道德价值的道，不管是出于经世致用的目的，还是因为老子对道的阐述已经足够完善，孔子无需补充转而走向延申阐述“德”的道路，我们都不能通过论语中的只言片语，就随意武断孔子境界低或者层次低。 至于孔子的思想： 在聊到传述传统的制度和观念时，孔子给予它们的解释，是由他自己的道德观推导出来的。像对”三年之丧“礼制的解释，对”诗三百“的评价。中华文化中的很多关键词，都是由这位先贤定义的，忠孝、仁义、信用……没有这些关键词，我们甚至连开口说话都困难，更不用说流传下来的上百条成语了。 这种以述为作的精神，被后世儒家的人传之永久，经书代代相传时，他们就写出了无数的注疏。后来的《十三经注疏》，就是用这种精神对经书原文进行注释而形成的。正是这样，才使孔子不同于当时寻常的儒，而使他成为新学派的创建人。正因为这个学派的人都是学者同时又是《六经》的专家，所以这个学派被称为“儒家”。 但我们需要知道，儒学和儒家是要区分开来的。把孔子创立的儒学比作一个容器，后世数代的人们都往这个容器里添加了自己的私货，形成了各色各样的学派，像理想主义的孟子，现实主义的荀子，研究宇宙发生的周敦颐、邵雍，和外来佛教融合的新儒学，以及后续大名鼎鼎的理学心学之争。 道家则是杨朱老庄，后续的新道家则划分为主理和主情两派。 《尚书》有云“人心惟危，道心惟微，惟精惟一，允执厥中。” 在前人“允执厥中”的基础上，他进一步提出了了“君子之中庸，君子而时中” 一个是“中庸”，就是不偏不倚，不左不右，直奔目标。而目标是什么呢？是无处不在的“有用”。有了这个外挂，孔子的学说就不可能错。因为只要有人实践不成功，我们就可以说是他自己的问题，因为他没做到“有用”，所以他没有做到中庸。 另一个是“时中”，中不是静止的、一成不变的，而是要与时俱进的，昨天偏左了，向右是中，今天偏右了，向左才是中。如果你不变，出了问题就不能怪理论，因为人家说得很清楚了，要与时俱进。咱们自己因循守旧，该变却不变，不是只能怪自己没有执行到位？ 当然了，如果孔子仅仅满足于开挂，保持不败金身的话，那么他绝不至于到达圣人的高度。 他的伟大之处在于为“有用”设立了一个明确标准，那就是仁。 仁者爱人，施恩于人，己所不欲勿施于人。 大家可不要小看这个字，中华文明的伦理核心就是他所定义的。 中华文明的伦理观是什么呢？ 是恩文化，是积极施恩与人的文化，是受人滴水之恩，必将涌泉相报的文化。不但报恩，而且要超量报恩，而第一次的施恩，我们也可以看作是超量报恩，从无到有产生新的恩。于是，恩上加恩，人间充满温情。 这与基督教文明的“罪”文化形成了鲜明对比。 另外，孔子提出了“学而时习”的概念，不但要学，而且要实践，他自己带头。 于是有了中国第一位民办教师，弟子三千，贤者七十二。 他在历史上首次以私人身份教导了几千个学生，在周游列国时，这些学生成群结队的跟随着他。 大家可不要小看这位教师的力量，他的弟子中藏龙卧虎。有兴趣的可以自己去查查，曾子、子夏、子贡……这些人以及他们的弟子影响了整个战国时代。 中国的尊师重教，历经几千年延续至今，孔子可谓居功至伟。 一生致力于维护和恢复周礼的原因因为，那时候除了周礼，还有什么更好的选择吗？例如选择殷礼？ 周礼以人为本，强调人文精神； 殷礼以神为本，强调神鬼核心； 孔子自称“殷人之后”，但是他却坚定的主张，“周监于二代，郁郁乎文哉！吾从周。” 为什么？ 答案的关键，就是这个“文”字。 文，甲骨文是一个人身上刺有花纹，也就是现在的纹身，显然这个字与人有着不可割裂的关系。现在我们人文并称，有人才有文，给人用的才叫文，所以又有了文化、文明等等。 孔子这句话赞颂的其实正是周礼的人文精神，用现在话说就是以人为本的精神。只有以人为本了，礼乐才开始围绕着人来设计，而不是围绕着鬼神设计。只有当围绕着人来设计礼乐，礼乐才能“郁郁乎”繁盛。否则，如果都是为了鬼神而设计，根本不管人的感受，他还可能繁盛吗？谁没事会用他呢？ 与人本主义相对应的，就是神本主义，凡事以神鬼为核心，人则靠边站，殷商的文化就是如此。 商纣王为什么如此暴虐？发明了挖心、炮烙、醢等等惨绝人寰的酷刑，难道就是因为心里变态吗？其实，这些玩意很可能不是刑罚，而是祭祀所需要的献礼。 从对商纣王的描述来看，这个人力大无穷、辩才无碍、高大帅气，妥妥的一个学霸。而且他能征惯战，铁腕政治，绝不可能是一个患有精神疾病的人。从他的表现看，更加有可能是一个宗教狂热分子。他的认知就是，只要我对鬼神虔诚，他们就一定会保佑我。 联系到殷商的占卜和祭祀制度，烧龟壳，然后按照图案指示去给鬼神准备贡品，其结果本就难以预测。很可能烧出了一副图案，像是一个人在嚎哭，他们便想，怎么才能让一个人使劲嚎哭呢？于是发明了炮烙。过两天又烧出了一个图案，像是一颗七窍玲珑心，那就赶紧找吧？可是人心隔肚皮，怎么找呢？那就只能挖出来找。找了几个都不像，于是他们就想了，是不是越贤明的人心才越好呢？王子比干最贤明啊，为了虔诚，那就把比干的心挖了献祭吧。 不光是商纣王，整个殷商的文化应该都是如此。所以即便是施行了这么多让我们毛骨悚然的酷刑，商纣王的统治依然还是稳固的，直到以人为本的周人推翻了他们。 周是中国人本思想的奠基者。虽然在这之前我们不能说他们没有这样的思想，但起码可以说并没有明确下来、推广开去。而周公制礼，则是把人本思想确立了下来，并且传播到了每一个角落。 到了春秋时期，老子在《道德经》中写道，人法地，地法天，天法道，道法自然，域中有四大，人居其一焉。如此一来，便将形而下的人，与形而上的道联系起来，在理论上奠定了人与道天地并列的基础。可以说，是人本主义思想的集大成者。 孔子继承了老子，通过宣扬礼，继续将人本思想加以巩固，从此几千年，中国人再也没有陷入到宗教的泥沼，从来没有过黑暗的中世纪。 这不也证明了周礼是正确的选择吗？ 有德之人，何谓其德？上文提到，孔子和老子是一脉相承。不看道德经，了解一些老子的知识，同样搞不懂孔子的”道“与”德“。 我们一起来看《道德经》第三十八章上德不德： 上德不德，是以有德；下德不失德．是以无德。上德无为而无以为；下德无为而有以为。上仁为之而无以为；上义为之而有以为。上礼为之而莫之应，则攘臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。前识者，道之华，而愚之始。是以大夫处其厚，不居其薄；处其实，不居其华。故去彼取此。 《德经》第一章就语出惊人，仁义礼智被全盘否定，很多人据此说老子是反对儒家的，也有人把老子理解成了虚无主义，更有甚者据此认为老子是反人类、反社会的。实际上，老子并不是否定仁义礼智存在的意义，而是要说明，在有更好的认知模型的情况下，不要选择差的那一方。俗语可以理解为”不要把路走窄“。这个最好的认知模型，最宽的康庄大道，就是老子口中的”道“。 有道之人无需刻意追求德，因为道的认知里，德已经是内化于心、顺其自然的产物了。有德之人无需刻意追求仁，也是同样的道理。这里可以参考孔子所言”七十而从心所欲，不逾矩“。这里的矩，可以理解为德之下的仁、义、礼。”我已具备德的品质，仁义礼智信等都是德之下的延申，不需要刻意约束我自己，我也不会再违背了。“这一点也可以与道德经里的”无为无不为“相印证。 德：&#x3D;&#x3D;上德无为而无以为；下德无为而有以为。&#x3D;&#x3D; 上德并不刻意去追求德，因为他追求的是道，所以有德。追求德，和追求道有什么区别？ 好比咱们打羽毛球，练高远球标准动作，高手是把这些标准动作训练成了肌肉记忆，只要球来了，自然而然的就会打出一整套连贯的标准动作。但是，他会去想每一个环节做得是不是标准？动作是不是连贯？发力是不是集中？正是因为他不想，所以动作才能行云流水，也才能把高远球打好。 下德刻意的去追求德，唯恐失去德，所以还处在无德而求德的阶段。 还是打高远球，新手训练一定是从分解动作练起，蹬地、转髋，转肩、挥臂、旋腕、收指，每个动作都有很多的细节，需要一项一项的打磨。整个一遍练下来，分解动作都没问题了，就要练习连贯了。 很多环节是同步的，还有一些环节是动力链，一环扣一环，连贯做不好，就会怎么打怎么别扭，还不如之前业余瞎打。 为什么不能连贯？因为练得不够，没有把动作融进潜意识，每个动作都需要想，这一想就慢了，慢了动力链就断了，断了就发不出力了，高远球自然也打不远。 下德就是这样，他们时时刻刻、心心念念想着“德”，为人处事不自然，反而会让人觉得惺惺作态。为了获得“德”这种回报而去做事，就好像为了把标准动作做对而去打球，反而适得其反打不好，所以叫做无德。 上德不会刻意作为，是因为“本应如此”，为什么本应如此？因为道是世间万物万事运转的底层逻辑，是大本大源。既然是抽象到最高层的大本大源，那具体到一件件小事上，抽象的规律便会埋藏其后，不着痕迹。我们所能做的，就是摔一次跤后不让自己在同样的坑摔第二次。即使再摔第二次，也不要摔第三次。在实践中成长，用实践指导我们做事的方法论。 这就是前面说的“道可道，非常道”。一切以时间、地点、条件为转移，实事求是。不妄想用一个道理、一次经验、一次实践就一劳永逸。随着时间的推进不断的更新自己，迭代认知模型。 俗语常说知足的人最富有，道德经说”知足之足常足“。都是一样的道理。像”好好努力，绷紧弦，考上好高中就稳了；考上好大学就能随便玩了；找个好单位这辈子就拿下了“，这种心态只会让自己像一个追着胡萝卜跑的驴一样，永远被欲望骑在身上，难以收获真正的快乐。 像咱们在追求道的过程中，心里形成了一个叫做德的半成品模型。虽然还不是道，但他具备了道的混沌特征，就是说不清。我还尚未领会其意，只是在路上跌跌撞撞的闯荡、探索。直到量变引起质变后，通过复盘反思一朝醒悟。 为什么觉得星空很美？不知道，语言无法描述，也不用描述，美就是美，这才是德。如果咱们能列出一二三四来论证星空的美，那咱们论述的已经不是美，而是具体的一二三四这些概念了。 所以，老子才说，下德无为而有以为。意思就是，虽然咱们不刻意去做什么，但仍然有一个不刻意而为的理由，哪怕理由是为了仁爱、为了道义、为了信用，这些未必不好，但就德而言，已经是下德了。 在你约束自己”不要刻意“的时候，你已经刻意了。 在你强迫自己忘掉这件事的时候，你又强化了一遍自己的记忆。 哈哈，这里有点禅宗的意趣了。 仁 ：&#x3D;&#x3D;上仁为之而无以为&#x3D;&#x3D; 如果德做不到，那就只能退而求其次追求仁了，仁者爱人。 大家可能就困惑了，爱人有什么不好呢？为什么老子要批判仁爱精神呢？请各位注意，老子并没有评价好坏，老子说过“美之为美斯恶也”，人家说的就是价值判断没有固定标准，只是相对而言，所以不会犯这种低级错误自己打脸的。 老子之所以说仁是一个退而求其次的选择，只是因为与德相比，他确实就是退而求其次了，这是一个事实，或者说这是形式逻辑推导的必然结果，并不带有任何主观因素。 为了理解这一点，我们要回顾一下，究竟什么是德？道是宇宙万物在人心中的投影，或者说，道是人类思维为宇宙建立的那个完美模型，他是一个理想状态。 人类很难达到那个理想状态，因为我们用于建立复杂模型最有效的工具是语言，广义的语言包括了自然语言、数学语言、机器语言等等。全部这些语言加到一块，也没办法建立一个精确的完美模型。但是，好在我们可以用类比的方式去建立一个模糊模型。这个模型虽然不精确，也不完美，不能做到100%预测万事万物，但他终究还是更接近于道了。这个我们心中模糊的，不完美的，追寻着道所建立起来的半成品模型，就叫做德。 天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。道的特点是，以万物为刍狗；德的特点与道类似，以百姓为刍狗。 刍狗这个意象多次讲过，这是一个非常形象的比喻。刍狗是草扎的狗，粗制滥造，祭祀之后不是烧了就是扔了，其本身毫无价值。但是，他是祭品，所以又很神圣。因为不结实，要轻拿轻放，倍加小心。祭祀的时候摆在祭坛前面，人们对着祭坛行礼，看起来也就是对着刍狗行礼。 一句话总结，就叫对你好，但与你无关。 所以，德就是这样，没有任何目的、没有任何企图，你之所以觉得我对你好，其实并不是我为你做了什么，而是我追寻着道，而你这个刍狗沾光了而已。 各位觉得这种德，咱们自己可以做到吗？是不是很难做到？难就对了，因为老子所讲的德根本就不是为咱们普通人讲的，而是为天子讲的，诸侯勉强也可以参考，至于诸侯以下的士大夫都已经不适用了，那就更别说平民百姓了。为什么天子要修德呢？因为天子富有天下，任何一点喜怒好恶都会被一层层逐级放大。上有所好，下必甚焉，所以对待任何事、任何人都要慎之又慎。一个合格的天子不能偏爱任何一个人，因为这种偏爱会给予这个人极大的权力，以至于导致权力失衡；也不能偏好一件事，喜好战争就会引发穷兵黩武，喜好女色就会引发荒淫无度；甚至喜欢学习、文艺、体育都不行，因为会有人钻营取巧，投其所好，就算没有人迎合，自己也会玩物丧志。所以，天子不是人，天子是天的代表，他的所有行为要尽可能的符合于道，所以他追求的是德。 现在天子虽然没有了，权力的焦点却永远都在。就算是一个普通人，也会有不同的社会角色，对父母是子女，对子女是父母，对老婆是老公，对朋友是朋友，对领导是员工，对员工是领导。这么多的角色要怎么管理？ 咱们自己也需要一个天子的角色去统管所有这些角色。而天子角色，所要追寻的就是道，指导行为的就是德。 但是，一个人有很多不同的角色，也不可能只按照德的方式去扮演所有角色。于是就有了仁。仁的基础是“恻”，也就是共情能力。 看到婴儿在井边爬，是不是想一想都一身冷汗？遇到这种情况，没有人能视若无睹吧？这就是孟子所说的“恻隐之心，人皆有之。”正是这种共情能力使人类天生心中就有仁。 那为什么说仁比德是退而求其次了呢？因为德离道最近，以德行事，不但可以使万物众生感受到咱们对他的好，而且还可以使他们获利，可谓两全其美。所以，德虽然没有刻意的仁，但却可以达到所有仁能够达到的效果，可以说，道兼容了德，德兼容了仁。 那仁与德的区别是什么呢？德的目标是道，仁只是过程中的副产品，我对你好但与你无关。仁的目标就是人，我对你好就是为了你。求其上者得其中，很可能出现“妇人之仁”这一类仁而无用的东西，我只是爱你，但却对你一点帮助都没有。更糟糕的是，会出现“假仁”，我表演出一副仁的模样就好了，反正这就是目标嘛，达到就好了，管他怎么达到呢？当然，这还不是最糟糕的。最糟糕的是，有人会借着仁的名义实施道德绑架，或者强行把自己的喜好强加于人。 坐车就有年纪大一些的人倚老卖老，强行要求年轻人让座，不让座就恶语相向，说人家没教养；家长借着”我为你好我有理”的名号，强行动摇孩子的选择；熊孩子划了人家车，家长不但不道歉，还说对方抓住熊孩子是大人欺负小孩；自己听歌觉得好，就一定让别人必须听，说不好听都不行…… 例子太多，就不一一列举了。孔子也意识到了仁存在这些问题，所以当子贡问孔子，如果一辈子只遵行一句话，应该是哪句话？孔子并没有说“己欲立而立人，己欲达而达人”，而是说“己所不欲勿施于人”。就是担心后世曲解，给道德绑架找借口，不可不谓一片仁心啊。 而德就没有仁的这些问题，因为德是个人的事，不论是心还是行，都与他人无关，所以不可能被利用或者歪曲。所以，老子说，失道而后德，失德而后仁。 关于“己所不欲勿施于人”，和“己欲立而立人，已欲达而达人”： 《论语》记载：“仲弓问仁。子曰：‘……己所不欲，勿施于人。’”（《颜渊》） 孔子又说：“夫仁者，己欲立而立人，已欲达而达人。能近取譬，可谓仁之方也己。”（《论语·雍也》） 由此看来，如何实行仁，在于推己及人。“己欲立而立人，己欲达而达人”，换句话说，己之所欲，亦施于人，**这是推己及人的肯定方面，孔子称之为“忠”，即“尽己为人”。 ** “己所不欲，勿施于人”,这是推己及人的否定方面，孔子称之为恕， 推己及人的这两个方面合在一起，就叫做忠恕之道，就是“仁之方”（实行仁的方法）。 后来的儒家，有些人把忠恕之道叫做“絜矩之道”。就是说，这种“道”是以本人自身为尺度，来调节本人的行为。 絜矩之道在大学中庸中皆有阐释： 儒家有一部论文集名叫《礼记》，其中有一篇《大学》，说：“所恶于上，毋以使下。所恶于下，毋以事上。所恶于前，毋以先后。所恶于后，毋以从前。所恶于右，毋以交于左。所恶于左，毋以交于右。此之谓絜矩之道。” 《礼记》另有一篇《中庸》，相传是孔子之孙子思所作，其中说：“忠恕违道不远。施诸己而不愿，亦勿施于人。……所求乎子，以事父。……所求乎臣，以事君。……所求乎弟，以事兄。……所求乎朋友，先施之。” 义： &#x3D;&#x3D;上义为之而有以为&#x3D;&#x3D; 而义对于仁而言则又退而求其次了。 如果说仁还是符合人的本心、主动去爱人的话，那么义则带有被动性。这违背了人的私欲。也就是说，义的推动力就不能只来自于人的内在自发，而需要借助外力，最主要的就是来自于他人的舆论。 这样一来，问题就更大了，既然义来自他人舆论，那如果有人去影响他人舆论，来确定我们是义还是不义，我们的自由岂不捏在了他人手里？ 这种担心并不是多余的，朝野之中的党同伐异，封建礼教，愚忠愚孝……这些都根源于义。 当然，这并不说明义有什么不好，好像一把菜刀，可以用来切菜，也可以用来杀人。有人用菜刀杀了人，我们总不能去指责刀匠生产了菜刀吧？不是刀杀人，是人杀人。 孟子提倡义，只不过是磨了一把刀。把刀磨的锋利无比不是孟子的错，后世的人不用这把锋利无比的刀切菜，造福人间，反而拿他去杀人，谁才是凶手？ 不论如何，与仁相比，义的危险性更大，所以老子才说，仁做不到了再退而求其次才追求义。 礼：&#x3D;&#x3D;上礼为之而莫之应，则攘臂而扔之&#x3D;&#x3D; 如果精神层面连义都做不到了，那就只好追求形式上的礼了，到了这个地步，已经是没有办法的办法了。 所以老子形容礼，是需要刻意而为的，就算刻意推广，结果却是“莫之应，则攘臂而扔之”。这个描写就非常形象了，就是咱们去推销东西，人家不理，咱们就强拉着硬塞给人家。用现在的话说，就叫强买强卖了。 前面说义已经带有强迫性了，但好歹还只是语言、态度上的强迫，虽然也算强迫，但并不强硬。可到了礼，可就真要动手了，古代不讲礼法，真的是要被判刑的，例如用了不该用的车子、穿了不该穿的衣服等等。包括现在也要讲究很多礼节，通过履行很多高情商的“潜规则”来表明自己的诚心和忠心。当然了，这个层次诚心只是通过特定的行为表面上表明了，其背后的人心仍然是不稳定因素。 像一些目的性强的利益酒局，劝酒的一门心思灌醉他人，被劝的骂他一万句不是，表面上也要恭恭敬敬、心甘情愿的咽下去。 酒喝完，事谈成，各自在背后扣嗓子吐酒，一个愿打一个愿挨，不得不做。 当然，辩证的看，礼节也有好的一面。好的礼法提供了一种行为准则：小事上能让大家用彼此心领神会的方式表达自己，节省了沟通成本；大事上能维系群体和谐，让大家在追求自我个性、满足自我利益的同时也能履行社会义务。 但如果到了仅仅靠强制性的礼去维护，依礼者没有通过礼节表达自己，甚至只是空洞的走个过场，那么再好的礼制最终也会沦为形式主义，最终消失殆尽。 &#x3D;&#x3D;故失道而后德，失德而后仁，失仁而后义，失义而后礼。&#x3D;&#x3D; 道德仁义礼，就是一步步妥协，逐步退而求其次的过程。 从道的自然，到德的效法自然，再到仁的发自内心主动爱人，再到义的半自发半强迫的自我牺牲，最后到礼的完全形式化的行为标准。 所以老子说，到了刻意强调礼的时候，必然是道德仁义这些内在的、自发的东西已经淡薄到极致了。 不忠不信的人太多了，迫不得已，才只好用礼去规范他们。所以，礼就是“乱之首”。 这个首字要注意，很多人把他翻译成罪魁祸首，显然曲解了老子的意思。老子说礼是迫不得已的产物，可没说是因为礼才迫不得已的，因果不能搞混了。首，就是头，也指起始点。罪魁祸首这个词，要到明朝才出现，老子那个时候是没有这个用法的。所以，老子说礼是“乱之首”，就是字面意思，到了礼就要开始乱了，礼是乱的起始标志，而不是说因为有了礼才会乱。 前识者，识与认相对，我们现在常说认识，要先认而后识。认，从言从忍，指用言语对事物进行分割，分割成什么呢？分割成名，也就是概念。识，从言从织，指把语言关联起来，也就是把概念连接起来。概念连接起来就是理，指概念之间的连线，是不是很形象？而理继续综合就变成了知，也就是有用的经验。所以，前识，指的就是这些理和这些知。 老子把前识比喻为“道之华”，华就是花，华而不实就是只开花不结果。 意思就是，这些理和知虽然看起来很美，但那只是形式，如果咱们只追求这些，那就是“愚”的开始。愚，甲骨文是心上面一只猿猴，就是心猿意马中的心猿。“意”，也就是咱们的注意力，这东西很活泼，但带宽却有限，如果放任不管，他就会像猿猴一样四处乱窜。注意力不集中，自然就显得愚蠢了。 老子用这个字是想说，如果咱们被花吸引，把心全部放在理和知上面，看花看太多，就会乱花渐欲迷人眼，忘掉自己一以贯之的初心了。 玩手机，也许开始我们带着目的，一旦打开短视频之类的信息流中，很容易忘记自己一开始为什么要打开。 所以，大夫们不居住于薄的地方，薄的是什么，是礼；而应该处于厚的地方，厚的是什么，道德仁义，道最厚，依次递减。不应该居住于花，花是什么，理和知；而应该处于果实，果实是什么，当然是心中那个德，也就是半成品的道。 老子讲这些，是讲给大夫听的吗？当然不是，仍然是讲给天子、君主听的，所以最后才有这么一句，“故去彼取此”。意思就是，因为大夫们应该处其厚、处其实，所以咱们作为君主的，要取其厚、取其实，给团队营造良好环境，这样才能把大家凝聚起来，咱们自己才能无为而无不为！ 道、儒、法、墨我们总是习惯性的把道、儒、法、墨四家分的清清楚楚，甚至互相看不顺眼；可实际上，他们根本不是并列关系，而是内核高度一致，路径各有不同。 老子和孔子最早的老子，他谈到了宇宙万物，既谈了道，也谈了德，是最大的那个圈。 小一辈的孔子曾专门拜访、请教过老子，更关键的是，他们读的书都是一样的，礼记、尚书、诗经、易经等等，而且老子就在周的图书馆，这些书都是周书，所以，他可能比孔子看过的书还多。从后来孔子的思想中，能看出他继承了很大一部分老子思想，尤其是关于道，孔子不再谈了，他只谈德。 这感觉就像是我在知乎看到一个很有意思的问题，看了一眼答案，发现人家已经回答了大部分，只是有一块没说透，需要展开，于是我只需要单独展开来谈这一块就够了。 孔子展开的就是德的部分。这些都是他们重叠的部分，不同的是什么呢？是方法，道家认为你什么也别管，让社会自己运行，这是最好的方法。 “治大国若烹小鲜”，千万别折腾，那么多小玩意你能挨个折腾？显然不能，折腾多了小虾小贝就都碎了，没法吃了。 儒家现阶段不适合用这个方法，儒家认为要先用“礼”，积极树立榜样，引导大家有样学样，君先打个样，臣跟上，爸爸跟着学，儿子跟爸爸学，完美。由礼及义，由义知仁，由仁生德，由德得道。讲究一个循序渐进的过程。 道德经里说”道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。“ 这个“一”就是对立统一的“一”，就是矛盾双方的统一体，就是有正反两面的硬币，就是太极，也叫太一。 这个“一”，还是《尚书》中《禹谟》里舜对禹说的“人心惟危，道心惟微，惟精惟一，允执厥中。” 这个“一” , 还是孔子所说“吾道一以贯之”的“一”，曾子解释是“忠恕而已矣”，这里说的是孔子的&#x3D;&#x3D;“道之用”&#x3D;&#x3D;。 理解了这个“一”，那么“一生二”就好理解了，“二”就是矛盾双方，中国的说法叫阴阳。《周易》说“一阴一阳之谓道”，也就是矛盾双方对立统一，反之又反永恒运动。这种运动便产生了三，然后是四、五、六，以至于无穷。量变引起质变，最终产生了宇宙万物。 而孔子&#x3D;&#x3D;“道之体”&#x3D;&#x3D;，必然是与老子，《周易》，《尚书》一脉相承的。因为，孔子看的书，跟老子是一样的，周的文化奠基人就是武王的弟弟周公，而周公被封在鲁国，孔子便是鲁国人。 韩非子&#x3D;&#x3D;韩非其人&#x3D;&#x3D; 韩非子处于战国末期，是韩国（今河南省西部）公子，祖国韩国是战国七雄中最弱的一国，离秦国又近，被秦国百般欺凌，积贫积弱。 他受够了这种半死不活的状态，原地踏步无异于等死，所以不论如何也要踏出一步，这一步就成了法家之集大成者。 《史记》说他“与李斯俱事荀卿，斯自以为不如非”（《老子韩非列传》）。他擅长著书，著《韩非子》五十五篇。 富于讽刺意味的是，秦国比别的任何国家都更彻底地实行了韩非的学说，可是他正是死在秦国的狱中，这是公元前233年的事。 他死于老同学李斯的政治暗害，李斯在秦国做官，嫉妒韩非在秦日益得宠。 深谙“御下之术”的韩非子，竟然敢冒天下之大不韪，在千古帝王面前谋求保全韩国，以至于被李斯所害。或许韩非身上还有杀身成仁的赤子之心未可知。 &#x3D;&#x3D;社会背景&#x3D;&#x3D; 周朝的后几百年，封建社会制度逐步解体，社会发生了深远的变化。君子和小人的社会区别不再是绝对的了。 在孔子的时代，已经有一些贵族丧失土地和爵位，又有些平民凭着才能和运气，顺利地成为社会上、政治上的显要人物。 社会各阶级原有的固定性，被打破了。随着时间的推移，通过侵略和征服，大国的领土越来越大了。 为了进行战争，准备战争，这些国家需要一个强有力的政府，也就是权力高度集中的政府，其结果就是政府的机构和功能比以前越来越复杂得多了。 自孔子以来诸子百家共同努力解决的就是国家治安问题。可是他们提出的解决方案，已经不够现实、难以实行了。 各国诸侯需要的不是对百姓行仁政的理想纲领，而是如何应付他们的政府所面临的新情况的现实方法。当时有些人对现实的实际政治有深刻的理解。诸侯常常找这些人打主意，如果他们的建议行之有效，他们往往就成为诸侯相信的顾问，有时候竟成为首相。这样的顾问就是所谓的“法术之士”。 &#x3D;&#x3D;核心观念&#x3D;&#x3D; 韩非所在时期，法家已经发展了三派，韩非作为集大成者，吸收了(慎到)的势、(申不害)的术、(商鞅)的法。 “势”，指权力，权威；“法”，指法律，法制；“术”，指办事、用人的方法和艺术，也就是政治手腕。 法 : 法治萌芽 韩非师从荀子，受到老师的影响，他认为人都是自私自利的。如果没有一个强大的外力作用，儒家希望构建的那个&#x3D;&#x3D;帕累托最优&#x3D;&#x3D;是无法实现的。而儒家所依赖的外力是什么呢？是圣人，尧舜禹，汤文武，还有周公。孔子那个年代，周公的影响力还在，人们心中还存有希望，希望能有圣人降世。 但是，到了韩非那个年代，经过几百年的战乱，这种希望已经彻底破灭了。所以，韩非认为圣人是可遇而不可求的，想解决眼前的问题，不能等着天上掉圣人，创造人类幸福，全靠我们自己。 所以，韩非总结了子夏、李悝、吴起、商鞅这一线的传承，希望退而求其次来构建一个&#x3D;&#x3D;纳什均衡&#x3D;&#x3D;，既然仁义离得太远，那咱们就用刑名来划条底线吧。有了这条底线，对君主的要求就没有那么高了，他只需要维护法，并在原有的基础上修修补补、不断迭代就好，这就简单多了吧？这就是全世界最早、最全面的“法治”思想。 术 ： 政治手腕 几千年下来，其实大家关于法的争议并不大，即便独尊儒术之后，也听不到什么反对法的声音，因为这是“阳谋”，根本就无从反驳。大家骂得最多的，一个是术，一个是势，为什么？因为这两个东西讲的是怎么实现君主集权，就是在手把手教君主们把官僚集团玩弄于股掌之中。而掌握学术话语权的是谁呢？不就是官僚集团吗？所以他们对这些阴谋简直恨得牙根痒痒。 韩非绝对是个耿直boy，那些原本上不得台面的东西他居然搬出来讲，不但讲了，还讲得异常透彻，你说耿直不耿直？ 例如韩非教君主在官聊之中找平衡，拉一派打一派，谁露头就打谁，不许官聊掌握兵权、人事权、财权，不许拉帮结派，甚至不许他们在百姓中树立良好形象。 最狠的是，连怎么杀大臣都说明白了，不能直接杀，那样名声不好，要“行饮食”暗杀……咱要是官僚会怎么想？关键是就算咱们知道这些手段，可就是没办法。中国的君主们自从有了法家利器，对官僚就产生了压倒性的优势。几千年的君主专制，始终用的就是韩非子打造的这把大杀器，所以也叫“外儒内法”。 势 ：威权政治 就是通过权力收放、利益分配、礼仪形制对官僚进行心理威慑，当然这其中道德约束也必不可少，本来提倡民本的儒家也被君主拉进来为虎作伥，可见法家之无所不用其极。 咱们看看古代的宫殿，皇帝高高在上，下面匍匐着文武百官，如果是咱们在场，是不是连大气都不敢出？这就是威权的表现。 &#x3D;&#x3D;儒家和法家&#x3D;&#x3D; 儒家主张，治理百姓应当以礼以德，不应当以法以刑。他们坚持传统的治道，却不认识当初实行此道的环境已经变了。在这个方面，儒家是保守的。在另一方面，儒家同时又是革命的，在他们的观念里反映了时代的变化。传统上只按出身、财产划分的阶级区别，儒家不再坚持了。 当然，孔子、孟子还继续讲君子与小人的区别。但是在他们看来，这种区别在于个人的道德水平，没有必要根据原来的阶级差别了。 在早期的中国封建社会中，以礼治贵族，以刑治平民。所以，儒家要求不仅治贵族以礼，而且治平民也应当以礼而不以刑，这实际上是要求以更高的行为标准用之于平民。在这个意义上，儒家是革命的。 在法家思想里，也没有阶级的区别。在法律和君主面前人人平等。可是，法家不是把平民的行为标准提高到用礼的水平，而是把贵族的行为标准降低到用刑的水平，以至于将礼抛弃，只靠赏罚，一视同仁。 儒家的观念是理想主义的，法家的观念是现实主义的。正由于这个缘故，所以在中国历史上，儒家总是指责法家卑鄙、粗野，法家总是指责儒家迂腐、空谈。 韩非子出自儒家，他根本连德也不谈了。他好像在说：这方面孔子说的都对，但是我不赞成他的方法。学习好榜样固然是好，但要是有人不学呢？而且只要有一个人不学，那这套体系就危险，损人利己的人反而占便宜了，这个榜样的力量更巨大不是吗？ 所以，榜样没有用，要用刑法，让损人利己的人受到严厉制裁，其他人看到这个前车之鉴，就不敢越雷池一步。 为什么法家未能实现取代儒家? 首先什么是法家？历史上有哪位法家的代表人物自称法家吗？ 没有。 不但没有，法家的学术发展脉络也是断断续续的。 集大成者韩非子，师从大儒荀子，人家从来没说过自己是法家，“儒以文乱法”多少看着都像人家作为儒者的自我批判。 韩非的继承者呢？没有，断了…… 商鞅据说师从尸子，但显然受到李悝、吴起影响更大，这条线倒是很清楚。商鞅的继承者呢？还是没有……吴起的师承是子夏，孔门高足。李悝是子夏的再传弟子…… 管仲没有师承，应该是无师自通的，之后也没有传人…… 申不害，这位据说好黄老之学…… 子产，铸刑鼎那位，中国最早的成文法制定者，他自己都觉得铸刑鼎是迫不得已…… 先秦出现过的显学，杨朱、墨家、儒家，就这三家，从来没有法家，法家这个称呼最早可能要到汉代才提出来。 既然从师承上看不出什么，咱们只好看看法家讲得是什么？ 这倒简单，看《韩非子》就够了，人家真的是集大成者，法、术、势面面俱到。 但关键在于，《韩非子》这本书不涉及本体论、认识论，价值观是荀子的，甚至没有方法论，有的只是具体的方法，这其实就是一部“帝王操作指南”，只不过是史上最强攻略，没有之一。 为什么后世外儒内法配合起来毫无违和感？ 因为法儒本是一体，法家只是儒家的一个技术分支。 &#x3D;&#x3D;道家和法家&#x3D;&#x3D; “无为而无不为。”无为是道家的观念，也是法家的观念。 韩非和法家认为，君主必需具备一种大德，就是顺随无为的过程。他自己应当无为，让别人替他无不为。 韩非说，君主应如“日月所照，四时所行，云布风动；不以智累心，不以私累己；寄治乱于法术，托是非于赏罚，属轻重于权衡”（《韩非子·大体》）。 换言之，君主具有种种工具和机器，用来进行统治，有了这些，就无为而无不为了。 道家与法家代表中国思想的两个极端。道家认为，人本来完全是天真的；法家认为，人本来完全是邪恶的。道家主张绝对的个人自由；法家主张绝对的社会控制。可是在无为的观念上，两个极端却遇合了。这就是说，它们在这里有某些共同之处。 法家的治道，也是后期道家所主张的，只是词句上稍有不同。《庄子》里有一段讲“用人群之道”。这一段既区分了有为与无为，还区分了“为天下用”与“用天下”。 无为，是用天下之道；有为，是为天下用之道。 为天下用 君主存在的理由是统治全天下，所以他的功能和职责是自己无为，而命令别人替他为。换句话说，他的统治方法是以无为用天下。臣子的功能和职责，则是接受命令，遵命而为。 换句话说，臣子的功用是以有为为天下用。这一段里说：“上必无为而用天下，下必有为为天下用，此不易之道也。”（《庄子·天道》）《庄子》这一段接着说：“故古之王天下者，知虽落天地，不自虑也；辩虽雕万物，不自说也；能虽穷海内，不自为也。” 君主一定要这样，因为他万一考虑某件事，这就意味着别的事他没有考虑，可是他的功能和职责是考虑他治下的“一切”事。 所以解决的办法，只有让他不自虑，不自说，不自为，但是命令别人替他虑，替他说，替他为。用这种方法，他无为，而无不为。 哈哈，想到了权术大师嘉靖皇帝了吗？ 用天下 至于君主“用天下”的详细程序，这一段里说：“是故古之明大道者，先明天，而道德次之；道德已明，而仁义次之；仁义已明，而分守次之；分守已明，而形名次之；形名已明，而因任次之；因任已明，而原省次之；原省已明，而是非次之；是非已明，而赏罚次之；赏罚已明，而愚知处宜，贵贱履位，仁贤不肖袭情。……此之谓太平，治之至也。” 很清楚，这个程序的后部分正与法家相同。这一段还继续说：“古之语大道者，五变而形名可举，九变而赏罚可言也。骤而语形名，不知其本也。骤而语赏罚，不知其始也。……骤而语形名赏罚，此有知治之具，非知治之道；可用于天下，不足以用天下；此之谓辩士，一曲之人也。”从这里可以看出道家对法家的批评。 法家的治道，需要君主公正无私。他一定惩罚应当受惩罚的人，即使这些人是他的亲友；他一定奖赏应当受奖赏的人，即使这些人是他的仇敌。只要他有一些时候不能这样做，他的整个统治机器就垮了。这样的要求是一个仅有中等智力的人远远不能胜任的，真正能实现这种要求的还只有圣人。 墨子&#x3D;&#x3D;社会背景&#x3D;&#x3D; 墨子对儒家的观念有所批评，但实际上还是其思想的延申。 上文聊到，周代贵族的教师、文人们在周后期封建制度解体后流落各地，成了早期一批教师。同样的，贵族军队的那些将士们，在丧失爵位后也成为了最早的”游侠“。 关于游侠：谁雇佣他们就为谁服务，以此为生。《史记》说他们“其言必信，其行必果，已诺必诚，不爱其躯，赴士之厄困”（《游侠列传》）。这些都是他们的职业道德。大部分的墨学就是这种道德的发挥。在中国历史上，儒和侠都源出于依附贵族“家”的专家，他们本身都是上层阶级的分子。到了后来，儒仍然大都出身于上层或中层阶级；而侠则不然，更多的是出身于下层阶级。 在古代，礼乐之类的社会活动完全限于贵族；所以从平民的观点看来，礼乐之类都是奢侈品，毫无实用价值。墨子和墨家，正是从这个观点，来批判传统制度及其辩护者孔子和儒家。这种批判，加上对他们本阶级的职业道德的发挥和辩护，就构成墨家哲学的核心。 &#x3D;&#x3D;核心观念&#x3D;&#x3D; 儒家的中心观念仁、义，墨子并没有批评；在《墨子》一书中，他倒是常讲到仁、义，常讲仁人、义人。不过他用这些名词所指的，与儒家所指的，还是有些不同。照墨子的意思，仁、义是指兼爱，仁人、义人就是实行这种兼爱的人。 兼爱是墨子哲学的中心概念。 墨子出于游侠，兼爱正是游侠职业道德的逻辑的延伸。这种道德，就是在他们的团体内“有福同享，有祸同当”（这是后来的侠客常常说的话）。以这种团体的概念为基础，墨子极力扩大它，方法是宣扬兼爱学说，即天下的每个人都应该同等地、无差别地爱别的一切人。 这很像三五个哥们，相处到位了，一起结拜结盟拜关老爷，然后在这个小群体内践行彼此的道德共识。 十个主要思想： 兼爱：不分等级、不分亲疏的爱天下所有人。 非攻：反对侵略战争，坚持正义战争。尚贤：崇尚贤良的人才。尚同：政令、思想、言语、行动等要与圣王的意志相同一。节用：崇尚节俭、节约，反对铺张浪费。节葬：反对厚葬久丧，主张薄葬短丧。非乐：反对奢靡的音乐活动，提倡节约人财物力。天志：天是有意志的最高主宰，天的意志是兴利除害。明鬼：辨明鬼神的存在，鬼神能扬善惩恶。非命：否认天命对人事的支配和影响 &#x3D;&#x3D;功利主义的劝说&#x3D;&#x3D; 于是这个学说面临一个根本问题：如何说服人们兼爱呢？你可以把上面所说的告诉人们，说实行兼爱是利天下的唯一道路，说仁人是实行兼爱的人。人们还是会问：我个人行动为什么要利天下？我为什么必须成为仁人？ 墨子说：“夫爱人者，人必从而爱之；利人者，人必从而利之；恶人者，人必从而恶之；害人者，人必从而害之。”（《墨子·兼爱中》） 如果对全天下有利，也就是对天下的每个人都有利。 这样说来，爱别人就是一种个人保险或投资，它是会得到偿还的。可是绝大多数人都很近视，看不出这种长期投资的价值。也还有一些实例，说明这样的投资根本得不到偿还。 墨子用这种功利主义的辩论，证明兼爱是绝对正确的。仁人的任务是为天下兴利除害，他就应当以兼爱作为他自己以及天下所有人的行动标准，这叫做以“兼”为“正”。 “以兼为正，是以聪耳明目，相与视听乎；是以股肱毕强，相为动宰乎。而有道肄相教诲，是以老而无妻子者，有所侍养以终其寿；幼弱孤童之无父母者，有所放依以长其身。今唯毋以兼为正，即若其利也。”（《墨子·兼爱下》） 这也就是墨子的理想世界，它只能通过实行兼爱而创造出来。 &#x3D;&#x3D;宗教劝说&#x3D;&#x3D; 为了诱导人们实行兼爱，所以墨子在上述的道理之外，又引进了许多宗教的、政治的制裁。因此，《墨子》有几篇讲“天志”、“明鬼”。其中说，天帝存在，天帝爱人，天帝的意志是一切人要彼此相爱。天帝经常监察人的行动，特别是统治者的行动。他以祸惩罚那些违反天意的人，以福奖赏那些顺从天意的人。除了天帝，还有许多小一些的鬼神，他们也同天帝一样，奖赏那些实行兼爱的人，惩罚那些交相“别”的人。 非常有趣的是，即使墨子动用了宗教来劝说，他自己对鬼神也仍然是没有任何兴趣的，只是将其作为一种劝说的工具。就好像孔子常说丧葬、祭祀、拜祖等礼仪之事，却对鬼神避而不谈，敬而远之。 照儒家所说，行祭礼的原因不再是因为相信鬼神真正存在，当然相信鬼神存在无疑是祭礼的最初原因。行礼只是祭祀祖先的人出于孝敬祖先的感情，所以礼的意义是诗的，不是宗教的。 对墨子而言，他要证明鬼神存在，本来是为了给他的兼爱学说设立宗教的制裁，并不是对于超自然的实体有任何真正的兴趣。 &#x3D;&#x3D;政治极权&#x3D;&#x3D; 当然，人们若要实行兼爱，除了宗教的制裁，还需要政治的制裁。 墨子认为，无论什么情况，人们最终都会自愿选择绝对权威来统治他们。人们接受这样的权威，并不是由于他们选中了它，而是由于他们无可选择。因为他们需要把自己无政府状态中拯救出来。 墨子论证出，国家必须是极权主义的，国君的权威必须是绝对的。这是他的国家起源学说的必然结论。因为国家的设立，有其明确的目的，就是结束混乱，混乱的存在则是由于“天下之人异义”。因此国家的根本职能是“一同国之义”（均见《墨子·尚同上》）。一国之内，只能有一义存在，这一义必须是国家自身确定的一义。别的义都是不能容忍的，因为如果存在别的义，人们很快就会返回到“自然状态”，除了天下大乱，一无所有。 在这种政治学说里，我们也可以看出，墨子发展了侠的职业道德，那是非常强调团体内的服从和纪律的。它无疑也反映了墨子时代的混乱政治局面，使得许多人向往一个中央集权的政权，哪怕是一个专制独裁的也好。这样，就只能够存在一义。义，墨子认为就是“交相兼”，不义就是“交相别”。这也就是唯一的是非标准。通过诉诸这种政治制裁，结合他的宗教制裁，墨子希望，能够使天下一切人都实行他的兼爱之道。 &#x3D;&#x3D;墨家和儒家&#x3D;&#x3D; 虽然表面上墨子是反对儒家的，但从他的思想来看，墨家仍然继承了儒家的中心思想。 与其说墨子反对礼，不如说墨子认为“礼”这种有等级的爱不是终点，而是中间状态。他认为终点是兼爱，是无差别的爱，是大同世界，共产主义。所以，他另创了墨家。 大同就是孔子提出来的，他能反对大同？墨子见到老爷子，两人没准一拍即合，己欲立而立人、己欲达而达人，这种仁一旦实现，其实也就是兼爱。 不过墨子这个思想实在太超前了，以至于他的组织与当时的社会不相容，完全自成一派，这是一种比“礼”更加不稳定的均衡，其实就是“帕累托均衡”，这种均衡虽然是最优，但危如累卵，所以墨家很快就失去了实体组织。 各家背景：如何达到真正的均衡？春秋之前，大家讲究的是“灭国存嗣”。说白了就是打你只是因为你这个君主无道，百姓民不聊生，我是吊民伐罪。把这个君主赶走之后，这个国我不要，在这个国的宗族里面找一位贤明的人继续当国君。我不但不争夺利益，反而会帮助你治理国家。这就是所谓的“王道”。 但是，进入春秋情况就变了，各国君主的私欲开始膨胀，发动战争的目的已经不是吊民伐罪，而是土地兼并，扩充实力。所以，春秋开始的战争逐渐开始既灭国又灭嗣了。这个打法使得所有君主人人自危，因为这是真玩命呀。搞不好就灭门了，而灭门率之高也是耸人听闻的。春秋初年有国一百多个，春秋末年只剩了二三十个，其余一百多个都被灭了。在这种情况下，打起来那真是拼尽全力、以死相搏。 打仗一般在“郊”这个地方打，也就是城外不远的地方。因为举倾国之力用于战争，怀孕的母马都被征调去打仗，以至于直接在战场上产下小马。可以想象一下，这是何等惨烈的情景。 当然，春秋时期各个诸侯还要点脸，多少会找点借口遮遮掩掩。老子、孔子觉得还可以抢救一下，所以来劝架，想让大家冷静下来，回归王道。可王道是什么？是帕累托最优，也就是每个人在不损己的情况下积极利他。好是好，但这是一种不稳定的平衡。只要有一个人开始损人利己，这种平衡就会被打破。而由于私欲的存在，在长周期里面，是这种事是必然会发生的。所以，这种平衡必须一个强制力量进行维持，春秋之前这个强力是周天子。可维持强力本身就很难，这个强力自身还需要公正无私，也就是要施行“王道”，这可就难上加难了。 历代周天子挺了四百年才进入春秋，这已经是个奇迹了，后面就真的带不动了。一旦周王室稍显颓势，各个诸侯被压制的私欲便抬头了。从郑庄公开始，千里之堤溃于蚁穴。私欲这东西星星之火可以燎原，一旦起了个头，后面就一发不可收拾。于是天下开始滑向另一种均衡，就是大名鼎鼎的纳什均衡。最著名的例子就是“囚徒困境”。其实说白了就是人心隔肚皮，人与人之间无法建立信任，所谓害人之心不可有，防人之心不可无，就是这个道理。 于是为了防人，宁可自己受点损失，也比被人坑了蒙受最大的损失好。每个人都采取最保守的策略，这种策略可以保证即便遇到最差情况，我也不会有更多损失了。所以，纳什均衡才是稳定的平衡状态，如果任由博弈自然的发展，最终一定会以纳什均衡的形式达到平衡。在这种趋势下再坚守王道，分分钟就被玩死了，所以大家转而遵循“霸道”，说白了就是谁胳膊粗听谁的。 一脉相承不知道大家有没有发现，中国哲学的宗师们，从来没有一个强调自己的理论是原创的。 老子说”人之所教，我亦教之“，孔子也说“述而不作”，意思就是我所讲的道理只是复述古人的，我自己并没有创作。孟子说“游于圣人门者难为言”，意思就是圣人把该说的都说了，我想再说什么都很难了。 这就是中华文明传承数千年，连绵不绝、屹立不倒的原因了。古代先贤，一脉相承。而究其根本，还是中国古老辩证思想的潜移默化。 我们承认矛盾，但强调统一，这叫做“中”；我们承认运动是永恒的，但强调反之又反，这也叫做“中”；我们承认事物是会发生质变的，但强调这种显著的质变必然是由微小的量变引起的，应对好这些细小的量变叫做“和”；我们承认宇宙是个混沌系统，没办法为其建立精准模型，但仍然强调“道可道”，“人亦大”，人是需要去努力追求道的，这叫做“德”，德便是“道之用”。这种“用”细微而弱小，所以我们把这种用叫做“庸”，甲骨文的形象，上面乐器下面水桶，表示日常所用。以上这些概念就是我们耳熟能详的，“允执厥中”、“中和”、“中庸”了。"},{"title":"芜湖芜湖","path":"/essay-md/芜湖.html","content":"芜湖芜湖真的好舒服"},{"path":"/notes/mac.html","content":"name: 备忘录title: 备忘录icon: # 列表页图标cover: # 封面页大图coverpage: [cover, title, description] # 封面页显示的内容 comments: service: giscus # 若你不适用默认的评论方式，需要添加此项 giscus: # 需要你在主题配置文件_config.stellar.yml中设置好giscus的其他参数，其他评论方式同理 ‘data-term’: ‘23’ ‘data-mapping’: number base_dir: &#x2F;notes&#x2F;tree: ‘日常问题解决方案’: - mac ‘移动端开发笔记’: - ios - flutter ‘前端学习笔记’: - nodejs - server ‘在线工具’: - json"}]