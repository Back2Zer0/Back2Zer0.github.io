[{"title":"徐克给我们编织的武侠梦","path":"/2026/01/28/对徐老怪镜头下江湖的痴迷从何而来/","content":"对徐老怪镜头下江湖的痴迷从何而来：徐克很喜欢用佛学和禅意去留白，去作为烟花绚烂后的宁静注脚。形成一个 沉浸美好→极致幻灭→顿悟留白 的模式。 首先用天然矛盾的一对，邂逅在一片清幽净土中，于是一刻的美好化作永恒，藏在两人心里，也藏在观众心里。这个场景可能有遨游在怀抱里的点点飞花，有暖灯下的窃窃私语，客栈里的欲拒还迎；有破旧古庙里两情相悦的幽会，折柳水桥上江南女子的游街弄景…… （这一对如《青蛇》的小青和法海；《倩女幽魂》中的书生和女妖；如《新龙门客栈》的邱莫言和周淮安；《笑傲》中的东方不败和令狐冲，刘正风和曲洋；如《梁祝》……） 此时心里成全这二人的私欲会让观众心里挠痒痒一样，被迫审视矛盾之上的“制度”“规矩”，心想自私一把也没什么不好的吧？一旦产生这个想法，你就着了徐老怪的道了，因为心中那个浪漫天真、不切实际的自己被引诱了出来。 然后现实的引力把你骤然拉回，重重的摔在地上——矛盾爆发了。 大喜转大悲，那永恒的浪漫和无形的枷锁纠缠在一起，摔碎在了地面上。 最后观者默然，无语凝噎，那个终极问题还是抛了出来，如此自然: “何以至此呢？？？” 是啊，不至于此。 于是佛家的“应无所住而生其心”，“一切有为法，如梦幻泡影”，“菩提本无树，明镜亦非台”等等，顺势而生，这些禅意如电影末尾镜头里一定会出现的山水一样，包容着这里发生的一切，古井不波，静水流深。直指观众内心。 以金庸的文化基底，徐克的镜头习惯，黄霑的灵性词曲，佛法和禅机就在留白和问题之中。 出世或入世，需要用自己的心去寻找答案—— 直到终于接近徐老怪不同电影的相同境界:热烈，不羁，纯真，克制，品味，游荡…… 极致永恒的一方天地。 人不就活这么几个瞬间吗？","tags":["电影"],"categories":["审美"]},{"title":"《好运设计》(史铁生)读书笔记","path":"/2026/01/28/好运设计/","content":"越长大越感受到，幸福是一种能力，是一种智慧。 成功并不能让你幸福，只能让希望你成功的人幸福一点点和不希望你成功的人不那么幸福。 人需要成功。但人又不能为成功活。前者让生命体验有所深度，后者让自己在各种体验中率性而为，不臣服，少点贪瞋痴。 我是山河四省00后这一代。我的高中生活是老师能光明正大对同学们说“读书一秒就是挣一分钱”。身边不是互帮互助的伙伴，而是无暇顾及的“成功”路上的竞争者。 树立学习标杆没有给孩子们榜样的力量，倒是在心里植入了不配得感和单一评价标准带来的二极管思维——要么鸡血要么摆烂，要么自恋自负要么自卑自贱。 “焦虑”是最大的生产力。 家长对上一版本的读书致富路径觊觎已久；校长为升学率和重点率达不到家长预期在想怎么榨出来孩子最后一点焦虑感； 老师权力的削弱和被迫加班早就告别了过去“一日为师终生为父”的灵魂工程师职能，被迫成为斡旋于领导和家长的缓冲层，匆忙于打卡下班中。 于是在孩子最大的社会化工作和心理健康前，学校教育和家庭教育都失能了。 孩子能怎么做呢？ 诉诸于上一代家长老师，他们会告诉你，“有努力的机会已经是一种幸福”。“别人都行为什么就你事多”。“我当年吃不上饭的时候……” 另一个版本的“凭什么不欺负别人，就欺负你，一定是你的原因。” 孩子的疑问没有任何回答。只是对自己的提问感到羞耻。ta的心理病，ta的善妒、自负、麻木、焦虑、不配得没有任何回应。ta的社会化，将心比心，亲密关系，独立思考，价值判断是一片迷雾。 没有否定没有肯定。问题本身被抛弃在迷雾里。被抛弃的，还有孩子作为人本身的意义感。 我们朝着家长老师口中的理想自我无休止地攀爬，没有一丝倦怠，直到分不清“我是生命的人，还是生命的机器”，像一个工具，像一个工具的奴隶。 虚无感从中而来，我和世界切断了联系，感受到的是沦为无用工具的格格不入，而不是我们强调的”个体独特的存在”了。 焦虑感短暂消失，又潮水般涌来。所有的鼓励、暗示、交流，都在为焦虑感服务。 焦虑是第一生产力。 带着一身新的期望和任务，迈向“死命玩”的大学。又发现大学不过是高中生活的变种，甚至同学的名字都不必记得。 只不过高中是逼着你接受优绩主义、“失败”者不配幸福的生活理念， 大学让你发挥主观能动性自己给自己强化这个理念。 一个被升学率剥削，一个自我剥削。 服从性更强了。美其名曰“自发的成熟”。 踏实的学习知识技能是绝对必要的。 但为了让孩子学到知识技能，用孩子十六年的时间 把ta的世界观、人生观、价值观摧毁，把ta的社交生活、心理生活、社会化生活扭曲，不知这算不算有才无德？这算不算本末倒置？ 真正的教育仍然是稀缺资源。 这是应试教育路子的必然阶段，是教育gaige反思更新之前的高峰。 之前看到一个文章。 （知乎@ 离阿米浪子） 人需要优秀吗？ 请觉察这其中的荒诞：优秀始终是一种对工具的评价，人不需要是优秀的。人只需要是活着的，自洽地存在着的。 如果你愿意观察周围，你会发现既得利益者永远认为自己是“优秀”的，因为他们没有任何向下或向上的认知， 他们的认知永远被局限那个被他们的出身和运气局限好的体系内。 “优秀”这个词的荒谬在于: 在学生时代，“优秀”用来衡量你做牛马的质量， 也就是能创造社会价值的能力(甚至衡量的 标准也是相对单一和粗暴的)。在成人时代，“优秀” 则突然变成了用来衡量你占用社会资源的多少。他们把这个时期的优秀称为“社会化”。但在此之上的遮羞布是:没有人告诉你占用社会资源的人中的大多数并不创造社会价值。 说白了，一切“优秀”的定义都被金钱和权力掌握，只有靠近资本的人才是“优秀”的。 比如我无法定义一个 深耕乡村教育的师范生， 一个在大厂码字的程序员，一个在上海赚了钱买房的金融男三个人哪个更优秀。但我们的资本话语体系显然可以分出优劣，因为收入和资产是可以量化的，这是一种结果导向的价值思维。 请记得，每次你在比较中获得“优秀”的精神快感时，就有一个老鼠人受到伤害。 一个真正优秀的灵魂(这里的优秀指的是剥脱了所有现世意义的优秀)，只会听从自己的本能去劳动和创造，并且善用上天给自己的躯体和灵魂。这种能量的挥洒自然可以是在工作中完成的，并且这种人会自然而然达到世俗所追求的“优秀”标准。这种浑然天成的优秀和为了“优秀” 去“优秀”，本质上是两种截然不同的东西，是人和器的区别。 就算你没有这样的天赋，你也不见得失去了优秀的资格，普通人同样可以在社会体系中成为优秀的。工作对普通人的一个重要的意义是: 承担责任，去养家糊口。这里的优秀在于:你作为一个人，承担了责任(人依旧是主体，不得已的工具性只是一种手段)。 而在满足这个基本目的基础上，如果你再以“优秀”的目的去追求“优秀”，那就是把自己彻底工具化，这对任何一个个体来说都是悲哀的，并且大概率也不会为整个社会创造什么正面价值。因为这种以个人目的为导向的人往往是自私的，是吸收周围环境和人的能量的。 精致利己。","tags":["文学"],"categories":["读书"]},{"title":"注意力与心流：《the inner game of tennis》与《道德经》对提高运动表现的启发","path":"/2026/01/28/theinnergameoftennis/","content":"此文为《The inner game of tennis》读后感 “致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。” 从《大学》的话中可以看到，在精进某项技能的过程中，会引发我们很多思考与感受。这些感受积累的多了，便能上升到“方法论”，即形成超越技能本身的，能够应用于生活各方面的普适的规律。 这便是由术入道。 和你钱多钱少、职业等所有因素无关——自天子以至于庶人，壹是皆以修身为本。 “知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。 物有本末，事有终始。知所先后，则近道矣。” 能够在事业技艺上达到高境界的前提，便是我们今天的主题：注意力。 互联网时代，软件应用几乎全部配备有那些由聪明人设计出来的算法。这些算法用尽浑身解数吸引你的注意力，消耗你的注意力资源。 所以在这个时代，注意力更是稀缺资源。如何认识注意力便成了一个很重要的问题。 目录 前置知识：自我1和自我2 注意力 注意的方法——集中到呼吸（智慧的起点) 真正的心流——它总是在那里，而我才是那个会离开的人。 注意力的涣散——不满足眼前而逃避到过去或未来的时侯 前置知识：自我1和自我2在《The inner game of tennis》中，作者将人的内心分为自我1与自我2。 自我1：有意识的“发号施令者”，负责思考、计划、提醒，爱用经验和规则来指导动作。 关键词：判断、分析、权衡、应该、期望、计划、成功失败、焦虑或满足 自我2：无意识的“采取行动者”，也就是身体与潜意识，它直接操控肌肉、平衡、感官，拥有与生俱来的学习与适应能力。 关键词：本能、天性、自然、顺势、随心、皆可、平静、不欣喜也不焦虑 自我1往往担心动作是否完美、是否符合外部标准，于是不断下指令、批评或过度控制； 自我2则默默执行，却因被自我1唠叨而变的“笨拙”——这便出现挥拍犹豫、脚步拖沓等种种失误。 想想那些自我怀疑、犹豫、对失败的恐惧…… 所以理想状态是自我1负责思考，自我2负责执行；只有当自我1学会信任并让位，自我2的潜能才能自然释放，表现才会流畅而稳定。 就像父母与孩子：健康的关系来自信任与放手，而不是过度指导与批评。 注意力 注意力是一门生活的艺术与哲学。是人之根基，精气神之源泉。 当一个人实现了专注，内心就会安静下来。当内心保持在当下，它就会变得平静。专注意味着将内心保持在此时此地。 专注需要放松身心。一个紧绷的人难以全心投入到事情之中，因为TA有一部分注意力资源分配给了导致紧绷的“执念”之中。 所以放松之下的专注是一门至高的技艺，如果不学习它，一个人就无法在网球或任何努力方向上达到潜力的极限。 在此文里，网球可以成为一种奇妙的媒介，通过它可以发展专注内心的技能。通过学习在打网球时集中注意力，这个技能可以应用到生活的方方面面。 像我个人在运动之中就极容易分心，有以下三个方面 —— judgemental 的紧绷僵硬、用力过猛、自我抱怨； flash back 的情绪化导致的羞耻与自卑； distracted by over-sensitivity to others’feedback 自我客体化与内外批判者对专注度的破坏。 这些分心时刻可以总结如下： 最大的注意力缺失出现在过去和未来 1.当我们的注意力飘向未来时，常常有两个表现： ①我们的内心会不自觉的预测即将发生的事 还有几天才干完活？作业还剩多少页？如果我失败了会怎么样？…… ②纠缠于已经发生的事情（内心真的非常容易沉迷于各种“如果”当中）。 例如： “如果我输了这一分怎么办？”它想，“那么我将在他的发球局中以5:3落后。如果我不能打破他的发球局，那么我就会输掉第一盘，可能还会输掉比赛。 我想知道当玛莎听到我输给乔治时，她会怎么说。”到了此时，内心经常会陷入一个小小的幻想，幻想玛莎听到你输给乔治的消息后的反应。 当你打网球时，一旦分身想到这些未来可能发生，却更大概率压根不会发生的事情，对你的竞技状态会是一种灾难。等你用力回到当下，比分仍然是3:4，30:40，你差一点儿就忘了你是在球场上。 什么都没改变。唯一改变的是，你在当下发挥出巅峰状态所需的意识能量已经在想象中的未来泄漏了一部分。 2.同样地，我们的注意力常常沉湎于过去。 “如果边线裁判没有判最后一个发球出界，比分将是平分，我就不会陷入这种困境。同样的事情上周也发生在我身上，它让我输掉了比赛。这让我失去了信心，而现在同样的事情又发生了。这是为什么？” 如果我这球打进了，会不会…… 如果我没走那条路，我肯定能更。。。。。。 网球有一个好处：过不了多久，你或你的对手就会打出一个球，逼着你回到当下。 但我们的部分能量已经被留在过去或未来的思想世界中，导致了我们的注意力能量被消耗殆尽了。 最终，我们真正的目标开始变得暗淡，球似乎来得更快，显得更小，甚至球场也似乎变小了。 所以如何解决这种情况? 在正式比赛中，最好选择一个注意力聚焦点——无论什么，只要是对你最有效的——并坚持下去。 例如，如果球的接缝能让你的精力集中在当下，那么就没有必要专注于声音或感觉。通常情况下，你在打比赛这件事本身就会帮助你集中注意力。在争取得分的过程中，你经常发现自己处于一种相对深度专注的状态，你只觉察到了在那一瞬间发生了什么。关键的时间是在每一分之间！在一个回合的最后一球之后，内心会放下对球的专注，自由地游荡。正是在这个时候，关于比分、你不稳定的反手、生意、孩子、晚餐等想法往往会把你的能量从当下吸走。然后，在对下一分的争夺开始之前，就很难重新获得同样的专注度。 注意的方法——集中到呼吸（智慧的起点）如何在两分之间保持专注于当下？我自己的方法，也是对我的许多学生都很有效的方法，就是把注意力集中在呼吸上。 这里需要一些始终存于当下的对象或活动。有什么比一个人的呼吸更能扎根在当下呢？把注意力放在呼吸上，意味着观察在其自然的节奏中进、出、进、出。 这并不意味着刻意控制我的呼吸。 呼吸是一个了不起的现象。无论我们是否有意，我们都在呼吸。无论是醒着还是睡着，它总是在发生。即使我们试图停止，一些力量很快就会压倒我们的努力，我们就会吸一口气。 因此，当我们专注于呼吸时，我们是把注意力放在与身体的生命能量密切相关的东西上。另外，呼吸是一种非常基本的节奏。据说，在呼吸中，人重现了宇宙的节奏。当内心被呼吸的节奏攥住的时候，它往往会变得全神贯注和平静。 无论是在球场上还是在球场外，我不知道有什么比把心思放在呼吸过程上更好的方法来开始处理焦虑了。 载营魄抱一，能无离乎？专气致柔，能如婴儿乎？焦虑是对未来可能发生的事情的恐惧，它只发生在内心想象未来结果的时候。 当你的注意力集中在当下时，当下手里的事情会有能够完成的预期。于是，未来的预期将成为最好的当下。 因此，在对一分的争夺结束后，在你回到位置上或去捡球时，你可以把心思放在你的呼吸上。 当我的内心开始琢磨我是要赢还是要输的那一时刻，我就把它轻轻带回到我的呼吸上，在它自然和简单的活动中松弛下来。 这样一来，当对下一分的争夺准备开始时，我能够比在前一分钟更加专注。 这种技巧对我来说不仅有助于阻止内心对坏球的焦躁不安，也让我不会对超乎寻常的好球感到迷恋。 真正的心流——它总是在那里，而我才是那个会离开的人。关于“心流状态”有一点需要注意：它不能由自我1控制。 我看到很多文章声称提供了一种能让人“每次都在心流中打球”的技巧。忘了它吧！这是个陷阱。这是一个古老的陷阱。 自我1热衷于判断(judge，分别心)。所以TA喜欢在心流状态中打球，尤其喜欢心流时出现的好的结果(正反馈)。 于是，自我1会试图抓住那些保证能把你带到心流状态的任何机会。（谁不想进入专注状态呢？） 但这里有一个问题：到达那里的唯一方法是抛弃自我1,即放下你的分别心，依靠天性本能去做。 可只要你处于想让自己变好的目的，让自我1作为主导者带你到那里，那么它也会同行——于是你越渴望越用力，越无法进入心流状态。 即使你进入了，哪怕只有片刻，自我1都会说：“很好，我进入了专注状态。”然后你就会再次从该状态中脱离出来。 我曾经以为心流状态是转瞬即逝的，早晚都会离开我。 而现在我知道，它总是在那里，我才是那个会离开的人。 生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。看待心流的另一种方式是，把它当作一个被赐予的礼物。 它不是你可以强求得来的，而是一个你可以去探索的礼物。 你怎么请求？通过你的努力？什么是你的努力？你的努力取决于你的理解。 我的理解是，它总是涉及内心专注的尝试和放下自我1控制的尝试。 随着信任的增加，自我1安静下来，自我2变得更有意识、更有存在感。 于是当你享受运动的比例增加了，礼物也就随之而来了。 如果你愿意放下自己的”能力“，不认为自己“知道”如何做到，那么礼物往往会更频繁地到来并且变得更加可持续。 这听起来可能不科学，或者听起来不像你希望的那样有控制感。 *但我可以说，我刻意追求自我2已经有很长一段时间了，超过了25年，它会在自己的时机到来，*当我准备好的时候——谦逊、尊重、不去期待，以某种方式将自己置于比它更低的位置，而不是高于它。 然后当时机成熟时，它就来了，我可以享受自我1思想的缺失和身心愉悦的存在。 我非常喜欢这种状态。所以我尝试去握紧它；可我的手一用力，它就会像滑溜的肥皂块一样喷出掌心。 一旦我把它视为理所当然，我就会分心并失去它。 一旦我开始想利用这种“好状态”了，甚至为之开心、自满、鼓舞，那么此时内心的期望也就被拔高了——所谓音声相和，前后相随；后续失望的种子也同时埋下了。 企者不立，跨者不行，自见者不明，自是者不彰，自伐者无功，自矜者不长。其在道也，曰余食赘行，物或恶之。故有道者不处。 注意这个“不处”。 不处不居，天性使然。 心流的礼物随之而来。 还是那句话：我曾经以为心流状态是转瞬即逝的，早晚都会离开我。而现在我知道，它总是在那里，我才是那个会离开的人。 自我2，可能是唯一一直存在的东西，并将存在于你的整个生命中。 各种思绪和考虑来来去去，但天真无邪的自我，纯粹真诚的自我，就在那里，只要我们的呼吸还在，它就会一直在那里。 去享受它，去欣赏它，你就能体验到专注所带来的礼物。 “虚其心，实其腹，弱其志，强其骨” 注意力的涣散——不满足眼前而逃避到过去或未来的时侯我们为什么非得去离开当下？这个事琢磨起来挺令人费解。 明明当下是一个人享受生活或完成手头任务的唯一起点。 如上文提到的，我们的大部分痛苦都发生在我们允许自己的内心想象未来或沉思过去的时候。 所以思路来了——好像很少有人会对当下就在我们眼前的事物感到满意。 我们期望事情与当下不同的心态把我们的内心拉到了一个不真实的世界，因此，我们不太能欣赏当下所提供的东西。 对过去的美化，对未来的幻想…… 我们的内心，只有在我们更倾向于很不现实的过去或未来时，才会背离当下。 所以要开始理解自己注意力涣散的原因，我就必须知道我真正渴望的是什么，我为什么要迫切逃离眼下的现实。 反思之后，我意识到，在球场上，我的身体内存在着更多的欲望，而不仅仅是为了打网球。 换句话说，网球并不是我在球场上参与的唯一游戏。 当你的执念认为自己参与的是生死攸关的斗争时，你就很难获得乐趣或集中精力。 然而当一个人看清楚自我1所参与的游戏，增加自我2所占的比例时，才能获得一定的自由。 只有了解到这一点，你才能客观地进行觉察，减少”我执“，避免”着相“，被眼前的分数、成绩、KPI所影响，导致动作变形、心态扭曲。 实现专注、心流的过程，就是梳理内心状态的过程。也就是去了解和解决这些相互冲突的欲望 我的一个相关的思考 少培养吃苦的能力，多培养“转苦为乐”的思维转化能力。 这需要对事物的本质的洞察力。 看到高数线代，提到做题，你会怵头；因为脑子里想的都是: “开始做题了”、“题做出来了”、“题没做出来”、“知识点”。 这是很无聊、生硬、乏味的。 如果你转化思维，数学题是给你两三个条件，去推理出一个结果。 那你的脑子里的标签就是: “我有两条线索”、“我想得到这个谜面”、“让我来推理一番”、“创造逻辑链”…… 这就成了玩推理游戏 每天去准备着“玩”和逼着自己“做”，战斗力不在一个量级。 心态和效率都是差异极大的。 我在经历一次“恶性循环”之后觉察到了这个认知。 原文： 失态表现—— 开始关注时间的时候； 开始提前看终点的时候； 开始做题往后翻页的时候；开始心手不一，做一想二的时候(未来？过去？空想。云烟。)； 开始庆祝犒劳自己沮丧否定自己的时候(即使是负面行为！)； 开始身体僵硬，不松软的时候； 开始幻想寄托，幻想救世主人物的时候（性娱乐新闻游戏）； —————— 此时，我首先应该做的是抚摸我的心。 —————— 性和游戏，都只是镇定剂。根本药方在心。是心在燥动。 这些逃避的方式本质都是鸦片，都是找“救命稻草”。而不是靠自己。 —————— inner peace. 内心的宁静千金不换。 要有nonjudgmental 和 resilience。（jenson huang Timothy Gallwey) 具备忘记上一刻的能力和拒绝完美的能力。（Forget the last time.let the past be past.）+（very low expectations） 忘记并非回避，并非无视。而是直面，接受，不评价，无差别，做事在我不在外。 —————— 课题终点是知行合一。 我想最大的幸福便是知行合一。最好的境界便是忘记时间、过去和未来。最酷的状态:平静而有价值感。","tags":["成长","认知"],"categories":["读书"]},{"title":"《掌控习惯》读书笔记","path":"/2026/01/28/掌控习惯/","content":"只是重复频率，就这么简单 我们一门心思地要找到做事的最佳方式，却从来也不付诸行动对此伏尔泰这样写道:”因追求最佳而丢掉了足够好。” 我称之为酝酿与行动的区别。两者听上去差别不大，但它真的不一样。酝酿意味着在计划、策划和学习。这些都是好东西，但是它们不会产生结果。 酝酿让你感觉自己正在做事。但实际上，你只是在准备做事。当准备工作变成某种形式的拖延时，你需要有所改变。 习惯的形成是一种行为通过重复变得越来越自动化的过程。你重复活动得越多，你的大脑结构变化得也就越多，从而能更高效地进行那项活动。神经学家称之为“长时程增强”139现象，这是指基于最近的活动模式大脑中神经元之间的联系得以加强。随着每一次重复，细胞间的信号传递得到改善，神经连接变得更加紧密。神经心理学家唐纳德·赫布(Donald Hebb)于1949年率先描述了这种现象，这种现象通常被称为赫布定律:“一起激发的神经元连在一起。” 就像身体肌肉对常规举重训练的反应一样，大脑的特完区域会国投入使用而发生变化，并会在荒废后萎缩。 人们在学习一门外语、演奏一种乐器或演练尚不熟悉的动作时，会感到难度极大，因为每种感党必经的通道尚未建立起来:但是，连续不断地重复打通了沟通途径之后，这种困难顿时烟消云散:这些动作变得如此连贯自如， 即便不在焉也能一气呵成。与厌倦结缘 在某个时刻，每个人在自我提升的旅程中都面临着同样的挑战: 你必须与厌倦结缘。 我们都有人生目标并心怀梦想，但是，假如你只在心血来潮或一时兴起时才做出一些努力，那么无论你的目标或梦想是什么， 你都不可能取得显著的成果。 我敢说，假如你下决心培养一种习惯并且坚持了一段时间之后，你总有一天会想要放弃。在你创业期间，有时你真的不想去上班。在你健身时，有时就想偷懒，少做几组动作。当该写作的时候，你会有几天不想打字。但是，当你感到心烦意乱、苦不堪言或精疲力竭时，是鼓足干劲还是萌生退意，这是专业人士和业余人土的分水岭。 专业人员依照既定计划行事，毫不动摇；业余爱好者则随波逐流，任性而为。专业人士知道对他们来说什么最重要，并有目的地去做；业余爱好者则随生活中的突发情况而变。 作家兼冥想老师戴维·凯恩(David Cain)鼓励他的学生别当”好天气的冥想者”。同样，你也不想成为一名努力与否全凭心情好坏的运动员、作家等等。当一个习惯对你真正重要时，你必须愿意在任何心情下坚持下去。专业人士不会因自己心情不好而改变行动的时间表。他们可能享受不到乐趣，但是他们仍能做到坚持不懈。 **避免33%的损失和获得50% 的收益具有同等的价值。**错过的日子对你的打击大于成功的日子对你的帮助。 我认为这个原则实在太重要了，因此即便我不能像我想的现样做得很完美，我也会坚持不懈。很多时候，**我们在培养习惯时会陷人全有全无的怪圈中。问题不在于出差错，而是如果不能做完美，就干脆不做的错误想法。**你是真的没有意识到在你情绪低落(或汇碌)的日子继续做有多么可贵。**错过的日子对你的打击大于成功的日子对你的帮助。**如果你从100美元起步，那么50% 的收益率会让你达到150美元。但是接下来只需亏损33%就能把你打回100美元的起点，换句话说，**避免33%的损失和获得50% 的收益具有同等的价值。**查理·芒格(Charlie Munger)就曾说过: “复利的首要规则:除非万不得已，否则永远不要打断它。” 不要让亏损蚕食你的复利。 **这就是为什么“糟糕”的健身做法往往是最重要的。**懒散的日子和糟糕的健身保持了你从以前的好日子中积累的复合收益。简单地做一些事，如十次下蹲，五次冲刺，一次俯卧撑，真的是任何事，都不容小觑。千万不要无所事事。**不要让亏损蚕食你的复利。**此外，健身时做什么并非头等重要的事，关键是你想成为严格遵循健身计划的那种人。当你感觉好的时候，锻炼很容易， 但是当你情绪低落时仍然坚持锻炼，哪怕做得比平常少，重要的是你坚持不懈的表现。去健身房练五分钟不太可能提高你的表现， 但它会重申你的身份。 **行为转变的全有或全无怪圈只是会让你的习惯脱轨的陷阱之一。 **另一个潜在的危险，尤其是当你同时在应用习惯追踪法的时候，是观测的标的有误。 当我们选择错误的测量标的时，我们的做法就会走偏，这有时被称为古德哈特定律，它是以经济学家查尔斯:古德哈特(Charles Coodhart)的名字命名的。它指出:“当一项措施成为目标时，它就不再是一项好措施。”200度量只有在引导你并辅助大局时才有积极作用，它不应成为主角并让你疲于奔命。每个数字只不过是整个系统中的一条反馈罢了。 强者思维和弱者思维区分：原因论和目的论。 ・强者思维：我从这段经历中获得了什么 强者的价值判断是，我在此经历中得到了什么。这种思维让你在不断的获得稻草时，燃烧它。 强者在燃烧稻草的过程中，已经学了避免烧到自己的能力。火源在强者思维中，又将使他们获得驱赶野兽蚊虫，带来美食甚至光明的能力。 他们在不断的挫折磨难中持续获得稻草并燃烧它并获得灵魂的力量。 类似心态，比如知足常乐，知道并满足，故能常乐。能够看到自己收获了什么，而不是自己要求低。 比如失败是成功之母。 ・弱者思维：我从这段经历中失去了什么 弱者的价值判断是，我在此经历中失去了什么，这种思维让你在不断的获得稻草时，告诉你 你失去了便捷的行动能力，稻草越多你的负担越重。你失去了奔跑的能力，你失去了张开双手拥抱世界，拥抱自己的能力。因为手捧住稻草了。那为什么不扔掉稻草呢？ 因为你的价值判断就是：我在这段经历中失去了稻草。 守恒和发现守恒 这个世界是守恒的：得到的越多，失去的越多 —— 失去的越多，得到的也就越多。 如果你没有发现你得到事物的能力，也就是强者思维和发现你所得到的人事物的认知，就算守恒定律使你得到，你也发现不了。 **所以会害怕失去，会害怕付出过后没有收获回报，最后陷入不想付出又想拥有的自我內耗、抱怨他人和缺少执行力中。 ** 这就是为什么这个世界是公平的，而弱者却发现不了的原因。 这就价值观的重要性，他是帮助我们判断我们该获得什么和该失去什么的判断。 **健全价值观中的健全，指的就是拥有客观判断所有人事物中得失的能力。 ______** 价值观和pua的区别：主观臆想还是客观获得（可经验证的） ———— 其他部分的总结: 0.习惯就是复利 习惯就像高速公路的入口匝道。它们引导你走上一条路，使你在不知不觉中加速前进，直到走上正路。 （所以玩手机，刷短视频会加速时间～小心！） 1.目标不能筛选人，实现目标的过程体系才能把人区分开。如果你想要更好的结果，那就别再紧盯着目标不放，要把精力集中到你的体系建设 任何一项运动的终极目标都是争取获得最好的成绩，但是在整场比赛中都死盯着记分牌则荒唐无比。争取每天都有进步是你走向成功的唯一方法。用三届超级碗冠军选手比尔·沃尔什(BI Walsh)的话来说就是:比分是会自理的” 生活的其他领域也是如此。如果你想要更好的结果，那就别再紧盯着目标不放，而e要把精力集中到你的体系建设上。 实现一个目标只会暂时改变你的生活。这正是改进这个概念违反直觉之处。我们本以为需要改变我们的结果，其实结果并不是导致问题产生的根源。真正需要改变的是导致这些结果的体系。 假如你只是围绕着结果动脑筋想办法，你只能取得一时的改进。 为了取得一劳永逸的成效，你需要解决体系层面上的问题。修正输入端，输出端就会自行修正。 2.警惕目标造成的非此即彼和幸福感缺失 目标会导致“非此即彼”的冲突:你要么实现了预定目标，最终取得了成功，要么你失败了并令人大失所望。你在精神上把自己禁锢在一种狭隘的幸福观之中，这属于自我误导实际走出的人生道路，不太可能与你出发时心目中的旅程完全匹配。成功之路不止一条，你毫无必要认定只有某个特定场景的出现，才能让你对自己的人生感到满意。 别因为完美主义和死板，让目标束博了你的幸福感。 设定目标的目的是驘得比赛。构建体系的目的是持续参与这项赛事。意在长远的思维方式不会拘泥于具体的目标。这不是为了取得任何单一的成就，而是一个精益求精、日趋进步的循环过程。 3.人的行为机制：提示、渴求、反应、奖励 强化正向习惯：让它显而易见、让它有吸引力、让它简便易行、让它令人愉悦 削弱负向习惯：让它脱离视线、让它缺乏吸引力、让它难以施行、让它令人厌恶 4.身份和自我暗示为出发点，然后用小赢证明自己，强化身份。 任何人都可以说服自己去一两次健身房，或者吃一两次健康食品，但是如果你不改变行为背后的信念，那就很难长期坚持下去。改善只是暂时的，除非它们成为你的一部分。 目标不是阅读一本书，而是成为读者。 目标不是跑马拉松，而是成为跑步者。目标不是学习一种乐器，而是成为音乐家。 你的行为通常反映了你的身份。你的所作所为表明你相信-无论是有意识地还是下意识1地–自己是哪种类型的人。研究表明，一旦一个人完全认同自己身份的某个特定方面，他们就更有可能如此这般地行事。 5.慢步前行，但永不后退 不要让亏损蚕食的你的复利，错过的日子对你的打击，大于成功的日子对你的帮助。 6.培养习惯如练肌肉，需要与倦怠结缘 7.反思过度易短视，反思缺少易出错。 过程整体和局部平衡好。 反思也能拓展视野。日常习惯之所以强大，是因为它们具有复利特性，但天天为自己的每个选择忧心忡忡就像用放大镜看自己，过于短视了。你专注于局部的瑕疵，忽略了更大的画面。这属于反馈过多。相反，从不回顾你的习惯就像从来不照镜子一样。你看不到能轻易纠正的瑕疵，比如衬衫上的一块污渍，牙齿上的食物残渣，这属于反馈过少。定期的反思和回顾就像是从正常距离照镜子，你既不失整体画面，也能看到应该做出的重大改变。你想观赏整个山脉，而不是局限于山峰和山谷。 8.目标、指标有局限性 当我们选择错误的测量标的时，我们的做法就会走偏，这有时被称为古德哈特定律，它是以经济学家查尔斯:古德哈特(Charles Coodhart)的名字命名的。它指出:“当一项措施成为目标时，它就不再是一项好措施。”200度量只有在引导你并辅助大局时才有积极作用，它不应成为主角并让你疲于奔命。每个数字只不过是整个系统中的一条反馈罢了。 9.人们常常过于纠结自己能力的极限，以至于放弃了充分调动自己潜能的努力。 10.两分钟准则 两分钟规则： 即使你知道应该从小处着眼，第一步也很容易迈得太大。当梦想做出改变时，你会抑制不住地异常兴奋，一旦头脑发热就容易贪多嚼不烂。我所知道对抗这种趋势的最有效的方法是使用两分钟规则，也就是:“当你开始培养一种新习惯时，它所用时间不应超过两分钟。” 你会发现几乎任何习惯都可以缩减为两分钟的版本: “每晚睡前阅读”变成“读一页”。 “做30分钟瑜伽”变成“拿出我的瑜伽垫”。 “复习功课”变成“打开我的笔记”。 “整理衣物”变成“折叠一双袜子”。 “跑3英里”变成”穿好跑步衣服”。 我们经常认为，读一冥想一分钟或打个销售电话都居小事一桩，没什么可大惊小怪的。但此处的重点不是做一件事， 而是把握住萌芽的习惯。事实是，你首先要确立一种习惯，然后才能不断改进它。如果你掌控不好养护习惯幼苗的基本技能，那么你就不大可能把握好与之相关的细节。不要指望从一开始就培养一种完美的习惯，要脚踏实地，连续不断地做些简单的事。你必须先标准化，然后才能优化 一旦你学会了呵护习惯的幼苗，前两分钟只是启动正式程序的仪式而已。这并非是为了更容易培养习惯而删繁就简的举动， 而是掌握一项困难技能的理想方式。一种程序的开始阶段越是仪式化，你就越有可能实现注意力高度集中，即做大事必需的状态。通过在每次锻炼前做同样的热身，你会更容易进入最佳状态。通过遵循同样的创造性仪式，你可以更容易地投入到艰难的创造性工作中。 万事开头难，但要是把开始变得简便下来的事也就水到渠成了。 11.憧憬即将到来的假期或许比度假本身更令人激动 有趣的是，当你获得奖励时，大脑电激活的奖励系统，与你期待奖励时激活的系统是同一个。这就是对一种体验的期待往往比体验本身，更令人感到愉悦的原因之一。 作为一个孩子，期待圣诞节马上来临的感觉可能好过真正打开礼物的那一刻。作为一个成年人，憧憬即将到来的假期或许比度假本身更令人激动。科学家称之为“渴求”和“喜欢”之间的区别。 下面是习惯模型","tags":["成长"],"categories":["读书"]},{"title":"我的奶奶","path":"/2026/01/28/我的奶奶/","content":"我的奶奶在上个星期日，也就是二零二三年四月二十二日这一天，在喝了最后一顿晚饭 —— 一碗小米粥之后去世了。 我是在周一早晨得到了这个消息。看到了哥哥和妈妈的几个电话。我的身体倒是流利的很 : 请假、洗漱、吃饭、打车，还没完全睁开眼吧，就赶到了回家的第一辆车上。 昨天晚上喝了点酒，醒来还算舒适。我的意识始终是麻木的:我想了想这种麻木和睡眠质量没什么关系。听到奶奶的离世我没有感到悲伤和难过，和现在我敲下这一段字一样。 或许我的奶奶岁数真的很大了吧。今天看到她的身份证，出生日期是1937年，已经八十七岁了。家人们第一时间布置好了灵位，我在下午赶回来磕了四个响头，跟我哥说的回家第一句话“我可以不哭嘛”。于是大家熬夜，行礼，吃大锅菜。 大家聚在一起，有欢声笑语，也有不经意的抽泣 —— 这种情绪要偷偷听到。 奶奶的年纪真的那么大了吗?我从初中开始在外面上学，每次放假回家，先和奶奶还有爷爷嘘个寒问个暖，当时会感觉任务终于完成了。现在想想，我的情商至今远远不够，既不懂世故，更不懂人情。今年我已经上大二了，马上就到暑假回家了，只是没想到这次回来的这么早。 睡了一个小觉，看一眼我奶奶的照片。我只能勉强想到奶奶当小朋友面拿笤帚疙瘩追着打过我一屁股。还有好像下午的时候我一喊饿，奶奶就给我在小小炉子上塞点蜂窝煤，那是要熬红豆沙了。奥，小时候天一黑，妈妈稍微不在家，我就会害怕的睡不着觉，让奶奶先跟我睡一个屋子，直到妈妈回来。记忆里这件事上奶奶从来没拒绝过我，所以她是很有安全感的，在我心里。 和爷爷没事拿本新华字典比划字画不一样，奶奶什么字都不懂，是个大文盲。但她舌吐莲花:按晚辈的话讲，我爷爷的嘴有多刻薄，我奶奶就有多随和 —— 这种随和真的不是通透或者什么大智慧，而是她天生始终的顺着人心里说，本能的“高情商”。所以我任性买把大枪却退不了钱，上学迟到学校大门不给开，甚至公媳矛盾妈妈有点委屈无处倾诉的问题，都是我奶奶出面调和。那时候她还没有眼盲，仍然作为活跃分子和老人们坐在门口唠闲嗑。她出马的事，即使到不了水到渠成的程度，也能让双方落个各退一步。奥，她还能说媒，而且有什么远村亲戚爸妈叔婶叫不上号了，就会问奶奶，她总能捋的清清楚楚明明白白。这些是我为数不多的记忆。 奥，奶奶的精神气是很足的。直到现在家里还有把带鞘铁剑，那是奶奶晨练舞剑用的。至于奶奶原来踩高跷、跳秧歌之类的事情，我的记忆太过模糊，已经没有什么印象了。 回来的时候奶奶已经入了冷箱，没有见到奶奶的最后一面。 明天就要火化了，不对，是今天早晨八点。 我记得我记录了最后一次和奶奶深度交流的内容。这一点我觉得非常幸运。感恩。 在奶奶陪在身边的最后一个夜晚里，在为数不多的回忆里，我翻开了那篇日志: 历史的厚重感与共情能力 留白 4月30日 21:05 高中最后一次放假回家。 到了我老爷家里，本来应该按我妈说的和我奶奶寒暄几句，然后吃饭。可当我坐在这位耄耋之年的，陪我长大的老人，我心里像被什么吸住似的，开始以不同以往的角度和我奶奶攀谈。奶奶双手紧紧握着我，用她的温度轻轻拭去了我匆匆回家时的冷气。只是我喊的声音非常大，话题却没能延展多少便到了饭点。 四月末五月初的时节。 “天气暖活儿了，入春啦。”立春了啊吗？立春惊蛰谷雨，芒种…” 我只是随便套了一句话，没想到奶奶顺口的说了一连串节气，如数家珍一般，字字准确，声声清楚，和她纯朴的方言毫无违和之感，甚至有种浑然天成，真诚调和的感觉。 我从来没听到过奶奶类似的话语，至少在我过去的印象里，在我“长大”以后，面对这样一位差了六七十岁的至亲。 我沉默了。一种亲切，温和的感觉涌入了身体。猝不及防中，我沉浸在这里面，品味一遍，又品味一遍。 “惊蛰要开始种蒜啦。种了就有好收成，之后要种小麦……”奶奶还在描述着，就像她此时正站在地里一锄头一锄头的铲着地，在春风中，在烈日下。 我就站在远处，仔细的观望着着这位老人，养活了我们一家的老人。 听母亲说，爷爷年轻时是一享乐闲适的主儿，天天把玩个口琴，喂养几只花鸟，抽口卷烟，拉拉二胡，没出过什么力气。把家里近十口嘴塞满的是我奶奶，不知道当时受了多大累多大苦。在太阳和月亮的闪烁中，许多年过去了，村子还是那个村子，爷爷和奶奶也还是老样子，只是家里的孩子们都渐渐长大了，硬朗了，能够一个个离开家门口，给家里寄钱了。后来奶奶的眼不知道什么原因，得了一种叫“百日青光眼”的病，在东奔西跑的治疗中，渐渐失明了。这样一来，照顾奶奶的担子就落到了爷爷身上。爷爷仍然在我母亲做饭时敲敲电子琴，正坐在沙发上，静望着电视机的画面，黄土色的身子一动不动，像座山丘。只是这位天生“享福的命”的老爷子，在慵闲的生活里，多了几个业余兴趣：扶我奶奶起床，扶我奶奶穿衣，扶我奶奶上厕所，扶我奶奶吃饭……等等等等。儿子和女儿们也都有一颗孝心，只是在家里伺候久了，身子骨容易软下来，精神上也容易受限。可每次我去爷爷家里吃饭，爷爷都再重复着日常的“差事”，一遍一遍又一遍。忙活的中间卷的烟草多了一些，而平时不太协调的琴声却几乎消失了。有一段时间我热衷于传统乐器，问爷爷怎么最近不拉胡胡了啊，最近怎么不弹琴啦，爷爷只是笑咪咪的，一口口嘬着烟，又让屋子里充满了雾气和一种清香的气味。于是两位老人又安安稳稳的过着每一年，每一日，任时间春去秋来，任岁月蹉跎流转。 回到现实。 “芒种有个种字，那芒种到底要种什么呀？”“芒种要种小麦，咱们家当时种了好多亩小麦…..”想起来我奶奶竟然准确说出“惊蛰”两个字，我就问她一些节气的事，包括以前种蒜苗啊，收好多亩田地的小麦做大米饭啊。心头的暖流逐渐涌动，我紧握着奶奶的双手，胸头的凝重冲上了双眼。我开始流泪。 难得的感动在寥寥数语中便降临在我身上了。这是一位至亲，一位经历的八十余载光阴的乡村老人赠与我的。在她的身上有一种历史的厚重感，让我敬仰，让我沉思。之后母亲叫我快点把奶奶扶起来吃饭，我还没抬手，爷爷已经到了床边，示意我回客厅吃饭了。 匆匆岁月的一天。 家人们都睡着了。哥哥说明天要忙一天了，得睡睡觉休息休息了。 被疼了无数次的孙子给奶奶烧烧纸吧。","tags":["生活"],"categories":["家族"]},{"title":"一碗热面条的故事","path":"/2026/01/28/一碗热面条的故事/","content":"在外上学，四月未归。大前天晚上匆匆到家。今晨返校，妈妈煮的面条刚刚揭锅，司机师傅到家门口了。忽然端来一大瓷碗，里面几缕面条，一层薄汤，一个白胖鸡蛋，腾腾的热气直往上冒头。哥哥、姐姐，招呼着让我赶紧吃。我推辞怕误了司机师傅事——“端外面就凉的快了”，我妈说。于是我背着包，拎着奶，另一支手在院子窗台上呼噜呼噜吞了两口面条，嘬了一嘴热汤。哥姐妈就这么盯着我。秃噜两口后，赶忙扭头走向大门。后面紧跟着几句“充电线拿了吗”“火龙果拿了吗”“衣服冷不冷”……. 上车前，我朝他们嘟嘴以表亲亲之意，这是我家自我小时传承至今的仪式。上车后，肚子里热融融的，这才发觉冬天的冷，汤汁的暖，面条的香。 想起自己老笑话妈妈，会用微信电话却不会用快手电话；刺啦我之前，自己先把油点子甩衣领上了…… 只是快到学校才想起来，她也开过一个小服装店，凌晨起来到北京进货；她也能在一瞬间反应怎么让热面条凉的快些: 反常的大瓷碗，克制着少盛些面条，在院子里吃……那些有趣的故事，我怎么没想起问？我好像只是在家胡乱打了两天游戏—— 下次吃这碗面条是什么时候呢？","tags":["生活"],"categories":["家族"]},{"title":"士兵突击——高城","path":"/2026/01/28/士兵突击——高城/","content":"人在追寻到内心的锚点，如理想信念、热爱的事业时，内心很难静下来，容易被标签裹挟。 高城身上背着的，是军长父亲的光芒，是钢七连的荣誉。一个是他想极力挣脱的标签，一个是他想全力捍卫的标签。我想我们都会拥有这样的标签。被误解，被轻视；怕失去，怕得不到。因为在自我觉醒前，需要标签带来的价值感，来安顿年少时那颗骄傲急切的心。 如果说阅历能让人在经历中找到自我，离开他人；那么年轻的局限，或许就是容易迷失自我，依赖外在；亦或是依赖自我，以己度人。 将门虎子，少年老成的背后，是对证明自我的执念，是以己度人的局限，是因年轻二字不得不经历的果。 于是看到了许三多的笨拙以后，高城用这把“名为自我的尺子”，给许三多贴上了一个可能一辈子撕不下去的标签。 于是钢七连解散。如doria所说，“命运对骄傲者的教诲，往往是与失去。” 我会想，如果不失去“钢七连”，高城评判他人的精英叙事泡沫何时才能破灭？如果没有史今母亲般的庇护，许三多的自我主体性何时才能觉醒？可见阅历难得。痛苦的背后是坚守，是重生。 终于在解散后的相处里，高城看到了光芒里的微尘，看到了尖子里还有许三多这样的“孬兵”。 可想，如果没有这次“有容乃大、无欲则刚，容是他人，欲是自己”的顿悟，再看到从老A“落败”且背叛自己的成才，“逃”出来的许三多，高城不会把两个人的心结解决的这么好。 人对掌控的执念，往往握得越紧，手心的空间越少，肌肉也越紧绷。直到手里的东西碎了，消失于无形，才把手张开，用掌心感受整个世界和微风拂过指尖的自然与放松。感叹“这样的天地才跑的欢畅” 我远比不上高城，却曾遇到过很多像许三多这样的朋友。我常常用自己的价值体系和认知去打量他们，通过贬低他们来巩固自我价值。直到我经历失败，真的收心做好一件小事时，才看到他们的闪光点，看到自我的局限。想起以前以己度人的局限，干涉他人课题的自我，真是哭笑不得😂 ps:doria视频里说高城是亲手挑选的“天马”成才，我印象里只有会餐时成才和他喝告别酒的片段。翻了翻，发现有一集伍六一指着成才的简历说这人假，事实像做给人看的。高城的回答是七连最怕人不争。伏笔啊。七连氛围确实是高城年少得志后的强者叙事（优绩主义）。对手下的兵只看结果，不看过程，作为上级还不能像袁朗一样抛开标签因材施教，挖掘出不同个性的兵的潜能。从这点看来，上级培养下级时，不同性格的见识、包容和理解还是很重要的。 关于不同立场、价值观下对“有用”“无用”的定义： 个人拙见，判断一个东西“有用”，涉及到价值观。每个人的价值观都是不同的，所以同一件事情，不同人的感受会大相径庭。于我而言，价值观是帮助我们判断该获得什么和该失去什么的判断。换言之，价值观成熟（健壮）的人是不大容易后悔的。不易后悔的底气，就是能够看到多元的价值。和识人一样，看到不同人的不同价值。 对七连解散前的高城来说，许三多是“没用”的吊车尾；成才是最符合钢七连“争”的精神的。可高城没料想到，最没用的兵却有着最坚定的信念；最有竞争力的兵却为了前途背叛了连队。（doria已聊过） 所以回过头看，那些从世俗角度看没有意义却被人类发展千年的事情，如文学、艺术等感性体验时，“没用”这个价值判断是否会被观念局限？对我来说，我在看士兵突击电视剧时只是想圆个军旅梦，结果里面的每个人物都给了我极大的启发，提高了对人对事对自己的认知。（当然也因此看到了doria和各位hh）我初看史铁生«好运设计»时纯粹当个作家的白日梦，其内容却引发了我对优绩主义、应试教育及何为幸福的思考。 所以我的拙见是，可能短期来看没用的东西，反而对长期有用（贪心算法：局部最优不意味着全局最优）；可能在具体局限的场景执行中没用的，反而对整体系统推进有用；读李娟、史铁生、汪曾祺等经典作品时，是否对我们的人生也有意想不到的用处呢？这一点我不下定论，仅同诸位分享(╹ω╹)✋","tags":["随笔"],"categories":["认知"]},{"title":"几个真心的方法论","path":"/2026/01/28/见路不走，推陈出新。丢掉幻想，积极行动。/","content":"见路不走，推陈出新。丢掉幻想，积极行动。1.警惕经验和既有路径一味依赖方法的结果就是落入经验的陷阱。一旦当前的实际和环境不适用，方法和经验就会立即失效，甚至产生无所适从的焦虑。结果是思维固步自封，无法找到新的解决方案。见路不走，避免经验主义，根据极局限的经验去得出相同的结论。遵循底层的因果关系，去增加概率。而不是做题一样，用相同的路去框定自己，用相同的结论去定义自己。 实际在这个非线性的世界里，通向成功的路径就没有固定的。除非这个成功很渺小。你让成功的人自己复现一遍，都未必能再次实现。何必用既定路径去拘束自己？ 2.不给潜意识制造焦虑的机会。停止捏造不存在的问题：预设困难、想象中推演过程、幻想完美主义的结果。请不思考，直接去行动。迅速行动得到正反馈，比拖延五分钟的内耗要舒服的多。当机立断，不要再自己吓自己了。踩着刹车，又想加油前进，轮胎在原地疯狂空转，车没往前一毫米，油却耗尽了。 3.善于编造借口这些恐惧长期存在于我们的潜意识，形成一种惯性思维。我们甚至都很难察觉到这些恐惧本身，一旦理性想要开启对于一件事的行动，那些存储在潜意识当中的恐惧立刻扑面而来。然后为了缓解理性上的矛盾和焦虑，就给自己编出一大堆合理化借口：就还剩半小时，学不了啥了，吃完饭再做吧。 另外： 1.横看成岭侧成峰，远近高低各不同。 局部高低不影响全局最优。山远看高低分明，细看都是起伏沟壑。 该休息休息，失误以后向前看。忘掉所有无意义情绪，忘记内耗。 生活中大多数事情还是非线性的。看到这种非线性也是一种系统化思维。 （做题家和完美主义者最容易在这点栽坑，俗称“看不开”） 2.少想少拟合多做多训练。 多余的概念会蒙蔽自己。警惕过拟合，多相信直觉和本能一点。 天天把事业说给别人听也是手动给自己设障碍。做代替说。 3.避免干涉他人课题，更不要介入他人因果。 以前我总是妄自干涉他人课题，又总是让他人肆意干涉我的课题。 这是不懂边界感和自我意识过剩的表现。 4.少进行意识层面无中生有的比较。 在精力体力心力盈余，且手头事业未竟时，少沉浸过去，少幻想未来，少看他人的“进度”，少了解“标准”的指标。 本质都是意识层面的比较。自己和自己比，自己和同行比。 无中生有的比较只会给判断和实践增加障碍，属于臆想的一部分。真正有益于实践的理论是还是靠亲自与人交流互动，亲自调查收集而来。 摆脱标签，实事求是，坚定信念，张弛有度。一切回归到本我和当下，正视事业的曲折。 5.“全面”并不全面。 抓大放小，解决主要矛盾再解决次要矛盾。所谓的全面很有可能是包着糖衣的完美主义。 反而是放弃一些枝干末节以后能得到更多东西。这也是所谓的全局思维而非全面思维。 6.迷信自己一定能成功，随时push可持续的好习惯（无论是事业还是生活）。 相信还不够，至少得到“虔诚”的层面。 7.累了就多睡觉。 早睡晚起、运动、吸收阳光、接触自然、培养爱好，少接触碎片信息和社交，多看能让你专注的文章，能让你专注的事（那些好习惯）。","tags":["随笔"],"categories":["认知"]},{"title":"社交算法重构——弱关系与沟通目的","path":"/2026/01/28/社交算法重构——弱关系与沟通目的/","content":"最近对社交有了一些想法，分享给大家。 先说结论 这个时代不是遇到事情处处找搞发小、熟人、盟兄弟的时代。“附近”的概念已经渐渐淡化；想搞搞个人爱好、做成点什么事情乃至聊个精细点的话题，只靠找熟人好朋友是很匮乏的。无论是兴趣爱好还是事业理想，到了一定进度，占比最大的都是弱关系了。 这里的强关系包括熟悉的亲人、朋友。 强关系的局限性：情绪、实用大于深度。 身边熟透了的好朋友，主要作用只有陪伴，即“一路上有你”；没必要对好朋友强求太多，让朋友承担过多的寄托。经常来往的熟人能够做到彼此不吸血、有底线、讲三两人情就不错了。 从我自己的经历看，当年我先是意识到了“身边朋友”对自己的意义，即彼此照应、互帮互助、合作共赢，才开始尝试打开自己心房。但当时打开的方式相当单纯而生硬——把压抑已久的孤独和表达欲都倾泄在身边几个朋友上(甚至无论生和熟)。与此同时，我还会把自己喜欢的各种领域的话题，都用很自我的语言一股脑发出来。几年以后再看，发现当时的语言表达抽象、用词晦涩，完全牺牲了通俗性，没有考虑听者的阅读体验。而当时的我甚至以此为傲，殊不知沟通的双方，倾听者的地位并不比表达者低。 于是运气好点人家吱唔你两句，运气不好人家回都懒得回。。。实际上这才是人之常情。 如果你很自恋，有大量自我为中心的表达，不考虑双方的目的，那么你的沟通只是一种自恋，这场沟通效率大概率极低。 并且出现这种情况时，你真的需要好好观察一下自己的孤独感。 像岁数大了老人容易话多，逮住一个路过的年轻人念叨自己的经验、过往，都是孤独感溢出的表现。 与之相对的，还有很多对熟人乱七八糟的情感投射和不切实际的期望。这都是把心理精神上的溢出的自我，投放到其他人身上了。 这么做可以理解，毕竟人需要发泄和认同；但彼此之间自然刻意的距离，反而更能激发友情美好的一面。 潜意识里的投射和期望，会让两个人的良性互动变成单方面的发泄，表达者得不到预期反馈，倾听者如坐针毡，不明所以，甚至会背负上表达者暗地施予的债务——我都说这么用心了，你还不认真听；是不是敷衍不在乎我。 我想这也是沟通能力不足的人容易吵架上头的原因——投射和期望本质上还是情绪。同理它会让强调互动的沟通变成单方面发泄负面情绪的垃圾桶。 这就是一方的自我带来的双输局面。 想到了朱光潜《谈美》，里面提到欣赏一样东西必须有距离感，大智慧啊~ 所以结论来了：你并不能把你有一定深度的想法和爱好全部交给一类人去解决。 弱关系的优势 所以可见，长篇大论那是给同一爱好项目场地的人说的——高山流水，曲终人散；不用知道彼此的名字，背景，立场。只需要通过一个想法、一个爱好相互连接，自有其价值和意趣。 这是从一个点链接彼此的弱关系——不需要沉重，不需要交心。在这片场地上松弛的开心就好了！痴痴傻傻！{痴人找痴人} 莫说相公痴，更有痴似相公者。 无论多么小众的喜好和想法，都会有相当一部分人和你是同类。接下来的任务只是如何找到这群人，并团结起来共同深入挖掘，形成合力。 现实朋友只是恰好在身边而已。能互相扶一把，平常一块搞点情绪价值，吹吹牛逼，不错啦。专业的话还是要交给专业的人。 这也叫“闻道有先后，术业有专攻”。哈哈。 对我这种兴趣较广人来说，弱关系诉求更是高于平均线。 以前总想到自己能找一个对象，机械降神一般，四书六艺，人情世故，爱好事业，无所不聊无所不包。实际上这有点刻意，本质仍然是孤独感受下，对表达的渴望。而这不还是强关系的职责——全部加一起还是有点超载了。他应该是无数个弱关系汇聚而成的泉水，奔涌不息。召之即来、挥之即去，无所挂碍。 对强关系的期望也过高，不松弛，存在控制欲。于我而言，这都是看不到弱关系价值导致的偏颇。 像我之前对自己以前的朋友有意无意的怨气，觉得为什么彼此关系这么好，却不能深入广泛的分享自己的全部，以换取理解和共鸣。甚至带着这种不解去找自己和对方身上的缺点不足，分起锅来了。现在想想，还是这句话——发小、熟人、盟兄弟的责任天然是严丝合缝型，而不是琴瑟知音。熟人之间如榫头和卯眼完全密合，没有缝隙，自然也没有灵活的空间。 至少相当一段时间内，你们彼此知根知底，思想也相近。彼此碰撞产生的上限是望到头的。所以你们是知根知底，不是处处情合，不能要求太多。 总之，弱关系绝对是很重要的一环，它没那么多人情因素，没有那么多期待，只有最纯粹的认可和否定。而弱关系的寻找，则是关于你对社交平台的利用，在互联网搭建起你的社交名片，个人品牌。从而在四面八方各种维度不同侧面吸引志同道合者，这是效率最高的方式。 20-25这几年，无数的社交经验，无数的否定之否定，螺旋曲折，今天才慢慢总结出一点。算是社交上的资源配置吧。有意思。这是我最近意识到的弱关系的重要性，也是强弱关系的一种平衡和功能分配。 所以现在我的思路是:让强关系成为情感根据地，让弱关系成为精神扩展盘。人生知己不必尽在一壶酒里，也可散作满天星。 就这样。 参考感谢:何加盐《人生最好的机会，往往来自弱关系》《情商高不是让人舒服，而是达到目的》 大冰切片（交友，对友情的理解——陪伴，老年人孤独的表现——话多） fancy《一句话的艺术:情和理，劝解与附和，斗争和妥协》 关于沟通： 把“排除孤独”这一本能反应克制以后，就能涉及到聊天的目的了。明确好目的，才能对说话的方式有所选择。 我观察影响沟通效率的情况多数是聊天目的不明和聊天方式不恰当—— 方式上要考虑到沟通者的逻辑水平、情绪理性占比、协商中有利的思维习惯和不利的思维习惯（性格），扬长避短，最小成本达成共识。 记得有一次一哥们的女朋友让我看看她花80块钱做的大头照，我认真负责的按自我审美说，不如现实本人好看，人家小女生脸当时就呱唧拉下来了，我还不自知，只觉得自己老实公正hhhhh 目的上像原本双方轻松愉快的聊天被自己无意识的爹味说教自我表达给覆盖掉。 当然了，这是往理论和细致里说。如果你不在乎这些东西，对你的生活也没啥影响。无非就是让几次无关痛痒的交流以尴尬结尾，不会波及大方向。 引用书：《深度关系:从建立信任到彼此成就》 “当人们感受到情感上的满足时，他们会觉得得到了充分的倾听、理解、接纳，而不是受到评判。” 当你全身心地与对方待在一起时，你通常能感觉怎么做是合适的。但是我们习惯于把自己要传递的信息放在首位，于是在与他人相处时总是寻找契机表达自己，而很难真正的去倾听共情，所以真正沟通在这种状态下难以发生，对话的积极意义并不明显。当放下表达自己的执念时，积极地倾听，理解对方，回应并表达关心，让对方感受到情感上的满足，这些便自然而然的发生了。当对方从你这里感受到情感的满足时，也会以开放接纳的心态来对待你的想法。 引用博主：遨游之舟 忠言不必逆耳，良药不必苦口。 现在的苦药，大部分都有糖衣、胶囊、甜味冲剂，吃到嘴里特别苦的是极少的。这是为什么呢？因为可以苦和治病不具有必然联系。不苦反而有利于服药治病。 忠言和逆耳是一对矛盾关系，他们同样不具备天然关系。忠言的目的是利行，利行的前提是听得进去，忠言不逆耳，才是应该提倡的。所以古人有讽谏。这是智慧+忠心。 忠言逆耳的发生条件存在两种情形，一是必要的，反复而不听，刺一下。陌生人不在此列。这是极少情形。二是简单粗暴，好为人师，不顾及他人感受的沟通方式。这是多数情况。 忠言不逆耳，应该成为追求和常态。就像今天大多数药不再苦口。 暖风比寒风更有力量。如何让行人脱掉外衣？北风呼啸而起，行人反而把大衣裹得更紧。暖风拂面，行人就不由自主地解开纽扣。 就像教员处理人际关系的公式 团结——批评——团结。 从团结的愿望出发，经过批评和自我批评，最后达到新的团结。 直接奔着批评去，大多崩盘。","tags":["随笔"],"categories":["成长"]},{"title":"人还是工具——应试教育","path":"/2026/01/28/人还是工具——应试教育/","content":"今天看短视频平台猛然意识到的一个问题: 习惯了向上看的孩子，是很难想象“下面”的世界的。 现在的互联网所有的娱乐平台都在展示“上层”世界的纸醉金迷、声色犬马、虚荣心、多巴胺。每个人都希望把自己好的、完美到不真实的一面展示出来。 甚至家长会主动让孩子接触这类信息，方便给孩子的眼前挂个胡萝卜，有个所谓“奋斗的动力”;中间可能会举“别人家的孩子”和“98分剩余的那2分为什么没得，还是不够努力 …….”。 而孩子自己没有信息筛选能力和判断能力，极容易认为“眼前的萝卜”，所谓的“比我过得更好的人”就是整个世界。 这种形势下，孩子最原始的生命力、多远而简单的快乐、没有分别心的质朴显得尤为可贵。 可作为大人如果不去保护孩子宝贵的天真与朴实的本性，非要去强行灌输所谓“成熟的”“长远的”思想那一套，无异于拔苗助长。 所以这会带来什么后果？ 1.深入骨髓的焦虑感: “我太颓废了，现在就滚去做xxx””从不松弛，如履薄冰的螺丝钉“……焦虑是第一生产力…… 一旦孩子“通向上层的道路”被不可抗力（失败、疾病、运气）阻碍滞留了，TA就会产生天然的焦虑—— “我是不是比别人慢了？我要掉下去了，我也摔的满身是血了……我不愿与脚下的低层人为伍,我才不是弱者！” 换言之，放大的生存欲和焦虑将会周期性、不断的折磨这个孩子，一次次。 而孩子面对焦虑是怎么应对的—— “我还不够强，我还不够努力。我要继续往上爬，否则我就是废物，一无是处” 。 好了，如果孩子的能力运气让他得到正反馈，焦虑会延后；如果孩子接下来还是没能回到正轨，迎接ta的将是焦虑程序死循环，雪球越滚越大的自我否定。 继而从单一的应试教育成绩、工作业绩、金钱、地位等标准带来的焦虑，辐射到所有的生活里。 2.对快乐的迟疑（延迟满足成瘾） “等我xxxx了，我一定去xxxxx” “压抑自我、外重内拙、拔苗助长的空心人” （六岁喝到的可乐，和三十六岁喝到的可乐，味道真的不相同的） 我已经记不清多少次看到山河四省的孩子家长，在身边的亲友分享自己的开心、幸福时，本能般的刻意强调起来: “想想你的成绩存款地位吧，还在这自我安慰呢” 或者 “唉，真羡慕！快乐果然需要时间金钱地位xxxx，我还是继续努力上学工作吧。” 这就导致获取快乐与幸福的成本大大增加。（这可能是人类最重要的东西） 原本简单的知足、自我肯定行为被附加了巨大的沉重意义和负担。 心急的家长们尤其害怕看到孩子舒舒服服的躺着坐着，怕ta开开心心快快乐乐的。 于是快乐、幸福、满足成为了高成本的事情，甚至成为了强者才配拥有的东西。前提条件拉满了。 这是家长和老师把自己的焦虑（生活压力业绩指标）投射到孩子身上的后果。 有意思的是，这些家长老师劝说孩子应该去做的值得延迟满足的事，往往是已经饱和的、人人皆知的路径。 换句话讲，等孩子真的达到的目的，他很大可能—— 主观上并不会感到快乐（因为那是家长的一己私欲，而非孩子的顺从本心。） 客观上也达不到成功路径的预期（饱和了）。 只剩下一张更大的饼和一个延迟到麻木到不知快乐为何物的孩子，站在原地不知所措。 此时即使孩子得到外界的积极夸奖，也因为惯性觉得没有达到预期的成功的自己不配，不值得。 外界过多的干涉也影响了其内驱力的形成，缺乏积极正向的内在探索，难以形成内心自我真正的渴望。内驱力无法立足于如热情、喜爱、兴趣等人的天性，反而需要依赖外界洗脑般的痛苦叙事。 真正的“我”已经被压抑在厚厚的外壳里，成了学校的升学指标数据，家长一厢情愿的自我投影寄托。孩子成为了照顾一切外人期望，唯独没有照顾自我的“空心”人。 3.社交能力的缺失，社会化不足 “精致利己、虚荣慕强的机器人” 沉重的学业压力让孩子无暇探索自我性格，学校灌输的“弱肉强食”与“向钱看”观念让孩子难以对竞争者关系的同伴完全敞开心扉。 同学之间彼此信息交流的浅薄和克制导致个人世界观的匮乏和基本包容度、同理心的丢失。 多角度思考和亲密关系无从生根，无法发芽。 至于自我疗愈、发泄情绪的私人空间，在大锅菜、大宿舍（十人以上）、个人量化分体制下的填鸭式学习（时间塞满，不遵守扣分）就更不必谈了。 以“我”为中心的个人叙事太多了，总觉得“我”能行，不需要其他人。在校园内围绕“我”的叙事中，要求我们看到对方的“利他”性，只能是把人当工具化，高度功利主义。 4.素质教育缺失的背后是生命力的萎靡，是自我个性的驯化，是对我和他人的工具化 有没有可能，人作为人本身，不需要优秀？只有工具才需要优秀。只有工具才因人的需求而有“优胜劣汰”的质量评级。 如果没有基本的劳动教育、体育教育，那么劳动和体育中团结协作、迎难而上、心态平衡、以弱搏强的一面的就无从感知。 我甚至怀疑审美也会因此受到波及——无论男女，从原始的小麦色健康精壮身材，转移到白幼瘦、卖萌撒娇上去。 如果没有基本的心理教育，那么情绪调节，释放自我，个性培养就无从下手。 压抑的情绪，消失的自我会以极为曲折的形式缠绕在孩子的心中，以晦涩的情绪闪回、白日梦幻想表现出来。 代价是影响工作专注——你想想如果到这时孩子的自信还建立在工作指标上，那么…… 如果没有基本的三观德行教育，那么孩子即使有了才能，也不能有效的发展自我，承担责任，回馈家族，贡献社会。甚至会因才而骄，难以脚踏实地，个性中出现极端逼仄的一面。 稻盛和夫：人生工作的结果 思维方式 × 热情 ×能力‌如果思维方式歪了，能力和热情再强，也如没有刀鞘的利刃，伤人伤己，无所适从。 5.向下视野的缺失（不知足，不同情，不理睬） “不好好学习，就跟ta们一样……”’沉浸在精英叙事的原子人 ——精致、脆弱、孤独。 向上层世界对齐成为一种习惯甚至内驱力以后，生活在“精英”幻想中的孩子很难看到自己已经具备的优秀品质。 TA们更难看到习以为常的资源之下有一群原生家庭生而不养，三观认知支离破碎，封建陈腐思想压迫下的同龄人。 看不到所谓“一无是处”的失败与自卑，已经是运气给予的恩赐。 换言之，结果与幸福与否无关；为自我发展而奋斗的机会本身就是一种幸福；目的与成败与否无关；能拥有一个不会后悔的体验过程本身就是一种趣味。 TA们因此难以在真正成为精英以后为自己如何服务社会、回报社会这件事实现自洽；反而能出于认知本能第一时间牢牢把握自己的生态圈地位，维护自我利益。 Ta们沉浸在优秀叙事中： 对单一标准的体系内强者 嫉妒攻击来平衡内心； 对体系内弱者 鄙视贬低来提高信心（甚至以之为驱动力）； 对体系外的人 不在乎、不理解、不关心、不“敬畏”（对方身上潜在的自己认知不及的东西）。 回过头来，TA们还要感激这套体系给了他们自信，为他们提供了“靠自己努力拼搏”的平台，对任何批判体系的人扣帽子。 某些教育体系中，孩子发展缺失包括但不限于 如厕权、洗澡权、喝水权、充足睡眠； 生活常识、基础三观、心理健康、爱好培养、沟通表达、亲密关系（留给社交的空间时间）、耐心同理心换位共情能力、情绪管理； 学校教育和家庭教育失灵的情况下，只能让孩子用自己学校以外的一生去探索。 而你很难保证这孩子在维持基本生存、克服学业就业压力的同时，在生孩子之前把自己理顺了 而这事关创伤代际传递。 …… 终语Anyway。这个阶段是最讲究自我教育的阶段。所有的个人素质和精神需求都能在互联网上找到相关资源，ai也让信息获取效率飙升。 最后希望大家都能拥抱自己内心的那个小孩，守得一份独立于世的天真，穿行于始终如一的快乐。 你真的很棒了。 参考博主知乎：离阿米浪子公众号：躺平学原理书：《1984》《当今为什么还要研读马克思》综艺：《十三邀》——黄灯+林小英B站：《倦怠社会》——天真的和感伤的小说家 彩蛋庄子・马蹄 马，蹄可以践霜雪，毛可以御风寒。龁草饮水，翘足而陆，此马之真性也。虽有义台路寝，无所用之。 及至伯乐，曰：“我善治马。”烧之，剔之，刻之，雒之。连之以羁絷，编之以皁栈，马之死者十二三矣！ 饥之渴之，驰之骤之，整之齐之，前有橛饰之患，而后有鞭筴之威，而马之死者已过半矣！ 陶者曰：“我善治埴。”圆者中规， 方者中矩。匠人曰：“我善治木。”曲者中钩，直者应绳。夫埴木之性，岂欲中规矩钩绳哉！然且世世称之曰：“伯乐善治马，而陶匠善治埴木。”此亦治天下者之过也。 想到那些把尖子生往自己这掐，然后竭力表彰自己的功劳的学校了吗？ 最后所有家长都信服了这种叙事。 多少孩子、家长、老师、高校敢在这种压迫下说一句“此亦治天下者之过也”？ 种树郭橐驼传 ——柳宗元 橐驼非能使木寿且孳也，能顺木之天，以致其性焉尔。凡植木之性，其本欲舒，其培欲平，其土欲故，其筑欲密。既然已，勿动勿虑，去不复顾。其莳也若子，其置也若弃，则其天者全而其性得矣。 故吾不害其长而已，非有能硕茂之也；不抑耗其实而已，非有能早而蕃之也。他植者则不然，根拳而土易，其培之也，若不过焉则不及。 高中关于文言文的选修课本的小文。 记得当时语文老师意味深长的说，这些非必修的不考的文章，反而是语文教育里的精华…… 蝜蝂传 ——柳宗元 蝜蝂者，善负小虫也。行遇物，辄持取，卬其首负之。背愈重，虽困剧不止也。其背甚涩，物积因不散，卒踬仆不能起。人或怜之，为去其负。苟能行，又持取如故。又好上高，极其力不已，至坠地死。 这是杀君马者道旁儿的道理。 芝大教授毕业演讲 —— David Brooks 目前在这个国家，我们正经历着关于终极意义的危机。 许多人对自己的目标和目的没有清晰的认识。他们不知道他们在追逐什么，或者遵从什么样的根本信念行事。 他们在各自细分的专业领域接受大学的科研训练，学校教他们怎么做事，却不教他们思考为何要做。大学也没有为他们提供发问的论坛，去问我应该如何生活？我的使命是什么？我为什么要来这里？ 从大学里走出，他们就进入了真实的世界，一个忙忙碌碌的世界。成千上万的电邮要回，马不停蹄地规划事业、组建家庭。种种此般皆让人无法聚焦于关乎生命意义与目的的问题。我看到很多人就连这些思考德性话题的词汇都不具备。 他们并没有处在一个良好的道德生态之中，也甚少接触那些能引导指点他们的理念。这就造成了一种巨大的情感脆弱。我们的朋友尼采曾说过，若知为何而生，遂可纳受一切。但倘若你不知道自己的使命，那即使是第一次失败或挫折就能置你于危机之中，让你彻底崩溃。 我在我教过的学生身上看到过这种缺失，二十几岁的年轻人身上也屡见不鲜。没有明确目标的年轻人毕业了，指望用一次次堆砌成功来填补内心的空洞。 他们成了 Matias Dalsgaard所谓的“焦虑的佼佼者”。（注：Matias是麦肯锡前雇员，指出在初入职场的年轻人身上特别明显地存在一种焦虑状态，后来他在书详述了这种焦虑状态的五个特点） Dalsgaard 写道：“这种人一定没有稳固的处事根基，但依然试图让自己从所遇的问题中解脱出来。这等于陷自己于不可能之境。你无法通过建造新的楼层，来弥补像流沙一般的地基。但这种人会继续无视这点，一心希望只要修建工作继续下去，地基的问题就不会被发现。” 关于教育革命的谈话 —— 教员 〔一九六四年二月十三日、一九六五年十二月二十一日〕 我早就说过，我们的教育方针，应该使受教育者在德育、智育、体育几方面都得到发展，成为有社会主义觉悟的有文化的劳动者。现在课程多，害死人，使中小学生、大学生天天处于紧张状态。课程可以砍掉一半。学生成天看书，并不好，可以参加一些生产劳动和必要的社会劳动。 现在的考试，用对付敌人的办法，搞突然袭击，出一些怪题、偏题，整学生。这是一种考八股文的办法，我不赞成，要完全改变。我主张题目公开，由学生研究、看书去做。例如，出二十个题，学生能答出十题，答得好，其中有的答得很好，有创见，可以打一百分；二十题都答了，也对，但是平平淡淡，没有创见的，给五十分、六十分。考试可以交头接耳，无非自己不懂，问了别人懂了。懂了就有收获，为什么要死记硬背呢？人家做了，我抄一遍也好。可以试试点。 旧教学制度摧残人材，摧残青年，我很不赞成。孔夫子出身没落奴隶主贵族，也没有上过什么中学、大学，开始的职业是替人办丧事，大约是个吹鼓手。人家死了人，他去吹吹打打。他会弹琴、射箭、架车子，也了解一些群众情况。开头作过小官，管理粮草和管理牛羊畜牧。后来他在鲁国当了大官，群众的事就听到了。他后来办私塾，反对学生从事劳动。 明朝李时珍长期自己上山采药，才写了《本草纲目》。更早些的，有所发明的祖冲之，也没有上过什么中学、大学。美国的佛兰克林是印刷所学徒，也卖过报，他是电的大发明家。英国的瓦特是工人，是蒸汽机的大发明家。高尔基的学问完全是自学的，据说他只上过两年小学。 现在一是课多，一是书多，压得太重。有些课程不一定要考。如中学学一点逻辑、语法，不要考，知道什么是语法，什么是逻辑就可以了，真正理解，要到工作中去慢慢体会。课程讲的太多，是烦琐哲学。烦琐哲学总是要灭亡的。如经学，搞那么多注解，现在没有用了。我看这种方法，无论中国的也好，其他国家的也好，都要走向自己的反面，都要灭亡的。 书不一定读得很多。马克思主义的书要读，读了要消化。读多了，又不能消化，可能走向反面，成为书呆子，成为教条主义者、修正主义者。 现在学校课程太多，对学生压力太大。讲授又不甚得法。考试方法以学生为敌人，举行突然袭击。这三项都是不利于培养青年们在德、智、体诸方面生动活泼地主动地得到发展。整个教育制度就是那样，公开号召去争取那个五分，就有那么一些人把分数看透了，大胆主动地去学。把那一套看透了，学习也主动了。 据说某大学有个学生，平时不记笔记，考试时得三分半到四分，可是毕业论文在班里水平最高。在学校是全优，工作上不一定就是全优。中国历史上凡是中状元的，都没有真才实学，反倒是有些连举人都没有考取的人优点真才实学。不要把分数看重了，要把精力集中在培养分析问题和解决问题的能力上，不要只是跟在教员的后面跑，自己没有主动性。 反对注入式教学法，连资产阶级教育家在五四时期就早已提出来了，我们为什么不反？只要不把学生当成打击对象就好了。你们的教学就是灌，天天上课，有那么多可讲的？教员应该把讲稿印发给你们。怕什么？应该让学生自己去研究讲稿。讲稿还对学生保密？到了讲堂才让学生抄，把学生束缚死了。 大学生，尤其是高年级，主要是自己研究问题，讲那么多干什么？教改的问题，主要是教员问题。教员就那么点本事，离开讲稿什么也不行。为什么不把讲稿发给你们，与你们一起研究问题？高年级学生提出的问题，教员能答百分之五十，其它的说不知道，和学生一起商量，这就是不错了。不要装着样子去吓唬人。 学生负担太重，影响健康，学了也无用。建议从一切活动总量中，砍掉三分之一。请邀学校师生代表，讨论几次，决定实行。如何请酌。 现在这种教育制度，我很怀疑。从小学到大学，一共十六、七年，二十多年看不见稻、菽、麦、黍、稷，看不见工人怎样做工，看不见农民怎样种田，看不见商品是怎么交换的，身体也搞坏了，真是害死人。我曾给我的孩子说：“你下乡去跟贫下中农说，就说我爸爸说的，读了几十年书，越读越蠢。请叔叔伯伯、姐妹兄弟做老师，向你们来学习。”其实，入学前的小孩。一岁到七岁，接触事物很多。二岁学说话，三岁哇啦哇啦跟人吵架，再大一点就拿小工具挖土，模仿大人劳动。这就是观察世界。小孩子已经学会了一些概念。狗，是个大概念。黑狗、黄狗是小些的概念。他家里的那条黄狗，就是具体的。人，这个概念已经舍掉了许多东西，舍掉了男人、女人的区别，大人、小孩的区别，中国人与外国人的区别，只剩下了区别于其它动物的特点。谁见过“人”？只能见到张三、李四。“房子”的概念谁也看不见，只看到具体的房子，天津的洋房，北京的四合院。 大学教育应当改造，上学的时间不要那么多。文科不改造不得了。不改造能出哲学家吗？能出文学家吗？能出历史学家吗？ 现在的哲学家搞不了哲学，文学家写不了小说，历史学家搞不了历史，要搞就是帝王将相。要改造文科大学，要学生下去搞工业、农业、商业。至于工科、理科，情况不同，他们有实习工厂，有实验室，在实习工厂做工，在实验室做实验，但也要接触社会实际。 《你会承认自己并不优秀吗》离阿米浪子 “认为自己优秀”是一种性幻想，是一种高级奶头乐，是自己浅薄生命中抽教育体系和牛马身份的叶子抽出来一种神经高潮。 一个人谈论自己优不优秀简直像幼儿园小朋友谈论自己得了多少小红花一样无聊幼稚，这种人是不配进入成人世界的。 请觉察这其中的荒诞：优秀始终是一种对工具的评价，人不需要是优秀的。 人只需要是活着的，自洽地存在着的。 有人认为达到“优秀”的标准，就能获得恒常的奖励，这简直是童话故事，只能庆幸你们生活在一个火鸡的世界。 事实上，这个世界上默默死掉的诚实努力的天才数不胜数，倒是那些愿意说假话吹嘘自己的懒惰的庸人占据了话语权。如果你愿意观察周围，你会发现既得利益者永远认为自己是“优秀”的，因为他们没有任何向下或向上的认知，他们的认知永远被局限那个被他们的出身和运气局限好的体系内。 自然，这种人会继续制定“优秀”的规则，以便让自己和自己的后代能够永远享有话语权和劳动力。 但普通人要清醒一点：我们中的大多数，是不会因为这个“优秀”体系获得任何利益的（工资不是利益，那点儿工资是牛马应得的用以维持发电量的补给）。 剥削普通人，滥用他们的劳动力和注意力已经成为一种可以视而不见的常态，尤其是话语权的剥削。正如现在我们甚至要去赞美那些资本家后代和明星们“优秀”。当对“优秀”的定义已经歪斜甚至颠倒的时候，我只能认为这个词是恶臭的乃至荒谬的。另外，赞美资本家优秀这件事，有一种把幼儿园红花榜应用到到中世纪奴隶主上的荒谬。 前面说过，他们不需要是“优秀”的，“优秀”这个词只是施舍给工具人的兴奋剂，你对他们说“你好优秀”，他们只会奇怪地看着你笑。 综上，“优秀”这个词的荒谬在于： 在学生时代，“优秀”用来衡量你做牛马的质量，也就是能创造社会价值的能力（甚至衡量的标准也是相对单一和粗暴的）。在成人时代，“优秀”则突然变成了用来衡量你占用社会资源的多少。他们把这个时期的优秀称为“社会化*”。但在此之上的遮羞布是：没有人告诉你占用社会资源的人中的大多数并不创造社会价值。 说白了，一切“优秀”的定义都被金钱和权力掌握，只有靠近资本的人才是“优秀”的。 比如我无法定义一个深耕乡村教育的师范生，一个在大厂码字的程序员，一个在上海赚了钱买房的金融男三个人哪个更优秀。但我们的资本话语体系*显然可以分出优劣，因为收入和资产是可以量化的，这是一种结果导向的价值思维。 《倦怠社会》 —— 韩炳哲 -书评（B站：天真的和感伤的小说家） 1.抑郁来自自我的无限可能 人在获得自我以后，就无法躲在群体之中了。 我们每个人变得赤裸，于是我们开始剥削自己。韩炳哲在倦怠社会中谈到的规训社会和功绩社会的活法，同样适用于校园。 而今天的校园走向了另一个极端，也就是功绩校园（社会），我们强调自我，我们是自由的。社会变得无比的积极，于是我被肯定为一个无限可能的，个性的，自由发展的，不可融入大群体的。于此开脱，我是赤裸在外的，我不得不自己奋斗。我不需要任何人规训我，我变得无比的积极，我是自己功绩的主体了。于是我即是自己的主人，又是自己的奴隶。 这个时代过度的积极性和可能性，给我们套上了一个自我的，宏大的叙事。每个人都成为一个疲劳的英雄。 “你可以的，只要你努力”“你可以的，只要你坚持” 如果没有做到，那么我的问题。发出这个质疑的不是别人，而是我自己。过多的这种可能，让人不断地陷入自己主动带来的自卑与自责中。我在积极地不停地奴役和压抑自己，又发现自己不可能做到，于是带来一种自我自卑和自责。内外的压抑使年轻人开始抑郁。 人类从来没有像今天这样双重疲劳过，我们不敢偷懒，人不能像过去一样躲在群体中了，群体感缺失了。“我们每个人都是独立的，我们每个人都在成为一个伟大的自我”，于是我们每个人都赤裸在外，不能当混子了，不能公然的倦怠了，因为我们被过度的肯定了。 2.过度的肯定走向工具的奴隶。 韩炳哲在《倦怠社会》中认为“否定”缺席了，我们承认自我需要被肯定，才能确定自己的行动，但肯定与否定都是必须的，我们清楚社会的主流，什么是必须的，但那些“未被肯定的思想”成为了错误的代表，预示着他是自己的问题，不可到达死胡同逼死了自己积极的蛮信。 老师不能否定你，因为那是消极的，甚至放在当下是不正确的。家长不能否定你，因为没有家长愿意承认自己的孩子 生来不具有无限可能。而我自己也不行，因为我自己在给自己施加压力，我主宰我自己。 事实上人必定要学会否定自己，这种“否定”不是规训社会的“抹杀”（农民的后代必定永远是农民，思想抹杀其他的可能性）。否定自己是建立“新自己”的开始。 什么是“否定”？分为“我不行”和“我不必”。 什么是“我不行”？在一件事情上，我怎么努力和挣扎都没有用，但这也预示着我认可了秩序。我被肯定为“我是必须要行的”所有人告诉我，我是自我的 ，“我必须要行的”“自我是有无限可能的”“你注定了要成为那个人的”“主要你努力，你不可能不行”，所以我并没有“否定”，我只是在“我不行”的世界里反复轮回，反复失败，而我又不能找到借口，我在这个死胡同里，朝着我以为的“行”，无止境的疲劳下去。而“否定”起初来自“我不行”，其次它走向了“我不必”，“我不必”才是“否定”的开始。 这才走出一个倦怠的我，我走向另外一个“我可以” 我不必非得考上最好的大学，我可以否定掉它，并重新探索自我的可能。 “否定”不是可怕的，最可怕的是不能否定又不能确定肯定的“无意义”感。 过度的肯定逼迫着我们朝着必定的可能无休止地攀爬，没有一丝倦怠，直到我分不清“我是生命的人，还是生命的机器”，像一个工具，像一个工具的奴隶。 虚无感从中而来，我和世界切断了联系，感受到的是沦为无用工具的格格不入，而不是我们强调的“个体独特的存在”了。 自我规训比社会规训更苛刻。外界的视线总有移开的时候，自我的注视不曾有片刻停歇。 也许如果没有外界的视线，自我也就不会有多余的注视了。很多人不敢有片刻停歇的注视，就是为了在外界那一瞬间的视线来临时像一个正常人。 这感觉其实也是一种社会规训，社会规训了自我，给“我”建立了一个宏大的叙事，而我在此叙事中建立了高大的“自我”，于是在整个时间当中，这个高大的“自我”无时无刻俯视着真正的自我，“我”的目光也就从未离开过自我身上，自我规训便开始了。","tags":["随笔","心理学"],"categories":["成长"]},{"title":"初心","path":"/2026/01/28/初心/","content":"这两天的学习心不在焉 这两天的学习心不在焉，总是走神。投入不进去，浮躁。于是又想到自己努力的初心。之前想的都是自我发展，功利回报，或者干脆是考完之后多打打游泳、多看看闲书。 这次很奇妙的没有延续老路。脑回路忽然走向了先前不常走的岔路—— 一些回忆猝不及防的潮水般涌来: 我想到了我四舅。那是2010年的夏天，我放学后扔下书包，反常的说:“妈，我有点累，我一会再写作业吧”。于是戛然而止，再反应过来，我已经在车上，看着流泪的妈，不停的问她，“妈怎么了？”“妈怎么了？” 妈不语，只是抽泣。这是第一次见到妈的脆弱。半夜的病房安静，平和。我的肚子和胸都贴了奇怪的圆片儿，所幸不是打针，不疼。我能看见的，只有仪器上亮着微弱的光线，还有陪护的母亲们歪曲着身子，躺在折叠床上。我看不见的，是我四舅躺在走廊里，用不知从哪凑合来的拼图垫子，搭地上凑合了一个礼拜。听妈说，那是她自我住院几天来，第一次心里踏实点。 再往后的记忆就更碎了:白天四舅总拿着一沓红色钞票在走廊串来串去。我盯着在村里没见过的自动贩卖机，里面有瓶罐装芬达，四舅偷偷买了一瓶，被妈扔垃圾桶了。医生在我左肘窝抽了一管子血，我右手捏着棉花止住针口，医生再在我右肘窝抽一管子血。左手再捏棉花止住。就这么交叉着手出来，医生面无表情，我也面无表情，心里带点小自豪，为了自己没哭。每次医生把我拉进房间，门一关，我就听不到外面的动静，也听不到我妈的声音了。——————第二个想到的是李老师。生完病在家歇了一学期。受父母拜托，一到晚上，李老师就拎着小包来家里。妈妈把小方桌提前架好，我的发小们也一块乌央乌央的进来了。大家围着桌子听李老师讲课，可印象里却都是转着圈玩乐，只感觉热闹、开心。桌子上我只要一像个儒生般摇头晃脑的念诗，李老师就跟大家夸赞我。这导致我去老师家里玩，总要故作风雅的吟诗一首。看见我爸妈期待的眼都瞪大了，老师只好被迫营业，干起语文老师的活儿，好生评点一番，最后不忘勉励我继续努力。 李老师形相清癯，李夫人温良随和。两人笑脸迎人，除了训我和我发小的时候板着脸极是可怕，平常没见过他俩着急。那次老师和老爸带我和发小去地里。还骗我们说有秘密基地和宝藏。结果是钻到熟透了的棒子地里。一排排棒子杆中间，有好多蜘蛛网，那个脑袋上五彩的黑蜘蛛，现在想起来还浑身发麻。回家后李老师问我:“你生过病吗？” 我说“没有。”啪叽一巴掌。问发小，“没有”，又是一巴掌。这时候我才知道，最大的病是不知道父母的辛苦。李老师生活拮据。四个房间的小平房，其中一个只放了一张桌子，桌子上有个菩萨，被玻璃罩着。旁边一个小mp3，不停放着“阿咪，妥four”的声音。电视上的vcd，也只有两个碟子，一个是一休全集，另一个是关于行善有善报，行恶下地狱的动画宣传片。地狱里的恶鬼拿斧子砍人，上刑，现在想也感到害怕。 平常总有没见过的大哥哥大姐姐，拿着花来拜访李伯伯。——————第三个人是我的高中语文老师翟老师。那时的我自卑、内向，只剩下一身无处施展的生命力和周身的疑问，去假装自己混不吝，不在乎，摇头晃脑，心口不一，情商还极低。最近看到《神雕侠侣》中，杨过父母双亡，寄人篱下，同样的自卑敏感，张狂决绝，大有共鸣之感。这种小孩表面粗犷不羁，实际上是最渴望注意的，内心戏也多。显现在外的，是邋遢，抖腿，自我为中心。那时只有语文老师愿意在上课的时候跟我们聊聊人生，聊儒家经典，聊道德经，处下、大象无形、上善若水……还在中午放学后，牺牲休息时间带我们共读论语。也只有她愿意把我叫出去，好好倾听我是怎么想的。听完之后能按着我性子，给我最大的肯定和鼓励。最可敬的是，她不是对我有偏爱，而是对班级所有人都这样，包括被大家孤立的同学（或许因为我也不招人待见，所以我有个比较自豪的事是没有背后说过这同学的坏话，也没表现过鄙夷）。可以说，师者传道受业解惑也，因材施教，有教无类，她都做到了。于是我感激她，也想成为她。疫情期间，毕业以后，都在如饥似渴的读论语，读大学中庸，读曾国藩家书。可以说，我三观中的很大一部分，是在老师帮助下打的基础。至今仍记得老师对我的鼓励:“诚于己才能诚于人，才能坦荡前行，与低维度人事格格不入，却能吸引志同道合者并驾齐驱，所以慎独是修身的高起点。”“于世俗中，这条路不好走，要有心理准备，但一旦坚持走下去，便能近道入道，活出人生真况味[微笑]” ……所以在回到开始的那个问题:我努力的初心是什么？是新出的游戏，是一两本期待的书，是运动中挥洒的汗水？说实话，这些东西体验自然是极好的，但体验过后，了无痕迹，仍旧如平常。 不知道什么原因。一个早晨的走神，让现在我的答案好像忽然不太一样了:我想奋斗。不为用欲望填满另一个欲望；不为证明什么东西。只是想通过我的个人努力，为社会创造一些价值，然后收到一些价值（比如钱，比如更好的自己）。再用自己的微薄之力，和更有能力的自己，去回馈过往路上那些用心去爱护过我的人。 不只是为了片刻欢愉。而是我作为一个个体，一个身处阳光雨露中的个体，与他身边可亲可敬一人的深深的联结。 耐心……等待…… END.——————是不是人总要经历这样一个过程:一开始被集体驯化，压抑自我；后来自我意识觉醒，又开始对抗集体；最后在集体中找到自我价值，又在自我中发觉不可缺少的集体血液。 一言蔽之:在人我的互动中，找到自我定位。 这好像是最终不可避免的人和人之间的关联与孤独。 ——————彩蛋:1.当时足不出村的我和妈妈，第一次因为肺结核炎症进大城市的医院。医院里的医生护士多数在明面上歧视乡下人。后来做生意的舅舅他们一帮人来医院看过妈妈，医生态度才有所转变。 我在医院的那段经历是极幸福的。喝不完的各种牛奶，没有作业没有功课，顿顿都能吃到“外面的饭”。妈妈为了哄我还愿意给我买遥控汽车……可是后来成年才明白，我有多幸福，母亲就有多煎熬。不谙世事，恐惧，不安全感，生气疾病（有个比我严重的同病房患者，16岁的大姐姐因病去世了，那天早晨她的病床围了好几圈人），疲劳，开支，黑夜……我妈是个好面子的人。不愿意麻烦家里人，最多叫了几个舅舅。不知道她怎么扛过这一关的。或许她根本没扛过，压抑的不安全感直到后来才显现，造成对我和我哥截然不同的教育感受……好在一切已经同母亲梳理干净（交流是深度关系的基础）。 这场病导致我爸提前从国外回来。这对我是喜上加喜。于母亲来说是梦魇，于我而言却是有趣时光。这个没受过苦的大家小姐，用自己爆发出的能量，守护了孩子的安全感和幸福感。 所以现在我的唯一印象是T市的水真tm难喝，一股铁味。不及村里甘甜的生水。（现在村子还没城市化，水倒先城市化了。生水早已不能再喝） 2.李老师一家在我上完小学后，就搬到县里去了，至今没有再见到过。爸妈都失去了一位好朋友+好闺蜜。我失去了一个不好的发小（这位女士小时候仗着个子大老打我）。 3.从班主任那得知，语文老师教我们的时候身体状况很不好，是带病上岗的。我们毕业后也没听她提过。教完我们这一届，她就调到清闲岗位，离开教学一线了。","tags":["成长","生活"],"categories":["生活"]},{"title":"《不原谅也没关系》读书笔记","path":"/2026/01/28/《不原谅也没关系》/","content":"Complex PTSD: From Surviving to Thriving 这本书的中文名叫《不原谅也没关系》，但我觉得不如英文本身的蕴意好。 From Surviving to Thriving 是每次痛苦中成长的必经之路。 遗簪见取终安用，敝帚虽微亦自珍。奇伟瑰怪在险远，无限风光在险峰。 目录 零、概念阐述 一、本书对我个人心理治疗的运用 二、对本书感受较深的几个点（笼统） 三、我认为的心理学书籍的意义 四、本书原文摘录 ​\t1.内在批判者 ​\t2.外在批判者 ​\t3.讨好型人格 ​\t4.不正常的原谅 零、概念阐述症状正如书名所言，这种心理疾病叫“复杂性创伤后应激障碍”（Complex Post-Traumatic Stress Disorder，简称C-PTSD）。 这种病症的医学定义是：个体在经历一次或一系列具备威胁性或恐怖性，通常长期、反复发生并且难以逃脱的创伤事件后形成的精神障碍。 其中最常见的五个主要症状： 情绪闪回（Emotional Flashbacks） 遭受创伤性遗弃的幸存者极易发生痛苦的情绪闪回。情绪闪回是一种突然发生且通常持续时间较长的退行(Regression)，幸存者会退行至童年遭受虐待或遗弃时所产生的强烈的情绪状态。这种情绪状态可能包括强烈的恐惧、羞耻、疏离、愤怒、悲伤和抑郁，甚至出现不必要的战或逃(Fight or Flight)反应。 情绪闪回可能是CPTSD最明显、最典型的症状。 在此必须指出，情绪闪回和生活中的大多数事情一样，并不是“全或无”的。也就是说，并非所有闪回都能被归为退行。闪回程度或轻微，或严重，持续时间也可能从片刻到数周不等，只有达到一定的程度和持续时间，才会被心理治疗师判定为退行。 毒性羞耻感（Toxic Shame） 毒性羞耻感能够在顷刻间摧毁人的自尊。家人过去对你造成的创伤可能会让你在当下的情绪闪回中立刻退行至一种“自己没有价值、必被鄙夷”的感受和想法中。 毒性羞耻感还会阻碍我们寻求他人的慰藉和支持。当童年被遗弃的经历在闪回中重现时，我们常常会孤立自己，无助地向强烈的羞辱感投降。如果你深陷于自己毫无价值、有缺陷或自卑的感受中而无法自拔，或是迷失在自我厌恶和恶性的自我批判中，那么你可能正处于一次情绪闪回中 自我遗弃（Self-abandonment） 当你困于羞耻感之中，毒性羞耻感就会发展为极度痛苦的自我疏离，让你陷入混杂的被遗弃感(Abandonment Mélange)中——仿佛身处被全世界抛弃的绝望的深渊。“混杂的被遗弃感”是一种混杂着恐惧、焦虑和毒性羞耻感的痛苦感受，这种感受还会与遗弃抑郁(Abandonment Depression)相互作用。 遗弃抑郁充满着犹如走入死巷的无助感和无望感，这种感觉深深折磨着遭受创伤的孩子。 恶性内在批判（ViciousInner Critic，或称内在批判者） 1.情感忽视带来的完美主义(超我) 当父母通过被动忽视或主动虐待造成情感遗弃时，孩子长期处于安全感缺失的焦虑中，被迫发展出病态完美主义作为生存策略。这种危险氛围会扭曲超我（内化父母规则的心理机制）的功能，使其异化为自我攻击的”内在批判者”——它通过苛求完美来乞求父母认可，却在努力失败后转向自我憎恨，将父母的拒绝错误归因于自身缺陷。 超我是一种通过学习父母的规则来寻求接纳的心理。内在批判者是变质的超我。它的出现意味着超我在超速运转，想拼命赢得父母的认可。当父母没有提供足够安全的联结和积极的反馈时，孩子就会在焦虑和恐惧中挣扎。 许多孩子会仿佛出于“本能地”追求完美主义来适应这些危险的遗弃。在家中弥漫的危险氛围会迫使孩子的超我过度追求完美主义并设想各种危害。 2.批判背后的灾难幻想 **内在批判者会不断指责孩子的缺点，因为它觉得这些缺点是父母拒绝孩子的原因，而无法理解真正的问题其实是出现在父母的身上。**就好像你的内心会多出来一个小人，不断的审视你，让你失去主体感、支配感，也就是“自我客体化”。 CPTSD的内在批判者将我们对遗弃的恐惧与对自身不完美的憎恨结合在一起，然后用完美主义和设想危害这两条纠缠在一起的“毒蛇”折磨我们。 设想危害(Endangerment)指在足够安全的情况下一直设想危险的过程。你可能在很安全的环境中，忽然想到一些灾难，或者自己处在死亡威胁、绑架威胁等引起你警觉的场景，并产生巨大情绪波动，影响专注力。 社交焦虑（Social Anxiety） 还有一些其他的症状：绝望的孤独感和被遗弃感、脆弱的自尊、依恋障碍、发展停滞、人际关系困难、极端的情绪波动、发生解离(在行为活动和精神状态层面分散注意力)、极易触发战或逃反应、对应激情境的过度敏感、自杀意念。 4F反应： 当孩子处于危险警觉的氛围之中，会本能的产生4种反应去应对，即“4F”反应。 战—自恋型 ：人在面临威胁时突然做出攻击性反应。 逃—强迫型：人通过逃离来应对威胁，或象征性地开启过度活跃的状态来逃避 僵—解离型：人在意识到抵抗无用时放弃抵抗，麻木地陷入解离或崩溃状态，仿佛接受了注定会受伤。 讨好—关系依赖型：人在应对威胁时，试图通过讨好或协助来预先阻止和安抚攻击者。 如果攻击或遗弃行为激发了过于强烈的4F反应，以致在威胁消失后这个反应还无法平息，就会造成创伤。此时，受到创伤的人会被困在一种肾上腺素高亢的状态，其交感神经系统也持续被锁定在“开启”状态，使其无法激活副交感神经系统的放松功能。 成因那些因为被虐待或遗弃而遭受创伤的儿童是如何发展出CPTSD的呢？ 尽管CPTSD的成因通常与童年长期遭受躯体虐待或性虐待有关，但我的观察使我相信，持续的言语虐待或情绪虐待也会引起CPTSD。当婴幼儿为了寻求联结和依附而悲伤地哭唤时，许多病态的父母会做出轻蔑的回应。这种蔑视对婴幼儿来说极具伤害性，即便对成人来说也极为有害。有特别严重的虐待行为的父母会将体罚与蔑视结合，这样做会加重孩子的遗弃创伤。 打个不恰当却十分贴切的比方：在奴隶社会，奴隶主通常会使用蔑视和鄙视来摧毁奴隶的自尊，这样的行为会让奴隶感到自己没有价值、没有力量，并陷入习得性无助。于是，奴隶主之后只需投入很少的精力和注意力就能对奴隶加以控制了。再打个比方，邪教头目在用短暂、虚假、“无条件”的爱哄骗信徒入教之后，也常通过蔑视来打压信徒，直至其陷入彻底的服从。 蔑视如同一杯掺杂了言语虐待和情绪虐待的有毒鸡尾酒，是一种汇集了诋毁、愤怒和厌恶的致命混合物。 父母对孩子发泄愤怒会在孩子心中制造恐惧，而被厌恶则会让孩子产生羞耻感，于是孩子很快就会学会压抑哭泣，并不再寻求关注。用不了多久，孩子就会完全放弃向他人寻求帮助或联结。在此后的生活中，一旦孩子想要亲近他人或获得接纳的尝试受到挫败，他便只能忍受由被遗弃带来的惊慌绝望。 除了受到言语和情绪层面的双重虐待之外，单是情感忽视也可能使孩子患上CPTSD。如果你因为自己受到的创伤看起来不如别人的严重而谴责自己小题大做，极有可能你在压抑自己的真实情感，并把自己遭受的负面情绪强行“最小化”。 大多数创伤的表象之下通常都潜藏着情感忽视。当孩子呼唤关注、联结和帮助时，父母如果经常予以忽视或不加理睬，就会将孩子遗弃在无边的恐惧中，使其最终放弃努力，并被无助与无望所带来的死一般的消沉感受压垮。 父母的这种拒绝行为会放大孩子的恐惧，并最终为这种感觉“镀”上一层羞耻感。长此以往，这种恐惧和羞耻感会演变为有毒的内在批判，这种内在批判会让孩子始终将父母的遗弃归咎于自己的行为，直至他们将自己变成了可怕的敌人，并陷入CPTSD的深渊。 一、本书对我个人心理治疗的运用我幼时曾生过一场大病导致母亲遭遇创伤，在医院照顾我时压抑对陌生环境的恐惧，同时积累了很严重的对我健康的担忧（怕我随时会死。巧合的是同一病房的小女孩去世了）。于是母亲的创伤导致她对我的教育过度紧张，产生变形。 这里的背景可以联系到一篇文章： 例如： 1.对我的过错（尤其是可能影响健康的）会小题大作，过于敏感，反常的愤怒。 2.对我的控制欲更强，总是对我的主动行为指指点点、加以评价。 3.对我的行为不满意时，喜欢对我甩脸子而非理性的告知（这一点影响甚大，我直到高中的闪回都在被这种表情困扰）。 于是形成了“创伤代际出传递”。我因为母亲的创伤而遭遇了创伤。 症状如下： 1.我有严重的社交完美主义和内外批评症状（为了满足高权威和情绪不稳定的母亲）： ①对内批评：我不敢表达自己的真实情绪和想法，表达后会反复自我反思批判，幻想他人对自己的评价。 ②对外批评：希望朋友眼中的我是完美的，同时希望我的亲密朋友是完美的（对他人不切实际的期望和批判）。 2.我有严重的讨好+战逃僵特征 ①完美主义投射：喜欢对朋友指手画脚，强加给他人建议；而非关心彼此情绪。（不敢正视情绪，不接受脆弱） ②极其害怕和朋友冲突，为此牺牲自己的情绪和想法。面对冲突大脑会停止运转，呆若木鸡。（冲突会联想到母亲） 3.我失去了主体性，阻碍了对自己的认识和信任。我做事会反复询问母亲，力求她的满意（她会甩脸子：“这么小的问题还问？”）。对演讲和深度交流感到恐惧（过度自我客体化，会出现一个内心小人反复拷问质疑自己）； 这两点的表现就是走神时忽然没来由的情绪闪回，过去的创伤场景浮现，出现从母亲老师身上投影而来的《毒性羞耻感→混乱的被遗弃感》+《完美主义→脆弱感》 4.左右脑解离： 右脑解离是右脑对强烈感受或内在批判者不间断的攻击逐渐感到麻木的过程，也是一个分散注意力的过程。幸存者的解离通常表现为迷失在幻想、混浊的意识、电视、疲劳或睡眠中。 右脑解离可以被视为一种典型的解离，也是僵类型的人最常使用的防御方式。 左脑解离会体现为理智化(Intellectualization)。**一些幸存者会过度依赖逻辑和高深的对话，以使自己远离混乱而痛苦的感觉世界。**即使是最具创造性的思维，在过度使用时也会恶化成一种强迫性的防御。 如同小说家伊恩·麦克尤恩(Ian McEwan)说的“专注思考的高墙堡垒”(High-Walled Fortress of Focused Thinking)。 左脑解离也可以表现为轻视(Trivialization)：幸存者过度聚焦于肤浅的外在关注点，以此来转移自己对不安的内在体验的注意力。一个常见的例子是，过度专注于体育赛事统计数据或好莱坞名人的生活。当然，这并不是说不能适度追求这类兴趣。 几个代表性场景： 和朋友打游戏，为朋友辅助，挨骂，有理也不敢还嘴。 高中由于完美主义（渴望关注）导致内在批判者太强，学习时常常在解离状态和情绪闪回之间跳动。 解离时，会在晚自习沉浸在自己未来的幻想之中，或喜或悲； 闪回时，会想到过去的场景和对应的负面情绪，开始羞耻、愤怒、自责、卑微。 高中为了回避自己的自卑和脆弱，渴望得到老师和同学的认可重视，开始假装”混不吝“，自我为中心，进行了一场”行为艺术实验“ 被相当一部分老师和同学反感。 哈哈，虽然如此，仍是一段极有价值的经历。至少从”打破自我设定“”厚脸皮“”表达自我“上有了很大进步 和朋友交流，担心自己说话的哪个标点符号错了被骂被讨厌；对对方不理解自己的地方感到不理解和孤立，并蔑视对方；面对他人的主动交流，对情绪麻木，过于依赖理性。 对朋友有严重讨好心理，常常以对方为中心，极端在乎对方感受。并且和朋友冲突过后，会极度敏感，关注朋友的一举一动，通过讨好来得到安全感（本质是害怕被遗弃感）。 初中甚至怀疑自己的性取向。还好看片看的早，没在这个路上栽跟头哈哈哈 大学前期常出现的： ①”内在批判者不断用超我代表的完美主义批判自己“，最终把辛苦构建的自信心完全摧毁，于是开始自暴自弃，封闭式的放纵摆烂。摆烂后又会出现“被遗弃感”，不配得感很强，于是开始更深的向内攻击。 具体见四(一) 摆烂之后，又开始指定新的计划，获得一点控制感、方向感、意义感，直到下次计划和期望成为批判自己的工具。 ②外在批判者会让我在社交中不断触发“危险”感受。把我的真实情感发到朋友微信群里，我会感到尴尬。把我的想法发到陌生人的qq群里，我会幻想自己被攻击。这两种都会让我提前产生大量的“被遗弃感”和毒性羞耻感。 实际上这来源于我与父母在相处过程中，对自己真实想法的封闭和自卑。童年在表达真实想法时，有过被父母忽视和否定的经历。 实际上我的母亲自身也有很强的创伤表现： 1.情绪激动时双手无力，缩成“鸡爪”状且颤抖。 2.聊天涉及到过去的记忆会触发“解离”，不愿回忆。一旦想起便“情绪闪回”，感到伤心压抑。 她很好的一点是擅长倾诉，即通过书中的“mourn（哀悼）”向周围人表达出来，不至于憋出更严重的心理病。只是对我不太妥贴，毕竟当时是个小孩，接受这么多负面情绪的信息，如果难以处理好容易被影响。 3.自卑倾向。宁愿过分谦让也不愿无条件支持自己。 以上是我的观察和刻板印象。考试结束后，我需要和母亲带着新视角再次共同交流。 后来的发展是极其幸运的。虽然我的创伤与情绪闪回强度很高，但我的心理治疗过程遇到了相当大的优势因素。例如： 1.我的母亲虽然不理解自己和孩子的创伤，但她相当乐于和孩子沟通，并能尽力理解孩子。 2.我遇到了性格成熟度较高+人品较好的朋友，培养出了正向亲密关系，有了成功社交的经历。 3.我在压力锅式的高中，经历了一年疫情，在家被迫经历了gap year。虽然成绩下滑，但有了充足个人空间和时间去了解我自己，认识我自己，同时接触到正向成长内容。 4.哥哥偶然给我买了个篮球→入门运动→身体锻炼+认识了一种正能量运动文化，反作用于我身上。同时因篮球了解到了一个贵人级别的博主，虽然没有任何交流，却被其传道授业解惑，足以为我的一生奠定基调。 5.高中语文老师让我读经典+看课外书→有了基本的世界观且入门阅读→豆瓣了解高分心理学书→开始自愈之路。 6.高考完我主动和母亲大吵一架，因为母亲(1)+疫情(2)+那个博主(4)，所以吵架过程中我足够清醒，引导了母子相处关系矛盾的解决，从而赢得了自己一部分的独立人格。7.我的家庭几乎没给过我压力和期望。我在思想上独立的有点“奔放”了。8.我朋友不多，但家族庞大。各种家族事务给了我极其需要的社交阅历素材。 9.如书中所言。当我缺乏对外归属感的时候，我诉诸于更高层次的归属感了（这一点绝对要感谢电脑+互联网）。 通过置身于自然、聆听音乐或欣赏艺术获得了归属于某种更宏大、更有价值事物的灵性体验。 神性体验是一种有力而动人的精神感受，它能让人感到在宇宙背后和自己内心之中都存在着一股积极、正面的力量。这股感受有时会让人体会到恩典，并深深地感到自己是有价值的，生活可期，生命可贵。 不管灵性或神性体验源于何处，它们都能为幸存者提供归属感，使其感觉自己归属于某种更宏大、本质上更美好的事物。 这种体验可能会指引幸存者找到与自己有同样感受的作者、演讲者或其他的人生旅途中的旅伴，然后为其打开一扇新的大门，让幸存者从其他人身上找到安慰。最终，幸存者甚至能感受到，这世上还有足够美好、安全，并值得与之交往的人。 山河四省很多学校的孩子是没有资格腾出时间和精力来关注自己的。他们甚至连得到一个人独处的空间都十分奢侈。所以初高中注定是一个懵懵的任由自我意志发展的状态，不同孩子的创伤表现也不同。但就我观察而言，高中的高压状态是会强化孩子的创伤的，让孩子压抑更多情绪，带来更多疑惑。 除非你碰到一个好老师。但老师受限于大环境也不能过多干涉。 于是大学四年成了我的心理自愈之旅。期间情绪闪回无数次出现，人格弱点（不成熟之处）被他人无数次利用，吃一堑长一智，渐渐成熟完整。 同时心理学书籍有了少许阅读量(阿德勒+卡伦霍尼)，我也针对母亲和我的共同创伤（大病经历）和她自己的创伤（与我无关的）都有过顺利完成的梳理，为我和她解决了心事（自豪！）。 后来考研期间和高考一样，注意力被“无形的力量”严重干扰，难以学习。我开始主动去认知这种负面能量，接受它的存在并尝试复现。 经过一段时间的自我思考+搜索引擎+AI，终于在“（难以集中注意力”“走神幻想过去的经历”“Thought-chatter ，心智游移 ，自发性思维漫游, 大脑默认模式网络，耳朵虫”等）一大堆名词里，找到了“情绪闪回”。而情绪闪回的相关书籍里，恰好有篇推文提到了《不原谅也没关系》。于是至此完成了一轮浅薄的知识体系闭环。 好了，这就是我治疗情绪闪回的故事。 意识不到创伤→发现自己的脆弱但逃避→开始了解自己认识自己→开始改变自己，矫枉过正，性格的不同面极端化→了解并接受自己的创伤，但知识能力有限→开始反思自己的创伤并治疗→积累心理学知识+阅读量+现实生活阅历。 用一句书里的笔记做结尾：不承认自己对完美主义的追求，本身就是一种完美主义；敢于同情自我并哭泣的“弱者”，才是真正的强者。 “请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐予我智慧，分辨这两者的区别。” 二、对本书感受较深的几个点 遇到问题时判断自我接纳和寻找诱因哪个让自己更舒服。 永远疼爱关心你内心的小孩，察觉到他的呼救 ; 对父母的批评是为了更好的爱父母和爱自己 感恩是自然的，期望自己一直感恩是极不自然的。 期待是批判的种子。 秉持“大事化小、小事化了”原则。闪回(或滑坡谬误)时要思维阻断、思维纠正，保持自我安全感，一旦幻想负面事件及时安抚自己。 急功近利、贪快：对成绩的幻想，对完美的追求期待，预示着未来的自我批判。 不自然的粗糙的原谅是逃避问题作践自己，他人劝你大度也是如此。 警惕毒性羞耻感和完美主义。这两个的表现是被遗弃感和脆弱感。 渴望认可关注→完美主义遗↔弃抑郁↔恐惧和羞耻↔内在批判者↔4F反应 三、我认为的心理学书籍的意义心理学的伟大意义:“认识你自己”→“接受你自己”→“欣赏你自己”→“无条件的爱你自己” 这本书的文学性也很舒服。 心理学、文学、灵修，这些学科的交叉是很有趣的。 再由己及人，由自然到社会，还可涉及到哲学、社会学。 像茨威格、陀翁、王小波、老舍等作家的文学作品里，心理描写能细致入微，离不开对人性心理的洞察力吧？ 这位作者能准确描述cptsd的心路历程，也要具有些语言基础了。对自己了解深入后，又离不开那几样基本问题，这时难免涉及到灵修，关于自我的灵性，人本思想，修行的方向（儒释道）。浅浅的哲学思考也就出来了。 后来只强大自我还不够，还要了解了解身边的家人朋友，以及不同的集体组织的底层逻辑。毕竟他人是自我的一面镜子嘛。所谓“相由心生”，好多对世界对他人的偏见其实是自我的投影。 这就涉及到社会学，还有一些管理者的基本素质了。（说到这，怪不得有门学科叫“社会心理学”，学科交叉是很自然的。）得有点基本的共情能力、换位思考能力，还得超越这些能力不为其左右影响判断。这些能力的锻炼又得涉及大量的乱七八糟的朋友，沟通表达演讲叙事能力又出来了。 （共情能力可真是个天赋+技术活儿。也得练。像写《呼啸山庄》的那个小孩，写《飘》（乱世佳人）的米切尔，都是天赋姐。老天爷喂饭吃的。 拿我自己来说，太容易被眼前的环境局限，看不见远方的人。更看不到上层和下层的同类。实际向下看让自己清醒、知足、悲悯。向上看让自己有目标、有理想。） 诶呦！当个成熟的人太难了！动辄一辈子的课题！就和治疗这情绪闪回、完美主义一样，还不能急，一急就重蹈覆辙，又变脆弱了。 于是心理学又告诉我们，接受你的脆弱。想变成一个成熟的大人，你得先成为一个天真烂漫的孩子。 成熟的标志反而是敢于当个孩子。有趣~ 这些学科基本通识是个认识世界认识人的过程。学起来是个通不了关的好玩的游戏。人的探索欲和好奇心才是最大的生产力啊~ —————————————————— 推荐几本相关书: 1.《我们内心的冲突》卡伦霍妮 2.阿德勒的思想。我看过的有《像阿德勒一样思考和生活》+《被讨厌的勇气》 （第一本日本人写的，第二本好像也是日本人写的） 3.欧文亚隆的书。 4.王小波的书对我的心理也有点治愈作用。 5.毛姆的《刀锋》给我的心理分析提供了素材。 还有一些没看过的书不知道有没有用。。。 《生命之书》克里希那穆提 还有没看过的荣格的书。 四、本书原文摘录（一）内在批判者原因与表现内在批判者的成因诱发闪回的内在批判者通常来自童年时危险重重的家庭。**这种危险既可能是父母在不经意间被动的忽视遗弃，也可能是他们主动的虐待遗弃。**当父母没有提供足够安全的联结和积极的反馈时，孩子就会在焦虑和恐惧中挣扎。许多孩子会仿佛出于“本能地”追求完美主义来适应这些危险的遗弃。在家中弥漫的危险氛围会迫使孩子的超我过度追求完美主义并设想各种危害。 **超我是一种通过学习父母的规则来寻求接纳的心理。内在批判者是变质的超我。它的出现意味着超我在超速运转，想拼命赢得父母的认可。当追求完美主义的努力没能讨得父母的欢心时，内在批判者就会变得越发敌对和刻薄。**它会恶化为一种恶毒的内在声音，越发表现出自我憎恨、自我厌恶和自我遗弃的倾向和态度。内在批判者会不断指责孩子的缺点，因为它觉得这些缺点是父母拒绝孩子的原因，而无法理解真正的问题其实是出现在父母的身上。 对遭受创伤的孩子来说，过度亢奋的交感神经系统会越来越促使其变得过度警觉(Hypervigilance)。 过度警觉是一种对危险过度关注的固着反应，其成因是过度暴露于真实危险之中。为了预测、识别和躲避危险，过度警觉会在孩子的为人处世之道中根深蒂固，它会限制孩子的注意力，使他不断警惕地观察周围的人。它还会经常使孩子焦虑未来，想象即将到来的社交活动中的危险。 此外，过度警觉通常会演变为一种强烈的表现焦虑，从而影响孩子在各个层面的自我表达。正如长时间处于战斗中的士兵会患上PTSD一样，孩子之所以会患上CPTSD，也是因为觉得自己在不断受到攻击。不幸的是，他现在不仅要应对外部攻击，还要遭受内部攻击，被困在过度警觉和交感神经系统亢奋中。 想法也可能触发闪回 孩子如果得不到父母的认可，就会认为自己的观点和感受是不完美的，是危险的。**在最严重的情况下，单是产生说话的冲动就会引发孩子的恐惧和羞耻感，因为他会想到自己一开口就将招致更强烈的责备和更严厉的惩罚。**但是对于一个孩子来说，要说什么话自己才不会被父母认为是愚蠢和无用的呢？ 这里的不完美会导向“被遗弃感”，进而激发潜在的羞耻和恐惧。 完美主义→遗弃抑郁↔恐惧和羞耻↔内在批判者↔4F反应 当持续的忽视或虐待反复强化了内在批判者后，即使是最无害的利己想法或思考也会引发孩子强烈的情绪闪回。 一个简单想法会被孩子内心的那个小人反复的分析打击，降低积极性。 由于孩子心中还有赢得父母认可的虚幻愿望，他的完美主义追求会不断升级，并可能发展为强迫症。在此时，即使是一个想象中的错误也会引发闪回。 内在批判者是内化的父母 常有来访者在面谈时羞愧地忏悔道：“我昨晚反复骂自己是个笨蛋。这一定说明我本质上有问题，因为我母亲从没说过这个词。虽然她很坏，但她从来没有说过脏话，我怀疑她甚至没有听说过这个词。” 之所以会出现这种现象，是因**为内在批判者的批判是一个不断发展的过程，它会收编我们的创造力，并以一种“全新改进后”的方式模仿父母的蔑视。父母的蔑视是造成情绪虐待的关键因素，会使你产生毒性羞耻感。**毒性羞耻感使我们无助地陷于闪回中，是导致遗弃抑郁的情绪基础，也是内在批判者的情绪基调。羞耻感会在情绪上加剧前文的14种攻击，从而侵蚀我们的内心。 毒性羞耻感是在一个无形的社会脉络中攻击我们的，它具有社会性，并能在我们与父母的病态交流中发展出内在批判者。此外，当独自一人陷入闪回的那一刻，我们感觉就像回到了父母面前一样。 对我来说最有力的证据是，当我独自一人试图做一些困难的事情时，如果我犯了错误或没有尽可能高效地完成任务，就会感到非常焦虑，好像正在被监视并受到批评。 我认为出现这种现象是因为我们把父母内化到了自己的心中。父母在我们的成长过程中是无比重要的存在，以至于我们在心理上对他们有强烈的代入感，包括他们对我们的看法和批评。如果不能努力减少他们对我们的影响，内化的父母就会一直存在于我们心中，并成为控制我们生活的关键力量。 应对内在批判者的固执 缩减内在批判者是疗愈过程中最重要的环节之一。父母将内在批判者的“程序”深深烙印在我们心中，我们自己也在不知不觉中模仿父母并将其固化。成年后，我们继续沿袭了父母施加的有害影响，甚至还起到了关键的强化作用。**如果缺乏足够的正念，我们就会通过愤怒和自我厌恶来无数次地重复父母对我们的评判，从而伤害自己。**有效的疗愈需要你不再盲目服从于这种只关注自身消极方面的思维。但转变自我否定的思维模式是一项艰巨的任务，通常需要我们终身的努力，我们往往前进两步又会后退一步，而这后退的一步让人感觉像好多步，非常令人挫败。 完美主义和情感忽视 如前文所述，完美主义也是遭到情感遗弃儿童的一种本能防御反应**。完美主义为弱小无援的孩子带来了方向感和一定的意义感。追求完美让他获得了一丝控制感，而进行自我控制也让他感到更安全**，因为有遗弃行为的父母通常会用严厉的手段惩罚忍不住表达不满的孩子。但是因为完美永远达不到，这些孩子便不知放弃地努力，直至失败迫使其退至解离性的僵反应或反社会的战反应。 由于对完美的追求总是失败，且仍然难以获得父母的认可和关怀，所以孩子逐渐认定“不完美”就等同于羞耻感和恐惧。孩子会认为自己“不完美”，引发对被遗弃的恐惧，进而引发对“不完美”自我的厌恶，使父母的遗弃延伸为自我遗弃。这反过来又进一步增强了恐惧，并加剧了自我厌恶，最终让孩子陷入恐惧和抑郁（包裹着羞耻感）的恶性循环。 这种情况可能持续数小时、数天甚至数周，对于那些患有严重CPTSD的人来说，这甚至可能成为他们的常态。 再谈危害设想 内在批判者的危害设想会对幸存者产生深远的影响。我有许多进展良好的来访者，他们已经相对克服了完美主义，但仍然忍不住预想潜在的危险，为此深受困扰。换言之**，很多幸存者在很大程度上消除了完美主义式的自我攻击思维，却没有意识到自己的脑海中仍然充斥着令人恐惧的想法和画面。** 永久的遗弃、公开的羞辱、致命的疾病、孤独的死亡、迫在眉睫的攻击、身无分文的流浪，这些是许多幸存者设想的危险主题。我的一位来访者这样形容他的设想危险的内在批判者的角色：“我的内在批判者是一位恐怖电影制片人。”对我自己来说，我花了很长时间才学会不再执着于对痛苦和危险的想象，这远远超过了摆脱完美主义所花的时间。事实上，我非常善于把这些想象幻化为一部关于自己即将死亡的长片。 如果让我描述内在批判者两个最关键的运作过程，我会这样说：首先，这是一个极度关注负面并且不断自我延续的过程；其次**，这是一种持续的过度警觉，为了应对自认为随时可能发生的灾难而全力防守。** 解决方法：思维替换、思维纠正、思维阻断 思维阻断 利用愤怒对内在批判者进行 我强烈建议幸存者通过愤怒来阻止内在批判者的攻击，并借助战反应来更有效地对内在批判者进行思维阻断。我们必须从批判者那里夺回愤怒，并强制将其转向内在批判者，而非自己。然后，我们可以通过在心中默念“不！”“停下！”或“闭嘴！”来缩短极端化和完美主义的心理过程。 愤怒地对内在批判者说“不”，便能够在内心设立一个界限，反对不自然、反自我的过程。它是自我“翻新工程”中的一部分，帮助我们重建自我保护的本能。此外，将愤怒导向那些造成我们发展出内在批判者并将其留在我们体内的人，有助于强化疗愈效果。 内在批判者会创作出最可怕的恐怖电影，其中的主题包括意外、生理疾病、绑架、精神疾病、恋母情结式的背叛等。如果我不懂得如何识别、解释和拒绝这些极端化想象，我与儿子的亲密联结必定会受到严重影响。而如果我想要进一步摆脱内在批判者，单凭思维阻断还不够，我必须借助愤怒的力量，让这个方法更强力、有效。 我特别喜欢用这样的话语来挑战内在批判者：“我不再害怕你们了，爸爸妈妈。你们就是那些毒性批判背后的始作俑者，是你们把内在批判者放在了我心里。我要抛开你们那些有‘毒’的话语。快把你们对我的羞辱和厌恶拿走吧。我对你们可耻的养育方式感到厌恶。”有位来访者与我分享了她在家中与内在批判者斗争时想到的一句话：“你彻底毁了我的童年，现在我不会再让你毁了我的生活。”她告诉我，这个观点已经印刻在她的意识中，现在经常帮助她对抗内在批判者。 思维纠正 （完美主义型攻击） 1.完美主义 【思维纠正】我追求完美主义是为了在危险的家庭中获得安全和支持。完美是一种自我迫害的幻想。我现在不需要完美就能获得安全和爱。我会放弃那些要求我做到完美的关系。我有权犯错。犯错并不会使我成为一个“错误”。每个错误或意外都是一个机会，让我在未得到爱的方面练习爱自己。 2.“全或无”和非黑即白思维 【思维纠正】我拒绝极端化或过于笼统的描述、判断或批评。一个意外的负面事件并不意味着我会永远失败。用“总是”或“从不”这类语言描述我通常都有失偏颇。 3.自我憎恨、自我厌恶和毒性羞耻感 【思维纠正】我会忠于自己，站在自己这一边。我是一个足够好的人。我拒绝谩骂自己。我会把羞耻感转变为责备和厌恶，回击给那些羞辱我正常情感和缺点的人。只要我没有伤害任何人，就要拒绝因正常的情绪反应（如愤怒、悲伤、恐惧和抑郁）而受羞辱。此外，我尤其拒绝因难以完全消除自我憎恨的习惯而攻击自己。 4.微观管理、担忧、执念、循环、过度忧虑未来 【思维纠正】我不会一遍遍地重复检查细节，不会直接下负面的结论，也不会无休止地怀疑自己。我无法改变过去，所以我原谅自己过去犯下的所有错误。我无法保证未来完全安全，所以我不再担忧未来可能会犯错。我不会试图控制无法控制的事情。我不会对自己或他人进行微观管理。我会以一种“足够好”的方式工作，并接受“努力未必总有成效”这一现实。 5.与他人或自己最完美的时刻进行不公平或贬低性的比较 【思维纠正】我拒绝将自己与他人无端进行比较。我不会将“我的内在与他们的外在”进行比较。我不会因为自己没有一直处于最佳状态而批判自己。在这个迫使我们一直表现出快乐的社会中，我不会因为心情不好而对自己失望。 6.内疚 【思维纠正】感到内疚并不意味着我有过错。我拒绝出于内疚而做出决定和选择。有时我需要在感到内疚的同时依然照常行事。当我不可避免地无意伤害了某人时，我会道歉、做出补偿，并停止内疚。我不会一次又一次地道歉。我不再是一个受害者。我不会接受不公平的指责。内疚有时是伪装的恐惧，请对自己说：“我感到内疚和害怕，但我并没有错，也没有危险。” 8.精力过于旺盛、停不下来、工作狂 【思维纠正】人不是为了工作而存在的。我不需要永远保持高效。从长远来看，当我在工作与休闲娱乐之间实现平衡时，我的效率会更高。我不会试图一直保持全力工作的状态。我认为效率有高低波动是正常的。 7.“应该” 【思维纠正】我会用“想要”这个词来代替“应该”，并且只在我觉得想要这样做时才遵循这一点，除非我有法律、伦理或道德上的义务。 9.对自己或他人进行苛刻评判、人身攻击 【思维纠正】我不会认同童年时的霸凌者和内在批判者，我不会让他们得逞。我拒绝攻击自己或虐待他人。应该受到批评和指责的是我那糟糕的父母，我不会把这些批评和指责转嫁给我自己或身边的人。“我关爱自己。我越是孤独，越是没有朋友，越是没有支持，我就得越尊重我自己。”——《简·爱》 （设想危害型攻击） 10.极端化、灾难化、疑病症 【思维纠正】我虽然感到害怕，但身边其实并不存在危险。父母并没有要惩罚我。我不会把事情夸大。我拒绝用生活会每况愈下的设想来吓唬自己。我不会再自己构想恐怖电影场景和灾难片情节。我不会把每一次疼痛都想象成自己快要死了。我一切安好。 11.负面关注 【思维纠正】我不会再过度注意和纠结于自己的缺点或生活中可能出现的问题。我不会轻视或忽视自己的品性。现在我会关注、设想和列举自己的成就、才能和品质，以及珍视生活给予我的许多礼物，例如自然、音乐、电影、美食、色彩、朋友、宠物等。 11.负面关注 【思维纠正】我不会再过度注意和纠结于自己的缺点或生活中可能出现的问题。我不会轻视或忽视自己的品性。现在我会关注、设想和列举自己的成就、才能和品质，以及珍视生活给予我的许多礼物，例如自然、音乐、电影、美食、色彩、朋友、宠物等。 12.时间紧迫感 【思维纠正】我没有危险，不需要赶时间。除非是真正紧急的情况，否则我不会着急。我正在学习享受以轻松的节奏进行日常活动。 13.让人失能的表现焦虑 【思维纠正】我会提醒自己不接受任何人不公正的批评或完美主义式的期望。我不会因为害怕批评或失败而拖延时间。我不会让恐惧左右自己的决定。 14.总觉得自己要被攻击 【思维纠正】除非有明显的危险迹象，否则我将使用思维阻断，停止将过去的霸凌者或内在批判者投射到别人身上。生活中的大部分人都是平和友善的。如果被少数有敌意的人威胁，法律会保护我们。我会想起朋友的爱和支持。 思维替换 许多年前，我感觉自己的内在批判者就像健美运动员反复锻炼出的肱二头肌一样强健。我当时猜想，如果用同样的方式针对内在批判者进行自我保护意识的训练，应该也能增强思维纠正的“肌肉”。事实确实如此，现在，**每次闪回几乎总能自动激起我的自我保护的本能。**不夸张地说，无数次积极的思维替换使我获得了“友善待己”的心理状态，而且这种状态还相当稳定。 我鼓励你立即用积极想法（如本章开头罗列的那些）来对抗内在批判者的消极想法。这在CPTSD的疗愈过程中是至关重要的，因为如果不去对抗毒性思维，它就会像病毒一样失控地传播感染，使你产生羞耻、恐惧和无助的复杂感受。 我们在闪回时快速进行思维替换或思维纠正，往往可以削弱内在批评者的动力，从而避免陷入闪回的恶性循环。这在对抗内在批判者的过程中非常重要，因为内在批判者一旦获得了动力，通常会更凶狠地攻击我们。在这些时候，内在批判者会虚伪地蔑视我们，使我们在“本可以”避免的情况下又陷入自我批判，而“这时正是最需要思维纠正而非自我指责的时刻”——我的前实习生经常对来访者说这句话。 此外，我鼓励你做一份列表，把自己的积极品质和成就都写下来，当迷失在自我憎恨中时，你就可以把这份列表读给自己听。 思维替换还涉及到正念冥想等。 总结①关于思维阻断、思维纠正、思维替换 1.思维阻断（Thought Stopping） 核心作用：快速中断负面思维的循环，防止其持续恶化。 操作方式：通过“暂停”或“打断”机制（如默念“停止”、深呼吸），阻断消极想法的自动涌现。 适用场景：应对突发的灾难化思维、强迫性担忧或情绪闪回时的即时干预。 示例：当发现自己陷入“我永远无法改变”的自责时，立即用“停！”打断，转移注意力到呼吸或具体任务上。 2. 思维纠正（Cognitive Restructuring） 核心作用：修正扭曲的认知模式，建立更客观的思维框架。 操作方式：识别不合理信念（如“必须完美”“过去无法改变”），用事实或理性分析替代（如“接受不完美是成长的一部分”）。 适用场景：长期调整根深蒂固的负面思维模式（如自我批判、过度担忧未来）。 示例：将“我必须控制一切才能安全”改为“我能控制的是自己的反应，而非结果”。 3. 思维替换（Cognitive Reframing） 核心作用：用积极或中性思维替代消极内容，重塑认知视角。 操作方式：主动引入与负面思维相反的积极陈述（如“我已尽力，足够好”），或转换看待问题的角度（如将“失败”视为“学习机会”）。 适用场景：缓解即时情绪困扰，培养自我关怀的思维习惯。 示例：面对“我一无是处”的念头时，用“我有独特价值，值得被接纳”替代。 关键区别总结 工具 目的 操作时机 长期效果 思维阻断 立即中断负面思维 突发性消极念头时 短期情绪缓冲 思维纠正 修正认知扭曲 日常反思与练习时 建立理性思维模式 思维替换 转换思维内容与视角 情绪波动时主动干预 培养积极自我对话习惯 书中实践提示：思维纠正常结合“尼布尔祈祷文”（接受无法改变的，改变能改变的）作为核心工具；思维替换则通过记录积极品质清单等具体行动强化自我认同。三者常协同使用，形成“阻断-修正-重塑”的完整认知干预链条。 ②关于羞耻感与完美主义 羞耻感：对自己的不公指责 伟大的心理学家爱利克·埃里克森(Erik Erikson)认为：羞耻感是对自己的指责。童年时，我们的父母太过强大，我们无法指责他们，因此只能责备自己。但如今我们已经摆脱了父母，并且可以将不公平的自我责备重新指向父母，从而切断羞耻感的来源。你可以将自我批判中的愤怒转向那些将内在批判者置于你心中的人，或者转向内在批判者本身。你可以对父母霸凌你时的形象感到愤怒和厌恶，从而把羞耻感还给他们。你还可以怒斥他们在你年幼弱小还无法自卫时用羞耻感来压迫你的行为。 在早期的疗愈过程中，我们需要竭尽所能，不断挑战内在批判者对消极面的单一关注。通过练习，一部分自我最终将会对父母不公平的霸凌和冷漠感到愤怒，对长期被灌输的自我虐待和自我遗弃的观念感到愤怒。我们还会因为事发时太过年幼而愤怒，那时的我们无法抗议，甚至不知道自己身上发生了什么。 我们可以逐渐培养自己说“不”和“闭嘴”的能力，在内在批判者攻击我们时勇敢拒绝。当有了足够、积极的内在自我保护能力时，我们将逐渐学会不再无意识地自我虐待和自我遗弃。健康的自我保护意识将开始形成，并逐渐发展为一种强烈的意愿，想要阻止一切不公平的批评，无论是来自内在还是外在。 从心理学的角度讲，这是破除强迫性重复的一个环节。破除强迫性重复包括内外两个层面。在内部，我们通过坚定地对抗内在批判者，来克服重现父母虐待行为的习惯。 这样一来，我们也会在外部更加留意其他人（类似我们父母）的虐待行为，并且与他们对抗，让他们停止虐待，或把他们驱逐出我们的生活。通过足够的练习，我们可以切断父母遗留下来的可怕影响，不再认为爱是麻木地接受虐待和忽视。” 解决问题的关键在于思考的视角。**你是为了自己好而寻找诱因，还是为了挑自己的错？**如果是后者，那么你最好还是放弃寻找诱因，改为寻求自我接纳，因为总有一些诱因是难以查明的。当控制闪回的努力夹杂了大量对自己的气恼和失望时，我们需要用自我接纳来替代这种努力。自我接纳有时应该超越“把一切都弄清楚”的冲动。 完美主义 随着父母批评的持续性加强，有关自我憎恨和自我厌恶的神经通路会扩张为复杂的大型神经网络，成为主导孩子心理活动的内在批判者。 内在批判者的消极视角生成了许多关于自我厌弃的完美主义“程序”，使孩子时时自危，不断地小题大做。 最终，只要孩子想进行真诚或脆弱的自我表达，就会激活自我厌恶的内在神经网络。孩子被迫生活在一种自我攻击的不健康状态中，并最终彻底抛弃了自我，完全失去自我支持和自我保护能力。 在虐待“洋葱”的言语层和情绪层之下，还有许多更细的“最小化”层，扭曲地否认虐待。 一个充斥着言语虐待和情绪虐待的童年迫使孩子如此彻底地认同批判，仿佛批判就是他全部的自我一样。摒弃对批判的认同，循序渐进地将神经系统从批判者主导的状态中解放出来是一场持续终生的斗争。在这场斗争没有取得一定的胜利之前，自我(Ego)很难得到健康有益的发展,即发展停滞。 发展停滞的健康自我这里所说的自我(Ego)有别于日常普遍的用法，并非形容一个人自私，它并不是一个贬义词。 在心理学中，自我(Ego)一词代表“自我意识”或“我的身份认同”。 健康的自我(Ego)是一个对自身友好的心灵管理者。不幸的是，导致孩子患上CPTSD的父母会破坏孩子自我同情和自我保护意识的形成过程，而这些关键的自我过程无法正常发展，则会阻碍自我(Ego)的成长。 每当孩子自然而然地想要同情自己或为自己挺身而出时，那些病态的父母便会对孩子进行羞辱和恐吓。 于是，孩子照顾自己和保护自己免遭不公的天性就会被迫休眠。 久而久之，孩子会愈发认同自己内在批判的声音，其超我则会蜕变成一个专横的内在批判者，凌驾于健康自我(Ego)之上。 “因此，我多年来都在刻苦地练习展现自己的痛苦的能力。起初我只能偶尔做到，因为我太习惯童年时默认的处理方式了：每当处于“混杂的被遗弃感”中时，我就会用物质或讨好他人来掩饰或伪装。但后来，我日益反感这种由病态的关系依赖导致的社交完美主义，这反而使我获得了加强练习的力量。现在我知道摆脱孤独的唯一方式，就是冒险看看那些我信任的人是否能接受我的全部，而不只是闪光点。 最小化，是幸存者故意淡化童年创伤的防御机制。 去最小化(De-Minimization)是一个对抗否认的重要方法，对童年创伤的影响“去最小化”是一个持续终生的过程，这个过程就像剥开一个光滑辛辣的洋葱。 “洋葱”来形象地说明童年复杂创伤的三层含义： 层层包裹的结构 • 表层是可见的躯体虐待或明显事件；中层是言语、情感和心理上的虐待；核心层则是持续的情感忽视与遗弃。这些层次像洋葱一样层层相扣，必须按顺序、耐心地剥离，才能真正看见伤害的根源。 逐步揭示的过程 • 在疗愈过程中，人们往往先意识到最外层的事件，随着安全感增加，才开始觉察更深层的言语和情感虐待，最后才直面核心的情感忽视。每剥开一层，都会引发更强烈、也更真实的痛苦，但同时意味着离真相和修复更近。 对抗否认与“去最小化” • 许多人会本能地把伤害“最小化”，用“别人更惨”之类的理由说服自己没事。作者把这称作“洋葱的防御层”，提醒读者通过“去最小化”一层层拆解否认，直到愿意直视自己的真实感受。 情感体验的转折 • 正如剥洋葱时常伴随辛辣泪水，疗愈过程中的痛苦也会反复涌出：先苦涩，因为真相残酷；后甜蜜，因为痛苦被承认、责任被归位；再苦涩，因为意识到伤害发生得如此频繁；最终又转甜，因为泪水象征着自我同情和幸存者的坚韧。 拥抱内在批判者 根据我的经验，在战反应基本恢复之前，认知疗法、心理动力学疗法或正念疗法这类鼓励接纳内在批判者的方法对CPTSD幸存者的帮助不大。而在后期的疗愈过程中，当幸存者拔除了内在批判者的毒刺后，这些方法则可能有相当大的价值。只有到了那时，我们才能重新从健康的自我批评中获益。**有一个典型的迹象能够说明内在批判者已经变得柔和而有益，那就是它会以一种亲切助人的声音对我们说话。当我们能够且应该做得更好时，它会冷静地提醒我们调整自己的行为。然而，如果它因为我们的不完美而责备我们，就暴露了它其实仍然是父母置于我们心中的毒性批判。**用左脑客观地拥抱内在批判者通常起不到帮助的效果，除非它与右脑主观的坚定自我保护相平衡。这也许是因为内在批判者与高度感性的右脑共同支撑着情绪闪回，也许是因为有毒的内心批判过程过于情绪化，以致理性和冷静的抵制太过微弱而无效。 （二）外在批判者CPTSD的批判者包括内在批判者和外在批判者，两者都是你心理活动的一部分。外在批判者与破坏自尊的内在批判者相对应，内在批判者认为自己有缺陷且没有价值，对自己采用完美主义和执行危害设想“程序”，而外在批判者则认为他人有缺陷且没有价值，将同样的危害设想“程序”作用于他人。当外在批判者掌控你的思想时，你会觉得他人看起来非常可怕、危险、没有价值和难以信任。 有些幸存者在大幅减少了自己的主要批判者后，往往会更受另一种批判者的影响。 当我意识到这一点时，感到失望而震惊，因为此时我正庆幸自己的内在批判者已逐渐缩减。此后不久我就注意到，自己被一种全新的对他人评头论足的感觉（外在批判者）所困扰，而这似乎不符合我的性格。 这个批判者就是外在批判者。 原因儿童最初不敢对父母的虐待或忽视做出愤怒的反应。除了战类型的儿童之外，大多数遭受创伤的儿童在很早就知道，对父母的不公平对待提出抗议是一种不可原谅的罪行。他们一般被迫压制自己的抗议和抱怨，这就使他们将愤怒默默藏于心中。然而这种愤怒并没有消失，它们不断汇集成怨恨的汪洋，滋养着执着于寻找他人错失和危险性的外在批判者。 外在批判者会从被父母遗弃的视角来看待所有关系，并且从不放松警惕。它不断地将未释放的童年愤怒转移到他人身上，夸大当前的失望，并默默地将他人作为替罪羊。幸存者如果在情绪闪回中进入了外在批判者模式，就会把他人无足轻重的过失作为借口，长时间陷入对他人评头论足式的思维中，并在心中默默发怒和抱怨。 用伊丽莎白·芭蕾特·布朗宁(Elizabeth Barrett Browning)风格的话说就是：“你是怎样地不完美？ 外在批判者与亲密关系 如前所述，CPTSD通常包括依恋障碍，这种依恋障碍源于童年时缺乏具有同情心的照料者。当发展中的儿童得不到父母的支持和庇护时，他就永远无法学会让他人帮助抚慰自己的孤独和痛苦，也永远不知道真正的亲密关系来源于分享自己的所有体验。如果我们的照料者因为我们表现出脆弱而攻击或遗弃我们，那么我们之后就会不愿再真诚地表达自我，而这种自我表达正是建立亲密关系的基础。 外在批判者恐吓我们，所有人都必定和我们原来的照料者一样危险。潜意识中我们记得自己因寻求父母的支持而遭到父母的蔑视，这样的记忆打消了我们分享困扰和寻求帮助的意愿。更糟糕的是，当我们表现出自己的弱点时，遭到攻击的幻想会困扰我们数小时甚至数天。 我曾经历过这种情况，当时我因为求职而接受了八位面试官的面试，而我表现得非常诚实，并展现了自己的脆弱面。后来我连续失眠了三个晚上，我的外在批判者不停地播放画面，展示着面试官对我所说的一切都感到轻蔑，并对我遗漏内容感到不满。甚至在对方热情地雇用我之后，我的外在批判者还在用冒充者综合征来困扰我，幻想着我最终会无法胜任新工作。 表现在外在和内在批判者之间切换许多CPTSD幸存者挣扎于严厉的批判之中，在病态化他人（外在批判者的毒性指责）和病态化自己（内在批判者的毒性羞耻感）之间来回切换。他们陷入无休止的循环中，反复细数与他人关系的欠缺和自己的不足。 卡伦·霍妮(Karen Horney)这种创伤的双重机制描述为：在浮夸的自我和受鄙视的自我两极之间摇摆的“全或无”思维。 当我们迷失在这个过程中时，会错过体验归属感这一重要情感需求。我们永远生活在疏离感中，总是处于两种极端之间：要么觉得自己太优秀，别人都配不上我们，要么觉得自己太不讨人喜欢而不接纳自己。 这就是有着雅努斯面的批判者令人痛苦的社交完美主义：别人有太多的缺陷，不值得我们去爱；而我们自己也有太多的缺陷，不值得被爱。 从外在角度出发分析 因为想要逃避由社交触发的“危险”感受，所以外在批判者的评头论足模式被激活。即使是与他人交往的想法也会激发幸存者的反对“程序”，从而让他感到有理由孤立自己。然而，长时间的退缩会重新唤醒他对人际关系的渴求，以及与他人联结的冲动，也会同时使批判者由外在模式转变为内在模式。于是内在批判者会开始清算幸存者的不足，让幸存者相信自己对别人来说太可憎了，因此无法与人社交。随之产生的是自我怜悯式的被害幻想，最终重新吸引外在批判者来佐证他人的可怕……如此不断地循环往复，使幸存者“安全”地躲藏在沉默的自我疏离中。 从内在角度出发分析 幸存者消极的自我关注会促使他力争完美。他为此非常努力，不懈工作，以致开始怨恨那些不努力的人。**一旦怨恨积累到一定程度，他人的一个小失误就会触发他的内在批判者变为极端的外在批判者，充满对他人的失望和沮丧。然后，他会默默执拗地清算人们所有的缺点和背叛行为。**他停留于极端的外在批判者状态的时长通常取决于他的4F反应类型，但他迟早会再次感到内疚，内在批判者又会突然发作，严厉地批评他对别人评头论足。然后，他又开始认真细数自己的缺陷。 下述情景是一个在闪回中忧虑的典型例子。 我和妻子已共同生活十多年了。我们花了很大的功夫，协商出了一种（大多数时候）对彼此公平且灵活的方式，来处理家庭和育儿过程中的无数琐事。 但有时，当我经历了长时间的闪回后，我还是会过度关注家庭秩序中的不完善之处。内在批判者指责的方面每次都有所不同。如果我进入疲惫的求生状态，内在批判者就会指责我没有对家庭做出应有的贡献。而如果我开启逃反应模式，并且在家里大搞卫生，我的外在批判者就会开始斤斤计较。 在后一种模式下，我的外在批判者会坚持认为妻子比我做的少得多。（这些比较通常是关于我最近在家庭里过度贡献的那些方面。）但是我的讨好倾向相当强烈，没过多久我的内在批判者就开始关注到那些我贡献没有她大的方面。突然间，我就成了家中自私的懒鬼。随着闪回的继续，我可能会转而责怪自己的挑剔和狭隘。但在特别强烈的闪回中，外在批判者迟早会回归，并开始对我贡献的分量和重要性给予更多的肯定，然后贬低妻子，说她懈怠、不思进取、自以为是等。 思维替换与思维纠正挤走外在批判者我们中的许多人在引导自己去关注他人和生活中美好的、值得信赖的、可爱的东西方面，依然处于发展停滞状态。在努力缩减外在批判者的过程中，思维替换能够从脑海中“调用”关于他人的积极想法和画面，从而消解外在批判者对他人的严厉批评，以免这种习惯性的批评破坏亲密关系。 一种有效的思维替换练习是：列出和某位朋友之间五个积极互动的回忆，以及这位朋友的五个美好品性。 这个练习应用在自己身上时也很有效，可以帮助我们摆脱内在批判者建立的消极自我形象。约翰·戈特曼的研究表明，保持这个正负比例是拥有和谐亲密关系的共同沟通特点。这一点很关键，因为外在批判者是童年时由父母的示范作用催生出来的，而父母在给予反馈时的比例至少是“五负一正”。 用“我尊重你的选择”替代“我为了你好”式控制。 （三）讨好型人格“我将基于创伤的关系依赖症定义为一种自我否定与自我遗弃的综合征，它表现为基于恐惧而无法在关系中表达权利、需求和界限。它是一种丧失自我捍卫能力的障碍，其特点是战反应处于休眠状态，且容易受到剥削、虐待或忽视。” “这些失去自我的现象刚开始出现时，孩子还没有完全学会说话，当然也还不具备洞察力。对于正处于关系依赖症萌芽阶段的儿童，一切危险的暗示都会立即引发他们的奴性行为，让他们放弃自身的权利和需求。这种反应模式深深地烙印在他们心中，以致于很多关系依赖症患者成年后会像狗一样自动对威胁做出反应，仿佛在满地打滚、摇尾乞怜，希望得到一点怜悯和偶尔的残羹剩饭。《韦氏词典》对“讨好”的第二个定义是：“（指狗）通过舔手、摇尾巴等表示友好。”可悲的是，有些关系依赖症患者就像狗一样忠于自己的“主人”，哪怕那些“主人”极其恶劣。” 这类孩子通过日益深陷解离状态来逃避恐惧。他学会了让父母的言语和情绪虐待“左耳进右耳出”。那些后来患有关系依赖症的幼童“明智地”放弃了战、逃和僵反应，而是学会了讨好父母，让自己显得有用，从而获得些许的安全感。 早熟的他们发现，只要能为父母提供各种帮助，就能换来零星的安全感。讨好、谄媚和被奴役成了他们的重要生存策略。他们巧妙地放弃了所有可能给父母带来不便的需求，不再提出不符合父母偏好或可能激怒父母的意见，放弃了各种自我界限来讨好父母，但父母亲并没有尽责地照顾他们。孩子往往会变得“父母化”，并尽可能地为父母提供帮助。 讨好-僵： 由于讨好类型和僵类型的人都非常被动，又倾向于极度自我否定，并且他们通常在幼儿阶段就因坚持自己的主张而遭到了较多的惩罚或拒绝，所以他们中的许多人最终都会沦为替罪羊。 最糟糕的是，讨好-僵类型的人很容易被战类型的人识别出来，并沦为其俘虏。于是这一类型的人可能成为受气包，甚至遭受家庭暴力。大多数讨好-僵类型的人，如果无法在童年时期摆脱替罪羊的角色，成年后同样会成为受害者。 这些受害者有时甚至意识不到自己正在遭受虐待，甚至还会责备自己（就像童年时那样）。许多讨好-僵类型即便愿意努力疗愈，也只是做出象征性的努力。他们往往被迫彻底放弃了自我保护本能，从而陷入心理学家所说的习得性无助(Learned Helplessness)。 关于暴力循环周期的研究表明，许多自恋型施暴者懂得在合适的时间用合适的方法，在受害者即将离开时给予些许的浪漫。这些施暴者往往是上一章中描述的“迷人的霸凌者”。霸凌者偶尔的小恩小惠，比关系依赖症患者在原生家庭中获得的一切都更温暖，所以受害者很快就会重新上钩，虐待的循环也会马上重新开始。值得注意的是，许多迷人的霸凌者在求爱阶段也会短暂地大献殷勤，但一旦追求成功，这些殷勤也就消失。 讨好-逃（强迫症）： 有些讨好-逃类型的人会把他们的完美主义投射到别人身上，充当别人的人生导师，把自己的意志强加于人。 然而，讨好-逃类型的人应该明白，关心他人有时并不意味着要帮他人解决问题，特别是当我们试图帮助那些痛苦的人时。 很多时候，人只是需要找到同情、接纳和口头宣泄的出口，而且一些情绪状态确实需要时间来化解。当人心情不佳时，对他的爱就是一种强有力的关怀。 这也意味着讨好-逃类型的人要接受他人的不完美。每个人都存在一些难以改变的局限性和缺陷。我们不应该给所爱之人施加压力，让他们去解决无法解决的问题。我的做法是，让对方自愿选择是否接受我的建议。因此，我会尽量避免反复唠叨。此外，我通常会先确认一下对方是否真的想要一些反馈意见。 讨好-战： 以上两段建议也适用于许多讨好-战类型的幸存者。他们中的一些人在试图帮助别人时可能非常具有攻击性。他们通常将帮助等同于改变，并坚持不懈地迫使别人接受他们的建议，最终反而使对方疏远了自己。 讨好-战类型的人惯用的照顾方式充满了令人窒息的爱。他们过度关注被照顾的一方，这有时是在重复扮演他们童年时的服务角色。此外，他们给予的帮助通常比上一章提到的战-讨好类型的人更无私。尽管如此，他们过于热心的照顾有时真的会让对方感觉窒息，正如他们所说的：“我爱你爱得要死。” 讨好-战类型的人在处于闪回时，可能会将对他人的照顾恶化为操纵甚至是胁迫。那种令人窒息的爱可能会强迫对方去符合他的预期。当对方拒绝他的建议或回避强加的照顾时，讨好-战类型的人可能会极为受挫，进而爆发。他们有时会觉得自己有权以“为了对方好”的名义而惩罚对方，特别是当处于主要关系中时。 讨好类型的人需要明白，当他们担心自己不去讨好就会遭到攻击时，会放弃自己的界限、权利和需求。了解这一点是康复的必要条件，但不是充分条件。许多关系依赖者虽然意识到了自己放弃自我的倾向，但真的到了需要在关系中表达自我时，他们又会把一切抛在脑后。 （四）不正常的原谅有些朋友(包括我自己)因为受到“要原谅并忘记”、”要大方大度包容”类似观念的巨大压力，会否认自己所承受的创伤，或将其“最小化”。于是，他们的内在批判者继而也再度诋毁他们是如此不宽容，而他们的疗愈之旅则戛然而止。 “事实上，当人过早地在认知层面决定原谅时，通常就无法实现真正的原谅。因为过早的原谅是在模仿否认和“最小化”的防御机制，让人意识不到这是对未被处理的创伤的愤怒和痛苦。” 真正的原谅真正的原谅与过早的原谅全然不同。 真正的原谅大多是有效哀悼的结果，如果不进行大量的情绪疗愈工作，再多的想法、再强的意图或信念都不能实现真正的原谅。 另外，那些不相信原谅的信念系统有时会阻碍我们获得原谅的感觉，即便在这种感觉出现时也是如此。 关于原谅，最健康的认知态度可能是：一边进行大量的哀悼，一边允许原谅自然地出现。这种态度若要发挥出最佳的效果，必须符合一个条件：不强迫或假借原谅的感觉，来掩盖未被解决的伤害或愤怒。 需要再次强调的至关重要的一点是：在充分消除由父母的虐待和遗弃造成的创伤性影响之前，我们不要急于替他们辩解。 在考虑父母情有可原之处时，我们有时会“明白”父母在很大程度上也是受害者，因此我们可能会为他们感到难过。当这种对父母的同情变得足够深刻时，我们会理解他们的童年也和我们的一样糟糕和不公。这种对父母基于感受的理解有时会演变为对他们的原谅。 然而，这种对父母的原谅如果不是以自我同情为基础的，那么它就只是一种空洞的思维运动，甚至更糟的是，它可能会极大地阻碍疗愈所需的基本愤怒训练。 过早的原谅会使我们无法告诉自己的内在小孩，他有权利为父母无情的遗弃感到愤怒，还会阻止我们帮助内在小孩表达和释放那些旧时的愤怒情绪。过早的原谅也会阻碍我们与自我保护本能的重新联结。幸存者可能永远不会知道，在必要的情况下，现在的自己可以利用愤怒来阻止当下的不公。 真正的原谅是一种感受，它和其他所有感觉一样，都是短暂的。原谅的感觉从来不是完整的，也不是永恒的，更不是一成不变的。原谅是由人类感受的动态性决定的。我们的情绪体验是一个经常变化、无法选择且不可预测的心理过程，没有一种情绪状态可以永久持续。 尽管这很可悲，尽管我们很想否认这一点，尽管这一直让我们感到沮丧，尽管我们受到外界的压力想要控制并选择自己的情绪，但动态性仍然是一种人性的必然，不以我们的意志为转移。 原谅是一种爱的感觉。 原谅就像爱一样，是一种暂时的感觉体验。 然而，当我们彻底宣泄出对过去的愤怒时，我们就更容易感受到原谅。当我们学会通过哀悼把自己带离被遗弃的闪回时，我们就会重新获得对世界的归属感和对世界的爱。 随着我们的情绪弹性变得更成熟，失去的爱和原谅的感觉便会踏踏实实地回归，成为我们自主选择的价值观。因此，当我偶尔感到被亲密的对象伤害时，我可能无法立即唤起对他们的爱或原谅，但我知道，只要经过充分的沟通和非虐待性的宣泄，我最终会重新欣赏他们。 **我能原谅自己多少，就能原谅别人多少。我对别人的原谅之处，就是我自己以前感到的痛苦之处。**多年来，我因自我憎恶而感到脆弱，但现在我爱它、接纳它，对待它像对待一只折翼的鸟。羞耻感和自我憎恶不是因我开始的，但我由衷地希望它们终结于此。我希望别人如何对待我，我就先如何对待自己。","tags":["心理学"],"categories":["读书"]},{"title":"一个ADHD智力代偿者的自救","path":"/2025/11/06/一个adhd智力代偿者的自救/","content":"目录： 1.症状 2.自救：感性的创伤疗愈和理性的学习方法论。 ​ 2.1 走神：广度遍历优先 ​ 2.2 创伤：情绪闪回、内在批判者 3.感想 4.参考 1.症状先来了解adhd的概念： 这里来自BiliBili@阿卡迪萨 这类人的广度运算要更便宜，但深度运算更贵。并且在各种时间都能进行无意识的广度运算。主动注意力运算比较昂贵，但被动注意力运算比较便宜，往往会聚焦于脑内视野内浮现的高价值目标，而不是被外界认为的高价值目标。 添加图片注释，不超过 140 字（可选） (图中圆圈是注意力) 添加图片注释，不超过 140 字（可选） 关于我自己： 我是一个极容易走神的人，但同时我还有“超专注“现象。以前我完全无法解释，甚至认识不到这种现象。这导致我的学习过程走了很多不得不走的弯路。 所以我选择以“走神“为线索串起学习过程。 我的学习道路可分为以下几个阶段： 阶段 表现 小学初中 无意识的学习，没有学习方法论，一切出自本能。课程知识逻辑链条短，即使走神也能靠看书补回来。 高中 无意识的学习，几乎忽略不计的学习方法论。课程知识逻辑链条长，走神以后很多板书和稀碎知识点补不回来。 大学 形成了对学习的基本认知，但仍然是被动的、不成系统的。没有外部强制，走神更严重。方法论仍是碎片化的。 考研 知识量大。需要反复学习新的知识。为了稳定效率，开始有意识的思考学习方法论和认知。开始着重观察分析走神。 我走神的症状： 1.一旦大脑命令自己主动专注，就一定会分心到毫无关联的事情上。导致专注力带宽永远无法到80%以上，一定有一部分要分心。 如： 高中晚自习小测时，脑海会想起自己和朋友篝火晚会；会想象自己唱歌；会响起流行音乐;会想起自己过去丢人的事，未来的失意得意。 想要做题必须带着这种“第二个画面声音”去思考。即使慢，也不得不接受。因为越想消灭对抗TA，TA会越强大。 2.当我上讲台向他人表达自己时，会分出第二个上帝视角，去评判自我，分析自我。 这是感性的一部分。 我认为这个症状一部分和ADHD的思维模式有关，另一部分和PTSD的创伤心理学有关(详见2.2)。 这种症状是生理级别，不能靠简单粗暴的强制力或者“冥想”去解决。只能顺着TA，哄着TA，忘了TA。 就好像你和朋友跑出去玩，手里必须抱着个孩子。虽然你玩的不尽兴，但孩子不哭，能出门就已经是万幸了。 当然了，所有的思维模式，或者说个性，都是一体两面、长短相形的。 负反馈 1.智力代偿。学习效率低，不专注，学的慢。最要命的是中学阶段的封闭性导致自己不能发现问题、解决问题，老师也往往会认为你心猿意马，“故意不专心”；更严重的觉得你“天生脑子笨，上限就到这了”。 一个哭笑不得的故事：老师叫一个成绩低于我的同学到办公室，说“你要努力啊！无论如何你都不应该低于ZFX啊，你看他那个样！一看就不好好学习。” 这个同学和我关系不错，回头告诉我了。我没往外提过这事，但到现在记5年了。 2.做事爆发力差。属于是你越逼我，我越受不了。还是和抱娃娃一样，我只能顺着我的思维方式，不能强行控制。 反而是我没有负担的去做，会无意识的进入“超专注”状态。 其实我玩游戏、吃饭看电视、写作或者整理知识框架时超专注的概率会大。 我经常吃饭时看电视看的呆住了，筷子悬在半空中、嘴巴张开，眼睛直愣愣盯着电视。爸妈和哥哥喊我名字也听不见，非得把电视关了不可，我才回过神来。 关于超专注(心流)，我的一些理解： 注意力与心流：《道德经》对提高运动表现的启发 学习方法论之一 —— 心流 3.一对多讲课的方式完全不适用于我。老师在上面讲45分钟，我坚持不了5分钟就会走神幻想做白日梦。 这导致我的课程学习是完全碎片化的，很多逻辑链条串不起来，学习过程被分心切割的七零八落。 4.主次矛盾不分。准确来讲，是外部标准下的主次矛盾不分。 比如暑假留了4天复习补考的《计算机组成原理》，但赶巧朋友叫我去秦皇岛旅游，我很快就决定即使挂科也要去旅游。因为挂的科可以补，旅游的体验却难以补回。 5.考驾照科二挂了两次，科三挂了两次。 家人快火烧眉毛了，我却反过来安慰他们。因为我觉得这个事完成的成本不高，顺其自然即可，完全不需要任何情绪成本。 6.睡觉时一旦头脑开始泛化，各种记忆碎片和联想就会塞满脑海，难以入眠。 这里也给大家睡眠做一个参考。睡不着可以试试感受自己的身体，进入放空“冥想”状态，忘掉大脑的存在。 无论是睡眠还是做事，这种情况我都必须把注意力从“动脑子”转移到“感受身体”“相信直觉”“随缘”，才能让自己恢复过来，正常进行。 正反馈： 1.发散性思维会很夸张。涉及到想象力、灵感、交叉学科的联想会得心应手。表现出来是所谓的“悟性”。 我在读《道德经》《论语》《大学中庸》《庄子》这类文章时，感悟会比较多，能看进去。 同时我在经历一些事情，能够很快的用积累过的抽象理论(如上面的古文)去印证。 （当然，反面的毛病就是过拟合病。容易把一个小事或者脏数据强行用模型解释，且如倔驴一样不听劝） 2.共情能力强，艺术审美体验会深厚。 即使没有专业理论知识，也能用我的认知、五感去分析、体验、品味。 3.跑步的时候，如果是3公里5公里，我会很容易形成一段成体系的感悟，形成我的认知方法论。如果是7公里以上，就能形成很多文章的灵感，或者一段完整的文章框架。 但反过来看，打篮球时，如果是娱乐局，我会走神，想到过去的事或者一段音乐，影响运动表现。 4.泛化能力比较强：辩论时能旁征博引、灵感迸发，越聊脑子越兴奋。唠嗑侃大山时话题也会跳的很发散。 (曾经被我的朋友警告：盲目类比是一件很危险的事，因为容易失真) 5.写作时会废寝忘食。 例如这篇文章是从12:00-14:30连续两个半小时写成的，中间没有任何走神分心，甚至不记得喝水上厕所之类的。 ps：这种专注的“凝聚态”不仅不会消耗能量，反而是精神按摩，放松的享受。和刷两个半小时的手机的“耗散”状态完全相反。 6.整理单一学科知识的体系或者交叉学科的贯通时反应会比较快。 添加图片注释，不超过 140 字（可选） (这里是一本中医科普书和运动心理学书的相互印证，发现时真的很兴奋) 添加图片注释，不超过 140 字（可选） 7.兴趣爱好极端广泛。 不管是摄取专业知识，还是体验兴趣爱好，我都乐在其中。 同时这些事业的进行过程中，我会有大量的互相交叉的跨学科的感悟思考。 2.自救首先用知乎用户@9adgq的一段话： 你会说人类的语言，却认为有任何一种人类的普遍知识是你的智力所不能掌握的，犹如在说一台运行着整个操作系统的计算机因为没有安装算器软件而“没有计算1+1的天赋”。 停止这种“自我审视”，它没有意义。 我至今不理解的是，我不认为自己的应试智力有问题，但数理化科分数却很低。我的思考逻辑链路长度是足够解决一道数学题的，却在考试中很无力。 了解完ADHD的概念后，我的理解： 我太容易走神，老师在上面讲课，我小学时会用橡皮铅笔搭天平； 初中和同桌畅聊（因为声音过大，老师说“本来不想管你俩，现在聊到高潮了把老师声音都盖过去了”）； 高中会搓脸上的泥，会情绪闪回，会想到未来自己的情景。 我的文科成绩尚可，因为文科可以靠碎片化信息和悟性最大程度避免。而adhd的广度搜索对学习文科来说很方便。 但理科这种逻辑链长的对于注意力缺失是致命的。我很难深度搜索，不能长时间专注，所以无论是学习知识点还是答题都是碎片化的卡壳。 唯一反常的情况是“超专注”状态。 有一个月，我学物理的电磁章节时，忽然没来由的感兴趣了。我忘记自己在上课，而和老师积极的互动学习，同时忘掉分数，思考知识本身。于是我忽然觉醒了一样，在小测时解出同学们全都解不出来的题，在训练几个比较难的选择时极短时间全对（老师的大声夸奖让我难忘）。 那一章过去以后，我又回到了走神状态。我告诉自己要努力学习，但我逼的越紧，那种状态越无踪迹 。 理解到这一点，这里我想提醒大家(尤其是因为分数产生负能量的朋友)： 应试教育里的分数对你认识自我学习能力有极大的误导性。 你的上限和潜力远比你想象的要高， 只是你的性格成熟度心理病情绪创伤类似ADHD 阻碍了你的学习。 你无法意识到Ta们，而粗暴偏激的归咎于智力问题。最后被表现蒙蔽，自缚手脚。 这无异于你指着一块没装操作系统的智能手机，说ta永远不能计算“1+1”。 理解了这一点，超专注现象和分神现象的矛盾也迎刃而解。 当我非常主动的参与学习过程，让我的大脑兴奋起来，我就能“超专注”。 当我被动的、逼着自己去参与的过程，我的大脑是沉睡的，至少会有20%会分心。 所以经过半年的梳理，那些让我难以投入学习的障碍主要在： 1.情绪闪回：未能梳理清楚的带有负面情绪的过往； 2.1 创伤带来的内在批判者和外在认同感的渴望; 2.2 完美主义和分别心带来的紧绷感； 3.不能发现认识和驾驭adhd的思维方式 4.人性的弱点：虚荣心、价值感的匮乏，装模作样乞求认同。 其中:4在我高中时就已经明显察觉到，并输出在日记里。 3是在解决梳理1和2之后，得到的关键信息名词“adhd”。 1和2.1是考研初期自我反思时，从deepseek那得到的关键名词，从而找到关键书籍《CPTSD:From survive to Thrive》 2.2 是来自参加篮球比赛的经验启发的学习。还有关键信息源《The inner game of tennis》以及黄仁勋等人的演讲切片。 其中3是单独的理性模型的欠缺；其他的则是感性上的性格成熟度不足。 下面是两方面的解决经验。 2.1 对于ADHD者的学习方法论2.1.1 找“增量“ 如果你一天的学习时间不能做到80%的专注，投入更多时间也没什么用。 我认为ADHD最需要的是关注“效率”，而效率取决于你“专注力”带宽的分配。 你需要尽量减少走思的带宽，弱化那些画面和声音，不需要完全投入，只需要能在自己偏离的时候意识到TA，然后把自己拉回来就很不错了。 如果要学好，必须要找到增量然后学习时间自然会增长，而不是强迫自己一天学十多个小时。如果我能学的很久，那一定是因为看到了增量。 这里的增量并非简单的正反馈。而是能让你的专注力延续下去的“机关”。 对于我而言，增量较多的学习场景有：1.问答 2.主动输出 3.写作 4.一对一 5.将知识动嘴说出来 。 这些场景类似费曼学习法，能够倒逼我注意力沉浸进去。 这些场景的表现都需要我的即时反馈，而非讲台下面干巴巴的听。即时性能让我的大脑保持兴奋，思维火热。 例如： 学高等数学时，让我自己去拼拼图，把概念串起来。从函数增量的线性近似，配合图像，由一元函数微分推到多元函数微分，再自然的衍生出全微分、全导数。 添加图片注释，不超过 140 字（可选） 学线性代数时，从几何的角度去感受矩阵和线性变换。（这里可见我的一篇3b1b的线代笔记《《线性代数的本质》3blue1brown 笔记》） 学请求页式存储管理时，让我自己主动去把TLB、cache、页表项等概念串起来。 添加图片注释，不超过 140 字（可选） 可如果你站在讲台上，先把一大堆概念丢给我，去念PPT，而没有场景导入，没有自然的知识衍生过程，我会很痛苦且难以专注，进而学的支离破碎。 2.1.2 减少干扰源 主要分两方面：宏观的大方向和微观的小技巧。 大的方面 1.减少不必要的社交活动情绪的投入； 五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。是以圣人为腹不为目，故去彼取此。 2.放下一些徒有广度、蜻蜓点水、没有深度发展可能的事业爱好。 我曾经会花大量时间看不同领域的推文、视频。但即使是长文字、长视频，一段时间后我也没有留下印象，同样成为了消遣的东西。但这却令我有一种“学到了”的错觉，白白浪费精力，耽误主线。 所以抱着成长的目的时，评估一段信息，要考虑能否立即去实践。如果能做，做完能复盘，那就能成长；如果看完就忘了，那很大概率是奶头乐一样的消遣。 (能够“事上磨”时再去做，以避免无意义的沉没成本。) 3.时常关照自己的情绪、精力、体力。 克制欲望，保存能量 兵马未动，粮草先行。如果情绪和精力不足，本身就不凝聚的注意力会更容易散开。即使坐在工位上，也会因为低效没有产出，白白感动自己。效率比时间重要，而效率的前提是好的精神和身体的状态。 4.以广促深，做点“短期无意义”但“全局有意义”的事 小的方面 1.创造远离干扰源的环境。 比如有意识的不带手机。 2.有意识的尝试依赖本能和直觉，让子弹飞一会，避免刻意的情绪（如惭愧、内疚、甚至负罪感） 3.接受和承认走神，当走神时有意识的设置机关（计时）或者确保自己能拽回来(否则广度遍历会不断递归直到爆栈耽误事……)。 4.需要走神却不想去遍历时，尝试整理行为。 整理过去的文章，整理情绪，整理桌面文件夹，洗衣服，收拾屋子…… 2.2 对于情绪闪回者的创伤疗愈方法3.感想从我对文章的引用，以及过去的文章可以看出，这些思考需要长时间的很私人(即不能被他人代替)的自我审视、信息摄入和模型训练才能解决。 这是一个否定之否定，曲折反复、螺旋上升的过程。 说到这里，很多小时候到长大的困惑都解开了。原来那些没有解决的课题是一以贯之、始终存在、无法逃避的。我只是没有能力去发现ta、解决ta。 那么在这样多的课题下，我仍然能收获很多美好的记忆、欢声笑语的快乐，以及基本的毕业证书，我不由得感到幸运和窃喜。 能有书读，能有意识不断的剖析自己，真的太太太太太太太幸福了。我愈加感受到自己拥有的一切的难得。 当然，这篇文章只是我成长道路上有一个锚点，而非终点。我会遇到新的课题，也会更新新的模型。 未来的路上， 我仍然会不断的拓展自己的体验得到数据集——君子不器，博学明辨； 不断的思考出模型去拟合数据集——修身齐家，审问慎思。 感谢成长中遇到困惑时，总能有现实的贵人相助，提供给我宝贵的启发信息； 感恩遇到互联网和纸质书的时代，能获取到好的经验和概念的营养。 如果说我未来能具备能力贡献什么价值，也全是得力于周围的帮助推进，此为命、势。我能做的，只是微薄的顺和运。 所以在我的认知里，一个人的三观认知模型，处世方法论要远远大于其所谓天赋、智商。 一个人认识自我、坚守内心，格物致知、梳理外部的能力要远远大于其已有的成就。 这些成就和经验甚至会极大可能对自己的进一步成长造成障碍。我始终认为，人的潜意识是摆脱不了自大和虚荣的。 宏观上看，每个人的潜力都是无穷的。一时的挫折只是刷经验值的副本，无论如何都要找回信心，避免如成绩分数kpi工资等单一指标的定义带来的情绪消耗。 很开心能和大家一同成长，遇水架桥，浪遏飞舟，游戏人间。 参考阅读： 三百六十行，无论命运安排我进入哪一行， 行行我都会是第一流。 不用“自我审视”，不用问我合适不合适。 没有不合适。 不凭我是“天才”。 而仅仅因为我是人类，是这个世界上已知最强大的思维机器，地球演化过程的最高结晶，所有文化成就的最终目的。 凭我是神的宠儿。 任何一个人类，天生就是天才，这是显而易见， 理所当然的。 难的不是微积分，难的是1+1。从不知数为何物到明白1+1的智力鸿沟，远比从1+1到微积分为大。 生物用了几亿年，才明白了1+1,却只用了几干年就明白了微积分。你不费吹灰之力就理解了1+1,你已经有了充分的能力理解微积分。 做人工智能的人会很清楚，真正难的是教会a 理解什么是狗，什么是马，什么是太阳。从知道何谓狗、马、太阳到会画蒙娜丽莎的距离远没有从一无所知到知道狗、马、太阳遥远。 而你在干什么呢？ 你觉得明白1+1、知道狗、马、太阳“一钱不值”。 然而你却以为这最后一米才是一切，要喊着你“没有能力”，“没有天赋”，“学不会”、“做不到”。 你还要“审视”来“审视”去，问你是适合爬勃朗峰，还是适合爬乔戈里峰。 人类一切的“文化成就”，在你学会的语言本身面前都不过是小矮子。 你会说人类的语言，却认为有任何一种人类的普遍知识是你的智力所不能掌握的，犹如在说一台运行着整个操作系统的计算机因为没有安装算器软件而“没有计算1+1的天赋“。 停止这种“自我审视”，它没有意义。 你一定可以，你一定适合，你有一切必要的天赋， 你只是需要给自己足够的机会看到这一点。 参考： B站@阿卡迪萨《在b站搞笑了一番后发现自己好像是ADHD》 知乎@9qadg 《如何正确的审视自己？》 添加图片注释，不超过 140 字（可选） 添加图片注释，不超过 140 字（可选） 添加图片注释，不超过 140 字（可选） 添加图片注释，不超过 140 字（可选）","tags":["成长","心理学"],"categories":["认知"]},{"title":"当时只道是寻常","path":"/2025/05/04/当时只道是寻常/","content":"今天和妈妈、哥哥、姐姐，还有我的小侄女去爷爷那打个晃，再去看看姥姥和姥爷。 姥姥穿着一件薰衣草紫的外衣，胸口处有个玫瑰刺锈。衣服很好看，只是发旧了，像连着穿了几天来不及换。妈妈当即给姥姥换上新带的衬衣，嘴里埋怨着先前买的一衣柜新衣服都不穿，还有新鞋新袜新裤子。姥姥坐在那里，嘟囔着“都这岁数了还显眼什么”、“人长得丑没用”，只是一味的叹气，一如近几年我记忆中的一样。 早时候，村里都说嫁出去的闺女，泼出去的水。媳妇熬成了公公婆婆，终于能指使新的儿媳妇给自己干活了。爷爷奶奶对妈妈确实是这么做的，尤其是结婚前二十年，爸爸妈妈包括我和哥哥在内，都跟爷爷奶奶住在一起，看在眼里。爷爷对妈妈那是比亲闺女还亲——有什么活儿计第一个指使妈妈去干，有什么不乐意的第一句就呛。恰好姥姥又和自己的闺女最亲，不乐意麻烦儿媳妇，所以也和妈妈煲电话煲，天南地北厨房客厅都吐槽一番。 总之纵使我当时年幼，仍然能感受到爷爷对俩孙子的偏爱和对儿媳妇的“不见外”。但老人就是这样，挨得越近伺候的越多，反而受的气越大。好在爷爷住进新房子以后，又常常夸妈妈的好，念想妈妈的名字。姥姥就更不必说，您到这段文字时，或许姥姥那里就正在通话中呢。于是那时的妈妈就这样一手电话一手磨茧子的走到了现在，我沿着妈妈只言片语铺起来的时光小路，还能隐约看见那个得空儿就向县里疯跑逛街，天热了跳大坑洗澡，想干活干活想买新衣服买新衣服的小女孩。 爷爷心宽，为了多喝一口茶水，多睡几钟觉，能从三百里外分配的张家口单位里辞职，回家里种地来。美其名曰是“自家种地，想啥时候起床就啥时候起，起来再干活不迟。”人心里敞亮，话说的也挺淡泊，沉重的活最终还是靠奶奶干了。为了生计，奶奶带着大伯要饭，带着二伯、三伯去人家地里”拾坯子“，就为了能让四个儿子两个女儿喝口热粥。 就到这份上了，爷爷还是烟不离手，茶不离口。童年记忆里那个有着红漆木头柜子，黄漆木头抽屉，一排排画龙描凤的白底蓝花青瓷茶具的房间内，我没少跟着爷爷嘬上这一口热茶浓茶。灰尘遍布的小玻璃杯抬进嘴里，味道就像深的发暗的棕色茶水一样，清香气抱团攒成一股浓到发苦的草木气味，从舌尖包裹到嗓子眼。直到肚子暖暖和和的，才觉得喝一口这心里踏踏实实的，不想种地，不想干活，更不想写作业了。 房间里还有那萦绕全身置身仙境般的二手烟（后来因肺炎小学休学一年的我怀疑爷爷功不可没）。写文章的现在，爷爷小区房的茶几上还摆着长方小白纸，包浆黑方盒，里面铺着一层棕色木屑似的烟草。爷爷瘫躺在沙发上，醒了就喝几口茶，嘬几口烟，暖暖和和，迷迷糊糊，吞云吐雾。 无论如何，孩子们长成了，爷爷奶奶享福了。奶奶却得了罕见的眼疾”百日青光眼“。时至今日我都不知道奶奶是怎么在失明以后仍然不吭不响（主要是不跟小辈们抱怨）的活了几十年的。奶奶的生命力由此可见。 喝浓茶的老卧室里，一直悬挂着一把红色宝剑。听说这是奶奶年轻时去“打场”闻鸡起舞，锻炼身体的家伙事。（写到这，本应该继续叙述下去的我不得不插一嘴，我其实特别想和奶奶说几句话，问问她年轻时在那样一个拮据匮乏的环境如何成长的如此博观多才，如此风风火火。是不是她小时候也会像妈妈一样，在农村大坑里扑腾水，没事换衣服臭美。这股扑不灭、压不倒的探索欲和生命力是从哪里而来？只可惜当我真的发现这位老人身上的亮点，真正从“奶奶”这个沉重的两个字的背后看到一个活生生的人的时候，奶奶已经去世两年了。能和奶奶说话的时候都是和电视上学的作秀似的嘘寒问暖和寒暄。不能和奶奶说话的时候，却想起来奶奶。我不想自己这般无力，却只能尽快成长起来，把身边拥有的一切美好用心写下来、念出来……） （注解：打场，方言发音”大常“，实际就是大洼，耕地里，常常有的空旷的平地。用来将收割后的谷物（如小麦、稻谷等，铺在场地上，用石磙或拖拉机等农具进行碾压，使谷物的籽粒从穗上脱落下来的地方） 奶奶的口才很棒，喜欢说理，还能哄儿媳妇，给孙子们提供情绪价值（无论如何见面先一通夸）。一家六口吃饭时候谈到生点的名字，总是问奶奶才能追溯到哪个村子里，能攀上谁谁家的关系。平时村子有活动奶奶都踊跃参加，总不缺席。听妈妈聊到的就有”推小轮“、”耍宝剑“、”踩高跷（好像是演丑婆子？我不敢说）“、”扭秧歌“，还能跟爸爸跳时兴的迪斯科、霹雳舞，“耍龙”、“唱曲”等等也有参与。妈妈就常跟姥姥分享奶奶的事迹，让姥姥不要丧丧的，积极乐观一点。 姥姥和奶奶是相反的，17年左右，村子广场新建出来，干干净净、热热闹闹；妈妈满心欢喜把姥姥、姥爷接来了，姥姥却总说”人家看见我多丢人“，脸皮薄，不好意思出门。好说歹说出去了一趟，在人堆里站了五分钟，又叫耍着回家了。所以心里有点什么事，姥姥也不好意思跟儿媳妇说，总是一通又一通电话打给妈妈吐槽。之前有一半气性得来自姥爷，毕竟姥爷腿脚动不了了，只能靠姥姥服侍。而服侍老人又是一个极伤神的活儿。 姥爷年轻时肉眼可见的精神矍铄，以前的照片里，永远是瞪着眼睛、神采奕奕的，和姥姥的含蓄收敛相衬相合。姥爷喜欢打牌，不管是斗地主炸金花的扑克牌，还是黑色方块的桥牌，甚至是近乎绝迹的长条牌，他都好打，力气比之干农活来而毫不逊色。于是姥爷一看到我就和我玩”大压小“的纸牌游戏，总是棋差一着，忿忿不平的输我几块钱。但几块钱总是不够的，姥姥总是在妈妈不在的间隙里往我口袋里塞几张红钞票。即使这样，在那个没手机的年代，我还总是叫唤着早点回家玩电脑，全然不知姥姥、姥爷的偏爱对一个小屁孩的意义是什么。 忘了妈妈是什么时候说的，姥爷年轻时是极爱打麻将的。哪怕自己玩不上，也要在叮铃咣当的麻将桌旁边看着听着。姥爷干活也是第一麻利快的，风风火火。不知道什么时候，姥爷没再摸过麻将；不知道什么时候，姥爷去外面种韭菜、收韭菜会被姥姥舅舅妈妈说。我想埋怨自己的记忆力太不够用，却想起来时间的力量是这样惊人，回忆起说久不久的以前时，像是把一个人的生命咔嚓拦腰截断，忽然就变了模样。如果小辈们不能很快成熟起来看到老人们经验的宝贵，将之化为文字或记忆，那些厚重的、快乐的、悲愤的、嘈杂的、宁静的过去，就这样悄无声息的埋在尘土里了。于我而言，真是不甘心啊…… 每个老人都会给孙子投喂点专属零食。下午我一喊饿，奶奶就在小圆柱子火炉下面添点蜂窝煤，上面架个小锅给我”糗豆馅“吃。要是爷爷，大概率是给我翻出来个红薯，用大锅烧热水之前埋灶台里，里面烧成灰，用黑铁棍子扒拉出来，带着灰烬的红薯吃起来也有股灶火味。放学回家时，小瓷壶口总会插个糖葫芦，留个切糕。这是爷爷想孙子疼孙子了。到了街上，爷爷也总比妈妈”大气“，随手买张大饼卷肉，小肉包子塞孙子嘴里。至于到姥姥家，姥姥煮的方便面是最香的，没有之一。 文字一个个落在纸面上，回忆一帧帧涌在脑海中。爷爷卷的烟更少了，眯缝着眼卷旱烟和孙子逗话的记忆也像角落里的”胡胡“（二胡）、不知踪迹的大烟杆一样淡忘模糊了。姥姥去年摔了一下，这次再去看望只能双手撑着姥爷用过的铁架子走路，再不能服侍姥爷。姥爷小脑萎缩、脑血栓，刚生病头两年总是和自己较劲，还要种韭菜，割韭菜。这两年也只是在一个位置坐着，等着，笑着。奶奶去世已经两年了。原来上次见到奶奶还是两年前啊…… 现在再回想一个镜头，看完姥姥、姥爷，二舅扬着手让我们回家休息，我和妈妈、姐姐、哥哥还有咿咿呀呀的小侄女坐车回家，一路上欢声笑语，吵吵闹闹，吐槽说理。这样的镜头，应该是最值得珍惜却又最容易被我们忽视的吧？ 生活如此—— 当时只道是寻常。","tags":["家族"],"categories":["家族"]},{"title":"关于解放思想、社交和考研的思考","path":"/2025/04/09/4.9.2025解放思想_以黄金注者殙：社交和考研的思考。/","content":"社交思考 以瓦注者巧，以钩注者惮，以黄金注者。其巧一也，而有所方今，则重外也。 凡外重者内拙。 我有一段时间，每隔一周都要考虑一次，哪些朋友最近联系少，要一个个一起吃饭， 来达到联终情感。现在想来，完全没必要的事。 一则你没事记桂着人家，他人未必记挂你。你消耗的心智带宽投入产出太低，不值得； 二则，岁数越大越需要边界感。你叫人家，人家未必愿意来， 来可能都是给面子卖人情。更何况我自己都不是好凑这种酒足饭饱的主。 所以何必呢？何苦来呢？ 从前觉得万事AA，挺舒服。后来发觉，礼尚往来也挺好，筛选嘛。小钱都AA太小家子气了，没劲。现在我只觉得两者都好。只是划分方式和场景不一样。《如果两人感情真的好，志同道合，那你AA和礼尚往来都只是表达情意的形式，什么都象征不了。》《同样的，我以前总让自己喝酒，党得感情到位了，酒是自然的必需品。但我现在真不这么想了。去他妈的吧，酒只是形式，感情好氛围到，不借助酒也能沉醉。 恰恰是彼此不熟悉，强拢在一个饭桌上，才要喝洒缓解尴尬。 所以什么为了以后工作未雨绸缪锻炼**，何必逼自己喝不喜欢喝的东西？**体验几次，有了经验，完全足够了 。 最终还是要做自己。 课题分离：放下助人情节关于干涉他人课题，这个事也很重要。 《他人没死气白求你》时，不要主动指手划脚。 不仅消耗心智带宽，而且因为是你主动干涉，所以人家没有感谢你的义务，甚至你说的失误了还会惹一身麻烦。非常值不当的。 即使求你了，也得点到为止，观察其诚意。否则一口气说太多，容易被反噬。和人家思路不一样，冒犯人家。甚至在信息不全的情况下，越说越错。 你还会因为说的多，内心消耗多，而有高期望。 高期望只会带来九成的内耗，和一成安慰。 这就是以黄金注者殙。 干涉他人是罪过，点拨他人是义务， 都不是值钱的买卖！ 真正的性情是不计回报，不计得失，而不是这些琐群小事。 所以别拿性情骗自己。干涉别人。《自己的性情留给理想、信仰、志同道合之人》留给利益共同体都不行，因为以后利益改变会被递刀子。 社交包袱对考研的启发《现在看来，生活就是一个不滞于物的过程。》 以前，我因为热爱打篮球，错过抱大佬大腿去打比赛； 因为想学习无关紧要的一门课而错过当主持人锻炼自己的机会； 现在，我意识到，第一次考研失败， 即是自己思想上的包袱太重。有三点: 我的社交包袱重。如上文所提，把大部分宝贵精力放在无效社交、酒肉朋友上收不回来； 美其各日”扩展自己”，但那不是真正的我自己想做的！ 我的看闲书包袱重。实际上我总是把知识当成一种追求安全感的工具，我想确保自己的经验能够跟佛和基督一样。 可是一个不断借由知识来保护自己的人，很显然不是真正的求道者。 学习不是一种累积，它是一种持续不断的觉察。一个不断累积的心是学不到什么的，它只能累积一些信息和经验，然后基于这个背景去学一些东西，因此它从未真的领会什么。 学习这件事是没有历史可言的。 如果你在学习，那么你的焦点将放在当下。 如果你在借助知识行自傲自伐之事，你将难以聚焦当下，也不能投入到学徒状态中。 “知识囤积症”同理。 我的篮球+体育包袱重。我太爱打篮球，以至于考研前期有球必约，后期十一月，还差一个月考试，我还参加校园篮球比赛，折腾了一个月。我每天还极端想腾出时间去跑步，进行无氧训练，有氧训练，甚至还有功能性训练。这都占据了大量时间。 所以综上，我必须解放思想，敢于斗争。 认清主要矛盾达成，减少暂时性爱好，断舍离+执行力。 DeepSeek的三个视角通俗视角：好的，我尽量用更直白的语言来总结你的问题，并给出具体建议： 一、关于考研失败的三大包袱1. 社交包袱 问题：花太多时间在不值得的人身上，表面热闹，内心空虚。 解决： 学会拒绝：接到聚会邀请时直接说“最近在闭关复习，考完约”。 保留核心关系：每周只和1-2个真心朋友聊半小时，其他群聊免打扰。 例子：以前一周约饭五次，现在减到一次，省下的时间够背300个单词。 2. 知识包袱 问题：把看书当安全感来源，却耽误了真正的学习。 解决： 区分“主食”和“零食”：专业书是饭，必须每天吃；闲书是奶茶，每周限喝两杯。 给闲书设条件：比如做完三套真题才能看一章小说。 例子：以前睡前刷哲学书到半夜，现在改成背完政治大题才能看30分钟。 3. 运动包袱 问题：打球跑步占太多时间，尤其冲刺期还分心。 解决： 考试季“运动缩水”：从每天2小时减到30分钟，换成高效短训（如跳绳10分钟+俯卧撑）。 把运动当奖励：完成一天学习任务后，才能去打球。 例子：11月篮球赛完全可以弃权，对队友直说“今年考研拼一把，明年带队夺冠”。 二、具体调整方案每日时间表（考前3个月示范） 7:00 起床 + 10分钟拉伸（代替长跑） 7:30-9:30 背专业课（最清醒时段） 9:30-10:00 允许自己刷一篇篮球资讯（当作休息） 10:00-12:00 做英语真题 午休 一定要睡30分钟 14:00-17:00 政治刷题+整理错题 17:00-17:30 去操场快走（放空大脑） 19:00-22:00 专业课模拟卷 22:30 睡前写50字日记，只记录今天“最该坚持的事”和“最该放弃的事” 关键原则 先啃硬骨头：早上先学最难的专业课，别把精力耗在简单任务上。 设置物理隔离：复习时手机锁柜子，电脑断网，书桌只放学习资料。 接受不完美：如果某天只学6小时，别骂自己，第二天补上就行。 三、送你三句大实话 关于社交“真朋友不会因为你备考消失就疏远，假朋友不值得你浪费时间解释。” 关于爱好“打球跑步是一辈子的事，但考研窗口可能就这几年。就像种地要看节气，该播种时就别忙着钓鱼。” 关于心态“别把考研当上刑场，就当在打一个超长副本。每天刷题就是攒经验值，最后BOSS战自然一刀秒。” 最后提醒 每周留半天彻底休息（补觉打球看剧），但定好闹钟防止放纵。 如果忍不住想玩，问自己：“这事半年后还重要吗？” 实在焦虑时，去操场跑三圈，回来对着课本说：“咱们继续干！” 你需要的不是彻底戒掉爱好，而是让它们为目标让路。就像农民忙时不误农时，等丰收了，自然能痛痛快快喝顿酒。 人文视角：考研败因的禅意破局——以古喻今的修行指南 一、三座包袱的因果轮回你像极了《儒林外史》中的范进，不过执念不在八股，而在「自我圆满」的妄念。三座大山实为一体： 1. 社交包袱：庄子的无用之木 你曾效仿战国门客四处交游，却忘了**「无用之用方为大用」**。酒肉应酬如朝露，看似滋润，实则遮蔽本心晨光。 破法：学陶渊明「门虽设而常关」，在书斋悬「谈风月者止步」木牌。逢人邀约，笑答：「在下闭关炼丹，丹成之日自当出关」。 2. 知识包袱：佛家的筏喻之困 你如抱佛脚的行者，把经书当盾牌。却不知**「法尚应舍，何况非法」**，知识是渡河之筏，到岸即舍。 破法：晨起抄《金刚经》一句：「应无所住而生其心」。读书时焚线香一柱，香尽即停，防堕入「知识囤积症」。 3. 体育包袱：侠客的走火入魔 你似痴迷武学的欧阳锋，把球场当华山。须知**「重剑无锋，大巧不工」**，真正的武者懂得收放如四季轮回。 破法：在球鞋篆刻「冬至闭关」四字，考前三月以站桩代狂奔，化外功为内劲。 二、破执三昧：向历史借智慧1. 社交断舍离：管宁割席现代版 效仿东汉管宁，在微信置顶「黄金分割法则」： 逢人发「在吗」，先问：「此人若今夜消失，我是否痛失至交？」 答案否定者，回：「贫道云游，归期未定」。 2. 知识祛魅法：陆九渊心学活用 读书前诵：「吾心即是宇宙，何假外求？」 专业书当《传习录》读，每章自问：「若王阳明学AI，会如何格此物？」 闲书如《聊斋》，只许子夜读，防堕「知识安全幻觉」。 3. 体育化内功：张三丰太极心法 变「运动消耗」为「备考筑基」： 晨跑时默背专业术语，想象脚踏八卦方位； 投篮时以抛物线喻知识体系，进球即「知识点贯通」。 三、备考新境：文人武士双修录1. 时间兵法：毛泽东的「持久战」 将备考分三役： 辽沈战役（筑基期）：弃篮球如弃锦州，集中火力攻专业要塞； 淮海战役（攻坚期）：以跑步为后勤线，每日五公里保思维粮道畅通； 平津战役（冲刺期）：化社交为地下工作，只与真题密谈。 2. 精力风水：文徵明的书斋布局 按明代文人书房设「备考五行阵」： 东方木位：悬《富春山居图》仿品，养发散思维； 西方金位：置铜制浑天仪，镇知识体系； 中央土位：留白三尺，每日静坐观呼吸，防心猿意马。 3. 自我观照：苏轼的「庐山真面」 备「错题本」如写《东坡志林》： 每道错题后附打油诗：「此错非我真颜色，只缘身在题阵中」； 月圆夜焚旧卷祭天，效赤壁酹江月。 四、终极顿悟：失败是开光的机缘你此番落第，恰似六祖惠能坠碓房——看似劈柴舂米，实则在红尘中打磨心镜。来年再战，当： 携「三无锦囊」入场： 无社交之累（君子之交淡若水） 无知识之障（至道无难唯嫌拣择） 无运动之执（大动若静气贯长虹） 怀「三有真经」修行： 有破釜沉舟志（项羽过江东之决绝） 有格物致知诚（朱熹穷竹七日之韧劲） 有游戏人间趣（唐伯虎画鸡之诙谐） 考场如江湖，你当如令狐冲使独孤九剑——无招胜有招。须知真正的状元，不是满腹经纶者，而是能「看山还是山」的觉者。此番闭关，不是断红尘，而是炼就「以出世心做入世事」的浑圆金丹。 理工视角： 考研失败的系统工程学解析与优化方案 一、问题建模：将人生视为动态系统你的备考是一个多目标优化问题，需平衡输入（时间精力）、输出（分数）、干扰项（社交运动闲书）。建立系统方程：Maximize 考研分数 f(有效学习时间, 知识转化率)Subject to: 每日总时间 ≤ 24h干扰因子 ≤ 容错阈值 二、关键参数测量与瓶颈分析 时间审计报告（基于历史数据） 原系统参数： 日均学习时长：5.2h（含走神） 运动社交耗时：4.3h 知识转化率：38%（有效记忆留存） 瓶颈定位： 注意力切换损耗：每次切换任务浪费17分钟（类比CPU上下文切换） 无效社交占比72%（数据包丢包率过高） 资源分配矩阵 项目 时间占比 能量消耗(kcalh) 收益权重 深度学习 25% 150 0.95 无效社交 30% 200 0.15 运动成瘾 25% 300 0.40 知识囤积 20% 100 0.25 三、系统升级方案1. 时间片轮转算法 2.0 改进调度策略： 将每日24h划分为 96个15分钟时间片 优先级排序： 核心进程（专业课数学）：占用40片（6h） 守护进程（政治英语）：30片（4.5h） 运动缓存：10片（2.5h）需满足：IF 累计学习时间≥6h THEN 解锁运动时间 社交垃圾回收：压缩至5片（1.25h） 防切换损耗设计： 设置连续3个时间片（45分钟）为原子操作单元 切换任务需支付代价：10个俯卧撑（增加切换成本） 2. 记忆缓存优化协议 LSTM神经网络仿生学： 晨间7-9点：写入专业课（海马体高活性期） 睡前1小时：复盘错题（利用睡眠记忆固化） 遗忘曲线对抗：复习间隔 = 1天 → 3天 → 7天 → 14天（指数衰减补偿） 3. 干扰因子抑制电路 社交滤波器设计： 白名单机制：置顶5人（父母导师挚友） 非白名单消息延迟响应：响应时间 = min(消息长度×10秒, 1小时) 运动脉冲调制： 高强度间歇训练（HIIT）替代长时运动：20分钟HIIT ≈ 1小时慢跑（多巴胺产出效率+170%） 四、容错与鲁棒性增强1. 冗余备份策略 建立 考研沙盒环境： 每周日15:00-17:00模拟考场（全真压力测试） 实时生成错误日志：错题类型分布图 → 薄弱点热力图 2. 分布式学习架构 知识点分片存储： 专业课 → 关联运动场景（投篮时默念神经网络公式） 英语单词 → 绑定日常物品（水杯贴”algorithm”标签） 3. 心跳监测机制 每90分钟执行系统诊断： 注意力熵值检测：熵值阈值 → 启动冷水洗脸协议 能量储备评估：血糖阈值 → 调用巧克力紧急补给 五、系统升级路线图Phase 1（1-30天）：硬件重构 卸载冗余社交APP（减少后台进程） 采购定时物理锁盒（强制进程隔离） Phase 2（31-60天）：固件更新 植入条件反射：篮球场入口 → 自动播放肖邦夜曲（抑制多巴胺激增） Phase 3（61-90天）：性能调优 开启超线程模式：边慢跑边听政治考点音频（双核并行） 六、预期收益计算优化后系统预测参数： 有效学习时长：+58%（达8.2h日） 知识转化率：+22%（达60%） 干扰因子：-64%（运动社交总耗时≤3h） 最终输出估值：考研总分预测 = (8.2×0.6)/(5.2×0.38) × 原分数 = 预估提升63.7% 将人生当作最精密的系统来设计，每一次失败都是珍贵的debug日志。记住：你不是在和别人竞争，而是在优化自己的算法迭代效率。当你的时间片调度精准到纳秒级时，成功只是必然的输出结果。 零碎的想法切忌: 1.外物所累的自卑 2.脆弱的完美主义 3.无正能量的比较 4.情绪化的白日梦 5.大量临时决策带来的慢性病 拥抱: 1.独与天地往来（尊重、斗争、感恩、不卑不亢） 2.别等了（其他的无所谓） 3.弱小的自己（强大进步空间） 4.知“止”后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。 5.专注，记录，决断 多运动， 保持身体+思维活跃；番茄钟，把多个想法延后集中处理；尊重大脑特性，发挥优势，善于用发散思维去联合记忆。不要有情绪负债 2.不要冲动发泄的决定，要无声的行动 我发现一开始就将就的事情到最后都要推倒重来。 做了事后悔反刍这种内耗其实是最大的失败， 错已错，从中学习，翻篇，降低期待降低自我要求，学会原谅自己。 .: 逆商。回弹力。目标失去后立马堕落？ 失败不可怕，空白是最可怕的 【驯服“自欺式合理化”的进阶技巧】 你擅长编造偷懒理由，说明具备强大的叙事能力。与其对抗，不如升级这个技能： 设计“堕落侦探”游戏 每次开始自我合理化时，立刻打开手机备忘录扮演两个角色： 骗子甲：（写下你的借口，如“今天状态差，玩会游戏恢复能量”） 侦探乙：（用考研知识点拆穿谎言，如“状态差是海马体未激活，做20个深蹲比玩游戏更能提升多巴胺”） 效果：把自我欺骗变成认知训练，逐渐提高借口门槛。 创建“放纵资格证”系统 制作虚拟奖券，每完成1项核心任务（如背完1章专业课）获得1张“堕落券”： 青铜券：30分钟无负担娱乐 白银券：1小时娱乐+必须产出1个跨界联想 黄金券：半天自由时间（需提前规划灵感捕捉方案） 心理学依据：用仪式感破除“偷懒羞耻”，将放纵转化为目标达成的奖励。 【用你的优势反向制约缺陷】 你提到热爱观察人性和写作，这两个特质正是破解完美主义的关键工具： “人性实验室”观察法 当想要放弃学习时，立刻启动“第三人称视角”： 想象自己是个小说家，正在观察“一个备考者的堕落时刻”，记录身体反应（如手指发痒想拿手机）、心理波动（“反正来不及了”的绝望感） 用200字描写这个场景，重点分析“这个角色为什么会崩溃” 效果：通过文学化抽离，把崩溃瞬间变成创作素材，自然消解焦虑。 “不完美”写作挑战 每天用5分钟写“垃圾日记”： 刻意用潦草字迹记录最羞耻的失败（如“今天只学了18分钟”） 结尾必须写一句荒诞赞美（如“感谢我只学18分钟，为地球节约了0.003度电”） 原理：用幽默感打破完美主义枷锁，训练与不完美共处的能力 【挑战与应对策略】 核心矛盾：兴趣广泛 vs. 备考需专注 → 本质是“短期目标”与“长期热爱”的冲突。关键在于：将“好奇心”转化为备考的燃料，而非阻力。 用兴趣“寄生”学习 例如： 研究历史事件时，联想考研政治中的相关考点（如“权力博弈”对应唯物史观）； 读名著时分析作者逻辑结构，锻炼论述文写作能力； 甚至把背单词设计成“游戏化任务”（设定成就关卡，完成后奖励自己一局游戏）。 原理：通过“意义赋予”让备考和你热爱的事物产生联结，减少抗拒感。 管理注意力的“潮汐节奏” 你的大脑像一块需要“间歇灌溉”的田： 冲刺期：用番茄钟法（25分钟专注+5分钟发呆运动），顺应发散思维的需求； 倦怠期：直接切换任务（如做数学题卡壳时，改背英语作文模板），利用新鲜感保持大脑活跃度。 关键：允许自己每天有1小时“无负罪感兴趣时间”（如研究游戏剧情），作为专注的奖励。 用运动习惯“倒逼”学习状态 把跑步固化为每天学习的“启动结束仪式”： 晨跑后立刻进入2小时高专注学习（利用运动后肾上腺素残留）； 晚上若未完成当日任务，用夜跑“重启大脑”后再补进度。 心理暗示：将“身体的掌控感”迁移到学习上（“我能坚持跑5公里，就能啃下这篇英语阅读”）。 【警惕你的“隐形陷阱”】 “兴趣”可能是逃避的借口 自检方法：当你想放下书本去玩游戏看书时，问自己：“我是真的被吸引，还是在害怕备考的困难？” 若属后者，先解决具体卡点（如某道题不会），再允许自己放松。","tags":["随笔","成长"],"categories":["认知"]},{"title":"《一句顶一万句》读书笔记","path":"/2024/12/17/一句顶一万句/","content":"信息交流受限于发送方和接受方的局限性，在传播过程中会造成不可避免的失真。 这个失真引出来了人和人之间的孤独感，也引出来一系列为弥补这种孤独感而重复的阴差阳错的故事。 说这故事二字，无非一场场对话。这对话里边，也逃不了情和理二字。有人抒情，有人说理。有人感性有人理性，这情理在一人身上本不分家，可牵扯到两个人，就崴了泥。坏就坏在东家说情、西甲说理，说情的不痛快，说理的不明白。两家交流本身好意，一失真，反倒成了坏事。有句话叫“酒逢知己千杯少”，这知己好就好在分得清个情和理。“ 一人一句，凑出来一万句，你痛快了我也痛快了。倒也不是句句痛快。坏也坏在分不清情和理的时候，你不明白，我不痛快。我想吐槽，你跟我说理；你想说理，我跟你附和。一句话用一万句话圆，这也算是“千杯少”吧。 说亲友相聚，交流感情，终归是一句话两句话的事儿。一种谈话是没事了闹着玩开玩笑，打个哈哈就过去了，也算是各美其美，美美与共，唠的高兴。另一种谈话就不一般了——得说理。说理本意是好事，看着彼此是个能通事的亲人、朋友、甚至陌生人，把自己肚子里的那点玩意儿剖出来亮给人看。好的情况是，你亮出来我亮出来，咱俩的心肝肺是一样的，认了同一个理；甚至由此为根延伸出来枝枝蔓蔓，这是交流感情之极乐，比第一种酒肉交换要实在、难得。不是说你俩感情好难得，而是说即使是陌生人，到这种程度你也至少得是一晚上的半个知己。 可剖胸开肚的事儿不能常干，因为这玩意儿跟股票一样，高风险高收益。险就险在这论理过程中，一旦俩人聊劈叉了，顺路的兄弟叉路走，这就坏事了。坏事不是说你俩聊急眼了打胳膊拽腿了，也不是说没劲了不搭话了，而是说俩人都认了自己的死理，寸毫不让，这就坏了事。“人要一赌上气，就忘记了事情的初衷；只想能气着别人，忘记也耽误了自己。“本来是肝胆之言，倾诉倾诉找个认同，排泄下情绪算了。这越说越来气，本来说到一块的事说不到一块了；倒不是说不到一块，而是本来排出去的情绪苦衷又从嘴边直塞了一肚子气。倒不是为了这一肚子气，而是原本消弥的孤独感又一下涌了上来，人是故人，理是新理，事已不是这事本身了。你说怎么办吧？ 说这难吧，也不是多难；而是上岁数的人他不服软。一场唇枪舌剑的战争，总得有一方服个软，低个头，这事也算顺利过去了。倒不是说跪下来让人家原谅，而是从言语上得绕个弯。这个弯绕出来，老牛就清醒了；老牛清醒了，老杨也就清醒了。这摩西不是那摩西，这东家不是那东家。回过神来，话叠着话，早已走了七百八丈远。 绕弯也有讲究。说一句话还是一万句话，无外乎一个情，一个理。你从情上走，抛开嘴上那点三七二十一，给人应承一二，顺破下驴，也就了了。又是个美美与共。你从理上走，又绕到了那句话，高风险高收益。你从黑给二琢磨到马可喜，从老子想到小子，统筹一下双方思想吧。这又是开肠破肚了——俩人说的来还好，辩证一下就过去了，消耗点精力口舌还能接着絮叨；说不来，就是秀才遇到兵，有理说不清。谁知道你这忠厚之言，八万降兵后边是不是一个迷魂阵、空城计？最后还得是以情解情，为啥呢？正是不讲理的都情绪化，比不讲理还情绪化的是认死理。活脱脱一杠头，不杠自己，专杠别人。远的不杠近的杠，生的不杠亲的杠。本来无心插柳的一句话，硬是杠出来一万句，真是以一敌万，一句顶一万句！ “本是一泡痢疾，蚂蚁般的事，最后拐了几道弯，变成了一头大象；本为图省事，反倒多花出去几十倍的工夫，几十倍的钱。“ 这就是一句话的艺术：人家想跟抒情和说理？劝解还是附和？斗争还是妥协？ 话说对了，一句顶一万句；话不投机，一万句顶不住一句。 琢磨琢磨： 下次男朋友女朋友跟你说话，左邻右舍找你泡茶，看看是吐槽还是说理，别给人会错意喽。 啥？你嫌这么着忒累，不如想啥说啥？ 错喽。看看吧，看人家找你说贴己话，你按自我那一套表达的结果是啥样吧，是你明白，他痛快，还是他明白，你痛快？ 毕竟成年以后，谁没事儿了会闲的蛋疼找另一个人咕噜这一堆话呢？ 此之谓孤独感。 何以得解？ 大道不孤。 大道难寻。","tags":["文学"],"categories":["读书"]},{"title":"焦虑破局-心行不一","path":"/2024/12/13/焦虑破局-心行不一/","content":"焦虑的破局大体涉及到 主要矛盾，整体与局部的关系。 很可能有偏颇。大家可以指正 问题场景： 一个人在忙学业，但他每天玩手机平均6h。 怎么让他把玩手机的过量时间转移到学习上？ （怎么解决玩手机问题?） 尝试解答： 如果你要靠“努力” 实现不玩手机，那两天都坚持不了就歇菜了，因为这是通过表象去解决表象，无头苍蝇，看不清问题的实质。 所以片面强调人的主观能动性，或者说遇到问题就说“努力”，认为“努力”可以解决一切问题矛盾的，是一种把问题简单化、幼稚化的方法论。 怎么分析本质？他必然是间接中带有直接相关性的逻辑链条： 玩手机本质是消磨时间。消磨时间的本质是没核心事业。没核心事业的本质是1.理想缺失2.心行不一 。 心行不一的本质是逃避，即畏难情绪与心态。 所以玩手机表象背后的本质，是逃避(学习中的)困难。 分析到本质了，那破局思路不就来了吗？（甚至是自然而然的答案） 所以你解决了畏难情绪，也就是解决了核心事业问题，手机问题自然会解决。 这是一层一层的，而不是舍本逐末的。你自己在逃避，又说不要逃避。这不就是心行不一，精神和实践不符？ 这时拧巴就是必然现象，是应该的。你把他解决了，心行一致，你看你还拧巴不。 心行不一，导致的“逃避困难”，最终导致的最坏结果是，学习系统失灵、崩溃，一蹶不振，谈之色变，用其他事物转移自己的注意力。 比如用正向习惯（跑步、读书）安慰自己，或者用奶头乐欲望（喝酒蹦迪玩游戏） 麻痹自己。 所以焦虑的本质是 看不清眼前的信息，分析不到问题的本质，任由问题（矛盾）产生负能量作用于我身上。 关于焦虑期间的方法论： 我的经验是 尽量维持开辟正向习惯：（获得事业之外的新的生活的价值感，先稳住自我，至少不会波动太大） 大量摄取信息并在合适的时机分析透彻：（当你看不清时，多听多看，各方渠道得到信息、观点建议。不着急出答案，在低谷里躺会，放过自己。等分析清楚焦虑本质后，再如利剑，直捣黄龙） 如果可以，哪怕很微弱，都不要停止前进：（如果你之前能日行千里，遇到麻烦，停顿了；那我建议你在“动荡阶段”，还没有答案与方向的阶段，在已走过的路上，继续走。不需要日行千里，日行十里，哪怕日行一里都可以。因为这个阶段，形式大于价值，精神大于产出。或者说形式和精神本身就是最大的价值了。 很好的例子是亮剑精神：明知不敌也要毅然亮剑） 这里可以借鉴一本书《掌控习惯》 不要给自己叠加“心理负担”：意识到负能量拖累自己时，立即警醒，停止并切换思路。因为从辩证角度看 —— **所有不利于你的事，都能因势利导成有利于你的因素。**所以先阻止自己叠加心理负担，內耗，再打开视野，通过理性分析找到有利方向，并主动作为。“万事皆备于我”。 只要解决了矛盾根源，情绪自然会消失。 连带着的所谓“恶习”、“玩手机”也会消失。 针对“逃避困难”的解决方案： 1.降低预期。 你只要写一道题就很厉害，不管别人写多少，不管表面上这道题多简单。你就值得为这一道题高兴，而不是为没写的9道题而pua 打击自己。 （又称“半瓶水”效应：看到拥有的半瓶水并为之感激窃喜，而不是为没拥有的半瓶水而懊恼沮丧。这叫求不得，乃人生八哭，自己给自己找不快） 2.增强反馈。 写题可以给自己搞错题本，学习知识点可以给自己搞个笔记本，学完一科、一天可以简单写个汇总。 这样你每次看到自己的记录，都会有一股自豪感油然而生，这是将你的成就可视化了。 3.劳逸结合。 越是长期事业，越要讲究可持续性。休息好了和学好了是相辅相成的。想让你的能量始终保持在较高状态，需要充分分配好精力体力。切忌短期鸡血式突击，这根本就不符合人性和生理规律。 （详情请看文章《车马未动粮草先行》） 比如，在你学了一天汇总后，给自己留一个晚上两个小时去做自己想做的事；比如每一天，每一周，能站在上帝视角上，给自己安排几个“Gap Day” “Gap hour” 。 时间短了不过瘾还打断思路，破坏节奏；时间长了，又容易玩的撒了欢，不管不顾。 所以这个时间的分配 ，需要自己找。 结尾： 当你不再逃避困难，直面课题的时候，焦虑感便损失无几。 如果你直面课题的过程中，又进入了专注状态，那么事业，或者核心课题，将从偷偷消耗你能量的坏蛋变成给你提供正能量和价值感的源泉。 顺其自然吧！ 扩展阅读： 知乎用户@Mr.v 事实上，遇到的最大的困难，并不是说物质条件，而是这根视野上的锁链。不怕打断腿，就怕蒙上眼。 “如果当时的我，知道五年以后，我花900块钱，就可以满足我的一切需求，并让我有地可去。我大概就不会在那个晚上，整晚都想着跳河了。” 我后面去翻评论区，重新看到这句话的时候，我自己都被自己震撼到了。 因为我后面解决这个问题的时候，它简单的跟买菜一样。 *我缓解焦虑的经验，一个是“极度明确”，一个是“打开眼界”。* 明确就是不要模糊，比如说，无家可归不等于“一辈子走投无路”。“无家可归”等于“每月九百的房租”。极度的清晰下来，人就不会陷入模糊而带来的恐慌。 特别是打开眼界以后，就会发现很多事情，在我能接受的范围内，它可以有很多解决方案和商量的余地，它本身是不值一提的。这点跟过来人去交流了之后，感触很深。 当初因为无处可去恨不得跳河的人是我，后面像买菜一样，把这个问题解决了的人也是我。每次我想到这个的时候，我就觉得这个世界很幻灭，幻灭到需要去学一下佛，去“看破假像”。 作者：Mr.v链接：https://www.zhihu.com/question/320535511/answer/3202793851来源：知乎 @作者不知道谁写的。 **你之所以会那么痛苦，说白很大一个原因就是期待值太高，还没有看清世界的本质。**你从一生下来，很多学的东西都是脱离现实被编程过的，只告诉你人的一部分，没告诉你人其实是上下限极高的无限成为者。**大量信息的丢失不足以完整的认识这个世界，你不痛苦谁痛苦？ ** 都告诉你人之初性本善，却没有人告诉你，人首先是个完全没有标准上下限的动物，做出什么事都不奇怪。能够达到保持人这个标准的，是极其之少的。众生如果不愚昧了，那就不是众生了。你拿人的标准去看人，你会发现牛头不对马嘴，开始痛恨世界。如果你拿动物的标准去看人，哎，你会感觉其实人还是有点可爱的。还可以被塑造这个人本身能量层级就不同，展现出的境界形态也就不同，六道状态是真实存在人身上的，**你首先要包容允许人会成为六道上下限差别极高的存在，你才能跳出来看一切。所以不要因为人会说话，长的都一样就被蒙蔽了双眼，这些全都是幻相，就是因为人与人差距太过巨大，所以你拿一个标准去衡量才会痛苦。**人先要脱离了动物性再谈人的方式。而大多数压根都还没有过动物关。你拿对人的方式对他们，那会被他们嘲笑然后心安理得的把你吃干抹净，因为在动物眼里你的礼貌只是弱小和免费食物的表现，压根看不到超出他自身层次外的东西，无异于对牛弹琴。用对动物的方式，你会发现其实非常好管理。就像小人和君子一样，君子的标准束缚不住小人。**所谓人的标准，压根就是人从动物这种模板里提炼出来的一种成为者，每个人出生都不具备这种标准，是人在这个标准环境里被塑造成这样。不是人，才是这个世界的常态，不经过驯化和教育，人是不会成为你认知中的那个人的。**所以先是动物，后才是人。还未完全脱离动物性当人看时，痛苦的必然是你自己，你跟动物讲礼貌它冲过来咬你一下，有错吗？它认知里世界弱肉强食别人靠近要么是攻击，要么是送上门的食物，不咬你纯属傻子。你靠近它是你世界认知里的礼貌，你也没错，他也没错，那到底谁有错呢？也许今天他是动物性，明天就蜕变成人了，后天甚至在你之上。**你们都是无限成为者，过程代表不了全部的你们。所以说要尊重客观规律，当你不再以人的标准去看所有人时，你才能把所有人看成人，因为他们都是未来的人。 ** 每个人纯度不同，世界最大的好处就是变化，世间所有存在都是另一种存在的你，你看到了要赶紧学呀，都是大补之物，越补越圆满，越接近无限。其实你早就拥有全部了，只是不懂得打开。你看聪明的人都在学开启无限，而那个愚钝的人还在作定点执着在一隅。就像佛祖看众生不是众生不是动物，而是未觉醒的佛一样。**我们不是从动物里提炼成为人，成为佛。而是每个生命都有上下限极高的层级标准。你从低层动物返到你的最高上限，保持住，就成佛了。你从你的低级动物下堕到你的最低下限保持住，你就成魔了。**佛，动物。魔。全都是你的一部分，所以你才可以成为。你现在是动物，不代表你整个生命都是动物，只能代表你现在的状态能量层级是动物性，发生了大的改变后你就不是了。从动物开始往上走，就慢慢是人，是觉悟者，是佛，接近你的最高上限至无限了。**而大多数人被卡在动物和人这关，也跟人这关被编程过有所关系。**所以很多人都上不去。就跟出去闯一样，你出生就在小山村，但你出去后才发现，好像你们这个地区的认知是有问题一样，所以大多数人才被卡住出不去。这个很聪慧的人，他就天生发现，自己的标准是多种多样的，他就发现自己虽然生下来是个动物，但不完全是他。他就想有意识的去看看自己的上限在哪里，然后不断的开发，从一开始就脱离了动物性往上发展。最后成为生命的最高状态，一切皆是他一部分，但一切，皆不是他。 ​ 一本书@《胜者思维》 —— 金一南 行动要积极，目标要节制，不要想一口吃个大胖子。节制目标，关键来自于力量，**力量的有限性决定了目标的有限性，力量与目标之间的距离就是风险。你的目标很高，你的力量达不成，你的风险就不可控了。**有个人讲过一句话：“我制订的目标跳起来能够着。”我觉得这个比喻很好，也就是说，目标比较高，我一时够不着，但是我跳起来就能够着它，经过努力我能够着它。目标与力量之间有风险，但是我跳起来能够着，就意味着风险可控；如果跳起来够不着，就意味着风险太大，不可控。 我们根据力量来配置这个目标，一步一步来，分阶段实施目标，而不是一下子达到最终的目标，这就是对目标的节制，对目标的节制反映了什么呢？反映的是对力量的清醒认知，你有多大的力量、能干多少事，这是需要注意 士兵突击：这过日子就是问题叠着问题，你唯一能做的，就是迎接这些问题。 像打仗一样未必给你准备。 b站用户@硬核的HeyMatt 大部分的无效焦虑，来自单一维度的评判标准 b站用户@张骏 回血的核心是专注","tags":["随笔","成长"],"categories":["认知"]},{"title":"读书的目的","path":"/2024/11/27/读书的目的/","content":"人要在这个世界收获存在感和价值感，最廉价的活动莫过于求知。所谓“仰观宇宙之大，俯察品类之盛。“”求知的过程是渗透到世界的各个角落的。如果你留心做饭，你就会留心平时注意不到的，洗菜切菜、爆香勾芡；如果你留心喝酒，你就能学点喝酒的技巧，对酒局中的人交流的更亲密些。 问题在于，为什么我要留心呢？ 换句话说，我甚至不知道为什么非要在这个世界收获存在感。 像我这样的年轻人，我想年纪轻轻就能找到热爱并可持续的事业，乃是一种奢侈。这里的事业不是某个爱好，而是开头我们提到的，超越生理感受的入世感 —— 我在源源不断的创造价值，我在生活着，生命力从周身萦绕到指尖。 大家耳熟能详的那些故事，口口相传、津津乐道的传奇人物，带给我们的精神共鸣实际是有限的。在读到类似横渠四句“为天地立心，为生民立命”这样大气恢弘的昂扬的句子，我们能感受到崇高的理想，却难以将之内化于心，作为自己生命内核的驱动力。这就好像照片传递给我们美感，却由于三维压缩到二维的局限，丢失了很多完整充实的信息，使我们不得其真。是啊，哪有什么一飞冲天，该走的路一步也少不了，我们能做的，仅仅是降低成本，减少内耗，增加可持续性和乐趣。 死记硬背是为理解服务的，但当我们真的理解时，往往已经忘掉了、丢掉了。 仅此而已吗？绝不是。我们终究是要找到自己的理想的，正如我们终究是要面对死亡。身边的种种轮回，就像生活给我们开了一个小口子，让我们能管中窥豹，洞悉到那些不以人的意志为转移的冰冷规律的一部分。 臣服规律。去传宗接代，去抢占生产资料以保全自己，去投入到社会运转的零件之中，在机器运转过快升温时，叫骂几句摩擦。 面对规律。当你面对规律时，你已经意识到规律，或者说“道”的存在了。意识到道的存在，就已经走在路上了。终点在哪？ 理想、信仰、自我。 理想、信仰、自我，都太大了。大到你不能用“失去”一词。你永远在寻找自己的理想，然后追寻，然后继续寻找。 而人的弱小，注定我们难以深入各个领域，排着队找到一生热爱。实践不得，只能通过实践过的人提炼出来的信息了解，这就是阅读的意义。大量的阅读，增加通识，再博观约取，找到自己感兴趣的扇区，选择深入 ；于是按耐不住性子，理论和情绪积累到一定水平，终于开始实践了。于是小口子越撕越大，你的自我画像越来越清晰，原本遥不可及的理想也接近了。是的，你的存在感和价值感终于迎来又一次飞跃。 狂喜。 我的论述已经完成了。接下来是我的体会。 很多宏大的、崇高的叙事是情绪化的产物，更多的是“安抚”，临时麻醉剂的作用，而难以成为长期的生命力源泉。但这不意味着这个叙事中的人物、故事是低价值的，更不是假的。而是我们需要用自己的亲身经历去共鸣，用自己的某个刻骨铭心的生命阶段去为这个叙事作注脚。这个时候它就已经从情绪中脱离了出来，转而在情绪之上给自己提供正能量。 所以说是没有用的，那些人很厉害，那些话很动人，那些事也真的很了不起。听一遍，扩展了。再说再讲再揣摩，没有用了。 你如果真的向往那类人、那些品质，你的本能（热爱）会让你极其自然的知行合一，不需要这些故事给自己降低多少成本。所有的脑电波信号都按照你的理想、信仰、自我构成的路标，全力冲刺指挥身体去做。 所以阅读这件事，没什么高尚的理由。就是多认清认清自己，给自己现有的或未来有的迷茫，提前划个路标，到时候少费点事。 所以别再内耗了，别再用瞎琢磨“找自己”了，别再去用身子“贴”了。 没事去读读书吧。读读古今中外人写的书，读读自己，读读生活。 则近道矣。 另一个角度： 人生并不是一种“到达”目的的过程，而是像卷轴一样的自我展开。人不用把自己依附在外在的目的上面，自己就可以是目的。所以，人生是一种“展开”，而不是“到达”。一个从内而外，另一个从外而内。就像一颗种子的目的是变成大树一样，人的目的是了解自我的内在和潜力，让自己的可能性成为现实。活着是为了展开自我，是像一颗种子一样，发芽、开花。所以 去它的外在价值!我就是价值本身。如果你认同这一点，那么你活着就有义务实现自我。 就像一颗种子的目的是变成大树一样，人的目的是了解自我的内在和潜力，让自己的可能性成为现实。活着是为了展开自我，是像一颗种子一样，发芽、开花。所以 去它的外在价值!我就是价值本身。如果你认同这一点，那么你活着就有义务实现自我。 书籍只是你搏斗的谜团，帮助你开悟的工具，是六经注我，而不是我注六经。除了书，很少有人会这么深入的探讨你的困惑。人的一生是有限的，你很难知道别人怎么深入考虑一个事情。 如果你带着“崇拜圣人”或者“变得博学”的观点， 这会让你的读书变得功利。而功利的缺点就是容易被莫名的指标kpi、一团莫名的欲望去控制，继而唯结果论，妨碍你享受读书本身。 我觉得正确的态度是把每本书当成一个脚印，我们要做的事情不是着迷这个脚印本身的形状、大小、特点，我们要做的是通过脚印去重新想象那个留下脚印的人，这个人是怎样的。我们能尝试重构作者的思想、经历和感受到的一切。这需要同理心和想象力。读书是为了体会生活。 彩蛋： 人的状态是由点及面的。往往是一个好的习惯，成倍的、低成本的衍生出了很多其他的好习惯。坏习惯也是如此。 你如果跑步，那就会有舒张的血管、身心。有了好的身心，你就不忍心把这来之不易的训练成果浪费掉，于是就留意饮食。同时，为了储备能量，提高效果，你还要想办法改善睡眠质量。同时，跑步的锻炼效果也会让你注意自己的体态，改善外在形象。 习惯是这样，敏锐度也是。 如果你享受一下无聊，会发现很多热闹之外的好玩的东西。 如果你开始看书，慢慢的，你能对身边很多事产生兴趣。这里的“看书” 形象的意义大于做这事本身的直接意义。它像一个标杆，一个旗帜，意味着你要对生活发起冲击了，让自己平静的生活泛起点好玩的波澜，这也是生命力的表现。 让看书作为一个起点，衍生出对不屑的、慵懒的、讨厌的、轻视的、无聊的东西，产生兴趣。 兴趣有了，能量就到了。 正能量堆起来，形神俱佳，精气神就来了。 精气神有了，谁还在乎什么社恐不社恐，笨不笨，傻不傻，钱不钱的，是吧？ 人就活这一口气~","tags":["随笔"],"categories":["认知"]},{"title":"何为心流","path":"/2024/10/05/心流/","content":"心流的前提先看心流的定义: 心流（英语：flow），又称福流，是[米哈里·契克森米哈赖]在《心流：最优体验心理学》中提出的概念。 心流是指人们在做某些事情时表现出的全神贯注、投入忘我的状态。 这种状态下，人们甚至感觉不到时间的存在，并且在当前事情完成后产生一种充满能量并且非常满足的感受。 米哈里提出心流有八个特征，包括任务明确、全神贯注、目标明确、即时反馈、投入深入、乐趣感、忘我的状态和时间感改变。 心流活动有助于人们享受心流体验，例如发呆、爬山、游泳、打球、玩游戏等。 心流体验源于挑战与技能的平衡，只有在高挑战和高技能的情况下才能达到心流状态。 在旅游服务平台设计中，应该设定明确目标、提供即时反馈、平衡挑战与技能，并创造适合心流的环境。 在游戏设计中，设定明确目标、平衡挑战和技能、提供即时反馈和创造适合心流的环境可以帮助玩家更好地投入和享受游戏，提高游戏的吸引力和可玩性。 进入心流的原因 毫无疑问： 进入心流能够让我们沉浸到当下所做的事情，在不借助外力的情况下，激发自己的全部潜力。这不仅能提高做事的效率和效果，也能最大程度减少我们的能量损耗；甚至能反过来让我们享受其中，调节情绪、陶冶情操，达到“干半天活不仅不累，反而更轻松”的增加能量的效果。 高质量的心流体验中，时间和空间发生有变化。体验过“心流”状态的朋友最能理解这种感受。 心流的例子 长跑的“第二次呼吸” 体育运动的ZONE状态 电竞里：FPS游戏枪枪爆头，MOBA游戏操作拉满 《大学》：知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。 物有本末，事有终始。知所先后，则近道矣。 注意：刷视频、玩手机不是心流状态。 因为刷视频时： 你并没有投入； 你的注意力是涣散的； 你的精力是快速消耗的； 你的反应力不会更敏捷，相反会愈加麻木迟钝。 为什么要进入心流？下文来自 知乎用户 @9adgq : #核动力学习 大学阶段的学习失能问题很难解决，因为很多学生并没有真正的建立起学习的长期战略，本质上只是在应激性的学习–面向家长认可、 面向班级地位、面向高考压力。 没有这些外在激励的刺激，学习的心理奖励就 会大幅的下降。 这并不是“学习能力”的下降，而是学习动机的 问题。 学习是影响你命运最重要的手段。 你想要什么样的命运？ 你到底是为什么而学习？ 你需要一个疯狂的、激动人心的、伟大的梦想来当志向。 否则仅仅是“要谋生”、“不能被人看不起”、“要谈得上恋爱”这类的理由在现在这个物质丰富的时代是很难成为长期的动力的。这个时代只要一个人没什么物质欲望，要得个温饱，混个日子，并有多么的困难。如果仅仅只以”不饿死”为基本目标，人根本没有必要、也没有动力去下苦功学习什么东西。 没有这个动力，要把基础知识学扎实的必要努力都自然变得过于奢侈。散漫个几个月，就会开始破罐子破摔，靠作弊混六十分万岁。 看似这是个学习问题，实际上这是个人生观、 价值观问题。 你需要一个梦想。 必须是某个造福于人类的事业。 这种东西对于学习也罢、事业也罢，都是核动力引擎。有了这个核动力，你才知道你要选什么课、要学什么技术、要追什么论文、要关心哪些老师、要考什么证、要申请什么学校…. 你才会有“有进展”和“不如预期“这样的概念， 你才有基于这些信号的种种奋斗的基本方向。 有了动力，再谈变速箱和方向盘这类方法问题、 策略问题，先解决你的动力。 如果你说“我就是一个平凡的人”，那么就这个问题而言就没什么解决方案了–因为这些症状就是”平凡的人”的正常轨迹。 否则“平凡的人”何以会成为平凡的人呢？ 这时有同志问了：心流这么厉害(๑•̀ㅂ•́)و✧，怎么进入这种状态？ 莫急，且看下文： 进入心流的方法提取几个关键词： 正向： 系统化模块化 兴趣热爱 身心健康，精神饱满 心里只装了一件事（主动或被动的） 不想开始，但还是继续去做了 静、定 熵减 正反馈 反向： 碎片化 强迫 疲劳 做这个想那个 不想开始，休息一下再做吧 躁、乱 熵增 无反馈（尤其是短期内） 我的经验： 关于冥想：找寻秩序的最简单直接的方式 由上可见，进入心流的重要状态是放弃外界干扰，聚焦于一点。 可以说是一种混乱之中的秩序。 而冥想，就是克服混乱，找寻秩序的最简单直接的方式。 关于手机：目的性一定要强 手机就不要沉浸式了。因为手机的设计天然是要与现实抢夺你的注意力的。 所有的机制、APP都在想方设法从你的人性上挖坑。 所以玩手机目的性一定要强。 开手机屏幕前一定要预设自己要干什么，然后在心里数1.2.3 。 否则极其容易被中间的其他内容吸引，目的没实现，玩了一大堆。 这真的很尴尬！ 下面则是集思广益了： B站用户:@机器回忆 聚焦，避免无关信息侵占大脑认知资源。我们的生理基础，决定了我们必然缺少用于自主思维的认知资源。这意味如果我们需要高效处理某件事务，就必须把认知资源全部投入到与主任务相关的事，而避免外来事物的干扰。核心认知资源：思考、视觉、听觉、 简单理解，聚焦主任务时，最好把一切与主任务无关但又能吸引你注意力的、干扰你的事物都清空，让你的世界里只剩下主任务，该学习学习、该工作工作、该休息休息，不要在学习时总想着休息，不要在状态不好该休息时强行学习，不要在该做事时心事重重啥也不干——这不过是在折磨自己。 大块的优质的时间要留给重要的事情，比如学习、阅读、锻炼、休息，避免把时间花在分散专注力的事情。不要为了做而做，去强行累积时长，而要真正地聚焦真正地专注真正地收获些成长——成长是由专注形成的，而非时间的简单累积。 为了快速恢复聚焦，在工作、学习的休息间歇里，选择“暂停”思考，而不是“中断”思考。 用CPU举例，暂停思考是CPU啥也不干，寄存器存储的还是目标任务的信息，中断思考则是发生了任务切换，寄存器存储的是新任务的信息，显然，暂停思考恢复目标任务更快速。 这也表示了如何有效的休息。 简单理解，休息间隙里选择放空大脑，暂停思考，避免任务频繁切换导致效率下降——举例：不要频繁查看手机，以免打断专注力。“冥想” 为了聚焦到底，根据疲劳程度，合理调整工作进度。 疲劳会可逆性地损害大脑的认知记忆功能，使得激活速率减慢从而出现了中断恢复的延迟，因此不论是暂停思考还是中断思考，中断后首次的绩效都出现了下降。 简单理解，一鼓作气，再而衰，三而竭。 根据正在处理的工作类型，灵活调整我们的 应对模式。 当我们处理内容简单、机械重复的工作时，会 出现一种“中断加速”效应。 这意味着在处理简单工作时，我们可以尝试在多种简单工作间按一定的频率来回切换，进而提升我们的综合工作效率。 简单理解，内容简单、机械、重复的工作攒到一起集中处理。最好是在垃圾时间处理这些工作，这些在聚焦主任务时会分散专注力的事情。警惕碎片化：时间碎片化、知识碎片化。 @ 专注的本质其实并不是去聚焦于想关注之物，而是主动放弃了关注点的所有。 我们之所以无法专注不是注意力从一个东西上“掉了下来，而是因为从一个东西转移到了另一个东西上。 也就是说出现了另一个更引人注意的东西，才把注意力夺走了。 而专注对于很多人来说，其实是一件不安的事情。因为这代表了你需要放下对周遭环境其他的信息，或是你心中正在担忧的某件事的注意。 就像当你处在一片随时可能会有危险出现的野外森林当中，会很难去认真阅读一本书。 因为必须时刻保留一部分注意去观察周遭的风吹草动。 所以专注也相当于放弃对周围环境的警惕 与选择相伴的，一定有舍弃。 当你注意到自己的注意力被一些其他事情夺走时，可以安抚这份焦虑，认识到此时它并没有那么危险。 并且与思考它相比，专注当下的事更为重要，也更为有效。 轻轻的把它放下。 另外，适当的压力可以给我们专注的动力。但一但压力造成了动力，就成了专注力最大的敌人。 而所谓的放弃，即对焦虑的放弃，对所担忧之物的放弃，正是取决于自身安全感的建立。 @请原谅我o 2个练习 扩大凝视。 随时可以做，通过全局视野可以始终看见手头的正事，能够避免【注意力被（感兴趣的）杂事分心-专注于杂事-而看不见正事】。这个练习锻炼的是一组独立的视觉神经回路，这条回路更关注物体的运动信息，帧率更高。这个练习第一次就会生效，使你减少学习工作时的分心（注意力闪烁注意力瞬失），让你更专注于手头事情。这个练习不限时长，一用就专注，每次用都能立马生效。 17分钟的专注于截断监听眼内视觉触觉等体内感觉。 这个练习只要一次，就能永久减少你学习工作时的分心（注意力瞬失）。不要求你达到各种冥想的所谓境界或状态，也不需要经常冥想（这对很多人来说很麻烦很讨厌），只要一次就能永久改变你的大脑。这个锻炼使得人们在按顺序寻找不同对象切换注意力时，每次切换本应有的注意力瞬失分神都不再发生。 @虚无闲 有个形容直接击中我：情绪是逻辑的快捷方式。 所以任何无视情绪、删除情绪、管理情绪都是错的、治标不治本的，你需要仔细的理清情绪问题的逻辑关系，找到情绪所在的原逻辑文件，并合理的重构逻辑。 但是，这并不容易，一点点逻辑错误都会积累bug，所以许多人选择了套用别人的逻辑来构筑自己 。 更可怕的来了：错误的逻辑导致情绪像弹窗广告一样喋喋不休。 这时候连删除逻辑文件都不管用了，因为你根本不知道这种情绪来自于哪种逻辑，你也不清楚为什么删了这个逻辑文件，那个情绪依然存在，你套用别人的逻辑太多，连你自己是谁也忘了，你大费周章的删除了大量的逻辑文件，感叹到重构自己的艰辛，于是你渐渐放弃挣扎，把“平凡”两个字安到自己头上想一劳永逸 可是，你别忘了，从你出生开始直到死亡，无论你做什么，都是一个“新建”的过程，你的所有情绪都将指向如何“新建内容”，这种意识，是超越死亡的 @居家的大猫仔 1、 第一个方法就是针对冷启动： 例如 在家里保持几个区域，每个区域只和同一种的信息保持接触： 饭桌上就是看剧； 床上就是看书和睡觉； 电脑前就是工作； 特意给自己设置不同的不同的环境区域： 学习区； 休闲区； 在专门的区域只做专门的事情，这样的话就能把‘环境’的作用发挥出来。 让自己冷启动更简单。 但是这里有一个问题： 如果你看书也就罢了，如果你用的是手机或者是电脑，它们不会让你只看一样东西吧。 解决方案推荐： 使用电脑和手机的模式切换功能了： 在电脑上给自己准备两个桌面：工作桌面和休闲桌面 在手机上切换工作模式和休闲模式； 这里推荐工作时使用工作模式，微信等都是静音状态。 2、 第二个方法就是针对随机性 这招貌似是防不胜防，因为现在很多APP都是这么设计的，这类APP 可以可以关闭竖屏模式，宁愿多调用一下自己的意志力，达到对竖屏模式APP的警觉。还是比较警觉的， 防止回微信走神，把微信的视频号也给设置不显示； 另一个是在关闭视频网站之前，学着去浏览一下你浏览的历史记录，这样你会发现自己的走神曲线。 维度是告诉自己： 什么时候走神的？ 走神到哪里去了？ 3、 针对正反馈 @TheSniperCola: 把会分心的东西，例如手机，拿的远远的，尤其是刚起床的时候。 让自己的身体在最适合进入心流时开始工作学习，例如早上起床的90s内。（睁眼下床上桌就是干！） 尽量实现以下条件：目标清晰、反馈及时和难度适中。 实现心流是一个曲折式上升的过程，一开始一定会有难受的感觉，生理上的不适。我们会在工作状态和闲散状态之间进进出出。但是一定要勉励自己再坚持一下，再坚持一下。专注力是锻炼出来的。在难受过后就是大脑释放多巴胺的奖励环节，以及专注工作时间。心流是消耗精神力量的。 最后需要放松恢复。 以上，专注力学习力是21世纪最关键的技能，共勉。 @摇曳生鲜 1目标量化 2循序渐进 3及时反馈 @改个名变强 心流状态很容易进入的，我将帮助你进入心流： ①首先，你得找一个相对安静的环境，屏蔽周围一切干扰 ②最后，你需要做你感兴趣的任务，确保有点难度。 比如你喜欢干净整洁，你可以做： 整理你的书桌 整理你的衣柜，把物品有序的摆好 进行一次家庭大扫除 如果你喜欢生活有序，那么你可以尝试以下任务： 整理你的书架 打造一间电竞房 组装一台高性能的电脑 修理一款损坏严重的自行车 如果你喜欢挑战自己，证明自己的能力，那么你可以： 在王者荣耀中一次不死并以16.0的评分终结比赛 通关艾尔登法环并且全成就 挑战极限运动：跳伞，爬山等 为你喜欢的游戏发表一篇攻略并获得广泛关注 制作一款现象级游戏并获奖 如果你喜欢漂亮的东西，那么你可以： 编辑一张照片到自己满意为止 写一个漂亮的网页 给自己剪一个漂亮的头发 给自己的物品收集保护装置 搭配一套你满意的服装 6，给绿植浇水 如果你喜欢探索新事物，那么你可以： 探索一种全新的舞蹈 尝试一款你从未尝试过的游戏 品尝一些全新的美食 学习一项全新的技能 探索动物世界 @烂尾孩: 人类的文化和科技，无不建立在专注之上。如果说宇宙是熵增的，那么转瞬即逝的人类生命，就是前仆后继地在专注中把熵增的宇宙归纳演绎从而缔造文明，或许这文明连宇宙的杂音也算不上，但这就是我们倔强地反抗熵增最有效的方式，逆熵就是生命的本质，那么专注就是生命对抗虚无的解药。 我是看了《成瘾：在放纵中寻找平衡》这本书后了解到：一味地追求快乐，逃避痛苦，反而会使自己对快乐的东西越来越不敏感，但对痛苦的东西越来越敏感。 我们在面对各种来自工作学习等等的压力痛苦时，如果选择用各种快乐的东西来逃避痛苦，并不能解决问题，只会让问题更加严重。 最好的做法应该是故意让自己去往更痛苦的环境中待一会儿（比如洗冷水澡，跑步健身）。当重新再回到自己之前的环境时，潜意识就会觉得“这么困难的环境我都能成功克服，那么在现在这个环境里，我肯定是游刃有余啊！” 就像尼采的一句名言：“但凡不能杀死你的，最终都会使你更强大。” @Kimi - gpt - AI 明确目标：确定你想要达成的具体目标，这有助于集中注意力。 挑战与技能平衡：选择对你来说既不会太容易也不会太难的任务，这样你既能够保持专注，又能够避免感到无聊或沮丧。 消除干扰：创造一个无干扰的环境，关闭手机、电子邮件通知，告诉周围的人你需要专注工作。 专注单一任务：避免多任务处理，专注于一项任务直到完成。 进入节奏：一旦开始工作，尽量保持连续性，不要频繁中断。 自我反馈：在工作过程中，给自己提供反馈，这有助于保持动力和专注。 适度休息：长时间工作后，短暂休息可以帮助你恢复精力，避免疲劳。 享受过程：不仅仅是为了结果，也要享受工作本身带来的乐趣。 自我激励：找到内在的动机，比如对任务的热爱或者完成后的满足感。 调整期望：不要期望一开始就能进入心流状态，这需要时间和练习。 练习冥想：冥想可以帮助你提高专注力和意识，从而更容易进入心流状态。 记录心流体验：当你体验到心流时，记录下来，分析是什么条件促成了这种状态。 走神、无意识的四种原因 Following information From Jordan Peterson By 1900 four functions of the unconscious had been described: Conservative: the unconscious stores memories, often unaccessible to voluntary recall Dissolutive: the unconscious contains habits, once voluntarynow automaticized, and dissociated elements of thepersonality,which may lead a “parasitic existence” Creative: the unconscious serves as the matrix of new ideas Mythopoetic: the unconscious constructs narratives and fantasies that appear mythic or religious in nature 心流之门的钥匙：兴趣下文来自 知乎用户 @9adgq : 只做自己感兴趣的事是可行的，但是那意味着你对这件事要足够的喜爱、认真、尊重、虔试 很多人只是喜爱而已，喜爱不到能认真服从它的纪律的程度，认真不到能尊重它的规律的程度，尊重不到能对它的价值虔诚的程度。 能喜爱到认真服从它的纪律–比如叫你几点去培训你就提前几小时能爬起来–你就能以此为业，在行内立足。 能认真到尊重它的规律–譬如叫你练基本功你就能沉下心练基本功–你就能以此成事， 可以指望在行内扬名。 能尊重到对它的价值虔诚–能以身立教，诲人不倦，对外光大外人对这事业的认知，对内追求代际传承–你就能在这一行成名成家。 迈不上这些门槛，仅止于肤浅的喜爱，其实根本没有机会真正的体会到这些东西真正神妙极乐之所在，往轻里说至少是不能算认真的兴趣， 不适合作为职业追求。 要么先热爱、再职业，要么先职业，再学会热爱。 热爱是必须的，是唯一能让你长久忍耐痛苦并化为自豪和快乐的奥秘所在。 而没有这份长久，你将始终无法获得足够的护城河和安全感，这在长期而言是非常危险的。 这时有同志问了：只靠兴趣也不行啊。靠兴趣我一开始还挺有干劲，干到最后，难题多了，挫折多了，我就容易泄气，就不想干了。 这是人性使然啊，咋办？ 莫急，且看下文： 进入心流之前的冷启动问题：要避免肤浅兴趣和浅薄热爱带来的 “唯开心是从，唯兴趣是从” 的主观错误思想。 无论从辩证还是实操，都要让 兴趣热爱 结合 努力忍耐 的部分。 否则会掉入“贪心陷阱”。 比如 鼠目寸光，捕鼠陷阱: 唯开心是从，是开心最大化的最佳策略吗？ 下文来自 知乎用户 @9adgq : 因为没有能力在不快乐的状态下先把事情干成的人，最后一定失去一切快乐。 逻辑显然、不言自明。 从现在这一秒起，放弃一切侥幸。 我嬴不赢，跟我快不快乐没有必然关联。 “心情好”才能打，算个什么东西？ 心情不好，照杀。 心情不好，那就去斩个华雄回来下酒。 斩完了自然心情就好了。 冷启动，哐哐哐哐哐。 有点费华雄而已。 记住这个答案，再喊什么“快乐重要还是xx重要”，想想华雄。 他刚才心情就不好。 还因为 “快乐 快乐的成果 快乐”的两冲程循环就像一台发动机。 虽然看似有自持性，但是本身是有内在脆弱性的，稍有风吹草动就会因为接力失误而熄火，被锁定在“不快乐也无成果”的阶段。 而从不快乐的状态创造出成果来，就是这台两冲程发动机的冷启动。 你如果学不会启动这台发动机，随你怎么去照料它，它必定有一天会停转，而且永远的锁定在停转状态。 你学会了手动启动，就不管多冷的天，总能一脚发动，说走就走。 冷启动和学扎实，是两个必须掌握且越早掌握效果越好的强大技能。 刚拿到驾照的时候开手动挡面包车，最怕在等红绿灯的时候熄火，怕拦了后面人的路被疯狂按喇叭催促，但越心急反而越掌握不好油门和离合的联动。 学会随时能起步，在任何地点任何情况下随手都能启动，这才能说你真正会开车了，无惧任何地形，大不了猛踩刹车到熄火嘛，熄火了再打着启动就行。 学扎实也是同样的，那种朝着目标一路过关斩将解决问题直达终点的经历，能让你以后学习任何东西都事半功倍。第二件打八折，第一件当然随便买双袜子先达成这个成就拿到打折的奖励再说。 学的东西马上就能让第二天的生活变轻松，自然学起来有兴趣，有劲头。而且这个如果你学得有效，你会越学越有时间，越学越有兴趣。 这时有同志问了：我上一天班，干一天活，你还让我进入心流，学这学那，干这干那？ 莫急，且看下文： 忙里偷闲的热爱 的可持续性 下文来自 知乎用户 @9adgq : 下班之后学不进东西，很多原因是反馈链没建立起来–例如上班是摊煎饼，下班学的是英语和线性代数，盘算着的是考个研就不用摊煎饼了，而这个考试要一年后开始，这就违背了基本心理规律，自然就艰难了。 其实很多人总是去寻求这类所谓“正途出身”， 这是不对的。每个行业、每个职业都自有门道和需求，需要研究和练习，研究透了练习好了， 自然在那一行里可以出人头地，甚至成为生产组织者、行业变革者。 避免学习的倦怠，关键总在于维持学习的兴趣， 而维持学习的兴趣，关键总在于缩小学以致用的路径。要避免那种“学两年才开始看到效用” 的安排，安排成”今天学，明天用，当周结算”， 你的进展会是飞速的，兴趣会大到影响性生活， 不信你试试。 其实这个道理并不复杂，然而为什么很多人就会选择反馈链路很长的领域去学习呢？因为这种学习的动力来自对自己现状的鄙视和憎恶。所以选材的原则就是离现状越远越好，链路自然就长了。链路长了，反馈就差了，要坚持自然就难了。 热爱你的生活，热爱本身就会给你福利，明不明白？ 目标带来挫败感后的处理： 下文来自 知乎用户 @9adgq : #耽误了五六年# 这里作者以抑郁症作比较，来描述 “打破被传统价值体系束缚的“这件事本身的价值。 抑郁症本质上犹如一种精神性的自体免疫病那些促进你“奋斗”“努力”的因素–譬如心理优越感、权力感、控制感、感官享乐、意识形态快感等等，在平时起着驱动你运作的关键作用， 但一旦遇上过敏原，它们自己就会转而对你自己发起攻击。 比如心理优越感让你感觉不错，但你一旦去到很大的赛场，见识过让自己腿软的天才或者利维坦，它会立刻转化为自卑感，对你自己发起反噬。你最大的依靠是钱带来的享乐，当你看到赚钱的前景悲观，你不可能不受负面打击。 等等。 对于这些内在问题已成定局的人来说，前面的人生只有两条路，要么运气好到不遇上过敏原， 要么遇上了、挺住了，并在反复发作中渐渐形成适应，达成脱敏。 很坦率的说，按照中国的(乃至世界的)现状， 大部分人都存在着来自物质主义的、内在的极大脆弱性。这其实也是普遍焦虑的根源， 因为人意识到了这种内在的脆弱。一般人没有发作，仅仅只是因为还没有遇上足够大的打击。 换句话来说，这是一个大概率事件。 人生几大关口，毕业、失恋离婚、落选、意外疾病、失业…..几乎无人能全部躲过。 更不必提还有衰老、失亲这几节必修课。 所以，我实实在在的告诉你，如果你是三十岁之前就得了抑郁症，而且挺住了，能经过五六年稳定住了，并且最后赢了—— 那么你是完成了一项重大的人生功课，你不但没有“落后”什么东西，事实上反而是领先了。 什么叫“赢了”？就是不但坚持过去了，而且你的引擎换掉了。不但能提供动力，而且可以逻辑性的免疫于这些所谓打击，有了大大强化的抗打击结构。 不但无惧于意外，反而能将一切意外视为自己的朋友；不但无惧于失去，而且将不得不舍弃视为一种幸运；不但不畏惧付出，而且将最大程度的付出视为值得追求的价值。 没有经过这一关的人，ta们的成就严格说都不算是建立在沙滩上，事实上是建立在一颗炸弹上。 所以，你并没有“耽误五六年时间”，你是提前了十几年面对拆弹工作。 你真正的问题是你有没有把这项拆弹工作做好。我必须要提醒你，你要把拆散和救灾区分清楚。 有很多人所谓的“治疗”，仅仅不过是在打扫现场、救治伤员、修复建筑，没有排雷。ta们把一切寄托在一个天真的幻想上–”下次不会这么倒霉”。 ta们错了，和下次相比，这次只是轻轻点点你的额头而已。 下一次才是耳光。 排雷才是最重要的工作。 如果你做好了排雷工作，你不但没有落后五六年，相反，你是跑在了别人前面十几年。 你现在就得了抑郁症是一种幸运，而不是不幸。 心流彩蛋从科学角度解释，专注力的背面就是分散力（自然之性），作用力与反作用力，集中注意力是需要做功，需要消耗大量的能量做功，需要一个稳定的能源供应，就像工厂运行需要水电气一样，然后就是组织架构有效的管理能力，才能输出合格的产品。兵法的核心原则也是集中，自己集中也是需要战胜自己的一个过程（减少组织系统的熵增），让敌人分散，避实击虚，各个击破，达到最后的胜利。 天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。天之道损有余而补不足，人之道损不足而奉有余。个人也一样，我们每天都在消耗自己，除了物质能量的补给，更重要的其实是精神力量的续电。根据物理学，能量只能从高到低传递，因此精神力量的获得只能从比自身更高的人或事物上得到，而获得这些力量大多数情况下是散乱无序的，个体承接载体只有一个，那就是志向（需要系统化化为中期，短期的目标做有序接续）。 最后用阴符经中关于专注的话语做结：“瞽者善听，聋者善视。绝利一源，用师十倍。三返昼夜，用师万倍。” 手机是让精神熵剧增的主要因素之一 关于心流的书：心流模型： 《掌控习惯：如何养成好习惯并戒除坏习惯》 詹姆斯·克利尔 英文版叫：: Atomic Habits: An Easy Proven Way to Build Good Habits Break Bad Ones 《 The Inner Game of Tennis》身心合一的奇迹力量 《当下的力量》 《原子习惯》 《成瘾：在放纵中寻找平衡》 《专注力》 《The 7 habits of high effective people》 《心流》《宝贵的人生建议》米哈里·契克森米哈 《心流的艺术：如何进入心流状态》达蒙·扎哈里亚德斯（Damon Zahariades） 《Secrets of the Millionaire Mind》 少有人走的路：心智成熟的旅程 《Peak: Secrets from the New Science of Expertise》 《成功，动机与目标》海蒂·格兰特·霍尔沃森 底层逻辑： 《像冠军一样学习》里根·A.R.古隆 《福格行为模型》， 《认知觉醒》《认知驱动》《聪明人的个人成长》周龄 《效率脑科学》 戴维罗克 心态：斯多葛哲学STOICISM； THE SUBTLE ART of NOT GIVING A FUCK 1.The Little Bookk of Stoicism 2.Everything is Fucked：Ae Book About Hope The Roadless Traveled（马克曼森的两本） 4.How to win friends and influence people","tags":["随笔","成长"],"categories":["认知"]},{"title":"菜根谭下","path":"/2024/10/05/菜根谭下/","content":"潜龙勿用，藏器于身 十语九中未必称奇，一语不中，则愆尤骈集: 十谋九成未必归功，一谋不成则訾议丛兴。君子所以宁默毋躁、宁拙毋巧。 淡薄之士，必为浓艳者所疑；检饬之人，多为放肆者所忌。君子处此固不可少变其操履，亦不可太露其锋芒。 地之秽者多生物，水之清者常无鱼。故君子当存含垢纳污之量，不可持好洁独行之操。 不责人小过，不发人阴私，不念人旧恶。三者可以养德，亦可以远害。 **炎凉之态，富贵更甚于贫贱；妒忌之心，骨肉尤狠于外人。**此处若不当以冷肠，御以平气，鲜不日坐烦恼障中矣。 恩宜自淡而浓，先浓后淡者，人忘其惠；威宜自严而宽，先宽后严者，人怨其酷。 毋因群疑而阻独见，毋任己意而废人言，毋私小惠而伤大体，毋借公论以快私情。 不可乘喜而轻诺，不可因醉而生瞋，不可乘快而多事，不可因倦而鲜终。 休与小人仇雠，小人自有对头；休向君子谄媚，君子原无私惠。 #清高 ——来自知乎用户9qadg、9qgda 、John Harx （此三人为同一人，老改名字他） 1)清高并不等于不合群、不随俗，清高仅仅指向不受胁迫。夫清高者，自守也。 清高并不妨碍–也根本不该妨碍–与任何对你无胁迫的人友好交往。陶渊明、嵇康朋友多得很，日程表都快排满好吗。 它仅仅只是“真正自由的人可以坦然的拒绝一切同流合污”的自然表现。 2)清高的人自食其力。 我是价值的创造者而不是消耗者，这就是我无法被抹杀的存在资格。 注意这不表示不需要与人分工合作。我非常擅长做包子，但我还得和做面粉的、养猪的合作， 不然我这个包子做不出来。但是只要是做面粉、 养猪的，我都可以合作，我都能让他们的猪肉和面粉凝结出更高的价值来。 有合作，但仍然是自食其力。这种自食其力其实未必需要是体力劳动，也并不见得一定是通过市场易。举个例子，接受民众自愿施舍的印度苦行僧，也同样可以看作自食其力。 自食其力的边界是不强迫、不掠夺、不出卖人格尊严。 不以恶为业。 3.）清高的关键意义，在于能使老、庄亲居贱职， 惠、朔安乎卑位。 至圣先师，不羞执鞭。 清高的一个至关重要的特性，是使精英从对名利地位的强迫性追求中解脱出来，去担当贱职、 卑位，从而使得社会循环的每一个角色都能有充沛而可靠的人力资源。而不是“有本事的都在争王位，所有其他的事都是没能力、没原则的人在做”。 换句话来说，真正清高的人身在“卑位”、”贱职”，绝不是”怀才不遇”、愤世嫉俗的，而是可以安坐冷板凳，做好自己手上的“贱役”，依然自给自足、自得其乐的。 在大山里无名无姓的做好自己的计算，造好氢弹；在地里种好水稻，育出好种；在厂里车好零件，装出战机；在学校里教好学生，培育人才。 不觉得“屈才”，不觉得“悲愤”，不捶胸顿足要”阶层跃迁”。这才是完整的清高。 它不是坏事，恰恰相反，它是不折不扣的君子之道，世上最宽的幸福道路之一。你只是需要完整的清高。 张弛有度，君子不器 魏晋南北朝时期，上流社会普遍喜欢围棋游戏，也就出现许多反对围棋的声音。东吴太子认为博弈没有任何用处，还特意让韦昭写了一篇《博奕论》，详细阐明这个道理: “今世之人，多不务经术，好玩博奕，废事弃业，忘寝与食，穷日尽明，继以脂烛”，博弈严重妨碍了工作和学习；其次，“当其临局交争，雌雄未决，专精锐意，心劳体倦，人事旷而不修，宾旅阙而不接……至或赌及衣物，徒棋易行，廉耻之意弛，而忿戾之色发”，说这个博弈损害身体健康、破坏家庭和社会关系，甚至引发赌博、争斗等恶行；最后，博弈之人**“所志不出一枰之上，所务不过方之间……技非六艺，用非经国……求之于战阵，则非孙、吴之伦也；考之于道艺，则非孔氏之门也”**， 对于我们所爱好的娱乐，如酒一般，小酌怡情，大酌误事。也要做到一收一放，张弛有度。 否则总要面临“胜负未分， 交争都市，心热于中，颜愁于外，名之为乐，而实煎悴”的境地，而事后后悔了。 ——《菜根谭》中华书局版杨春俏 点评 学者有段兢业的心思，又要有段潇洒的趣味。若一味敛束清苦，是有秋杀无春生，何以发育万物？ 事有急之不白者,宽之或自明，毋躁急以速其忿；人有切之不从者，纵之或自化，毋操切以益其顽。 俭，美德也，过则为悭吝，为鄙啬，反伤雅道；让，懿行也，过则为足恭，为曲礼，多出机心。 气象要高旷，而不可疏狂；心思要缜细，而不可琐屑；趣味要冲淡，而不可偏枯；操守要严明， 而不可激烈。 清能有容，仁能善断，明不伤察，直不过矫， 是谓蜜饯不甜、海味不咸，才是懿德。 锄奸杜幸，要放他一条去路。若使之一无所容，便如塞鼠穴者，一切去路都塞尽，则一切好物都咬破矣。 所谓 “ 围师必阙，穷寇勿迫，此用兵之法也。 “ 苟有恒，何必三更眠五更起；最无益，莫过一日曝十日寒。 这个不是菜根谭，这是明代理学家胡居仁 写来自勉的对联。 “一日曝十日寒” 出自 《孟子.告子上》 身不宜忙,而忙于闲暇之时,亦可儆惕惰气;心不可放,而放于收摄之后,亦可鼓畅天机。 闲中忙、忙中闲，放中收，收中放，调节身心，张弛有度。 夏则资皮，冬则资絺 有人辞官归故里，有人星夜赶科场。少年不知愁滋味，老来方知行路难。 苦心中常得悦心之趣，得意时便生失意之悲。 处富贵之地，要知贫贱的痛痒；当少壮之时，须念衰老的辛酸. 老来疾病，都是壮时招得；衰时罪业，都是盛时作得。故持盈履满，君子尤兢兢焉。 害人之心不可有，防人之心不可无，此戒疏于虑者；宁受人之欺，毋逆人之诈，此警伤于察者。二语并存，精明浑厚矣。 伺察以为明者，常因明而生暗，故君子以恬养智；奋迅以为速者，多因速度而致迟，故君子以重持轻 善启迪人心者，当因其所明而渐通之，毋强开其所闭。 善移易风俗者，当因其所易而渐反之，毋强矫其所难。 淡泊明志，宁静致远 马拉松运动员基普乔格在巴黎奥运会冲击三连冠的关键时刻，在28km处选择了人生中第一次主动退赛。 赛后记者问他： “你没有创纪录地达成奥运三连冠，在结束比赛时你在想什么？是感觉很糟糕，还是感觉到了竞争的残酷？或者你感觉还可以，因为你赛后很友好地去祝贺了对手。你当时怎么想的？” 基普乔格的脸上没有歇斯底里的惋惜，没有怨天尤人的愤懑。他的脸上只是带着一抹淡淡的微笑，平静的神态让这微笑充满了张力， 这次和他之前每次胜利完赛后的采访一样，平淡，宁静，柔和。在记者的每个句子结尾处悄悄的点头。 “**你是不是认为我没有获胜是个失败者？我想问一下你。“**基普乔格睁大了眼睛，嘴角上扬的更明显了。 记者没有回应。 失败说的是那些试都没有试的人，但我尝试了去获胜，只是那天不属于我，这就是运动的真谛。你要明白如果我们都能积极地去生活，我们可以走得很远。“ 他望着记者的眼神好温柔，他看的不仅仅是记者，是所以害怕失败停滞不前的人，宽容地原谅那些质疑他的人们，并鼓励人们勇往直前。 ——fancy 天理路上甚宽，稍游心，胸中便觉广大宏朗；人欲路上甚窄，才寄迹，眼前俱是荆棘泥涂。 宠辱不惊，闲看庭前花开花落；去留无意，漫随天外云卷云舒。 狐眠败砌，兔走荒台，尽是当年歌舞之地；露冷黄花，烟迷衰草，悉属旧时争战之场。盛衰何常？强弱安在？念此令人心灰。 心地上无风涛，随在皆青山绿树；性天中有化育，触处都鱼跃鸢飞。 石火光中争长竞短，几何光阴？蜗牛角上较雌论雄，许大世界？ 优人傅粉调朱，效妍丑于毫端。俄而歌残场罢，妍丑何存？奕者争先竞后，较雌雄于着子。俄而局尽子收，雌雄安在？ 学者动静殊操、喧寂异趣,还是锻炼未熟、心神混淆故耳。 须是操存涵养，定云止水中，有鸢飞鱼跃的景象；风狂雨骤处，有波恬浪静的风光,才见处一化齐之妙。 高光是你，低谷也是你。往往是跌宕起伏之时，才最检验一个人的本性。 所谓知行合一，知止而后有定。这道理真的吃透了，无论动静纷扰，我虑则一,彼纷不纷。 儒家阐述的表现之一就是慎独。 也可以说是内化成天性，达到“本来无一物，何处惹尘埃”，即无需自律，顺势而为，把事做成了。 自强不息，厚德载物 邓小平三起三落之一： 在17号院,只有警卫,没有其他任何人跟随,邓小平与卓琳就自己打扫卫生和洗衣做饭。 过了一段时间,警卫找来了原来的厨师,帮助做午晚两餐,早餐还是他们自己准备,好在他们的早餐一贯简单。 17号院外边的世界非常热闹,“x人帮”在all nation范围展开了公开点名的“批x、反击x倾翻x风”运动。 邓小平从报纸和广播里也知道这些,但他根本不理会这些zz闹剧,平静而从容,吃得饱、睡得香,照样有规律地生活。只是孩子们不在身边,使他们感到寂寞和惦念。 不久,卓琳因病住院了,17号院就只剩下邓小平一个人,他依然保持平静从容的性格,每天生活很有规律。 实在没事可做,他就拿出邓林塞到他衣服口袋里的扑克牌,一个人在桌子上摆牌开牌。 邓小平女儿回忆说:这副全新的扑克牌,到了最后,已被用得牌角都磨白了。 ——《邓小平是一个什么样的人？》三联生活周刊 天薄我以福，吾厚吾德以迓之；天劳我以形， 吾逸吾心以补之；天扼我以遇，吾亨吾道以通之？天且奈我何哉！ 贫家净扫地，贫女净梳头。景色虽不艳丽， 气度自是风雅。士君子当穷愁寥落，奈何辄自废弛哉？ 居逆境中，周身皆针砭药石，砥节砺行而不觉；处顺境内，满前尽兵刃戈矛，销膏靡骨而不知。 横逆困穷，是煅炼豪杰的一副炉锤。能受其煅炼者，则身心交益；不受其煅炼者，则身心交损。 富贵名誉自道德来者，如山林中花，自是舒徐繁衍；自功业来者，如盆槛中花，便有迁徒废兴；若以权力得者，如瓶钵中花，其根不植，其萎可立。 能晓物隙开合、通韵律神髓，善乘气象旋运、明内外起止者，此真明了通达，是师天地之才。 非《菜根谭》出处不可考。 不刻意、不着相 在金山寺，苏东坡看到老友李公麟画的一幅他的画像，百感交集，遂提诗一首于上： 心似已灰之木，身如不系之舟。问汝平生功业，黄州惠州儋州。 从此诗可以看出，对于此时的苏东坡而言，什么功名利禄、建功立业，全与自己无关。他曾经留下过德政的杭州、密州、徐州，都不足以体现自己的人生价值。 真正体现他人生价值的，反而是最落魄的时候所待的地方：黄州、惠州、儋州。 在这三个地方，他虽然经历了磨难，但是却找到了人生的真谛——只要有一颗热爱生活，热爱人生，热爱自然的心，懂得享受当下所拥有的一切，就会得到真正的幸福与安宁。在黄州、惠州、儋州，他的身体没有得到自由，他的命运没有得到自由，但是他的心灵却得到了自由。 ——《苏东坡》何加盐 文章做到极处，无有他奇，只是恰好；人品做到极处，无有他异，只是本然。 警惕对完美人设的幻想； 与其做一个劳模，不如做一个引起争论的批判者。 ——李健 父慈子孝，兄友弟恭，纵做到极处，俱是合当如是，着不得一毫感激的念头。如施者任德，受者怀恩，便是路人，便成市道矣。 真廉无廉名，立名者正所以为贪；大巧无巧术，用术者乃所以为拙。 喜寂厌喧者，往往避人以求静。不知意在无人，便成我相；心着于静，便是动根。如何到得人我一空、动静两忘的境界？ 性天澄彻，即饥餐渴饮，无非康济身心；心地沉迷，纵演偈谈禅，总是播弄精魄。 缠脱只在自心，心了则屠肆糟糠，居然净土。不然，纵一琴一鹤，一花一竹，嗜好虽清， 魔障终在。 语云:“能休尘境为真境，未了僧家是俗家。” 有浮云富贵之风，而不必岩栖穴处；无膏肓泉石之癖，而常自醉酒耽诗。竞逐听人而不嫌尽醉，恬憺适己而不夸独醒。此释氏所谓不为法缠、 不为空缠、身心两自在者。 山林是胜地，一营恋便成市朝；书画是雅事，一贪痴便成商贾。盖心无染着，欲境是仙都；心有系牵，乐境成悲地。 好丑心太明，则物不契;贤愚心太明，则人不亲。士君子须是内精明而外浑厚，使好丑两得其平，贤愚共受其益，才是生成的德量。 观人取其大者，不要从门缝里看人，这会让自己心窄。 此话不是来自《菜根谭》。 来自——fancy 福有福始，祸有祸先，自古过于厚者常获福，过于薄者常近祸。 勿以己之长而盖人；勿以己之善而形人；勿以己之能而困人。 不能容人不敛才智以能盖人此皆薄福之相。 ——来自自己查吧 面对和我们磁场不符的人，人性的第一反应，应该是讨厌吧？更有甚时是通过贬低对方，来增强自己行为模式的合理性。 这时可以考虑一个视角：“以德报怨”——以自己的德报自己的怨。内部消化。 他人的怨气，需要“以直报怨”。 关于 老子“以德报怨” 和 孔子“以直报怨” 的关系，可以等有时间写一篇文章，分享大家我的理解。还是很有趣的。 具体操作看萧峰萧大侠： “我乔峰是个粗鲁汉子，不爱结交为人谨慎、事事把细的朋友，也不喜欢不爱喝酒、不肯多说多话、大笑大吵之人，这是我天生的性格，勉强不来。我和你性情不投，平时难得有好言好语。我也不喜马副帮主的为人，见他到来，往往避开，宁可去和一袋二袋的低辈弟子喝烈酒、吃狗肉。我这脾气，大家都知道的。但如你以为我想除去你和马副帮主，那可就大错而特错了。你和马副帮主老成持重，从不醉酒，那是你们的好处，我乔峰及你们不上。” 总结来说就是“全面看问题”，不因噎废食，片面看人，“门缝里看人”。 谁还没点不周全的地方呢？ 两个方面解决： 对自己：贬低他人来“增强自己行为模式的合理性” 是安全感缺失，自卑的表现。我常常犯这个主观的毛病，心里容不下人。 解决方案是，宏观上接受世界和人的多样性，看到每一个人的优点、缺点，即性格上矛盾的对立统一。微观上看到自己和对方互利互惠的潜力，接受底线以上的弹性，调整自己的预期和方式；不因小得小失，小礼小节而生怨气（容）。最终达到自信的稳定态。 示例：刘邦对待韩信。（刘邦开始也容不了人。只是表面上暂时看不出来，憋着发泄之前就想明白了） 对他人：欣赏其长，理解其短。互利则进，相斥则各自为安。底线以下有“冷静翻桌子”的勇气和定力。 仇恨和讨厌真是一个毒剂，会让自己在局限的认知里扭曲别人的同时，也异化自己。 为什么是扭曲别人，异化自己？ 因为对别人的挑剔，是你自己内心的缺点投影。 如果你真的知道这人的不足之处，那你应该比他还要了解他。 这时相比厌恶，更多的是理解、包容、回避和祝福。 其实好多成长的破局点，都在负能量里…… 比如对别人的怨气. 考虑考虑“以德报怨”。 彩蛋： 一个小故事： 王巩在那里，也确实过得比较凄惨，一个儿子死在贬所，另一个儿子死在家中，他自己在岭南也多次生病，差点死在那里。后来王巩遇赦北归，和苏轼在京城见了面。苏轼发现他气色很好。而跟王巩一起赴岭南的一位歌姬，后来成为王巩侍妾的宇文柔奴（小名“点酥娘”），也是显得比以前更年轻。苏轼当时曾问柔奴，岭南应该很不好吧？没想到柔奴笑笑说：此心安处，即是吾乡。苏轼特别感慨，专门为柔奴写了一首词： 常羡人间琢玉郎。天应乞与点酥娘。尽道清歌传皓齿。风起。雪飞炎海变清凉。万里归来颜愈少。微笑。笑时犹带岭梅香。试问岭南应不好。却道。此心安处是吾乡。 ——《苏东坡》何加盐 另一个小故事： 贬到黄州之后，苏轼变成了苏东坡，一门心思过好自己的小日子，再也不提新法的事。他的诗文经常传到皇宫，宋神宗每次读他的文章，连饭都忘了吃。他又觉得，苏东坡真是人才，不用太可惜了。所以这几年间，他也屡次和王珪等大臣商议，要把苏轼调回朝里使用，但都被王珪想办法推掉了。 到了元丰六年，有次不知怎么民间传出谣言，说苏东坡死了，被玉皇大帝召到天上去写文章了。宋神宗也听到了消息，还很关心，特地派人查明是真是假。后来知道是谣言，但这件事情必定对皇帝有很大触动：与其让苏东坡去给玉皇大帝写文章，还不如给我写呢。 所以很快，宋神宗就让苏东坡“量移”了。 但对于苏东坡而言，这就是一个巨大考验了。他在黄州已经生活了四年，日子已经很安定；现在要重新被起用，眼看要当大官了。他必须得做一个抉择，是继续在黄州当农民，还是到朝中去当大官。 历来人们都认为，乌台诗案以及苏东坡的两次被贬，是他生命中的大考验。但何加盐认为，从黄州量移，才是他生命中真正面临的最大一个考验。它让苏东坡拷问自己的内心： 我究竟是要去建功立业，致君尧舜，还是就当过普通人，吟诗作赋，过好自己的日子？ 如果世界上真有穿越这回事，我一定会穿回元丰七年春天的黄州，死死地拉住苏东坡，让他一辈子就住在黄州算了，不要再回官场了。临皋亭的神仙日子不好吗？何必要回官场受罪呢？ 可惜的是，苏东坡此时毕竟还是凡人，没有成为坡仙，他终究还是选择了回朝，做官。 ——《苏东坡》何加盐 还有一个小故事： 对于篮球球技的问题，凯里欧文的个人篮球技巧与身体素质的结合已经无可挑剔，甚至可以说是当世无双。 但科比再次给欧文提出了建议，他表示，“对于凯里来说，下一步就是要找到如何激发队友的全部潜力的方法。这是非常困难的，这需要你去了解和每个球员建立情感链接，找到他们的恐惧和弱点，并帮助他们将恐惧转化为动力，要想做到这些，你必须花大量的时间。**不是把时间花在健身 房，而是学会倾听你的队友，**无论是一日三餐还是其他时间，你需要和队友们聊天，听他们说话。 科比还表示，自己也是到了30岁的年纪才懂得这些，当时科比带领的湖人在总决赛中不敌凯尔特人，科比表示乔丹在那之后也给了他同样的建议，“乔丹对我说‘听着你的队伍已经很完整了，现在你需要搞清楚怎么和你的队友建立链接，并激发出他们最好的一面，这不是简单的传球而已，没这么简单，不会让队友变得更好。而是说你必须找到按下那个按钮，让他们自发努力成为最好的自己’” 最后一个小故事 关于得失心： 以瓦注者巧，以钩注者惮，以黄金注者殙。 用瓦片做赌注的一定轻松，用衣带钩（银子打造的）做赌注的会有所忌惮，用金子做赌注的一定神思昏乱。 其巧一也，而有所矜，则重外也。凡外重者内拙。 轻松就能专心一志，而有所顾忌，就会分心注意其它的事。凡是分心他顾的人思维必然迟钝。 凡外重者必内拙。 过度关注赌注，关注赌注的价值，就会被得失影响，就会幻想丢掉赌注会怎样，反而在赌桌上丢失了输赢的机会。 伟人同志在《矛盾论》中如是说： 在复杂的事物发展过程中，有许多矛盾存在，其中必有一种是主要的矛盾，由于它的存在和发展规定或影响着其他矛盾的存在和发展。 所以，要解决问题就要找到主要的矛盾，主要的矛盾解决了，其他的次要矛盾就会迎刃而解。 “外”是次要矛盾，“内”是主要矛盾。 颜渊问仲尼曰：“吾尝济乎觞深之渊，津人操舟若神。吾问焉曰： ‘操舟可学邪？’ 曰：‘可。善游者数能。若乃夫没人，则未尝见舟 而便操之也。’吾问焉而不吾告，敢问何谓也？” 仲尼曰：“善游者 数能，忘水也；若乃夫没人之未尝见舟而便操之也，彼视渊若陵，视舟若履，犹其车却也。覆却万方陈乎前而不得入其舍，恶往而不暇！ 以瓦注者巧，以钩注者惮，以黄金注者殙。其巧一也，而有所矜，则重外也。凡外重者内拙。 以竞技体育为例： 竞技运动和好胜心要记住:到了场上，精气神比实力更重要。实力波动不会太大，但精神力却有天差地别。你可以输，但不能怂孬。宁愿站着死，不能苟着活。不要拿伤病安慰自己。这个看几眼就能看出来。贴身防娱乐除外，被迫摆烂除外。 竞技体育就是战争的延伸。 也是最能反映出民族精神状态的，来上班的战斗力自然不如来打仗的。继续自欺欺人，还是升起强烈的危机感，与我们每一个人所作所为息息相关。 还是得狂，是放下输赢，尽力的狂。不是一定赢的狂","tags":["菜根谭"],"categories":["小品"]},{"title":"菜根谭上","path":"/2024/09/25/菜根谭上/","content":"前言： “夫菜根者，弃物也，而其香非性定者莫知。如此书人多忽之，而其旨唯静心沉玩者方堪领会。” “菜之为物，日用所不可少，以其有味也。但味由根发，故凡种菜者，必要厚培其根，其味乃厚。“ “ ‘菜根’ 名，固自清苦历练中来，亦自栽培灌溉里得。” 随着商品经济的发展，传统的土文化与逐渐兴起的市民文化碰撞融合，知识分子需要重新寻找切合身份的生活方式。 《菜根谭》向这些“士君子”们展现了一种自然闲适的理想生活: 或隐居荒僻幽静的山林，在袅袅炉烟、悠悠茶香中品读圣贤之书，幕天席地，畅快饮酒，放浪形骸， 醉卧落花，在大自然的怀抱中体悟禅机妙理； 或居于红尘闹市，混迹俗世却不沾染丝毫俗气，赋诗饮酒却不迷恋清泉山石，(听任他人争名逐利却不对其嘲笑鄙夷，自己过得恬静淡泊却不自炫清高。 这种生活方式以超越世情俗欲之念、消解功名富贵之心、 深谙知足知止之道为前提，混合了儒家的“独善其身”、道家的“和光同尘”以及禅宗的“日常生活是道”等理念，对古代知识分子颇具吸引力。当现实迫使他们生活在落魄失意之中，他们要用高雅的情调去弥补平庸生活的缺憾；当商品经济的发展向世人展现了空前物质化、世俗化的生活方式，他们也需要保持一种淡泊超逸的精神姿态，勉励自己无挂碍地走过物欲横流的俗世。 作者认为，人无法控制和改变自己所生存的环境，却可以控制和改变自己待人处世的策略: 要尽量活得低调谨慎，收敛光芒，掩藏才华，逃避声名，时刻提防潜伏在背后的射影之虫:要和光同尘，随俗应世，绝不能摆出一副“众人皆浊我独清，众人皆醉我独醒”的另类模样: 要有包容的气度和“糊涂”的本事，“持身不可太皎洁，一切污辱垢秽要茹纳得；与人不可太分明，一切善恶贤愚要包容得”；待人要宽容和气，处事要圆融变通； 要奉行恕道，懂得换位思考，能够站到别人的角度想问题: 要让自己的心体如明镜止水般澄澈，意气如丽日光风般平和，用自心的圆满与宽平，去超越充满缺陷的世界、险恶邪僻的人情….· 这些处世技巧反映了作者对世情人性的深刻理解与认识，虽然未免有工于心计、偏于消极之嫌，但其出发点无非是苟全性命于乱世，而且即使在看透世情冷漠污浊之后，却始终要求自己尽力做个好人，其情可悯，其法可效，这是此书问世后不断被视为枕中之秘的主要原因。 1. 放下助人情结，尊重他人命运。因人而异，因材施教。 用一千种方法对待一百种人；而非用自己的一套方法企图说服一百种人。 善启迪人心者，当因其所明而渐通之，勿强开其所闭；善移风化者，当因其所易而渐反之，勿轻矫其所难。 放下助人情结，尊重他人命运 当你对自己的课题认识越深刻，别人的课题就无法 随随便便的干扰你的心力。当你对你自己的课题有非常清晰的认识后，你就会很清楚在解决你人生课题后获得了什么样的价值。你想做什么，该做什么，人生该往哪里走等。这个时候你就会很尊重自己的课题，同时也会尊重别人的课题，因而也会尊重由不同课题产生的不同命运。这种尊重是一种优雅的克制。精髓在于三个字“不干扰”。 面对跟你的课题、价值、认知完全不同的人，尊重人的多样性，优雅而克制的表示理解。但不干扰彼此。不浪费彼此一丝一毫的时间精力专注力。 懂得美妙的擦肩而过，这是一种善良。不堵住彼此的路，让大家达到彼此的目的地。 不着眼于一人一事，而是整个车流、整个交通秩序能不能有序的进行。 如果要让别人理解自己的意思，核心在于“别人”在于倾听方；而不是作为表达者的你。 这时切忌“自我意识过剩”，以己度人，先入为主。 **“不同频”，可能是访谈者的责任。**有的访谈者或自我意识过剩——过于关注自己，忽略嘉宾的真实感受；或提问不当——提出的问题过于私人、冒犯或不合适；或过度准备——“背诵”事先准备好的内容，而不是自然地交谈，相当程式化…… **有些谈话尴尬，是受访者的原因。**有些受访者不擅长表达，无法用言语清晰表达想法或感受，导致对话变得模糊不清或难以理解；有些受访者不配合，不愿意分享个人信息或对某些话题持保留态度，导致对话难以展开…… **不流俗很好，但文化人做节目也容易走向另一个极端，“艰涩”。**不少文化人“自我意识过剩”，很自恋，以自我为中心。他们的谈话节目过多地强调自己的存在，过度自我表现，主导了对话，没有给予嘉宾足够的空间来表达自己……当谈话节目沦为“个人秀”，也就没有太多交流的空间。 沟通方法论的补充： 沟通要讲究策略，尤其在谋求共识时，你的沟通方式和沟通态度尤为重要。沟通是以人为本的，要考虑到沟通者的逻辑水平、情绪理性占比、协商中有利的思维习惯和不利的思维习惯（性格），扬长避短，最小成本达成共识。 沟通最忌讳的就是只顾自己，先入为主。把自己说爽了，对方一百个不服气，这是傻瓜的沟通。 ——————1.考虑情绪因素。沟通时，情绪往往会成为主要矛盾，而让问题本身成为次要矛盾。 2.向下兼容。最优解不一定是最好执行解。要求别人具备和你一样的逻辑水平等是一种强人所难、先入为主甚至自私（说爽了问题却没解决）。 ps:这种水平差距没有高低贵贱之分，只是每人的立场、成长环境、受教育水平不同。这作为谈判沟通的要素必须杯考虑到。 上德不德，大智若愚，大处着眼，难得糊涂 好察非明，能察能不察之谓明；必胜非勇，能胜能不胜之谓勇。 大聪明的人，小事必朦胧；大懵懂的人，小事必伺察。盖伺察乃懵懂之根，而朦胧正聪明之窟也。 伺察以为明者，常因明而生暗，故君子以恬养智；奋迅以为速者，多因速而致迟，故君子以重持轻。 廉所以戒贪，我果不贪，又何必标一廉名以来贪夫之侧目？让所以戒争，我果不争，又何必立一让的以致暴客之弯弓？ 不着相： 立业建功，事事要从实地著脚，若少慕名闻，便成伪果；讲道修德，念念要从虚处立基，若稍计功效，便落尘情。 为善而欲自高胜人，施恩而欲要名结好，修业而欲惊世骇俗，植节而欲标异见奇，此皆是善念中戈矛，理路上荆棘，最易夹带，最难拔除者也。须是涤尽渣滓，斩绝萌芽，才见本来真体。 昨日之非不可留，留之则根柢复萌，而尘情终累乎理趣；今日之是不可执，执之则渣滓未化，而理趣反转为欲根。 心是一颗明珠，以物欲障蔽之，犹明珠而混以泥沙，其洗涤犹易；**以情识衬贴之，犹明珠而饰以银黄，其涤除最难。**故学者不患垢病，而患洁病之难治；不畏事障，而畏理障之难除。 不怕追求活生生的欲望，因为至少能看得见，好改； 最怕自己的能力、学识、认知把自己囚禁局限住。能力认知越强，越容易听不进外界信息，自以为是，画地为牢。 静气： 学者动静殊操、喧寂异趣，还是锻炼未熟，心神混淆故耳。须是操存涵养，**定云止水中，有鸢飞鱼跃的景象;风狂雨骤处，有波恬浪静的风光，**才见处一化齐之妙。 欲遇变而无仓忙，须向常时念念守得定；欲临死而无贪恋，须向生时事事看得轻。 纷扰固溺志之场，而枯寂亦槁心之地。故学者当栖心玄默，以宁吾真体；亦当适志恬愉，以养吾圆机。 贫土肯济人，才是性天中惠泽；闹场能学道，方为心地上工夫。 分别心： “持身不可太皎洁，一切污辱垢秽要茹纳得;与人不可太分明，一切善恶贤愚要包容得” 好丑心太明，则物不契；贤愚心太明，则人不亲。士君子须是内精明而外浑厚，使好丑两得其平，贤愚共受其益，才是生成的德量。 强极则辱，情深不寿 “乐意相关禽对语，生香不断树交花”，此是无彼无此之真机；“野色更无山隔断，天光常与水相连”，此是彻上彻下之真境。吾人时时以此景象注之心目，何患心思不活泼，气象不宽平？ “乐意相关禽对语，生香不断树交花”，这是不分彼此的真趣；“野色更无山隔断，天光常与水相连”，这是相通的美好境地。如果我辈能时时对此景象有真切的观赏和领悟，那心意自会舒畅，眼界自会博大。 包容之下要有原则和底线: 习伪智矫性徇时，损天真取世资考，至人所弗为也。 君子宁以刚方见惮，勿以媚悦取容。 总有不能丢弃的信仰、原则、底线。 总有丢掉了便积重难返的东西。 欲望与和谐 **淡泊之守，须从浓艳场中试来；镇定之操，还向纷纭境上勘过。**不然操持未定，应用未圆，恐一临机登坛，而上品禅师又成一下品俗士矣。 操存要有真宰，无真宰则遇事便倒，何以植顶天立地之砥柱？应用要有圆机，无圆机则触物有碍，何以成旋乾转坤之经纶？ 情之同处即为性,舍情则性不可见，欲之公处即为理，舍欲则理不可明。故君子不能灭情，惟事平情而已；不能绝欲，惟期寡欲而已。 贪得者身富而心贫，知足者身贫而心富，居高者形逸而神劳，处下者形劳而神逸。孰得孰失？孰幻孰真？达人当自辨之。 身不宜忙，而忙于闲暇之时，亦可警惕惰气；心不可放，而放于收摄之后，亦可鼓畅天机。 忧勤是美德，太苦则无以适性怡情；淡泊是高风，太枯则无以济人利物。 处世：不刻意，不积怨 落落者难合亦难分，欣欣者易亲亦易散。是以君子宁以刚方见惮，勿以媚悦取容。 膻秽则蝇蚋丛嘬，芳馨则蜂蝶交侵。故君子不作垢业，亦不立芳名，只是元气浑然，圭角不露，便是持身涉世的一安乐窝也。 士君子之涉世，为人不可轻为喜怒，喜怒轻则心腹肝胆皆为人所窥；于事不可重为爱憎，爱憎重则意气精神悉为物所制 从内耗上讲，邀千百人之欢，不如释一人之怨.。 完名美节，不宜独任，分些与人，可以远害全身；辱行污名，不宜全推，引些归己，可以韬光养德。 事事要留个有余不尽的意思，便造物不能忌我，鬼神不能损我。若业必求满，功必求盈者，不生内变，必招外忧。 待人留余地 , 避免情绪化 与人者，与其易疏于终，不若难亲于始；御事者，与其巧持于后，不若拙守于前。**待人而留有余不尽之恩礼，则可以维系无厌之人心；**御事而留有余不尽之才智，则可以提防不测之事故。 处世不必邀功，无过便是功；与人不求感德，无怨便是德。 升米恩，斗米仇。 不要轻易“施恩”。留有余地。 一厢情愿的善良也很可怕。 遍阅人情，始识疏狂之足贵；备尝世味，方知淡泊之为真。 处世让一步为高，退步即进步的张本；待人宽一分是福，利人实利己的根基。 路径窄处，留一步与人行；滋味浓的，减三分让人尝。此是涉世一极乐法。 老少皆宜 少壮者，事事当用意而意反轻，徒泛泛作水中凫而已，何以振云霄之翮？ 持身涉世，不可随境而迁。 总要有一些坚持的东西和极致的体验。 衰老者，事事宜忘情而情反重，徒碌碌为辕下驹而已，何以脱缰锁之身? 少年的人，不患其不奋迅，常患以奋迅而成卤莽，故当抑其躁心；老成的人，不患其不持重，常患以持重而成退缩，故当振其惰气 实践： 梦里悬金佩玉，事事逼真，睡去虽真觉后假；闲中演偈谈玄，言言酷似，说来虽是用时非。 对实践有敬畏之心。 分清理论和实践的关系。 事理因人言而悟者，有悟还有迷，总不如自悟之了了；意兴从外境而得者，有得还有失，总不如自得之休休。 审美 琴书诗画，达士以之养性灵，而庸夫徒赏其迹象；山川云物，高人以之助学识，而俗子徒玩其光华。可见事物无定品，随人识见以为高下。故读书穷理，要以识趣为先。 从五更枕席上参勘心体，气未动，情未萌，才见本来面目；向三时饮食中谙练世味，浓不欣，淡不厌，方为切实工夫。 景物，如山间之空翠，水上之涟漪，潭中之云影，草际之烟光，月下之花容，风中之柳态，若无，半真半幻，最足以悦人心目而豁人性灵，真间一妙境也。 土床石枕冷家风，拥衾时梦魂亦爽；麦饭豆羹淡滋味，放箸处齿颊犹香。 逸态闲情，惟期自尚，何事外修边幅？清标傲骨，不愿人怜，无劳多买胭脂。 夜深人静，独坐观心，始觉妄穷而真独露，每于此中得大机趣；既觉真现而妄难逃，又于此中得大惭忸。 冥想：打开自己意识中的无线网卡，连接大自然和宇宙的信号。 怀若谷，抱朴归真： 胜负心、上进心、欲望（包括求知欲之类）是好的。但此种血性必须由更高维度的品质所把控住，避免走上歪路。 此品质即 谦虚、低调、包容、淡泊、知足 …… 鹤立鸡群，可谓超然无侣矣。然进而观于大海之鹏，则渺然自小；又进而求之九霄之凤，则巍乎莫及。 所以至人常若无若虚，而盛德多不矜不伐也。 虚怀若谷，胜负心放下，很多烦恼迎刃而解。本质是自矜自是。 自以为是，觉得自己牛，心高气傲，反而自乱阵脚，不敢也不能放手享受比赛。 自以为是，觉得自己强，就在事后反复琢磨 胜一分输一分，毫无成长价值。 既丢了精气神，也会让自己失去享受比赛的机会，反复内耗于比赛之外的事情。 不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。夫惟不争，故天下莫能与之争。 我们总觉得下一次机会更好， 他们总觉得这次机会能把握。 擅长强化恐惧。 善于培养勇气。 为了获得安全感，从而稀释“我”，伪装成“无私”。 为了挑战不可能，选择当仁不让，曲解为“自私”。 有一种贴上梦想标签的欲望叫：“比他过得好。” 还有一种看不见的获得叫：“我不再害怕失去。” 没有什么比胜利更加令人空虚了，所有失落都在狂喜过后。欲望的心更喜欢用成功来装饰，而纯粹的心不在乎失败。如果你说你从来就没失败过，那么你也从来没有成功过。 顺境逆境：失意不丧志，得意不忘形 得意处论地谈天，俱是水底捞月；拂意时吞冰啮雪，才为火内栽莲。 才智英敏者，宜以问学摄其躁；气节激昂者，当以德性融其偏。 偏:偏执 众人以顺境为乐，而**君子乐自逆境中来；众人以拂意为忧，而君子忧从快意处起。**盖众人忧乐以情，而君子忧乐以理也。 欲做精金美玉的人品，定从烈火中锻来；思立掀天揭地的事功，须向薄冰上履过。 醴泉无源，芝草无根，人贵自勉，流水不腐，户枢不蠹，民生在勤。","tags":["菜根谭"],"categories":["小品"]},{"title":"欲望与和谐","path":"/2024/08/03/欲望与和谐/","content":"我在思考我向往什么。 当聊起我的一天，我会为没有做自己想做的事而后悔吗？如果会的话，那该多么遗憾？人的一生和这看似普通的一天又有什么区别呢——黑夜白昼往复，人醒而复睡。我总是把理想的状态、理想的自己拖到明天、后天，今天先满足自己的欲望。如果说我真的渴望成为理想的自己，为什么眼下的事情要让渡于欲望和本我呢？我应该立马行动啊！ 结果往往是，我对自己期待已久的欲望浅尝，但不能辄止。直到最终连欲望都懒得满足——玩游戏玩麻了，刷视频刷懵了。 我在干什么？为什么我“空档行驶”时的状态是这个样子(本我主导)？ 或许这才是真实的我。 人性，或者说“本我”往往是一头烈马。如果能驾驭住，就能时不时放出来驰骋天地，纵情恣意。 如果驾驭不住，就要栽跟头，一身灰。 我在思考“欲望”和影响喜不喜欢做一件事的因素。 人与其说不爱数学、不爱学习等等，不如说是一种害怕失败和复杂因素的原始动物性作祟。这种惯性会时不时让我们陷入“拧巴”之中，让实际的自己做与理想背道而驰的事情。是随波逐流，放任高人性乃至神性的超我淹没在 动物原始欲望 之中，还是实现理想超我，这取决于你对欲望的认知——你是否能驾驭它。这需要反复的犯错、纠正、犯错、纠正…… 这种往复带来的焦虑等负面情绪是在所难免的。但当你真的步入正轨时，类似内啡肽的生理性狂喜会比多巴胺带来的奶头乐更深远持久，更开心。 我曾经在高中和大学前中期反复的面临同一困境:面临预期之外的困境时，心理防线崩溃，丧失理性，回到现在看来的“真实”自我。我会报复性打游戏，频繁打飞机；会躲起来看期待已久的小说（如四天看完四本《笑傲江湖》），会选择独处亲近自然。这里面有被压抑的理想超我（期待已久、正能量却被久久拖欠的事），也有原始本我的动物性欲望（生理自慰），还有本我被压抑的爱好（打游戏）。即使他们在理性做事上会让困境更糟糕，但我的心灵会放松——好像我习惯于通过“破罐破摔”来躲避问题。 但这种解决困境的方式显然成本高、效率低。这个短期的“bug宕机状态”是能够通过系统优化（方法论、心理学、世界观）来规避的，所以能够明显感受到我做事“崩盘”的频率和表现都有所改善。但这对考研这种长期专注的事情还不够。 从考研这类有一定难度的事情上讲，我做事的一个优点是相较于平均值，悟性较高，想法多，感受深。但这也是我的缺点——理论超过实践太多。就像根基不深的花，经不住风吹雨打，也开不出饱满的枝芽。兴趣广而不深，难以扎根。所谓“蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也”，做一件事，超不过两分钟，走神想别的事情去了。坚持六七天，又因为几个小事耽误、不了了之了。我的专注力，和成事不足就来源于此。 从成事上讲，“郭靖”、“许三多”式的品质对我大有裨益，但需要我多经挫折，让自省产生在风雨之后，而非风雨之前。这在我的理性上讲得通，但现实生活里，我猜我更容易瞧不起这类朋友，或者看不到其人的长处与力量。更有甚者，这类人如同一把利剑插在我能力的软肋上，随时都在提醒我的不足——而我拒绝面对，因为不敢接受这种“麻烦”。 多经挫折并不容易，这违反了人类好逸恶劳的基因本能，也会冒犯动物性里的欲望。 而面对挫折的大门，就必须在欲望和理想的交界处搞明白——我是否能接受欲望、理解欲望，最终驾驭欲望，接近理想的超我？ 这就要看我的执着的力气了。执着的方向有三点(优先级按我个人优先级划分)： 第一，有强劲的意志，就能在被欲望一次次击败后找到它的弱点，在少数胜利中与欲望成为朋友，赢得它的尊重； 第二，还要有足够的审美——是的，生活品味决定了你理想做的上限。可能是回馈社会、报销家国；也可能是努力赚钱，兼济独善；又或许只是能吃饱饭，从而能多打几把游戏，多刷会短视频满足情绪价值。生活的审美于个人没有高低，但于能量来看，高低之分有，并且差距很大。搞出一个暖和的被窝或精巧的操作、拼图带来的能量，与修身齐家治国平天下带来的能量是不一样的。这个能量的标准，马斯洛需求理论已经给我们提供了参考。 第三，则是理论与实践的结合。理论过多如我，最易纸上谈兵、外强中干。下一分的力气，动一百分的嘴，离事情做成还差十万八千里。实践过多呢，则容易走没必要的弯路，踩没必要的坑。这两个方面失衡都会阻碍一件事的做成。 短视频： 1.事实证明，短视频和短文有辐射效果，容易点成点 ，辐射一大片。这是投入成本远远高于预期的原因。 2.为什么我打游戏就不会走神，写数学就走神打游戏需要及时反馈，随时投入进去。写数学稍微遇到困难，就会愣住，妨碍自己投入，也就是“不连续”的过渡阶段，走神的好时机。 所以打游戏难度肯定都不高，人物移动时不可能忽然不动了，走会神吧？ （难度的背后是过程中的正反馈，是连绵不绝，以及结果的成就感) 面条： 做饭也能让我专注，并且快速进入心流状态。从买菜到整理食材到炒炖蒸，再到收拾厨具。 我发现做家务也能让我专注。 今天状态不佳，低于预期。这时晚上来一碗热乎乎的炝锅面，幸福感唰就上来了了🥰 爆香葱花（多放），炒包菜(掺了点蘑菇），倒酱油、下面条，撒点姜沫，放盐糖。 以下为 kimi AI生成 本我、自我和超我 弗洛伊德的心理学理论中，本我、自我和超我构成了人格结构的三个主要部分，它们在人的心智发展和行为中扮演着不同的角色： 本我（Id）：本我是人格结构中最原始的部分，它遵循快乐原则，寻求即时满足，不受逻辑、现实或道德的约束。本我包含了所有与生俱来的冲动和欲望，如饥饿、性欲等。 自我（Ego）：自我是现实原则的代表，它在本我和外部世界之间起调节作用。自我试图满足本我的欲望，但同时考虑到现实的限制和社会规范。自我通过理性思考和计划来实现目标。 超我（Superego）：超我是道德原则的代表，它包括了个人的道德标准和价值观。超我由两个部分组成：良心（对错误行为的惩罚感）和自我理想（对理想自我的追求）。超我试图抑制本我的冲动，确保行为符合社会规范和个人的道德标准。 这三个结构在人的心理活动中相互作用，影响着人的行为和决策。当三者之间达到平衡时，个体能够健康地发展和适应社会环境。如果三者之间的冲突过于激烈，可能会导致心理问题或行为问题。 本我、自我和超我之间的相互作用: 本我、自我和超我之间的相互作用构成了弗洛伊德心理动力学理论的核心。以下是它们之间如何相互作用的简要概述： 本我与自我的相互作用： 本我是原始冲动和欲望的源泉，它试图追求即时的满足和快乐。 自我则必须在本我的欲望和现实世界的限制之间找到平衡。自我会尝试满足本我的需求，但同时考虑到现实情况，如社会规范、法律和个人安全等。 自我与超我的相互作用： 超我代表了道德和价值观，它对自我施加压力，要求其行为符合道德标准。 自我必须在超我的要求和本我的欲望之间进行调解。自我会努力使行为既符合道德标准，又能满足本我的需求。 本我与超我的相互作用： 本我和超我经常处于对立状态。本我追求快乐和满足，而超我则强调道德和规范。 当本我的冲动与超我的道德标准发生冲突时，自我作为调解者，需要找到一种方式来解决这种冲突，通常是通过妥协或延迟满足。 冲突与防御机制： 当本我、自我和超我之间的冲突无法解决时，自我可能会采用一系列防御机制来减轻焦虑，如压抑、投射、否认等。 防御机制帮助个体避免直接面对内心的冲突，但长期依赖这些机制可能导致心理问题。 适应与心理健康： 个体的心理健康在很大程度上取决于本我、自我和超我之间的平衡。当三者能够和谐共存，个体通常能够更好地适应社会和环境。 如果三者之间的冲突过于激烈或持续存在，可能导致焦虑、抑郁或其他心理问题。 总之，本我、自我和超我之间的相互作用是一个动态的过程，涉及到欲望、现实和道德的不断协商和平衡。通过理解这些相互作用，我们可以更好地理解人类行为和心理过程。 在日常生活中，本我、自我和超我之间的不平衡可能通过以下一些行为或习惯表现出来： 冲动行为：当本我占主导地位时，个体可能会表现出冲动行为，如暴饮暴食、冲动购物或不计后果的冒险行为。 过度自我批评：超我过强可能导致个体对自己过于严格，经常感到内疚和自责，即使他们的行为并没有违反社会规范。 焦虑和压力：自我在本我和超我之间挣扎时，可能会感到焦虑和压力，因为他们难以找到满足所有需求的方法。 逃避行为：为了逃避本我和超我之间的冲突，个体可能会采取逃避行为，如沉迷于电子游戏、社交媒体或过度工作。 依赖防御机制：个体可能会过度依赖某些心理防御机制，如否认现实、投射责任或合理化自己的行为，以减轻内心的冲突。 情绪波动：情绪波动可能是本我、自我和超我之间冲突的外在表现，如突然的情绪爆发或情绪低落。 社交困难：如果超我对社交行为有过于严格的要求，个体可能会在社交场合感到不自在或过度担忧他人的看法。 完美主义：超我可能导致个体追求完美，无法容忍任何错误或不完美，这可能导致工作效率低下和持续的压力。 自我牺牲：自我可能会为了满足超我的要求而牺牲本我的需求，如长时间工作而忽视个人健康和休闲。 缺乏自我认同：如果个体的自我在本我和超我的压力下无法发展出清晰的自我认同，可能会导致身份困惑或自我价值感低下。 依赖或成瘾行为：为了逃避内心的冲突和焦虑，个体可能会发展出对某些物质或行为的依赖，如药物、酒精或食物。 人际关系问题：本我、自我和超我之间的不平衡可能导致个体在人际关系中表现出过度依赖、控制欲强或难以建立亲密关系。 这些行为或习惯可能是内心冲突的外在表现，如果持续存在，可能需要专业的心理咨询或治疗来帮助个体找到平衡。","tags":["随笔","成长","心理学"],"categories":["认知"]},{"title":"克制欲望","path":"/2024/07/26/克制欲望/","content":"[TOC] 主要内容借鉴： 渤海小吏：《史上最著名饭局，鸿门宴上项羽没杀刘邦的真正原因是什么？西楚霸王为何要那样分封天下？》《”成事”的总纲是什么？为什么大多数人”行百里者半九十”的最终半途而废？》 王立群《百家讲坛：大风歌——刘邦传》 电视剧《汉刘邦》 个人感想：人的提升首先要立志。其次实现目标的过程要有足够的悟性和贵人，最后是健康。 立志：志向让你脚下有路可走，从起点到终点有一个完整的奋斗过程。过程不是别的，就是西游记里的九九八十一难，各种落差、困难、怀疑和相信。正是这些挫折提高了我们的实践能力。 悟性：比车子开往的方向更重要的，是能保证车子到达预期的终点。路程够长，车子势必有各种各样的麻烦 —— 油没了轮胎坏了离合松了 等等等等。这时能保证车子继续前进的就是修补能力 —— 让我们的车子足够强大，直到终点。 降低过程成本，提高成事概率的修补能力，正是我们的认知、眼界、方法论。 你能不能凌驾在懈怠、糊涂、诱惑之上，保持前进？你能不能在犯错失误之后，听人劝、听事劝，及时发现改正空间，对自己的做事思路进行迭代更新，变得更加牢固、合理？ 这两个问题的答案就是悟性的两个方面，随机应变和纠错改正。随机应变的多了，也就不会犯类似错误；犯的错误多了，也就更善于随机应变。都是经验、阅历 ，或者说实践。 在笔者看来，后者比前者要更重要。 能够发现错误本身是很大的成长空间。发现之后敢于低头认错扇自己巴掌，这体现的是我们的成长速度。 贵人：与其说是贵人，不如说是有营养的信息。成长谓之修身，从强调修身很多的佛教、道教上看，很多时候阻碍我们进步的不是理论，而是理论联系实践 —— 把他人的错套在我们自己的身上（这是一种悟性）。 理论大家都懂，每个人都能侃侃而谈，喊两句粪土当年万户侯。但有几个人能知行合一？ 难。这是比努力更难、更混乱、不确定性更强的**“关键信息”**。 很多时候我们的目标没问题，悟性和思考量也够了，仍然会“一叶障目、不见泰山”。直到“关键信息”的出现，才会能在这个问题的体系里一通百通，豁然开朗。 健康：字最少的最重要。 最近在看刘邦传。 渤海小吏说克制欲望，王立群说战胜自己。 过去几年我看了很多很多遍“克制欲望”、“战胜自己”这两个词。下意识视之为鸡汤，甚至车轱辘话。 但我从来没领会过，这不屑一顾的词语背后，蕴含着多么深沉的力量。 克制欲望小吏:穷人乍富后，眼光长远而打下天下的，几千年历史只有刘邦和朱元璋。相反悲剧人物如太平天国、赤眉军则多的多。 让人从眼前的苟且看向远方是反基因本能的，这需要高层次的眼界(认知)。 这个眼界需要一代代的积累——家庭的熏陶、贵人的提点、哲人的启发，让你知道资源除了饮食男女、声色犬马，还可以这么玩。 人的最强烈欲望就是 生存欲 —— 保证你和你的家族能够时代繁衍。 没有人能对抗死亡，你能做的，就是让自己的后代一代代繁衍下去，达到另一种形式的永生。 而培养后代，就需要吸引异性，需要物质上的装饰、享受。 总体来说，基因层面的快乐是低级的。绝大多数人，即使有家族底蕴和高人领路，仍然走不出基因层面的快乐。 刘邦是市井泥腿子。咸阳宫里是什么？无数的美女财宝，金碧辉煌的宫殿，各种好吃的、好玩的，美味珍馐，奇珍异食，全部超出眼界之外。 而刘邦初入咸阳宫，这个没有底蕴和见识的小吏，居然一咬牙放弃了快乐成仙的享受，说服了自己本能的冲动，克制住了自己50年来的习气，将眼光放远、将眼界提高，还军灞上，告诉全军咱们还有大事要干。 这才看出此人不凡，成为那个时代最伟大的蜕变者。他跨越了原有的阶级，完成了鲤鱼跃龙门的精神内核层面的改变。 而他改变的先决条件？ 张良、樊哙，智者理性分析，老乡感情劝说。 刘邦自己的悟性。 战胜自己历史人物们克制欲望谋取大业，或者功成名就欲望缠身，在史书上都只是寥寥数语，没有多线战争政治改革那般精彩、起伏。 我们看历史，不免把自己代入到历史人物中，幻想自己也能如鱼入大海、鹰击长空，自在遨游创立英雄伟业。下意识的觉得欲望这东西不足为重。 实际上这是因为我们的立场视野迷惑了我们。 所谓“当局者迷、旁观者清”。我们作为上帝视角，当然知道刘邦还军灞上厚积薄发，勾践卧薪尝胆一雪前耻。有这个乐观的，预知未来的因素兜底，我们做事时的最大难题之一就消失了。这就造成了“我上我也行”的错觉。 上学时，我习惯于带一行李箱+一书包的书回家。 因为在我的视角里，假期的我是清醒理智的，只有在桌子前认真读书的镜头。 真到了场景之中，眼前的信息和决策都成指数级增加。 要不要上个厕所？上厕所带不带手机？上完要不要玩会？每天玩还是定时间？ 等等等等。 现实的诱惑太多了。我们的欲望太活跃了。 都知道战胜欲望，抓住主要矛盾。而又有几个人能真正做到“克制欲望”？ 所以想到和得到中间还要做到。分析利弊、找到方向后，还需要修身。 不是逃避欲望，不是自我洗脑。而是真正驾驭在欲望之上，即使心有所动，仍然能及时纠正。 容错率有多高，纠正成本有多低，都是我们驾驭欲望的标准。 所以这样来看，驾驭欲望太难了。 所有手机应用都在争相蚕食我们的注意力；所有我们所热爱的都想毁掉我们(尼尔波兹曼《娱乐至死》)。 这何尝不是一种眼高手低？ 那么怎样摆脱欲望的囚笼，真正做到 舍小抓大 呢？ 车马未动，粮草先行消灭欲望，创建一个完全规避欲望的环境可以吗？一定时期来看，当然可以。 甚至如果你能逃避欲望，与之对抗直到目标实现，那也是极其强大，值得自豪的一件事。 甚至当前社会背景，应试为主的考核标准之下，这种“自我压抑”能力是能拿出来夸奖，即使生效的。 但这还不究竟 —— 因为你的驱动力还是自我压抑。 任何自我压抑为前提的行为都不能长久。 终有一天你要脱离应试教育和量化考核，回归正常的生活。 正常的生活意味着，当你的神经懈怠下来，不再时时紧绷的时候，你还能专注于预设的目标并保持理性吗？ 不能吧。如果这样也能，那只能说明一点 —— 你已经失去了生活的松弛感，习得性自我压抑。 这时损耗的是健康：身心的放松，或者说心力、精力、脑力的资源储备。 不懂得休息和资源的战略储备，终有一天大敌当前会捉襟见肘。 大英日不落帝国：两次世界大战,让他卖出了所有能对美国卖出的一切战略储备,让他再也无力气从全世界的殖民地吸血,也就那么回事了。 这就来到了一个成事的基础：兵马未动，粮草先行。你要打造能量正循环的系统。 打造能量系统前的理论基础： 关于能量本身的规律： 热力学第二定律的阐释：热量不能自发地从低温物体转移到高温物体，而不引起其他变化。 注意：不是低温物体转移能量给高温物体，而是高温物体奉献自己的能量给低温物体。 老子的阐释：天之道，损有余而补不足。人之道则不然，损不足而奉有余。 贾府鼎盛之时，两府仆人都作为燃料，支撑起了贾氏家族的红红火火、万事兴旺。 反倒是头部的太太、小姐，老爷、少爷们安得其祥，高枕无忧。 这是损不足而奉有余。 贾府衰败，树倒猢狲散。其仆人散开，反而混的不错 这是损有余而补不足。 从结果论来看，可以引申那句：“木秀于林，风必摧之。” 大明王朝能量高时，沈一石可以和官员们沆瀣一气，上下其手，混的左右逢源、虎虎生风。 王朝能量一旦消耗到临界点，第一个被抄家补充朝廷亏空的，就是沈一石这种钱多事少的。 “上下挥霍无度,便掠之于民*,民变在即,则掠之于商” 熵增理论说，自然规律是朝着无序、混乱状态演化。高能量者也希望自己永远沸腾，保持热量干事业。既然“散功”是避免不了的，就需要源源不断的燃料对他献祭。 寻找你的燃料，是任何国家、经济体、公司组织乃至个人发展壮大永远绕不过去的模型。 说的再多，想跑赢天之道，我们需要进的比出的多。 成事的过程中，我们注定会失去很多能量。一个事要干成，必然有大消耗，也要有大助力。 站在山顶没有不遭几次天打雷劈。小事小难，大事大难。 按老子的话： 天长地久。天地所以能长且久者，以其不自生，故能长生。 是以圣人后其身而身先，外其身而身存。非以其无私邪?故能成其私 不自生故能长生，后其身而身先。 如果做这事真的有足够能量支持你，你一定会自发的想去做，而不在乎领先或落后的多少。 即使是在原本的认知中，很困难很枯燥很陌生的事，在合理的正反馈循环系统中上手之后也能形成习惯，降低实践难度，提高实践兴趣，有所个人感悟。 慎独：毋自欺 还是拿高考举例： 高考是有限博弈,是设定好的规则,所以抑制人性; 人生是无限博弈,越是贴合人性走的越省力,走的越长远 回到开头那句话： 任何自我压抑为前提的行为都不能长久。 终有一天你要脱离应试教育和量化考核，回归正常的生活。 所以说到这，我们能理清楚了：欲望的力量有多强大，而克制欲望需要的层面，主要来自于能量的源源不断。 孔老先生话讲：“知之者不如好之者，好之者不如乐之者“ 是也。 所以大学开篇就讲“修齐治平”： 致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。 自天子以至于庶人，壹是皆以修身为本。 (ps:大学作者有争议，四书作者不一定是孔子。《大学》相传为春秋战国时期曾子所作) 这何尝不是一种能量递增？ 实现这个能量系统建立的标志就是： 所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也 你不再需要任何压抑，而内化于你的内心，成为一种本能。 “诚其意者，毋自欺也”，不再需要任何形式的自我压抑和洗脑了。有的只是自我热爱的挥洒。 反馈系统燃料，能量，或者说正反馈如何建立？ 下面有三个标准： 是否技能水平有反馈？ 是否精神领域有满足？ 是否物质层面有回馈？ 这些都是能让我们获得兴趣、快乐的方面。 耗能少、燃料多，都是能规避“行百里者半九十”的因素。 在和欲望的搏斗中，我们很容易忘记刻意提醒自己去把“能量”作为盈亏纲领去校正自己的脚步。 你可以不用着急走多快，但一定要走得稳。你抓取的物质和心灵总纲这条线，是能源源不断跟上的，是正循环的，是付出后能得到满足补偿的那种。 沉迷于“一不怕苦二不怕死“的人，往往因为“用力过猛”而走不远。用力过猛的人通常是迅速成功的幻想者，跟孩子一样渴望得到别人的赞美和证明自己。期待猛投入和猛回报，但这并不符合事物的发展规律。 所以也要学会给自己留冗余，不要妄想天天冲刺的叙事，而是真正脚踏实地的日拱一卒，甚至是原来的我们所不屑一顾的。","tags":["随笔","成长"],"categories":["认知"]},{"title":"孔子，及其身后的道儒法墨","path":"/2024/02/28/孔子/","content":"引用语料： 《中国哲学简史》第四章 孔子，第五章 墨子 墨子连山《孔子一生致力于维护和恢复周礼的原因到底是什么？》《韩非子》 墨子连山《道德经第二十一章、三十八章、四十一章、四十二章、四十六章》（专栏【三十年来《道德经》实践总结】） 孔子其人先看看孔先生的背景吧。 孔子姓孔名丘，公元前551年生于鲁国，位于中国东部的现在的山东省。 他的祖先是宋国贵族成员，宋国贵族是商朝王室的后代，商朝是周朝的前一个朝代。 在孔子出生以前，他的家由于政治纠纷已经失去贵族地位，迁到鲁国。 孔子一生事迹详见《史记》的《孔子世家》。 从这篇“世家”我们知道孔子年轻时很穷，五十岁时进入了鲁国政府，后来做了高官。 一场政治阴谋逼他下台，离乡背井。此后十三年他周游列国，总希望找到机会，实现他的政治、社会改革的理想。 可是一处也没有找到，他年老了，最后回到鲁国，过了三年就死了，死于公元前479年。 孔子是儒家创始人，刘歆说儒家“游文于《六经》之中，留意于仁义之际”。六经即《易》、《诗》、《书》、《礼》、《乐》（今佚）、《春秋》。孔子与六经的关系现在尚有争论。而按照冯友兰先生的观点，孔子是中国的第一位私人教师，而不是中国的第一位私人著作家。六经大概率不是孔子的著作，他本人在《论语》中，也未曾流露过亲自为后代著作的想法。 “子曰：‘述而不作，信而好古，窃比于我老彭。“ 孔子说自己”述而不作“，这里暂且浅显的理解为只是交流分享前人的知识，而没有写作记录的打算。 所以在孔子的时代以前已经有了《六经》。《六经》是过去的文化遗产。 《六经》又叫做“六艺”，是周代封建制前期数百年中贵族教育的基础。 可是大约从公元前7世纪开始，随着封建制的解体，贵族的教师们，甚至有些贵族本人——他们已经丧失爵位，但是熟悉典籍——流散在庶民之中。前一章说过，他们这时靠教授典籍为生，还靠在婚丧祭祀及其他典礼中“相礼”为生。这一种人就叫做“儒”。 孔子毫无疑问是精通六经的。大小六艺，礼乐射御书数，诗书礼乐易春秋。会的不但多，而且精，样样都出类拔萃。 传说孔子身高九尺六，自己作为徒弟们的射箭教练兼战车驾驶教练。所有孔子门人，射、御是必修课。孔子带着弟子练射箭，是会被围观的。 孔子出生于武将世家，他爹身高一丈，曾经单人力举城门，救出半只部队。这老爷子平时配剑，当时兵荒马乱，不配也不行。你想想这个遗传基因。孔子还特别爱吃肉，听说过“三月不知肉味”吧？那首先得是吃了三个月的肉。一个猛将之子、一米九大个、专业运动员的身板、配着剑、顿顿吃肉，说他是老师，反差是不是有点大？ 孔子做过中都宰，相当于市长兼市委书记；坐过大司空，相当于建设部长；坐过大司寇，相当于公安、司法部长；最高做到大司空涉相事，就是代理总理了。当然了，与他真正的事业相比，这些政治成就可以忽略不计： 有教无类、因材施教、学而时习之、温故而知新、举一反三等等教育理念，直到现在也没有跳出他的框架，教育才是孔子真正的道路；弟子三千，贤者七十二，这是他的实践，万世师表，为教师这个伟大行业树立了标杆。 孔子其道在道家的著作《庄子》中，可以看到道家的人常常嘲笑孔子，说他把自己局限于仁义道德之中，只知道道德价值，不知道超道德价值。表面上看，他们是对的，实际上他们错了。 请看孔子谈到自己精神修养发展过程时所说的话吧，他说：“吾十有五，而志于学。三十而立。四十而不惑。五十而知天命。六十而耳顺。七十而从心所欲，不逾矩。”孔子一生，到了三十四十，也许仅只是认识到道德价值。但是到了五十、六十，他就认识到天命了，并且能够顺乎天命。换句话说，他到这时候也认识到超道德价值 小一辈的孔子曾专门拜访、请教过老子，更关键的是，他们读的书都是一样的，礼记、尚书、诗经、易经等等，而且老子就在周的图书馆，这些书都是周书。所以，他可能比孔子看过的书还多。从后来孔子的思想中，能看出他继承了很大一部分老子思想。但关于超道德价值的道，不管是出于经世致用的目的，还是因为老子对道的阐述已经足够完善，孔子无需补充转而走向延申阐述“德”的道路，我们都不能通过论语中的只言片语，就随意武断孔子境界低或者层次低。 至于孔子的思想： 在聊到传述传统的制度和观念时，孔子给予它们的解释，是由他自己的道德观推导出来的。像对”三年之丧“礼制的解释，对”诗三百“的评价。中华文化中的很多关键词，都是由这位先贤定义的，忠孝、仁义、信用……没有这些关键词，我们甚至连开口说话都困难，更不用说流传下来的上百条成语了。 这种以述为作的精神，被后世儒家的人传之永久，经书代代相传时，他们就写出了无数的注疏。后来的《十三经注疏》，就是用这种精神对经书原文进行注释而形成的。正是这样，才使孔子不同于当时寻常的儒，而使他成为新学派的创建人。正因为这个学派的人都是学者同时又是《六经》的专家，所以这个学派被称为“儒家”。 但我们需要知道，儒学和儒家是要区分开来的。把孔子创立的儒学比作一个容器，后世数代的人们都往这个容器里添加了自己的私货，形成了各色各样的学派，像理想主义的孟子，现实主义的荀子，研究宇宙发生的周敦颐、邵雍，和外来佛教融合的新儒学，以及后续大名鼎鼎的理学心学之争。 道家则是杨朱老庄，后续的新道家则划分为主理和主情两派。 《尚书》有云“人心惟危，道心惟微，惟精惟一，允执厥中。” 在前人“允执厥中”的基础上，他进一步提出了了“君子之中庸，君子而时中” 一个是“中庸”，就是不偏不倚，不左不右，直奔目标。而目标是什么呢？是无处不在的“有用”。有了这个外挂，孔子的学说就不可能错。因为只要有人实践不成功，我们就可以说是他自己的问题，因为他没做到“有用”，所以他没有做到中庸。 另一个是“时中”，中不是静止的、一成不变的，而是要与时俱进的，昨天偏左了，向右是中，今天偏右了，向左才是中。如果你不变，出了问题就不能怪理论，因为人家说得很清楚了，要与时俱进。咱们自己因循守旧，该变却不变，不是只能怪自己没有执行到位？ 当然了，如果孔子仅仅满足于开挂，保持不败金身的话，那么他绝不至于到达圣人的高度。 他的伟大之处在于为“有用”设立了一个明确标准，那就是仁。 仁者爱人，施恩于人，己所不欲勿施于人。 大家可不要小看这个字，中华文明的伦理核心就是他所定义的。 中华文明的伦理观是什么呢？ 是恩文化，是积极施恩与人的文化，是受人滴水之恩，必将涌泉相报的文化。不但报恩，而且要超量报恩，而第一次的施恩，我们也可以看作是超量报恩，从无到有产生新的恩。于是，恩上加恩，人间充满温情。 这与基督教文明的“罪”文化形成了鲜明对比。 另外，孔子提出了“学而时习”的概念，不但要学，而且要实践，他自己带头。 于是有了中国第一位民办教师，弟子三千，贤者七十二。 他在历史上首次以私人身份教导了几千个学生，在周游列国时，这些学生成群结队的跟随着他。 大家可不要小看这位教师的力量，他的弟子中藏龙卧虎。有兴趣的可以自己去查查，曾子、子夏、子贡……这些人以及他们的弟子影响了整个战国时代。 中国的尊师重教，历经几千年延续至今，孔子可谓居功至伟。 一生致力于维护和恢复周礼的原因因为，那时候除了周礼，还有什么更好的选择吗？例如选择殷礼？ 周礼以人为本，强调人文精神； 殷礼以神为本，强调神鬼核心； 孔子自称“殷人之后”，但是他却坚定的主张，“周监于二代，郁郁乎文哉！吾从周。” 为什么？ 答案的关键，就是这个“文”字。 文，甲骨文是一个人身上刺有花纹，也就是现在的纹身，显然这个字与人有着不可割裂的关系。现在我们人文并称，有人才有文，给人用的才叫文，所以又有了文化、文明等等。 孔子这句话赞颂的其实正是周礼的人文精神，用现在话说就是以人为本的精神。只有以人为本了，礼乐才开始围绕着人来设计，而不是围绕着鬼神设计。只有当围绕着人来设计礼乐，礼乐才能“郁郁乎”繁盛。否则，如果都是为了鬼神而设计，根本不管人的感受，他还可能繁盛吗？谁没事会用他呢？ 与人本主义相对应的，就是神本主义，凡事以神鬼为核心，人则靠边站，殷商的文化就是如此。 商纣王为什么如此暴虐？发明了挖心、炮烙、醢等等惨绝人寰的酷刑，难道就是因为心里变态吗？其实，这些玩意很可能不是刑罚，而是祭祀所需要的献礼。 从对商纣王的描述来看，这个人力大无穷、辩才无碍、高大帅气，妥妥的一个学霸。而且他能征惯战，铁腕政治，绝不可能是一个患有精神疾病的人。从他的表现看，更加有可能是一个宗教狂热分子。他的认知就是，只要我对鬼神虔诚，他们就一定会保佑我。 联系到殷商的占卜和祭祀制度，烧龟壳，然后按照图案指示去给鬼神准备贡品，其结果本就难以预测。很可能烧出了一副图案，像是一个人在嚎哭，他们便想，怎么才能让一个人使劲嚎哭呢？于是发明了炮烙。过两天又烧出了一个图案，像是一颗七窍玲珑心，那就赶紧找吧？可是人心隔肚皮，怎么找呢？那就只能挖出来找。找了几个都不像，于是他们就想了，是不是越贤明的人心才越好呢？王子比干最贤明啊，为了虔诚，那就把比干的心挖了献祭吧。 不光是商纣王，整个殷商的文化应该都是如此。所以即便是施行了这么多让我们毛骨悚然的酷刑，商纣王的统治依然还是稳固的，直到以人为本的周人推翻了他们。 周是中国人本思想的奠基者。虽然在这之前我们不能说他们没有这样的思想，但起码可以说并没有明确下来、推广开去。而周公制礼，则是把人本思想确立了下来，并且传播到了每一个角落。 到了春秋时期，老子在《道德经》中写道，人法地，地法天，天法道，道法自然，域中有四大，人居其一焉。如此一来，便将形而下的人，与形而上的道联系起来，在理论上奠定了人与道天地并列的基础。可以说，是人本主义思想的集大成者。 **孔子继承了老子，通过宣扬礼，继续将人本思想加以巩固，从此几千年，中国人再也没有陷入到宗教的泥沼，**从来没有过黑暗的中世纪。 这不也证明了周礼是正确的选择吗？ 有德之人，何谓其德？上文提到，孔子和老子是一脉相承。不看道德经，了解一些老子的知识，同样搞不懂孔子的”道“与”德“。 我们一起来看《道德经》第三十八章上德不德： 上德不德，是以有德；下德不失德．是以无德。上德无为而无以为；下德无为而有以为。上仁为之而无以为；上义为之而有以为。上礼为之而莫之应，则攘臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。前识者，道之华，而愚之始。是以大夫处其厚，不居其薄；处其实，不居其华。故去彼取此。 《德经》第一章就语出惊人，仁义礼智被全盘否定，很多人据此说老子是反对儒家的，也有人把老子理解成了虚无主义，更有甚者据此认为老子是反人类、反社会的。实际上，老子并不是否定仁义礼智存在的意义，而是要说明，在有更好的认知模型的情况下，不要选择差的那一方。俗语可以理解为”不要把路走窄“。这个最好的认知模型，最宽的康庄大道，就是老子口中的”道“。 有道之人无需刻意追求德，因为道的认知里，德已经是内化于心、顺其自然的产物了。有德之人无需刻意追求仁，也是同样的道理。这里可以参考孔子所言”七十而从心所欲，不逾矩“。这里的矩，可以理解为德之下的仁、义、礼。”我已具备德的品质，仁义礼智信等都是德之下的延申，不需要刻意约束我自己，我也不会再违背了。“这一点也可以与道德经里的”无为无不为“相印证。 德：上德无为而无以为；下德无为而有以为。 上德并不刻意去追求德，因为他追求的是道，所以有德。追求德，和追求道有什么区别？ 好比咱们打羽毛球，练高远球标准动作，高手是把这些标准动作训练成了肌肉记忆，只要球来了，自然而然的就会打出一整套连贯的标准动作。但是，他会去想每一个环节做得是不是标准？动作是不是连贯？发力是不是集中？正是因为他不想，所以动作才能行云流水，也才能把高远球打好。 下德刻意的去追求德，唯恐失去德，所以还处在无德而求德的阶段。 还是打高远球，新手训练一定是从分解动作练起，蹬地、转髋，转肩、挥臂、旋腕、收指，每个动作都有很多的细节，需要一项一项的打磨。整个一遍练下来，分解动作都没问题了，就要练习连贯了。 很多环节是同步的，还有一些环节是动力链，一环扣一环，连贯做不好，就会怎么打怎么别扭，还不如之前业余瞎打。 为什么不能连贯？因为练得不够，没有把动作融进潜意识，每个动作都需要想，这一想就慢了，慢了动力链就断了，断了就发不出力了，高远球自然也打不远。 下德就是这样，他们时时刻刻、心心念念想着“德”，为人处事不自然，反而会让人觉得惺惺作态。为了获得“德”这种回报而去做事，就好像为了把标准动作做对而去打球，反而适得其反打不好，所以叫做无德。 上德不会刻意作为，是因为“本应如此”，为什么本应如此？因为道是世间万物万事运转的底层逻辑，是大本大源。既然是抽象到最高层的大本大源，那具体到一件件小事上，抽象的规律便会埋藏其后，不着痕迹。我们所能做的，就是摔一次跤后不让自己在同样的坑摔第二次。即使再摔第二次，也不要摔第三次。在实践中成长，用实践指导我们做事的方法论。 这就是前面说的“道可道，非常道”。一切以时间、地点、条件为转移，实事求是。不妄想用一个道理、一次经验、一次实践就一劳永逸。随着时间的推进不断的更新自己，迭代认知模型。 俗语常说知足的人最富有，道德经说”知足之足常足“。都是一样的道理。像”好好努力，绷紧弦，考上好高中就稳了；考上好大学就能随便玩了；找个好单位这辈子就拿下了“，这种心态只会让自己像一个追着胡萝卜跑的驴一样，永远被欲望骑在身上，难以收获真正的快乐。 像咱们在追求道的过程中，心里形成了一个叫做德的半成品模型。虽然还不是道，但他具备了道的混沌特征，就是说不清。我还尚未领会其意，只是在路上跌跌撞撞的闯荡、探索。直到量变引起质变后，通过复盘反思一朝醒悟。 为什么觉得星空很美？不知道，语言无法描述，也不用描述，美就是美，这才是德。如果咱们能列出一二三四来论证星空的美，那咱们论述的已经不是美，而是具体的一二三四这些概念了。 所以，老子才说，下德无为而有以为。意思就是，虽然咱们不刻意去做什么，但仍然有一个不刻意而为的理由，哪怕理由是为了仁爱、为了道义、为了信用，这些未必不好，但就德而言，已经是下德了。 在你约束自己”不要刻意“的时候，你已经刻意了。 在你强迫自己忘掉这件事的时候，你又强化了一遍自己的记忆。 哈哈，这里有点禅宗的意趣了。 仁 ：上仁为之而无以为 如果德做不到，那就只能退而求其次追求仁了，仁者爱人。 大家可能就困惑了，爱人有什么不好呢？为什么老子要批判仁爱精神呢？请各位注意，老子并没有评价好坏，老子说过“美之为美斯恶也”，人家说的就是价值判断没有固定标准，只是相对而言，所以不会犯这种低级错误自己打脸的。 老子之所以说仁是一个退而求其次的选择，只是因为与德相比，他确实就是退而求其次了，这是一个事实，或者说这是形式逻辑推导的必然结果，并不带有任何主观因素。 为了理解这一点，我们要回顾一下，究竟什么是德？道是宇宙万物在人心中的投影，或者说，道是人类思维为宇宙建立的那个完美模型，他是一个理想状态。 人类很难达到那个理想状态，因为我们用于建立复杂模型最有效的工具是语言，广义的语言包括了自然语言、数学语言、机器语言等等。全部这些语言加到一块，也没办法建立一个精确的完美模型。但是，好在我们可以用类比的方式去建立一个模糊模型。这个模型虽然不精确，也不完美，不能做到100%预测万事万物，但他终究还是更接近于道了。这个我们心中模糊的，不完美的，追寻着道所建立起来的半成品模型，就叫做德。 天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。道的特点是，以万物为刍狗；德的特点与道类似，以百姓为刍狗。 刍狗这个意象多次讲过，这是一个非常形象的比喻。刍狗是草扎的狗，粗制滥造，祭祀之后不是烧了就是扔了，其本身毫无价值。但是，他是祭品，所以又很神圣。因为不结实，要轻拿轻放，倍加小心。祭祀的时候摆在祭坛前面，人们对着祭坛行礼，看起来也就是对着刍狗行礼。 一句话总结，就叫对你好，但与你无关。 所以，德就是这样，没有任何目的、没有任何企图，你之所以觉得我对你好，其实并不是我为你做了什么，而是我追寻着道，而你这个刍狗沾光了而已。 各位觉得这种德，咱们自己可以做到吗？是不是很难做到？难就对了，因为老子所讲的德根本就不是为咱们普通人讲的，而是为天子讲的，诸侯勉强也可以参考，至于诸侯以下的士大夫都已经不适用了，那就更别说平民百姓了。为什么天子要修德呢？因为天子富有天下，任何一点喜怒好恶都会被一层层逐级放大。上有所好，下必甚焉，所以对待任何事、任何人都要慎之又慎。一个合格的天子不能偏爱任何一个人，因为这种偏爱会给予这个人极大的权力，以至于导致权力失衡；也不能偏好一件事，喜好战争就会引发穷兵黩武，喜好女色就会引发荒淫无度；甚至喜欢学习、文艺、体育都不行，因为会有人钻营取巧，投其所好，就算没有人迎合，自己也会玩物丧志。所以，天子不是人，天子是天的代表，他的所有行为要尽可能的符合于道，所以他追求的是德。 现在天子虽然没有了，权力的焦点却永远都在。就算是一个普通人，也会有不同的社会角色，对父母是子女，对子女是父母，对老婆是老公，对朋友是朋友，对领导是员工，对员工是领导。这么多的角色要怎么管理？ 咱们自己也需要一个天子的角色去统管所有这些角色。而天子角色，所要追寻的就是道，指导行为的就是德。 但是，一个人有很多不同的角色，也不可能只按照德的方式去扮演所有角色。于是就有了仁。仁的基础是“恻”，也就是共情能力。 看到婴儿在井边爬，是不是想一想都一身冷汗？遇到这种情况，没有人能视若无睹吧？这就是孟子所说的“恻隐之心，人皆有之。”正是这种共情能力使人类天生心中就有仁。 那为什么说仁比德是退而求其次了呢？因为德离道最近，以德行事，不但可以使万物众生感受到咱们对他的好，而且还可以使他们获利，可谓两全其美。所以，德虽然没有刻意的仁，但却可以达到所有仁能够达到的效果，可以说，道兼容了德，德兼容了仁。 那仁与德的区别是什么呢？**德的目标是道，仁只是过程中的副产品，我对你好但与你无关。仁的目标就是人，我对你好就是为了你。**求其上者得其中，很可能出现“妇人之仁”这一类仁而无用的东西，我只是爱你，但却对你一点帮助都没有。更糟糕的是，会出现“假仁”，我表演出一副仁的模样就好了，反正这就是目标嘛，达到就好了，管他怎么达到呢？当然，这还不是最糟糕的。最糟糕的是，有人会借着仁的名义实施道德绑架，或者强行把自己的喜好强加于人。 坐车就有年纪大一些的人倚老卖老，强行要求年轻人让座，不让座就恶语相向，说人家没教养；家长借着”我为你好我有理”的名号，强行动摇孩子的选择；熊孩子划了人家车，家长不但不道歉，还说对方抓住熊孩子是大人欺负小孩；自己听歌觉得好，就一定让别人必须听，说不好听都不行…… 例子太多，就不一一列举了。孔子也意识到了仁存在这些问题，所以当子贡问孔子，如果一辈子只遵行一句话，应该是哪句话？孔子并没有说“己欲立而立人，己欲达而达人”，而是说“己所不欲勿施于人”。就是担心后世曲解，给道德绑架找借口，不可不谓一片仁心啊。 而德就没有仁的这些问题，因为德是个人的事，不论是心还是行，都与他人无关，所以不可能被利用或者歪曲。所以，老子说，失道而后德，失德而后仁。 关于“己所不欲勿施于人”，和“己欲立而立人，已欲达而达人”： 《论语》记载：“仲弓问仁。子曰：‘……己所不欲，勿施于人。’”（《颜渊》） 孔子又说：“夫仁者，己欲立而立人，已欲达而达人。能近取譬，可谓仁之方也己。”（《论语·雍也》） 由此看来，如何实行仁，在于推己及人。“己欲立而立人，己欲达而达人”，换句话说，己之所欲，亦施于人，**这是推己及人的肯定方面，孔子称之为“忠”，即“尽己为人”。 ** “己所不欲，勿施于人”,这是推己及人的否定方面，孔子称之为恕， 推己及人的这两个方面合在一起，就叫做忠恕之道，就是“仁之方”（实行仁的方法）。 后来的儒家，有些人把忠恕之道叫做“絜矩之道”。就是说，这种“道”是以本人自身为尺度，来调节本人的行为。 絜矩之道在大学中庸中皆有阐释： 儒家有一部论文集名叫《礼记》，其中有一篇《大学》，说：“所恶于上，毋以使下。所恶于下，毋以事上。所恶于前，毋以先后。所恶于后，毋以从前。所恶于右，毋以交于左。所恶于左，毋以交于右。此之谓絜矩之道。” 《礼记》另有一篇《中庸》，相传是孔子之孙子思所作，其中说：“忠恕违道不远。施诸己而不愿，亦勿施于人。……所求乎子，以事父。……所求乎臣，以事君。……所求乎弟，以事兄。……所求乎朋友，先施之。” 义： 上义为之而有以为 而义对于仁而言则又退而求其次了。 如果说仁还是符合人的本心、主动去爱人的话，那么义则带有被动性。这违背了人的私欲。也就是说，义的推动力就不能只来自于人的内在自发，而需要借助外力，最主要的就是来自于他人的舆论。 这样一来，问题就更大了，既然义来自他人舆论，那如果有人去影响他人舆论，来确定我们是义还是不义，我们的自由岂不捏在了他人手里？ 这种担心并不是多余的，朝野之中的党同伐异，封建礼教，愚忠愚孝……这些都根源于义。 当然，这并不说明义有什么不好，好像一把菜刀，可以用来切菜，也可以用来杀人。有人用菜刀杀了人，我们总不能去指责刀匠生产了菜刀吧？不是刀杀人，是人杀人。 孟子提倡义，只不过是磨了一把刀。把刀磨的锋利无比不是孟子的错，后世的人不用这把锋利无比的刀切菜，造福人间，反而拿他去杀人，谁才是凶手？ 不论如何，与仁相比，义的危险性更大，所以老子才说，仁做不到了再退而求其次才追求义。 礼：上礼为之而莫之应，则攘臂而扔之 如果精神层面连义都做不到了，那就只好追求形式上的礼了，到了这个地步，已经是没有办法的办法了。 所以老子形容礼，是需要刻意而为的，就算刻意推广，结果却是“莫之应，则攘臂而扔之”。这个描写就非常形象了，就是咱们去推销东西，人家不理，咱们就强拉着硬塞给人家。用现在的话说，就叫强买强卖了。 前面说义已经带有强迫性了，但好歹还只是语言、态度上的强迫，虽然也算强迫，但并不强硬。可到了礼，可就真要动手了，古代不讲礼法，真的是要被判刑的，例如用了不该用的车子、穿了不该穿的衣服等等。包括现在也要讲究很多礼节，通过履行很多高情商的“潜规则”来表明自己的诚心和忠心。当然了，这个层次诚心只是通过特定的行为表面上表明了，其背后的人心仍然是不稳定因素。 像一些目的性强的利益酒局，劝酒的一门心思灌醉他人，被劝的骂他一万句不是，表面上也要恭恭敬敬、心甘情愿的咽下去。 酒喝完，事谈成，各自在背后扣嗓子吐酒，一个愿打一个愿挨，不得不做。 当然，辩证的看，礼节也有好的一面。好的礼法提供了一种行为准则：小事上能让大家用彼此心领神会的方式表达自己，节省了沟通成本；大事上能维系群体和谐，让大家在追求自我个性、满足自我利益的同时也能履行社会义务。 但如果到了仅仅靠强制性的礼去维护，依礼者没有通过礼节表达自己，甚至只是空洞的走个过场，那么再好的礼制最终也会沦为形式主义，最终消失殆尽。 故失道而后德，失德而后仁，失仁而后义，失义而后礼。 道德仁义礼，就是一步步妥协，逐步退而求其次的过程。 从道的自然，到德的效法自然，再到仁的发自内心主动爱人，再到义的半自发半强迫的自我牺牲，最后到礼的完全形式化的行为标准。 所以老子说，到了刻意强调礼的时候，必然是道德仁义这些内在的、自发的东西已经淡薄到极致了。 不忠不信的人太多了，迫不得已，才只好用礼去规范他们。所以，礼就是“乱之首”。 这个首字要注意，很多人把他翻译成罪魁祸首，显然曲解了老子的意思。老子说礼是迫不得已的产物，可没说是因为礼才迫不得已的，因果不能搞混了。首，就是头，也指起始点。罪魁祸首这个词，要到明朝才出现，老子那个时候是没有这个用法的。所以，老子说礼是“乱之首”，就是字面意思，到了礼就要开始乱了，礼是乱的起始标志，而不是说因为有了礼才会乱。 前识者，识与认相对，我们现在常说认识，要先认而后识。认，从言从忍，指用言语对事物进行分割，分割成什么呢？分割成名，也就是概念。识，从言从织，指把语言关联起来，也就是把概念连接起来。概念连接起来就是理，指概念之间的连线，是不是很形象？而理继续综合就变成了知，也就是有用的经验。所以，前识，指的就是这些理和这些知。 老子把前识比喻为“道之华”，华就是花，华而不实就是只开花不结果。 意思就是，这些理和知虽然看起来很美，但那只是形式，如果咱们只追求这些，那就是“愚”的开始。愚，甲骨文是心上面一只猿猴，就是心猿意马中的心猿。“意”，也就是咱们的注意力，这东西很活泼，但带宽却有限，如果放任不管，他就会像猿猴一样四处乱窜。注意力不集中，自然就显得愚蠢了。 老子用这个字是想说，如果咱们被花吸引，把心全部放在理和知上面，看花看太多，就会乱花渐欲迷人眼，忘掉自己一以贯之的初心了。 玩手机，也许开始我们带着目的，一旦打开短视频之类的信息流中，很容易忘记自己一开始为什么要打开。 所以，大夫们不居住于薄的地方，薄的是什么，是礼；而应该处于厚的地方，厚的是什么，道德仁义，道最厚，依次递减。不应该居住于花，花是什么，理和知；而应该处于果实，果实是什么，当然是心中那个德，也就是半成品的道。 老子讲这些，是讲给大夫听的吗？当然不是，仍然是讲给天子、君主听的，所以最后才有这么一句，“故去彼取此”。意思就是，因为大夫们应该处其厚、处其实，所以咱们作为君主的，要取其厚、取其实，给团队营造良好环境，这样才能把大家凝聚起来，咱们自己才能无为而无不为！ 道、儒、法、墨我们总是习惯性的把道、儒、法、墨四家分的清清楚楚，甚至互相看不顺眼；可实际上，他们根本不是并列关系，而是内核高度一致，路径各有不同。 老子和孔子最早的老子，他谈到了宇宙万物，既谈了道，也谈了德，是最大的那个圈。 小一辈的孔子曾专门拜访、请教过老子，更关键的是，他们读的书都是一样的，礼记、尚书、诗经、易经等等，而且老子就在周的图书馆，这些书都是周书，所以，他可能比孔子看过的书还多。从后来孔子的思想中，能看出他继承了很大一部分老子思想，尤其是关于道，孔子不再谈了，他只谈德。 这感觉就像是我在知乎看到一个很有意思的问题，看了一眼答案，发现人家已经回答了大部分，只是有一块没说透，需要展开，于是我只需要单独展开来谈这一块就够了。 孔子展开的就是德的部分。这些都是他们重叠的部分，不同的是什么呢？是方法，道家认为你什么也别管，让社会自己运行，这是最好的方法。 “治大国若烹小鲜”，千万别折腾，那么多小玩意你能挨个折腾？显然不能，折腾多了小虾小贝就都碎了，没法吃了。 儒家现阶段不适合用这个方法，儒家认为要先用“礼”，积极树立榜样，引导大家有样学样，君先打个样，臣跟上，爸爸跟着学，儿子跟爸爸学，完美。**由礼及义，由义知仁，由仁生德，由德得道。**讲究一个循序渐进的过程。 道德经里说”道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。“ 这个“一”就是对立统一的“一”，就是矛盾双方的统一体，就是有正反两面的硬币，就是太极，也叫太一。 这个“一”，还是《尚书》中《禹谟》里舜对禹说的“人心惟危，道心惟微，惟精惟一，允执厥中。” 这个“一” , 还是孔子所说**“吾道一以贯之”**的“一”，曾子解释是“忠恕而已矣”，这里说的是孔子的“道之用”。 理解了这个“一”，那么“一生二”就好理解了，“二”就是矛盾双方，中国的说法叫阴阳。《周易》说“一阴一阳之谓道”，也就是矛盾双方对立统一，反之又反永恒运动。这种运动便产生了三，然后是四、五、六，以至于无穷。量变引起质变，最终产生了宇宙万物。 而孔子“道之体”，必然是与老子，《周易》，《尚书》一脉相承的。因为，孔子看的书，跟老子是一样的，周的文化奠基人就是武王的弟弟周公，而周公被封在鲁国，孔子便是鲁国人。 韩非子韩非其人 韩非子处于战国末期，是韩国（今河南省西部）公子，祖国韩国是战国七雄中最弱的一国，离秦国又近，被秦国百般欺凌，积贫积弱。 他受够了这种半死不活的状态，原地踏步无异于等死，所以不论如何也要踏出一步，这一步就成了法家之集大成者。 《史记》说他“与李斯俱事荀卿，斯自以为不如非”（《老子韩非列传》）。他擅长著书，著《韩非子》五十五篇。 富于讽刺意味的是，秦国比别的任何国家都更彻底地实行了韩非的学说，可是他正是死在秦国的狱中，这是公元前233年的事。 他死于老同学李斯的政治暗害，李斯在秦国做官，嫉妒韩非在秦日益得宠。 深谙“御下之术”的韩非子，竟然敢冒天下之大不韪，在千古帝王面前谋求保全韩国，以至于被李斯所害。或许韩非身上还有杀身成仁的赤子之心未可知。 社会背景 周朝的后几百年，封建社会制度逐步解体，社会发生了深远的变化。君子和小人的社会区别不再是绝对的了。 在孔子的时代，已经有一些贵族丧失土地和爵位，又有些平民凭着才能和运气，顺利地成为社会上、政治上的显要人物。 **社会各阶级原有的固定性，被打破了。**随着时间的推移，通过侵略和征服，大国的领土越来越大了。 为了进行战争，准备战争，这些国家需要一个强有力的政府，也就是权力高度集中的政府，其结果就是政府的机构和功能比以前越来越复杂得多了。 自孔子以来诸子百家共同努力解决的就是国家治安问题。可是他们提出的解决方案，已经不够现实、难以实行了。 各国诸侯需要的不是对百姓行仁政的理想纲领，而是如何应付他们的政府所面临的新情况的现实方法。当时有些人对现实的实际政治有深刻的理解。诸侯常常找这些人打主意，如果他们的建议行之有效，他们往往就成为诸侯相信的顾问，有时候竟成为首相。这样的顾问就是所谓的“法术之士”。 核心观念 韩非所在时期，法家已经发展了三派，韩非作为集大成者，吸收了(慎到)的势、(申不害)的术、(商鞅)的法。 “势”，指权力，权威；“法”，指法律，法制；“术”，指办事、用人的方法和艺术，也就是政治手腕。 法 : 法治萌芽 韩非师从荀子，受到老师的影响，他认为人都是自私自利的。如果没有一个强大的外力作用，儒家希望构建的那个帕累托最优是无法实现的。而儒家所依赖的外力是什么呢？是圣人，尧舜禹，汤文武，还有周公。孔子那个年代，周公的影响力还在，人们心中还存有希望，希望能有圣人降世。 但是，到了韩非那个年代，经过几百年的战乱，这种希望已经彻底破灭了。所以，韩非认为圣人是可遇而不可求的，想解决眼前的问题，不能等着天上掉圣人，创造人类幸福，全靠我们自己。 所以，韩非总结了子夏、李悝、吴起、商鞅这一线的传承，希望退而求其次来构建一个纳什均衡，既然仁义离得太远，那咱们就用刑名来划条底线吧。有了这条底线，对君主的要求就没有那么高了，他只需要维护法，并在原有的基础上修修补补、不断迭代就好，这就简单多了吧？这就是全世界最早、最全面的“法治”思想。 术 ： 政治手腕 几千年下来，其实大家关于法的争议并不大，即便独尊儒术之后，也听不到什么反对法的声音，因为这是“阳谋”，根本就无从反驳。大家骂得最多的，一个是术，一个是势，为什么？因为这两个东西讲的是怎么实现君主集权，就是在手把手教君主们把官僚集团玩弄于股掌之中。而掌握学术话语权的是谁呢？不就是官僚集团吗？所以他们对这些阴谋简直恨得牙根痒痒。 韩非绝对是个耿直boy，那些原本上不得台面的东西他居然搬出来讲，不但讲了，还讲得异常透彻，你说耿直不耿直？ 例如韩非教君主在官聊之中找平衡，拉一派打一派，谁露头就打谁，不许官聊掌握兵权、人事权、财权，不许拉帮结派，甚至不许他们在百姓中树立良好形象。 最狠的是，连怎么杀大臣都说明白了，不能直接杀，那样名声不好，要“行饮食”暗杀……咱要是官僚会怎么想？关键是就算咱们知道这些手段，可就是没办法。中国的君主们自从有了法家利器，对官僚就产生了压倒性的优势。几千年的君主专制，始终用的就是韩非子打造的这把大杀器，所以也叫“外儒内法”。 势 ：威权政治 就是通过权力收放、利益分配、礼仪形制对官僚进行心理威慑，当然这其中道德约束也必不可少，本来提倡民本的儒家也被君主拉进来为虎作伥，可见法家之无所不用其极。 咱们看看古代的宫殿，皇帝高高在上，下面匍匐着文武百官，如果是咱们在场，是不是连大气都不敢出？这就是威权的表现。 儒家和法家 儒家主张，治理百姓应当以礼以德，不应当以法以刑。他们坚持传统的治道，却不认识当初实行此道的环境已经变了。在这个方面，儒家是保守的。在另一方面，儒家同时又是革命的，在他们的观念里反映了时代的变化。传统上只按出身、财产划分的阶级区别，儒家不再坚持了。 当然，孔子、孟子还继续讲君子与小人的区别。但是在他们看来，这种区别在于个人的道德水平，没有必要根据原来的阶级差别了。 在早期的中国封建社会中，以礼治贵族，以刑治平民。所以，儒家要求不仅治贵族以礼，而且治平民也应当以礼而不以刑，这实际上是要求以更高的行为标准用之于平民。在这个意义上，儒家是革命的。 在法家思想里，也没有阶级的区别。在法律和君主面前人人平等。可是，法家不是把平民的行为标准提高到用礼的水平，而是把贵族的行为标准降低到用刑的水平，以至于将礼抛弃，只靠赏罚，一视同仁。 **儒家的观念是理想主义的，法家的观念是现实主义的。**正由于这个缘故，所以在中国历史上，儒家总是指责法家卑鄙、粗野，法家总是指责儒家迂腐、空谈。 韩非子出自儒家，他根本连德也不谈了。他好像在说：这方面孔子说的都对，但是我不赞成他的方法。学习好榜样固然是好，但要是有人不学呢？而且只要有一个人不学，那这套体系就危险，损人利己的人反而占便宜了，这个榜样的力量更巨大不是吗？ 所以，榜样没有用，要用刑法，让损人利己的人受到严厉制裁，其他人看到这个前车之鉴，就不敢越雷池一步。 为什么法家未能实现取代儒家? 首先什么是法家？历史上有哪位法家的代表人物自称法家吗？ 没有。 不但没有，法家的学术发展脉络也是断断续续的。 集大成者韩非子，师从大儒荀子，人家从来没说过自己是法家，“儒以文乱法”多少看着都像人家作为儒者的自我批判。 韩非的继承者呢？没有，断了…… 商鞅据说师从尸子，但显然受到李悝、吴起影响更大，这条线倒是很清楚。商鞅的继承者呢？还是没有……吴起的师承是子夏，孔门高足。李悝是子夏的再传弟子…… 管仲没有师承，应该是无师自通的，之后也没有传人…… 申不害，这位据说好黄老之学…… 子产，铸刑鼎那位，中国最早的成文法制定者，他自己都觉得铸刑鼎是迫不得已…… 先秦出现过的显学，杨朱、墨家、儒家，就这三家，从来没有法家，法家这个称呼最早可能要到汉代才提出来。 既然从师承上看不出什么，咱们只好看看法家讲得是什么？ 这倒简单，看《韩非子》就够了，人家真的是集大成者，法、术、势面面俱到。 但关键在于，《韩非子》这本书不涉及本体论、认识论，价值观是荀子的，甚至没有方法论，有的只是具体的方法，这其实就是一部“帝王操作指南”，只不过是史上最强攻略，没有之一。 为什么后世外儒内法配合起来毫无违和感？ 因为法儒本是一体，法家只是儒家的一个技术分支。 道家和法家 “无为而无不为。”无为是道家的观念，也是法家的观念。 韩非和法家认为，君主必需具备一种大德，就是顺随无为的过程。他自己应当无为，让别人替他无不为。 韩非说，君主应如“日月所照，四时所行，云布风动；不以智累心，不以私累己；寄治乱于法术，托是非于赏罚，属轻重于权衡”（《韩非子·大体》）。 换言之，君主具有种种工具和机器，用来进行统治，有了这些，就无为而无不为了。 **道家与法家代表中国思想的两个极端。**道家认为，人本来完全是天真的；法家认为，人本来完全是邪恶的。**道家主张绝对的个人自由；法家主张绝对的社会控制。**可是在无为的观念上，两个极端却遇合了。这就是说，它们在这里有某些共同之处。 法家的治道，也是后期道家所主张的，只是词句上稍有不同。《庄子》里有一段讲“用人群之道”。这一段既区分了有为与无为，还区分了“为天下用”与“用天下”。 无为，是用天下之道；有为，是为天下用之道。 为天下用 君主存在的理由是统治全天下，所以他的功能和职责是自己无为，而命令别人替他为。换句话说，他的统治方法是以无为用天下。臣子的功能和职责，则是接受命令，遵命而为。 换句话说，臣子的功用是以有为为天下用。这一段里说：“上必无为而用天下，下必有为为天下用，此不易之道也。”（《庄子·天道》）《庄子》这一段接着说：“故古之王天下者，知虽落天地，不自虑也；辩虽雕万物，不自说也；能虽穷海内，不自为也。” 君主一定要这样，因为他万一考虑某件事，这就意味着别的事他没有考虑，可是他的功能和职责是考虑他治下的“一切”事。 所以解决的办法，只有让他不自虑，不自说，不自为，但是命令别人替他虑，替他说，替他为。用这种方法，他无为，而无不为。 哈哈，想到了权术大师嘉靖皇帝了吗？ 用天下 至于君主“用天下”的详细程序，这一段里说：“是故古之明大道者，先明天，而道德次之；道德已明，而仁义次之；仁义已明，而分守次之；分守已明，而形名次之；形名已明，而因任次之；因任已明，而原省次之；原省已明，而是非次之；是非已明，而赏罚次之；赏罚已明，而愚知处宜，贵贱履位，仁贤不肖袭情。……此之谓太平，治之至也。” 很清楚，这个程序的后部分正与法家相同。这一段还继续说：“古之语大道者，五变而形名可举，九变而赏罚可言也。骤而语形名，不知其本也。骤而语赏罚，不知其始也。……骤而语形名赏罚，此有知治之具，非知治之道；可用于天下，不足以用天下；此之谓辩士，一曲之人也。”从这里可以看出道家对法家的批评。 法家的治道，需要君主公正无私。他一定惩罚应当受惩罚的人，即使这些人是他的亲友；他一定奖赏应当受奖赏的人，即使这些人是他的仇敌。只要他有一些时候不能这样做，他的整个统治机器就垮了。这样的要求是一个仅有中等智力的人远远不能胜任的，真正能实现这种要求的还只有圣人。 墨子社会背景 墨子对儒家的观念有所批评，但实际上还是其思想的延申。 上文聊到，周代贵族的教师、文人们在周后期封建制度解体后流落各地，成了早期一批教师。同样的，贵族军队的那些将士们，在丧失爵位后也成为了最早的”游侠“。 关于游侠：谁雇佣他们就为谁服务，以此为生。《史记》说他们“其言必信，其行必果，已诺必诚，不爱其躯，赴士之厄困”（《游侠列传》）。这些都是他们的职业道德。大部分的墨学就是这种道德的发挥。在中国历史上，儒和侠都源出于依附贵族“家”的专家，他们本身都是上层阶级的分子。到了后来，儒仍然大都出身于上层或中层阶级；而侠则不然，更多的是出身于下层阶级。 在古代，礼乐之类的社会活动完全限于贵族；所以从平民的观点看来，礼乐之类都是奢侈品，毫无实用价值。墨子和墨家，正是从这个观点，来批判传统制度及其辩护者孔子和儒家。这种批判，加上对他们本阶级的职业道德的发挥和辩护，就构成墨家哲学的核心。 核心观念 儒家的中心观念仁、义，墨子并没有批评；在《墨子》一书中，他倒是常讲到仁、义，常讲仁人、义人。不过他用这些名词所指的，与儒家所指的，还是有些不同。照墨子的意思，仁、义是指兼爱，仁人、义人就是实行这种兼爱的人。 兼爱是墨子哲学的中心概念。 墨子出于游侠，兼爱正是游侠职业道德的逻辑的延伸。这种道德，就是在他们的团体内“有福同享，有祸同当”（这是后来的侠客常常说的话）。以这种团体的概念为基础，墨子极力扩大它，方法是宣扬兼爱学说，即天下的每个人都应该同等地、无差别地爱别的一切人。 这很像三五个哥们，相处到位了，一起结拜结盟拜关老爷，然后在这个小群体内践行彼此的道德共识。 十个主要思想： 兼爱：不分等级、不分亲疏的爱天下所有人。 非攻：反对侵略战争，坚持正义战争。尚贤：崇尚贤良的人才。尚同：政令、思想、言语、行动等要与圣王的意志相同一。节用：崇尚节俭、节约，反对铺张浪费。节葬：反对厚葬久丧，主张薄葬短丧。非乐：反对奢靡的音乐活动，提倡节约人财物力。天志：天是有意志的最高主宰，天的意志是兴利除害。明鬼：辨明鬼神的存在，鬼神能扬善惩恶。非命：否认天命对人事的支配和影响 功利主义的劝说 于是这个学说面临一个根本问题：如何说服人们兼爱呢？你可以把上面所说的告诉人们，说实行兼爱是利天下的唯一道路，说仁人是实行兼爱的人。人们还是会问：我个人行动为什么要利天下？我为什么必须成为仁人？ 墨子说：“夫爱人者，人必从而爱之；利人者，人必从而利之；恶人者，人必从而恶之；害人者，人必从而害之。”（《墨子·兼爱中》） 如果对全天下有利，也就是对天下的每个人都有利。 这样说来**，爱别人就是一种个人保险或投资，它是会得到偿还的。**可是绝大多数人都很近视，看不出这种长期投资的价值。也还有一些实例，说明这样的投资根本得不到偿还。 墨子用这种功利主义的辩论，证明兼爱是绝对正确的。仁人的任务是为天下兴利除害，他就应当以兼爱作为他自己以及天下所有人的行动标准，这叫做以“兼”为“正”。 “以兼为正，是以聪耳明目，相与视听乎；是以股肱毕强，相为动宰乎。而有道肄相教诲，是以老而无妻子者，有所侍养以终其寿；幼弱孤童之无父母者，有所放依以长其身。今唯毋以兼为正，即若其利也。”（《墨子·兼爱下》） 这也就是墨子的理想世界，它只能通过实行兼爱而创造出来。 宗教劝说 为了诱导人们实行兼爱，所以墨子在上述的道理之外，又引进了许多宗教的、政治的制裁。因此，《墨子》有几篇讲“天志”、“明鬼”。其中说，天帝存在，天帝爱人，天帝的意志是一切人要彼此相爱。天帝经常监察人的行动，特别是统治者的行动。他以祸惩罚那些违反天意的人，以福奖赏那些顺从天意的人。除了天帝，还有许多小一些的鬼神，他们也同天帝一样，奖赏那些实行兼爱的人，惩罚那些交相“别”的人。 非常有趣的是，即使墨子动用了宗教来劝说，他自己对鬼神也仍然是没有任何兴趣的，只是将其作为一种劝说的工具。就好像孔子常说丧葬、祭祀、拜祖等礼仪之事，却对鬼神避而不谈，敬而远之。 照儒家所说，行祭礼的原因不再是因为相信鬼神真正存在，当然相信鬼神存在无疑是祭礼的最初原因。行礼只是祭祀祖先的人出于孝敬祖先的感情，所以礼的意义是诗的，不是宗教的。 对墨子而言，他要证明鬼神存在，本来是为了给他的兼爱学说设立宗教的制裁，并不是对于超自然的实体有任何真正的兴趣。 政治极权 当然，人们若要实行兼爱，除了宗教的制裁，还需要政治的制裁。 墨子认为，无论什么情况，人们最终都会自愿选择绝对权威来统治他们。人们接受这样的权威，并不是由于他们选中了它，而是由于他们无可选择。因为他们需要把自己无政府状态中拯救出来。 墨子论证出，国家必须是极权主义的，国君的权威必须是绝对的。这是他的国家起源学说的必然结论。因为国家的设立，有其明确的目的，就是结束混乱，混乱的存在则是由于“天下之人异义”。因此国家的根本职能是“一同国之义”（均见《墨子·尚同上》）。一国之内，只能有一义存在，这一义必须是国家自身确定的一义。别的义都是不能容忍的，因为如果存在别的义，人们很快就会返回到“自然状态”，除了天下大乱，一无所有。 在这种政治学说里，我们也可以看出，墨子发展了侠的职业道德，那是非常强调团体内的服从和纪律的。它无疑也反映了墨子时代的混乱政治局面，使得许多人向往一个中央集权的政权，哪怕是一个专制独裁的也好。这样，就只能够存在一义。义，墨子认为就是“交相兼”，不义就是“交相别”。这也就是唯一的是非标准。通过诉诸这种政治制裁，结合他的宗教制裁，墨子希望，能够使天下一切人都实行他的兼爱之道。 墨家和儒家 虽然表面上墨子是反对儒家的，但从他的思想来看，墨家仍然继承了儒家的中心思想。 与其说墨子反对礼，不如说墨子认为“礼”这种有等级的爱不是终点，而是中间状态。他认为终点是兼爱，是无差别的爱，是大同世界，共产主义。所以，他另创了墨家。 大同就是孔子提出来的，他能反对大同？墨子见到老爷子，两人没准一拍即合，己欲立而立人、己欲达而达人，这种仁一旦实现，其实也就是兼爱。 不过墨子这个思想实在太超前了，以至于他的组织与当时的社会不相容，完全自成一派，这是一种比“礼”更加不稳定的均衡，其实就是“帕累托均衡”，这种均衡虽然是最优，但危如累卵，所以墨家很快就失去了实体组织。 **各家背景：**如何达到真正的均衡？春秋之前，大家讲究的是“灭国存嗣”。说白了就是打你只是因为你这个君主无道，百姓民不聊生，我是吊民伐罪。把这个君主赶走之后，这个国我不要，在这个国的宗族里面找一位贤明的人继续当国君。我不但不争夺利益，反而会帮助你治理国家。这就是所谓的“王道”。 但是，进入春秋情况就变了，各国君主的私欲开始膨胀，发动战争的目的已经不是吊民伐罪，而是土地兼并，扩充实力。所以，春秋开始的战争逐渐开始既灭国又灭嗣了。这个打法使得所有君主人人自危，因为这是真玩命呀。搞不好就灭门了，而灭门率之高也是耸人听闻的。春秋初年有国一百多个，春秋末年只剩了二三十个，其余一百多个都被灭了。在这种情况下，打起来那真是拼尽全力、以死相搏。 打仗一般在“郊”这个地方打，也就是城外不远的地方。因为举倾国之力用于战争，怀孕的母马都被征调去打仗，以至于直接在战场上产下小马。可以想象一下，这是何等惨烈的情景。 当然，春秋时期各个诸侯还要点脸，多少会找点借口遮遮掩掩。老子、孔子觉得还可以抢救一下，所以来劝架，想让大家冷静下来，回归王道。可王道是什么？是帕累托最优，也就是每个人在不损己的情况下积极利他。好是好，但这是一种不稳定的平衡。只要有一个人开始损人利己，这种平衡就会被打破。而由于私欲的存在，在长周期里面，是这种事是必然会发生的。所以，这种平衡必须一个强制力量进行维持，春秋之前这个强力是周天子。可维持强力本身就很难，这个强力自身还需要公正无私，也就是要施行“王道”，这可就难上加难了。 历代周天子挺了四百年才进入春秋，这已经是个奇迹了，后面就真的带不动了。一旦周王室稍显颓势，各个诸侯被压制的私欲便抬头了。从郑庄公开始，千里之堤溃于蚁穴。私欲这东西星星之火可以燎原，一旦起了个头，后面就一发不可收拾。于是天下开始滑向另一种均衡，就是大名鼎鼎的纳什均衡。最著名的例子就是“囚徒困境”。其实说白了就是人心隔肚皮，人与人之间无法建立信任，所谓害人之心不可有，防人之心不可无，就是这个道理。 于是为了防人，宁可自己受点损失，也比被人坑了蒙受最大的损失好。每个人都采取最保守的策略，这种策略可以保证**即便遇到最差情况，我也不会有更多损失了。**所以，纳什均衡才是稳定的平衡状态，如果任由博弈自然的发展，最终一定会以纳什均衡的形式达到平衡。在这种趋势下再坚守王道，分分钟就被玩死了，所以大家转而遵循“霸道”，说白了就是谁胳膊粗听谁的。 一脉相承不知道大家有没有发现，中国哲学的宗师们，从来没有一个强调自己的理论是原创的。 老子说”人之所教，我亦教之“，孔子也说“述而不作”，意思就是我所讲的道理只是复述古人的，我自己并没有创作。孟子说“游于圣人门者难为言”，意思就是圣人把该说的都说了，我想再说什么都很难了。 这就是中华文明传承数千年，连绵不绝、屹立不倒的原因了。古代先贤，一脉相承。而究其根本，还是中国古老辩证思想的潜移默化。 我们承认矛盾，但强调统一，这叫做“中”；我们承认运动是永恒的，但强调反之又反，这也叫做“中”；我们承认事物是会发生质变的，但强调这种显著的质变必然是由微小的量变引起的，应对好这些细小的量变叫做“和”；我们承认宇宙是个混沌系统，没办法为其建立精准模型，但仍然强调“道可道”，“人亦大”，人是需要去努力追求道的，这叫做“德”，德便是“道之用”。这种“用”细微而弱小，所以我们把这种用叫做“庸”，甲骨文的形象，上面乐器下面水桶，表示日常所用。以上这些概念就是我们耳熟能详的，“允执厥中”、“中和”、“中庸”了。","tags":["儒释道"],"categories":["读书"]},{"title":"内卷的本质","path":"/2024/01/06/内卷的本质/","content":"内卷的本质 在一个剧场里，大家都在看戏。每个人都有座位，大家都能看到演员的演出。忽然，为了看的更清楚，有一个观众站起来看戏了。他这一站挡住了别人的视线，于是别人也得站起来看。、于是，周围的人为了看到演出，也被迫站起来看戏。 最后全场的观众都从坐着看戏变成了站着看戏。 **内卷本质上是一种零和博弈。**大家同时往前迈一步，彼此的“相对差距”实际上是不变的。于是大家一起白受累。 两个人摽着膀子一起干，那不叫内卷。因为那确实是让双方受益，激发出了彼此的潜能。这是正和博弈。 有意思的是，当第一个站起来的观众出现时，他作为一个火种，将点燃整个群体的火焰。 教育制度里，一个超级中学的出现，意味着整个社会的教育产业都要快马加鞭了。 内卷的表现有句话叫“上赶得不是买卖”，你知道为啥吗？ 因为当你所处的生态圈到达一定层次，大家都会有点欲望、野心，都不缺上进心。 没有收集足够的信息，正确分析出眼前的形势，就埋头往前冲，等待你的只有懊悔。注意，不一定是失败。你可能会收获旁人眼光中的成功和”收获“，但目的地未必会是你的初心所想。 因为你压根没想清楚为什么要这么干。你只是觉得自己应该冲，像一头绕着石磨盘埋头冲刺的驴一样。这个情况下，溢出的上进心和匮乏的分析能力共同作用下，这头驴甚至还会透支身体，咬牙让自己再往前顶顶。 最可怕的是眼前真的有个胡萝卜在驱使着你，欲望！ 这里有个段子：如果努力是最有价值的属性，那世界首富应该是一头驴。 所以内卷的本质是零和博弈，表现之一则是焦虑。 对一个内卷的朋友来说，焦虑和负罪感是最好的动力！ 拿一个应试教育的例子吧： “这个学生很可能不知道，他的困境有潜在的根本原因。他最终接受了世界对他的评判：他是愚蠢的、迟钝的，或者是懒惰的。这是一个失败的循环，会削弱学生的自尊心，让他最后因气馁或羞愧而自暴自弃。 这个观点非常重要。一个正在困境中挣扎的孩子不会说：“这个不称职的老师根本不了解大脑功能的状态依赖，也不知道创伤正在影响我的学习能力。他应该帮助我进行调节，而不是对我进行错误的指责。”孩子只会说：’我一定是个笨蛋、懒狗。’” 焦虑和负罪感压根不是什么可维持动力。你就看吧，那些行色匆匆，恨不得独与天地往来的朋友，一旦那段“厚积薄发、励精图治”的过程结束，什么考研考公，减肥健身，学艺求知的过程结束，他们整个人都会垮掉。 那段过程的结束，才是人的最真实写照。 是本自具足，收获美满，意犹未尽； 还是咬牙切齿，唯恐避之不及？ 这个问题和内卷的朋友不好讨论。因为他们会选择性忽视。想问的尖锐一些，还不如问问他们是否在“自我感动”。 因为他们根本不是为自己而做。他们所依赖的，只是欲望、“别人目光里透露的期许”、虚荣心、“大家都这么干”等根本形不成“长期可持续且有趣的动力”的乱七八糟的东西。 醒醒吧！ 忙活半天，发现你的ROI不成正比，你会焦虑；焦虑半天，你会觉得是自己不够努力。 于是恶性循环：上进心、欲望、”干不死就死里干“这一套继续像名为“焦虑”的贪婪恶魔一样，逼着你鼓起最后一份勇气，榨干最后一丝力气。 当你实现目标以后，发现并没达到自己的期望，又重新向恶魔签订契约，投身到无休止的内耗中去。 这就是手脚勤快、脑子懒惰的结果。这就是战略定力和战略思维不匹配的后果。 所以内卷的表现之二：思维反刍(chu) 内卷高手都是自我 PUA 大师。 思维反刍的表现则是不自洽。 那些无端重复的大量负面情绪是不自洽的最好声明。 注意：这里的重点不是负面情绪，是无端重复。 无端，意味着你没有意识到为什么会产生这次负面情绪，更不知晓怎么排解这次负面情绪。 重复，意味着你的思维体系有一些恶性循环没有及时解决，还在拉低你的能量。 强调一下，这是个充分不必要条件：内卷和思维反刍会让你不自洽，但不自洽不意味着你思维反刍和内卷。 因为实际上不自洽是极度正常的。我们的阅历见识是有限的，思考能力也自然有其局限性。 不自洽本身不是什么问题，实事求是，勇于自我革命，把知行体系里不自洽的部分改掉就是了。 最后，我作为一个计算机专业的学习者，写一段话勉励自己，也供大家玩味： 大家太在意一个结果，而忽视了真正的底层竞争力。 我看到学长大二开始三级跳，就把眼睛盯在实习上。但完成跳跃的原因是比所有人快，比所有人赶吗？ 并不是，那只是急于求成，追名逐利的表象。核心是他的兴趣 ，让他即使完不成三级跳，也能在兴趣中不断提高技术竞争力。这才是“真本领”。 有路不走的另一阐释 ，即最笨拙的方法反而是捷径。这是注重结果的我们所看不到的。 即使在速成功夫中拿到了短暂成就，也会在后续的工作中地基不稳、摇摇晃晃。这些是找到好工作考上研后大家所看不到的故事。也是唯结果论的目光不及之处。 大环境不洗牌的情况下，真本事才是硬道理。 破局先说结论：关键在于选择。 选择无非就两点：挖掘个人价值，满足社会需求。 个人价值：当你的个人价值够大，即使社会受众面小，需要你的人少，你也能得到巨大收益。因为你的价值让你牢牢把握住了属于你的生态位。你的一亩八分地，别人是轻易抢不走的 —— 这个不可替代性也会让需要你的人难以离开你。 非遗继承人，高精尖技术人才，艺术领域开创者。 社会需求：可能你的个人价值并不大。但你满足了社会需求，尤其是翘首以待、生态位空缺的需求，也能被社会群体推着往上走，继而创造大的价值。 小里说，房地产新兴的土木，互联网泡沫的程序员，经济上行时的金融，都是红极一时，”五陵年少争缠头“到”门前冷落鞍马稀“的主。 大里说，丁针珍珠和16年开发出抖音的字节跳动，都是满足社会需求，被时势的浪潮推到人民群众的眼前的。 挖掘个人价值收集信息：认识你自己 希腊圣城德尔斐神殿上的一句著名箴言：Σεαυτον ισθι 英文叫 Be Yourself or Know Yourself ，中文是 “认识你自己”。 认识你自己。我的理解是认识并延伸自己的长板，补齐自己的短板。 短板： 负面情绪：负面情绪的产生是思维体系不完善的体现。当你通过分析实践让引发负面情绪的事情不会再传递给你负能量，甚至能一笑置之，这一部分就自洽了，你也变强大了。 行为习惯：坏的习惯要改正。站没站相，坐没坐相，体态猥琐，卫生邋遢。都是要改的。你的形象是你个人的第一张名片，也是展现你内心世界的第一个窗口。 强化者，甚至可以管理自己神态举止。应时而用。 拧巴：做一些事拧巴、不自然的时候，那必是不自洽了。脑子里有什么阴影、创伤之类的自我保护机制在作祟。找到源头，让自己大大方方的接受或拒绝去做。 疲劳：气血不足，心力匮乏，身体柔弱，双眼无神，精气神扁塌，都是要克服的疲劳表现。不过疲劳相比行为习惯的改善，要更细腻一些。 一言以蔽之：花一定的时间让自己自洽，补全思维体系，观念认知，让自己的精神内在和身体外在上都能相比昨天更健壮。 长板： 兴趣热爱：你最容易产生兴趣的事情往往藏着你最擅长的事情。“游戏、手机”这类事情也未尝不可尝试。比如玩一天的游戏，玩一天的手机。如果有所产出并且不累，甚至能余味无穷。那么恭喜你，你非常幸运的找到了自己的热爱。 **思考方式：**这其实有点天赋的意思。不过不是高下之分，是水平面上侧重点不同。找到最适合你思考习惯的事情，往往也能事半功倍，更容易创造价值。 像逻辑性比较强的天生适合理论上的玩意儿。数学逻辑里的 数学、编程、机械、电工等。情绪感知敏锐，信息综合能力强的适合文史经法社。 **外貌举止：**我没开玩笑。颜值确实有高低之分，但这种比较对我们的成长没有意义。我们要纵向和自己比较。结合自己的优势、特点甚至文化背景、审美偏好，去让自己的外形举止和自己的内心统一。这算是知行合一，内外协调的小小实践。也能增强你对生活的掌控力（本人实测）。 认知：一定要搞清楚自己有必要做什么、没必要做什么。努力获取优质的，进步的信息。避免垃圾信息，快餐信息。 正向习惯的培养：太极生两仪，两仪生四象，四象生八卦，八卦定吉凶，吉凶生大业。人和人之间的差距无非就是习惯不同。 时间问题，暂时想到这些。 概括一下：保持自己的和谐与自洽，完成认知和行为的统一。全面的发展自己的精神和肉体，在发展中感受生活、体会生活。 自信：认知和行为的统一，知道自己该干什么，不该干什么，对局面保持乐观。 整合信息：完善你自己 悟已往之不谏，知来者之可追。 信息已经收集完了。你大概知道自己是个什么成色了。于是可以保持对自我的把握，自然的敬畏了。 此时，就可以默默的发育完善自己，让自己变得健壮强大。 择其善者而从之，其不善者改之。 朋友也是很重要的能量来源，一个敢于面刺的朋友更是极其稀缺，只是我们通常为了自己愚蠢的自尊心，把握不住这种诤友。 不断精进自己的思维模型和行为模型，掌控宏观上的认知模型和心理上的微观表征，知行合一。 在不断实践和感受反思中，找到自己的价值所在。这一点其实不容易做到，因为一件事的周期最少也得按月来算。 达到极致体验就得论年。而我们的机会窗口期可能就那么一段时间。 所以我说，能早早找到自己价值所在，兴趣所在的人是极其幸运的。 所以：找到你自己的本领，找到那个能解决他人问题的同时，自己又能不断成长的能力。利用网络资源博观约取。 当你的价值交换能力增强，为社会提供价值，自然获取相应回报。同时脱离了少数人的评价系统。 多数人都在数目极其有限的少数人的反馈上进行生活。自己的心情、奋斗、动力都由别人掌控。 分清可控和不可控的，把可控的事装入做事的内存条（值得投入精力的地方）。增强系统的可控性，心境平和、抱朴归真。 可控当然不是保守。冒险和勇气也是增强可控性的源泉。因为你敢于去面对挑战。 发展你自己 这时，你就能收获有效实践带来的自我价值感，通过积累量变达到质而形成一片片的方法论——认知高度与践行厚度。 方法论多了，手里的神兵利器就会越来越锋利。培养好习惯的成本就会越低，实践过程中遇到什么困难都能砍瓜切菜，一笑而过。 于是好习惯越多，越不容易自毁自责。攒下足够的能量和气血，你的吸引力、生命力也会逐渐变强。 于是不被短期内的利益所动摇，不被慌张、焦虑、急于答卷的人事物所迷惑。因为你站在全局的角度，比其他人多了一个维度——时间，对过去的理解，对未来的判断，对当下的把握。 发展眼光看问题： 这是我们在回过头来看高中政治课本必修四，里面的发展眼光看问题—— 前途是光明的、道路是曲折的。 新事物是符合客观规律，具有强大的生命力和远大前途的事物。对我们自己而言，则是自我革命之后的自洽稳定的和谐状态，一个更加强大有力的精神内核。 新事物成长总要经历一个由小到大、由不完善到比较完善的过程。人对新事物的认识也有一个过程。旧事物在开始时往往比较强大，因而总是顽强抵抗和竭力扼杀新事物。 事物的发展是前进性和曲折性的统一事物发展的前途是光明的，道路是曲折的；对未来的信心和热情支持着新事物的成长。做事时，我们要做好充分的思想准备，不断克服困难，勇敢接受考验。 是不是没那么空洞了？ 所以长期主义看，完成比完美更重要。 有恒比有力更重要。 举个刚刚学到的例子： 事例一： 1927年大革命失败后，国内政治局势急剧逆转，原来生机勃勃的中国南部一片腥风血雨。蒋介石在南京建立政权后，经过一系列新军阀混战，建立起在全国范围内的统治。这个政权对外实行反苏、亲帝的政策，对内竭力维护官僚买办资产阶级和封建地主阶级的利益，限制和压制民族资本主义的发展，残酷地镇压、屠杀共产党人和革命群众。因此，同北洋军阀一样，它仍然是一个代表大地主大资产阶级利益的独裁专制政权。在这样的政权统治下，中国共产党必须继续进行反帝反封建的民主革命，首先必须直接反抗国民党的反动统治。然而，这时的党却遇到了前所未有的困难。据不完全统计，从1927年3月到1928年上半年，被杀害的共产党员和革命群众达31万多人，其中共产党员2.6万多人。在极其险恶的局势下，党内思想异常混乱，一些同志和不坚定分子离开党的队伍，党员数量急剧减少到1万多人。与此同时，工农运动走向低沉，相当多的中间人士同共产党拉开了距离。事实表明:中国革命已进入低潮。 事例二： 国民党军采取堡垒主义的新战略发起“围剿”，红军仓促应战。1933年初，日军大举入侵华北，中华民族危机日益严重，然而国民党政府主席蒋介石却置民族危亡于不顾，仍然坚持推行“攘外必先安内”的反动方针，决心消灭共产党及其领导的红军。从1933年9月25日至1934年10月间，蒋介石调集约100万兵力，采取“堡垒主义”新战略，对中央革命根据地进行大规模“围剿”。这时，王明“左”倾教条主义在红军中占据了统治地位，拒不接受毛泽东的正确建议，用阵地战代替游击战和运动战，用所谓“正规”战争代替人民战争，使红军完全陷于被动地位。经过一年苦战，终未取得反“围剿”的胜利。最后于1934年10月仓促命令中央领导机关和红军主力退出根据地，突围转移，开始长征 。 柳暗花明又一村 党曾两次经受严峻的考验:一次是大革命的失败，一次是第五次反“围剿”的失败。在常人难以想象的险恶环境中，中国共产党人不屈不挠，埋头苦干，度过最黑暗的时刻，奇迹般地开创出新的局面。 满足社会需求本人未经社会洗礼，诚惶诚恐不敢妄言社会之事。此处需各位前行路上慢慢玩味求索。 信息源信息素材 平台： b站up主：matt，戎震 公众号专栏 历史： 以教员为例：了解他的生平事迹和相关党史，然后看他的著作（《毛选》），从高能量人身上获得能量。 学人： 第一个阶段： 先认可，了解这个脉络，譬如要学习毛爷爷的著作时，需要了解毛爷爷的生平，看到毛爷爷的传记，以及当时国内的现状，还是他人传记中关于毛爷爷的事迹，尽一切之可能分析其招数背后的哲学观。“有道无术，术尚可求”“见路非路即见如来，见相非相即因果”。 第二个阶段，看的时候更在乎他著作的一个思想连贯性，再譬如毛爷爷，他的论持久战里面实际包含了他的实践论，他的矛盾论，乃至湖南农民运动考察报告的思想。一片文章一本书的问世，结合了作者吸取希望经验阅历融合后对当下的思考。思考的高度综合化。 第三个阶段个人的世界观已经形成并丰富。他在发表一些文字，都会透露出浓浓的形象他世界观思想的味道。 学历史: “时间流序与地缘空间结合，这样的立体模型就出来了”“任何事情置于此种模型下来分析，就更全面立体深刻透彻”“我们的分析，就是把事物的各种可能性转化成现实性的边界条件界定出来，然后再分析现实环境，看满足哪一个条件，从而预判事物的发展趋向。”“我们是三维的，置身历史之中应该了认为是四维。 能够从时间，区位来看待事物的演变，就约等于让自己站在了五维的角度来看待。 这个五维角度，或可以称作上帝视角。就是毛爷爷著作中，一直都是中俯瞰众生的视野，气魄之宏达，令人澎湃。”大致是这个意思。这可能是读史书的意义所在，而并非仅仅是那个“可怜北邙山”，也并非“早生华发，一尊还酹江月”“兴百姓苦亡百姓苦”的喟叹。 我们都知道资治通鉴的作者司马光，他在评价王莽，包括商鞅时都并不是赞扬其开拓精神的观点，这个涉及到司马光对于王安石的一个态度。这个是客观存在德。 好了有了这个思维，我们再回头看汉王项羽之争的时候，就不会被陷入到就史论史，上演“关公战秦琼”的戏码了。 拓宽思维深读以及广度，能够理智判断分析一些案例，并能够指导自己当下的境遇，遇见更好的未来。这大概是我们读书的一个追求吧。 ————以上选自小马哥的聊天记录，知乎名：凌江之鹤 书： 《我们内心的冲突》 《当代为什么要读马克思》 《被讨厌的勇气》 《像阿德勒一样生活和思考》 《大学》《中庸》 基本素质 这里的素质每一个都能大谈特谈，作者在现实中和网络平台上也基本聊了无数遍了。所以这里只是罗列，不再赘述。 情绪管理、时间管理、精力管理：最重要的是情绪管理。 身体健康意识：健身、好的生活作息、生活规律。对妨碍健康的事情“如恶恶臭”。 全局意识：不被一城一池的丢失得到而动摇，不在意短期的负面形势变化。 谈判协商能力：分辨出有效谈话和无效谈话，有把握对话的意识。 对世界万物的热忱：仰观宇宙之大，俯察品类之盛。好奇心之上的兴趣是最好的驱动力。 兴趣是最大的利器，在争辩哪一个工具是最好用最优雅的时候，有的人已经在磨刀了。 仰头急于求成的多，低头踏实打磨的少。 注意哦——不要被思维惯性打扰。我可没说低头打磨就一定是做什么事。我反倒觉得你应该在做之前分析清楚，做之后保持定力（习惯），做之时不断优化迭代。 记录能力：写作或视频记录自己的收获和总结。甚至一个人对着镜子录音都行。 激发主动思考，展示自己。 费曼学习法：通过输出带动输入。感受主动思考带来的快感 , 而非痛感。 内容输出铁三角:、阅读、写作、表达 思维能力: 文字:文字本身的意义 观察-大样本观察:较多的样本和表象 反思-洞察:抽象出客观规律 执行:思维和行为的日常化（想通了） 人物素材： 费曼：just for fun。兴趣驱动，费曼学习法。 马斯克：SpaceX，脱离低级趣味，理想驱动实践。 乔布斯：自我意识，周围人都是NPC，勇于跳出舒适区。 毛教员：主观能动性，叛逆，格格不入，混不在乎，高能量 赶走校长，为灾民和祖父辩论 方法论素材： 《大学》 大学之道，在明明德，在亲民，在止于至善。 知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天了以至于底人，壹是皆以修身为本。其本乱而末治者，否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。(部分版本无此段)完善 知止而后有定：你知道自己应该做什么，掌握信息分析清楚之后，决定要做了，就能保持定力放开手脚去做。（包括玩乐放松） 定而后能静：有了定力了，你的心就能静下来。因为你不用再纠结“我这么做不对呀”，我想干别的事呀等等 **静而后能安：**不纠结，就既来之则安之，先按着惯性走喽。遇到问题再及时修正。 **安而后能虑：**在做事的过程中，你知道你自己为什么要做这件事。踏实了，不慌张不焦虑了。就可以总结反思、优化迭代，不断变强。 例子：健身领域，我的运动笔记记录了我从小白到入门的过程。 **虑而后能得：**通过不断的总结反思，知行合一，实践和意识的相互强化，你就能得到成长，有所收获了。更重要的是，你培养出了一个好习惯，获得了一段极致体验，通过这个体验你能看到别人看不到的风景，从而洞悉到深层次的规律。 物有本末，事有终始。知所先后，则近道矣。 当你平衡好战略思维和战略定力，知道自己为什么要做，把握好主要矛盾和次要矛盾后（物有本末），你就能收获一段完整的旅程体验，也就是事有终始。 有了这段经历 —— 注意不是那种别人逼着你做，或者你不情愿去做，更甚至你做完了深恶痛绝避之不及的经历，不是这种经历！这是无效经历 —— 你就有了一段个人在特定领域的极致体验，知道了一个好习惯，一个领域的知识，一个事情从想法到完成的先后顺序和门道。你就能在这个过程中完善你的方法论，也就是了解到做所有事的一些规律。这叫**”则近道矣“**。 然后你就能凭借这个方法论指导你做其他事情。 用我上篇文章的话概括下： 道者，所有规律的总称，是整体，是客观存在；德器，具体事物的规律、本性，是个别，是主观存在 何以得德？由乎道也。何以得道？格物致知、知行合一。 当知行合一的极致体验多了以后，做事的方法论就出来了。方法论精进后，便接近这个世界的本质、规律了。 写于1.6.2024 9：55~11：30","tags":["随笔"],"categories":["成长"]},{"title":"我对情商里“和稀泥”的理解","path":"/2024/01/01/我对情商里“和稀泥”的理解/","content":"我对情商里“和稀泥”的理解今天吃完早饭，和好朋友发生了一场颇为受益的对话，特此记录，供自己玩味，也分享给各位。 引用语料： b站up主 戎震 （《社交能力决定你阶级跃升的速度，想要变得受欢迎》） 《论语别裁》 《中国哲学简史》 知乎博主：墨子连山 （专栏【三十年来《道德经》实践总结】） 朋友问：你怎么理解情商？ 我个人的观点： 情商的中心思想是“礼之用，和为贵” 《论语·学而》：“有子曰：‘礼之用，和为贵，先王之道，斯为美，小大由之。有所不行，知和而和，不以礼节之，亦不可行也。 阐述**礼之用，和为贵。**礼是行为，和是状态。既然有和，那肯定就有不和。和与不和是“情商”这一矛盾的两个方面，是情商两面性的体现。可以说我们在待人做事时的初衷都是“以和为美”。这是我们的大方针。当彼此的矛盾难以协调，出现分歧时，就需要完成两者相互转化的过程，通过不和而成其和，把问题摊开分析再去解决。这是一个斗争的过程，也是情商这一矛盾对立统一的体现。 对于两个人之间的小和，我们可以说“和气”“和平共处”； 对于群体或者系统之间的大和，我们可以说“和谐”“和顺”。 举例：舍友行为习惯不好，睡眠时间咣啷当啷，不尊重其他舍友。他影响了你的睡眠，你认为他很傻X。 这时就需要打破“和气”的假象，实事求是的和舍友进行沟通，把双方的利益诉求说清楚，达成一致。这个协商过程双方是对立的，协商完成则完成统一，也就是“不和成其和”的完成。 转化之后，舍友得到了你的尊重，不再有不尊重他人的愚蠢行为；你发泄了不满，也有了更好的睡眠环境。 行为的理想与否是分场景的（中庸），不同场景，礼仪要求不同，故有所不行。就像书上中西古今场景混为一谈的反例。 但只讲目的，不讲方法，又容易矫枉过正(亦不可为)；方法就是合乎场景的礼节（或者某种处世哲学），通过方法，春风化雨，以礼节之，达到调和均衡，大家开心的目的。 [礼源于天理，是天理的具化，对人言语行为的约束，人人真诚的遵守礼节，则人与人关系就能和谐，这其间真诚很重要，否则就是在演戏，所谓的和便成了一种假象。] 意诚而后心正，心正而后身修；真诚是人的生活中的基底，是’道’层面的坚守。相对来说，对他人真诚也是对自己真诚。而且真诚不一定是盲目跟从客观叙事，而应是一种心底的动机，行为的源泉。这样说来，倒不怕因真诚而犯错或者被误会了。不患人之不己知，患不知人应该也是这种感觉吧。而且由道生术，在学习成长上也可以联想到知之为知之，不知为不知，是知也。基本功不好，再花哨的动作也外强中干，成了一种假象（骗人也骗己）。 冲突：主要矛盾和次要矛盾人生来便有立场，在社会中就有其地位以及阶级，也就有自身所代表的利益。 在各种纷繁交错的社交关系和社会章程中，必然会出现利益矛盾、利益冲突。这时就要分析清楚主要矛盾和次要矛盾，进行合理的协调和取舍。 网上有个段子说：“我说我杀人不眨眼，你问我眼睛干不干”。面对一个人杀人的行为时，我们当然不会研究这个人的姿态优不优雅，发力标不标准。而是思考这个人杀人的动机，背景。这是因为杀人者的目的往往不是“杀人”，而是另有原因。 同样的，分析问题时，要区分好主要矛盾和次要矛盾，认死理是书生气的表现，也是做事的大忌。 和稀泥的合理性和稀泥，顾名思义就是不认死理，难得糊涂。 小里说，当是非对错的追究已经不能达成更大层面的“和”，满足大部分人的利益时，对错真相就已经失去了它的效力，不再是主要矛盾了。 大里说，我们要反对本本主义，不唯上不唯书只为实。而实际事态的情况变量极多，很多情况需要我们有所侧重，一定程度上忽视次要矛盾。这也是一种“和稀泥”的表现。 这里的大部分人并非是狭隘绝对的少数服从多数。而是指在对于整个系统而言，在人群之中代表最大利益占比的一方。也就是让整个系统和局面和谐共生、和顺运转的“主要矛盾”。 也是现实中坚定不移跟党走的论据之一。 书接上文，我们在学校里待多了，形式逻辑的训练过量甚至溢出了，就容易“瘸腿”，只知道搞标准答案，不知道对于很多人生课题的答卷，根本没有标准答案，只有局部最优答案。甚至科学知识里的真理也是不断修正变化的。 处理人情世故和做事这类混沌系统时尤其如此。和稀泥往往也是解决问题的一种方案，就好比沉默也是一种表达。 或者说，我们在面对生活琐碎小事的很多决策时，都是下意识采取和稀泥的方式而不自知。因为人的神经元毕竟优先，需要把精力放在更重要的事情上。 所以不管是和稀泥也好，还是把事情分析明白、表达明白也好，都要“实事求是”，一切以时间地点条件为转移，从实际出发，抓住主要矛盾，解决主要问题，让项目或事态顺利推进下去。 一个很鲜明的例子就是“酒场”。 酒本身是很单纯的，分析酒作为饮料时大家是不是爱喝没有意义。我们需要分析的是“酒场”，也就是当酒在人群中作为一种社交媒介时的意义。 对于酒桌文化，现在网上有很多人一棍子打死，觉得是彻底的糟粕，就像数十年前“打倒孔家店”的批孔潮流一样。这类思想实际是很偏激片面的，没有辩证看待酒桌文化，只看到其坏处没看到其好处。 酒从主观生理上能让人放下戒备，更加感性。客观上又能提供一个媒介，以酒为引子推进两个人的谈话沟通。 一个具备酒文化素质的朋友，能够在维护自己基本利益的基础上，和对方达成最大程度的合作。 这是酒的好的一面。 当然，凡事有度，物极必反。酒多误事，借酒欺人的形象也存在。所以我们也要具备一些酒文化的知识理论基础。（况且酒没有意识，有意识的是人，酒的作用全在人的操作下） 其中的尺寸拿捏是酒文化的落地实践方法论，本文不予赘述。 下面是对“和稀泥”和“礼之用，和为贵”情商思想的延伸讨论：为什么会形成这种处世方式和情商体系？ 中西方的文化差异地理和经济地理： “子曰：知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。”（雍也）中国是大陆国家。古代中国人以为，他们的国土就是世界。汉语中有两个词语都可以译成“世界”：一个是“天下”，另一个是“四海之内”。 海洋国家的人，如希腊人，也许不能理解这几个词语竟然是同义的。但是这种事就发生在汉语里，而且是不无道理的。从孔子的时代到上世纪末，中国思想家没有一个人有过到公海冒险的经历。如果我们用现代标准看距离，孔子、孟子住的地方离海都不远，可是《论语》中孔子只有一次提到海。他的话是：“道不行，乘桴浮于海。从我者其由与。”（《论语·公冶长》） 孟子提到海的话，同样也简短。他说：“观于海者难为水，游于圣人之门者难为言。”（《孟子·尽心上》）孟子一点也不比孔子强，孔子也只仅仅想到“浮于海”。 所以，生活在海洋国家而周游各岛的苏格拉底、柏拉图、亚里士多德该是多么不同！ 古代的中国士子们，所赖以触发灵感的自然环境都和土地有关。这一文化特征也表现在了经济形式上。 经济： 古代中国和希腊的哲学家不仅生活于不同的地理条件，也生活于不同的经济条件。由于中国是大陆国家，中华民族只有以农业为生。甚至今天中国人口中从事农业的估计占百分之七十至百分之八十。在农业国，土地是财富的根本基础。 所以贯穿在中国历史中，社会、经济的思想和政策的中心总是围绕着土地的利用和分配。 中国哲学家的社会、经济思想中，有他们所谓的“本”“末”之别。“本”指农业，“末”指商业。区别本末的理由是，农业关系到生产，而商业只关系到交换。在能有交换之前，必须先有生产。在农业国家里，农业是生产的主要形式。 所以贯穿在中国历史中，社会、经济的理论、政策都是企图“重本轻末”。 “士”虽然本身并不实际耕种土地，可是由于他们通常是地主，他们的命运也系于农业。收成的好坏意味着他们命运的好坏，所以**士子们对宇宙的反应，对生活的看法，在本质上就是“农”的反应和看法。**加上他们所受的教育，他们就有表达能力，把实际耕种的“农”所感受而自己不会表达的东西表达出来。这种表达采取了中国的哲学、文学、艺术的形式。 从生产方式的角度看： 具体到一个农户，中国农民的传统形象是“面朝黄土背朝天”，是“足蒸暑土气，背灼炎天光。力尽不知热，但惜夏日长。” 所以村子里最棒的人，不是坐在地头上夸夸其谈、巧言令色的人，而是踏踏实实，低头一门心思耕种的人。 “你不要说话，不要像没用的；踏踏实实的干活，把今天活儿干完了。一家子就指着这块地了！” 耕种好了，粮食收获了，这一年的收成就有了，大家就不挨饿了，能“过日子”，好好活着了。 《士兵突击》许三多：有意义就是好好活，好好活就是有意义。 不好好耕地，说大话的人，不管怎么信口开河、妙语连珠，搞不出粮食就是白搭。 所以大家对于表达是很含蓄的，我们父母这一代，能面对面，不扭捏几下说出来“我爱你”的，都算是极开明的父母了。 实际上这也算是传统中国人含蓄品质的一个小由来吧。并不严谨，仅供各位玩味。 实际上这种协作农耕的生产方式，也是中国人情社会的一个缩影。这里不再赘述。 综上而言：所以“农”的眼界不仅限制着中国哲学的内容，例如“反者道之动”，而且更为重要的是，还限制着中国哲学的方法论。 社会有四个传统的阶级，即士、农、工、商，“商”是其中最后最下的一个。“士”通常就是地主，“农”就是实际耕种土地的农民。在中国，这是两种光荣的职业。一个家庭若能“耕读传家”，那是值得自豪的。 至于表达的具体特征，我们可以通过中西方的语言特点来体会。 语言和经济背景的联系先聊下祖先，也就是东方自然语言： 现在聊到文言文，都是古籍里的语言了。但在新文化运动前，我们日常所说的还是“白话”，不是正统的书面文。 同样的，在古代也有白话。但古代的文字记录成本太高。最早时纸还没有出现，传播语言的形式是甲骨文，在龟壳上雕刻。或者在竹简上刻字。这两个形式都不是动动手，敲敲键盘就能完成的简单功夫。 所以古人在书面上写字成为一件很奢侈的事。人力物力的条件必须要求先贤们“惜字如金”，追求文字的简洁，即“书面文言文”。 恰好**，汉字的一个极大的优势就在于单个字的潜力。**一个“道”字能阐述出来多少世界观、方法论，无穷无尽，回味无穷！ 同样的，在对这些言简意赅的文字的揣摩中，自然语言的一大精髓“境界”便出来了。 这是追求境界的数学语言力所不殆的。 对于西方的朋友，也就是西方数学语言： 希腊人生活在海洋国家，靠商业维持其繁荣。他们根本上是商人。**商人要打交道的首先是用于商业账目的抽象数字。然后才是具体东西，只有通过这些数字才能直接掌握这些具体东西。这样的数字，就是诺思罗普所谓的用假设得到的概念。于是希腊哲学家也照样以这种用假设得到的概念为其出发点。他们发展了数学和数理推理。**为什么他们有知识论问题，为什么他们的语言如此明晰，原因就在此。 而对于海洋国家的人，不要说他们心肠坏、诡计多，换成说他们很精细、很聪明。我们还可以套用孔子的话，说海洋国家的人是知者，大陆国家的人是仁者，然后照孔子的话说：“知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。” 结论——语言表达的特点诺思罗普(Northrop)教授说过，概念的主要类型有两种：一种是用直觉得到的，一种是用假设得到的。 他说：“用直觉得到的概念，是这样一种概念，它表示某种直接领悟的东西，它的全部意义是某种直接领悟的东西给予的。 举个例子： ‘蓝’，作为感觉到的颜色，就是一个用直觉得到的概念。 ‘蓝’，在电磁理论中波长数目的意义上，就是一个用假设得到的概念。” （用假设得到的概念，是这样一种概念，它出现在某个演绎理论中，它的全部意义是由这个演绎理论的各个假设所指定的。） 往往从假设的概念出发的哲学家就偏爱有区别的，从直觉的价值出发的哲学家则偏爱无区别的。 所以“农”的眼界不仅限制着中国哲学的内容，例如“反者道之动”，而且更为重要的是，还限制着中国哲学的方法论。 从语言上的表现更是如此。 所以先说结论： 东方自然语言优势在于深度、广度，讲究“言有尽而意无穷”，“只可意会不可言传”。劣势是逻辑推理中的精度有所欠缺。 西方数学语言优势在于精密、清晰，讲究“环环论证，逻辑严谨，正确答案，一加一只能得二”。劣势是难以描述混沌系统。 所谓哲学，实际上是人类使用自然语言]对宇宙万事万物进行的建模，建模的过程也就是对语言潜力的挖掘过程。 人类自然演化和社会演化过程中，势必要对眼前的事物运转规律有所认知，在这个认知的过程中，有两个切入角度：一个是科学，一个是玄学。 在混沌系统中，针对客观存在的事物对象，想要了解对象的运转规律，就需要我们不断通过实验验证和理论推敲，来得到事物背后的规律。在这一认知体系里诞生了科学，从逻辑角度区分就是形式逻辑。 形式逻辑是自然语言内生的一套体系，任何成熟的语言都必然包含了形式逻辑系统，这是人类自然演化和社会演化的必然结果。 同时，针对那些从未遇见也没有必要存在的对象，也就是在客观事物之后“涌现”出来的东西，例如“本体”，“自由”，“道” 甚至人的色声香味触法等等，哲学所研究的对象正是他们，也就是形式逻辑、数学语言难以描述的东西。 当哲学模型无法精确表述他所研究的内容，形式逻辑已经捉襟见肘时，只能退而求其次求诸于语言中不那么精确的部分，也就是朴素逻辑。这一逻辑的主要描述方法是类比法。说他朴素，其实一点也不朴素，这恰恰是自然语言的精髓，是自然语言的“境界”担当。 正是因为有了朴素逻辑，人类才能够描述“美”以及上面提到那些高度抽象的“涌现”。 综上所述，两者所属的领域用一句中国古话概括：“形而上者谓之道，形而下者谓之器”。 道者，所有规律的总称，是整体，是客观存在；德器，具体事物的规律、本性，是个别，是主观存在。 何以得德？由乎道也。何以得道？格物致知、知行合一。 当知行合一的极致体验多了以后，做事的方法论就出来了。方法论精进后，便接近这个世界的本质、规律了。 这也能解释为什么哲学总是强调「阅读经典原著」，而科学却没有类似要求。 因为数学语言的本质是形式逻辑，是绝对精确的，因此数学模型在传播过程中也不会出现以讹传讹的情况。无非是一些基础假设和数学公式。 至于实验验证，简单的我们可以自己动手实验，例如浮力实验，稍微复杂点儿的我们则只能相信科学共同体的结论，例如引力波探测。 而自然语言的本质是朴素逻辑，讲究懂的都懂，所以更容易发生以讹传讹。于是为了避免传播造成的歪曲，我们最好去读读原著。 例如“存在即合理”，“我思故我在”，“他人即地狱”，绝大多数人对他们的理解与作者原意相去甚远，有些甚至背道而驰。 延伸一下：对于直觉，诺思罗普还说，用直觉得到的概念又有三种可能的类型： 已区分的审美连续体的概念。 不定的或未区分的审美连续体的概念。 区分的概念。 照他的说法，我们可以有一个新的角度来看待中国文化中两大学说：儒家和道家。 儒家学说可以定义为一种心灵状态，于是不确定的直觉到的多方面的概念移入思想背景了，而具体区分其相对的、人道的、短暂的‘来来往往’则构成了哲学内容”。 道家学说中，“则是不定的或未区分的审美连续体的概念构成了哲学内容” 再回到统一的中华文化中来说，已区分的审美连续体的概念，由此而来的未区分的审美连续体的概念以及区分的概念，基本上是“农”的概念。 **“农”所要对付的，例如田地和庄稼，一切都是他们直接领悟的。**他们淳朴而天真，珍贵他们如此直接领悟的东西。这就难怪他们的哲学家也一样，以对于事物的直接领悟作为他们哲学的出发点了。 这一点也可以解释，为什么在中国哲学里，知识论从来没有发展起来。我看见我面前的桌子，它是真实的还是虚幻的，它是仅仅在我心中的一个观念还是占有客观的空间，中国哲学家们从来没有认真考虑。 这样的知识论问题在中国哲学（除开佛学，它来自印度）里是找不到的，因为知识论问题的提出，只有在强调区别主观和客观的时候。而在审美连续体中没有这样的区别。在审美连续体中认识者和被认识的是一个整体。 这一点同样可以解释，为什么中国哲学所用的语言，富于暗示而不很明晰。它不很明晰，因为它并不表示任何演绎推理中的概念。可在体验过很多看不见、摸不着的体验和经验后，哲学家不过是把他所见的告诉我们。正因为如此，他所说的也就文约义丰。正因为如此，他的话才富于暗示，不必明确。 像道德经全文，是由关令尹喜记录，老子口授的。原话我们无从知晓，而为了增加我们理解的正确率，只能通过不断重复、反复印证同一个意思来增加容错率。 形式逻辑和朴素逻辑于是形式逻辑和朴素逻辑的两个思维方式的区分就很明显了。 或许我们这一代的义务教育里，理科和文科的切分太粗糙了。好像彼此之间水火不容一样。 实际上这两种逻辑也是相互配合的。 例如：通过黄金分割率，通过形式逻辑描述一种自然审美。这种审美又需要我们用朴素逻辑去感知。 所以我觉得一个精神健壮的人可以跳过这些标签的掣肘，不要习惯性的对抗，守着某个阵营的牌坊和另一阵营，这太小气了。 为我所学，为我所用。江上之清风，山间之明月，耳得之而为声，目遇之而成色；取之无禁，用之不竭。是造物者之无尽藏也，吾与子之所共适。 让自己成为一个全面发展、博闻强识的有趣的人。 一个合理优质的教育环境对人的塑造是极其惊人的。当今的教育体系综合各方经济、文化以及制度的权衡，只能让孩子们先在一条路上往深里走。但学校教育最多持续二十余年，剩下的八十年还要靠我们自己的后天教育。 我和朋友聊天时提到一个观点，我们对很多事情的考虑还停留在初高中教育模式带来的思维惯性上。 很多人看到数学就觉得望而生畏。实际这是应试教育体制给孩子们打上的思想烙印而已。当我们放下考试和分数，在闲暇时间仅仅为了有趣和探索，去慢慢的、缓缓的体验数学，或许也能得到“知识的快乐”吧。 所以无论是文科理科、男性标签和女性标签（传统意义上）、形式逻辑还是朴素逻辑，我们都可以接受，然后将其营养内化于心。 潘石屹给自己的生日礼物是学python。 君子不器，周而不比。博学之，审问之，慎思之，明辨之，笃行之。在实践和意识的相互强化中，波浪式前进，螺旋式上升。 和大家共勉。","tags":["随笔","成长"],"categories":["认知"]},{"title":"曾国藩第三卷","path":"/2023/10/24/曾国藩第三卷/","content":"话语权不足时，带头做事前的考虑 在中央，以彭蕴章、祁寯藻为首，在地方，以和春和何桂清为首，组成了一个强大的反湘军集团，影响着咸丰的决策。正是在何桂清不断打小报告的作用下，咸丰皇帝越来越轻视曾国藩，也越来越把宝押在江南大营之上，“人人皆以为大功可企足待 行善不以为名，而名从之；名不与利期，而利归之；利不与争期，而争及之：故君子必慎为善。 前半句是后话（来的很晚，甚至身死才来），后半句是当下（马上要面对）。 结论“必慎为善” 所慎之处便是前者和后者的程度能否接受 持盈保泰 曾国藩一生有两个核心焦虑：一个是自己能不能做到圣贤，挽救国家；另一个是曾氏家族能不能光大和永久。在曾国藩心目中，家族的分量，不亚于朝廷的兴亡。曾国藩在家书中不停地在讨论自己家族的兴衰，“我家气运太盛，不可不格外小心，以为持盈保泰之道”。(41)他自己的进退考虑，很多时候都是和对家族命运的考虑联系在一起的。 阻止中国的中世纪化 冯友兰在1999年人民出版社出版的《中国哲学史新编》序言中说：中国所需要向西方学习的是西方的长处，并不是西方的缺点。洪秀全和太平天国所要学习而搬到中国来的是西方中世纪的神权政治，那正是西方的缺点。西方的近代化正是和这个缺点的斗争而生长出来的。中国所需要的是西方的现代化，并不是西方中世纪的神权政治。洪秀全和太平天国如果统一了中国，那就要使中国倒退几个世纪，这是我对洪秀全和太平天国的评价。这个评价把洪秀全和太平天国贬低了，其自然的结果就是把太平天国的对立面曾国藩抬高了。曾国藩是不是把中国推向前进是可以讨论的，但他确实阻止了中国的倒退。这就是一个贡献。……阻止中国的中世纪化，这是曾国藩的大功。(16) 灵活处世 综观曾国藩一生，他的为官风格十分独特。一方面，曾国藩确实是一个清官。他的“清”货真价实，问心无愧。在现存资料中，我们找不到曾国藩把任何一分公款装入自己腰包的记录。但另一方面，曾国藩的逸事中缺少“囊橐萧然”“贫不能殓”、在官府里种菜吃这样容易让人觉得悲情的极端化情节。**在中国人眼里，真正的清官，必须清可见底，一尘不染，清到成为海瑞式的“自虐狂”或者“受虐狂”，才叫人佩服。**曾国藩远没有清到这个程度。如果给清官分类的话，曾国藩应该归入“非典型类清官”。也就是说，骨子里清廉刻苦，表面上和光同尘。这是因为曾国藩的志向不是做“清官”，而是做大事。 以海瑞为代表的传统清官，他们的特点是宁折不弯，只承认字面上的规章制度，而对事实存在的潜规则绝不妥协。所以海瑞拒绝任何灰色收入，工资不够花，不得不在官署之中自辟菜园才能维持生活，而偶尔买几斤肉也能成为轰动性事件。然而这样一清到底的清官，只能成为官场上的公敌，无法获得别人的配合。海瑞一清如水，必然反衬出他人的不洁。因此海瑞一生被官场排挤打击，无法调动一切可能的力量，来办成一些真正有益国计民生的大事。 曾国藩不想成为海瑞式的清官。他刻苦自砺，全力内圣，是为了达到外王之业。因此，他做事更重效果，而非虚名。曾国藩从自身经验总结出，一个人特立独行，必然为众所排斥：“人之好名，谁不如我？我有美名，则人必有受不美之名与虽美远不能及之名者。相形之际，盖难为情。”因此，曾国藩有意取海瑞一尘不染之实，却竭力避免一清如水之名。他的选择，远比做清官更复杂更沉重。因此，他才具有大力量，才能成就大事业。 自律 曾国藩对死亡毫不畏惧。他丝毫没有打乱自己的日程，在这一天接下来还做了这些事：接见了一个叫庞省三的人，然后阅《通鉴》二百二十卷。傍夕小睡。夜阅《宋元学案》吕东莱一卷。二更后，与儿辈讲《孟子》“定于一”章又阅《吕氏学案》。三更睡。 天津教案 乌合之众 这次教案，从慈禧到其他亲贵都认为，处理此案的关键是万不可失去民心，因为“民心”可用。对天津百姓，应该鼓励，而不是镇压。这样可以保护他们的爱国热情。在他们看来，民间对洋人的愤怒情绪，是可以倚重的重要力量。 对这种思路，曾国藩是明确反对的。 早在1868年6月，他就曾在致郭嵩焘的信中说：“来示谓拙疏不应袭亿万小民与彼为仇之俗说，诚为卓识。……明知小民随势利为移转，不足深恃，而犹藉之以仇强敌，是已自涉于夸伪，适为彼（指外国）所笑耳。时名之不足好，公论之不足凭，来示反复阐发，深切著明，鄙人亦颇究悉此指。” 统治者不应该凭着汹汹民意与外国开战。百姓是随势利而转移的，并无定见，他们在自身没有危险时，热衷于低成本爱国。但一旦有事，他们往往并不敢往上冲，因此并不足以依恃。鼓动排外热情来对抗外国，只能被人家笑话。办理外交，不能汲汲于个人名声，不能被无定见的舆论裹挟。 窘境 对天津教案的处理，让曾国藩又又又又一次陷入舆论危机。 查翁同龢日记，十月初六日（公历10月29日），翁同龢前去拜访曾国藩，当面嘲讽了他在天津的所作所为。“访曾湘乡，颇诮其津事。”当时敢于当面诮讽曾国藩的，当不止翁氏一人。这在以前是根本不可想象的。 曾国藩的部下李兴锐与京官们交往中，他发现“有见面谈论夷务者，什九不能持平”。他与都中人“谈天津夷务**，清议莫不归咎曾中堂**。甚矣！任天下之重，岂不难哉！”“众论咎侯不善处分，君子小人如出一口，全不谅局中苦心，可叹之至。”在这样的氛围下，曾国藩在北京受到什么样的冷遇可想而知。 陈由立的妻子赴北京上访，指控曾国藩办案不公，还说曾国藩贪污了陈由立四千两薪水不给。让曾国藩感叹，虽然早知道仕途有平坦有险阻，但是没想到会遇到这样的事，让他心情久久不能平静。这位昔日的“中兴第一名臣”已沦落到“千夫所指”的境地，在路宿平原腰站时，该县知县竟未照例来“办差”，而由其“自行租店买食而已”。三天后，曾国藩在日记中写道：“思余年来出处之间多可愧者，为之局促不安，如负重疚**，年老位高，岂堪常有咎悔之事**？ 面对天津教案，涉及洋人、朝廷大官、百姓三方角逐，曾国藩大可称病告辞。但他毅然决然拖着病躯上路，无不体现了儒家“虽千万人吾往矣”、舍生取义、杀身成仁的精神。从这一层面，他做到了超出名利、一心为国的境界。 下面是曾纪泽和慈禧说的： “臣从前读书到“事君能致其身”一语，以为人臣忠则尽命，是到了极处。观近来时势，见得中外交涉事件，有时须看得性命尚在第二层，竟须拼得将声名看得不要紧，方能替国家保全大局。即如前天津一案，臣的父亲先臣曾国藩，在保定动身，正是卧病之时，即写了遗嘱吩咐家里人，安排将性命不要了。及至到了天津，又见事务重大，非一死所能了事，于是委曲求全，以保和局。其时京城士大夫骂者颇多，臣父亲引咎自责，寄朋友的信常写“外惭清议，内疚神明”八字，正是拼却声名以顾大局。其实当时事势，舍曾国藩之所办，更无办法。” 求贤若渴，诲人不倦 曾国藩的人才实践 第一步是求才 他说，“山不能为大匠别生奇木，天亦不能为贤主更出异人”，而“大约上等贤哲，当以天缘遇之，中等人才，可以人力求之”。寻找人才，要如同饿鹰扑食，贪商求利：“采访如鸷鸟猛兽求食，如商贾之求财。”他行军打仗，每至一地必贴出告示，“询访英贤”，广为访察，称“本部堂久历行间，求贤若渴，如有救时之策，出众之技，均准来营自行呈明，察酌录用”，“如有荐举贤才者，除赏银外，酌予保奖”。凡具一技之长者，必设法延至，收为己用。他的幕僚中如王必达、程鸿诏、陈艾等人都是通过这种方法求得的。“曾国藩的周围聚集了一大批各类人才，幕府之盛，自古罕见，求才之诚，罕有其匹。事实证明，其招揽与聚集人才的办法是正确的和有效的。” 第二步是观察。每有赴军营投效者，曾国藩先发给少量薪资以安其心，然后亲自接见，认真面试。李鸿章到来之前，曾国藩先寄给他三百两以安其家。到来之后，曾国藩在近一个月的时间里，与他多次长谈，就是为了进一步观察了解他，看看他在数年军旅生涯中有没有什么长进。 一般经过这两项考察后，曾国藩才会确定幕僚的具体工作：有胆气血性者令其领兵打仗，胆小谨慎者令其筹办粮饷，文学优长者办理文案，学问渊博者校勘书籍。 第三步教育 不仅经常找人个别谈话，曾国藩还利用吃饭这个大家聚齐之时，同大家谈古论今，表面上看是闲谈，实际上是向幕僚传授自己的人生经验和读书心得。李鸿章后来回忆说：在营中时，我老师总要等我辈大家同时吃饭**。饭罢后，即围坐谈论，证经论史，娓娓不倦，都是于学问经济有益实用的话。吃一顿饭，胜过上一回课。** 桃李满天下 曾国藩是中国最有势力的人，当他死去的时候，所有的总督都曾经做过他的部下，并且是由他提名的。如果他曾经希冀的话，他可能已经成为皇帝。”话虽夸张，但从一个侧面反映了曾国藩影响之大。 和李鸿章 作为学生，李鸿章与老师曾国藩一生有过密切合作，也有过多次冲突，但是高明之处在于，他从来没有与曾国藩撕破脸，懂得有进有退。这是曾国藩日后交班给李鸿章的另一个重要原因。 针对李鸿章与人交接时经常流露出来的傲慢，曾国藩指示他说：词气宜和婉，意思宜肫诚，切不可露傲惰之象。阁下向与敌以下交接颇近傲慢，一居高位，则宜时时检点。与外国人相交际，尤宜和顺，不可误认简傲为风骨。风骨者，内足自立，外无所求之谓，非傲慢之谓也。 对于李鸿章这个人的缺点，曾国藩看得也很清楚。曾国藩后来对李鸿章的评价广为人知：“李少荃（李鸿章号少荃）拼命做官，俞荫甫（俞樾也是曾国藩弟子，字荫甫，号曲园居士）拼命著书。”李鸿章是行动者而非思辨者。曾国藩是以学术和道义为基，李鸿章则是以事业和手腕为基。虽然都是翰林出身，但是李鸿章一生与理学无缘，身上那种粗野之气一直不能去除。因此曾国藩说：“李少荃等才则甚好，然实处多而虚处少，讲求只在形迹。”(73)他是一个只能办事，不能传道的人物。然而人才无法求全，曾国藩说：“大抵天下无完全无间之人才，亦无完全无隙之交情。大者得正，而小者包荒，斯可耳。” 李鸿章对恩师在幕府期间的教诲，是感激终生的。李鸿章说：“从前历佐诸帅，茫无指归，至此如识南针，获益匪浅。”说：“吾从师多矣，毋若此老翁之善教者，其随时、随地、随事，均有所指示。”还说，他后来办事，“亦能起早，才知道受益不尽，这都是我老师造就出来的”。不光是李鸿章对曾国藩充满感激，曾国藩幕府中的大部分人对曾国藩都感激终生。他“能随人之才以成就之，故归之者如流水”。同时曾国藩用人，还有一个宗旨，那就是**“己欲立而立人，己欲达而达人”。全力给他们制造发展的机会。**曾国藩说：将帅之道，即所谓欲立立人，欲达达人也。待弁勇如待子弟，常有望其成立，望其发达之心，则人知恩矣。 不要脸，被攻击后能韬光养晦 好汉打脱牙和血吞。”这是一句湖南土话，好汉被人家打掉了牙，不要吐出来让别人看到，要咽到肚子里，继续战斗。他不再和长沙官场纠缠争辩，而是卷起铺盖，带着自己募来的湘军，前往僻静的衡阳。全省官员瞧不起我，我不争一日之短长。等到我在衡阳练成一支劲旅，打几个胜仗给你们看看，那时自会分出高下。这才是挽回面子的最好办法！ 曾国藩的一意孤行触及到了地方官员的利益，得到了奇耻大辱。意识到这些党羽势力的顽固，没有以卵击石或者知难而退，而是梳理好了情绪，制定好了策略，回衡阳韬光养晦，厚积薄发。这个二品大官面对挫折的理性和韧性值得我们强调学习。另外也说明了不痛不变，变则必痛。矫枉过正撞南墙的这一下无可避免。 一个反面例子是： 郭子兴到手的敌人跑了，一时咽不下这口气，得了心病，过了一个月死掉了。 仅供举例，史实存疑。可能是朱元璋出于政治考量把他弄死了。 太平天国的局限性 起义军进驻宁波，浙东天一阁一半珍本或被毁或流失。存放四库全书的江南三阁两阁荡然无存，一阁损失多半。因此苏南知识分子叹息：“经典书籍，弃等秽污。自古流寇之毒祸，未有如是烈者。” 盲目树敌当然能以最快速度达成结盟，然后“团结一心”。可打倒之后的天国靠什么文化来维持呢？在神州土壤上搞神权，搞君主立宪吗？“到了晚期，洪秀全深深沉溺在”天父天兄”的速网里，失去了对现实的清醒认识，以至使这个理论反而日益成了太平天国前进的障碍。” 洪老师借助农民阶级和统治阶级的矛盾起势，终究因为农民阶级 智力支持、理论武器匮乏的局限性上栽倒。说了这么多，只是想说烧书这种事合理，但挺low的。wg同理。抢夺文化话语权嘛。","tags":["曾国藩"],"categories":["传记"]},{"title":"曾国藩第二卷","path":"/2023/10/23/曾国藩第二卷/","content":"第二卷:湘军崛起 第七章~第十二章笔记 1.把保卫长官当作一项制度清政府为了防止军队尾大不掉，士兵们往往是各路征调过来，互不认识。这种军队有利于上级统治，却没什么凝聚力，“集而复溃，溃而复集”。一打败仗就都跑了，不关心谁是自己的长官战友。 于是曾国藩还为湘军立下这样一条规矩：一旦某军统帅战死，除非本部有受拥戴的继任将领，否则必全军遣散回乡，另行招募成军。这样一来，部下打仗的时候都会全力保护自己的长官。因为只有保住长官，你才有个人发展的机会。 曾国藩高明就高明在他用制度解决了别人用道德去解决的问题。保卫长官本来是一种道德要求，但曾国藩通过制度使它变成了符合下属自身利益的一种行为。 王闿运在《湘军志》中说：“其将死，其军散；其将存，其军完。从湘军之制，则上下相维，喻利于义。将卒亲睦，各护其长。” 2.过刚易折、和光同尘早期曾国藩的从政风格便是“忠直”，凭一颗忠心直言上谏。动不动就上疏教育皇帝或批评其他官员。可以说，曾国藩和传统的官场作风是反着来的。这也是他到哪，哪的官员都不待见他的原因 —— 枪打出头鸟，你成忠臣义士了，我们还算什么？ 长沙之辱后，在江西筹饷也遇到了大麻烦。当地巡抚想让这个”众人皆醉我独醒“的忠臣服从自己，朝令夕改；曾国藩不从，于是大家对曾国藩“多方掣肘，动以不肯给饷为词”。即使把巡抚参了，也反而让他们变本加厉。江西官员在第二位巡抚的率领下团结起来处处给曾国藩下绊子、设障碍。 曾国藩在江西数年之间步步荆棘，处处碰壁。他后来在给朋友的信中回忆说：“江西数载，人人以为诟病。”又形容当时的苦况说：“士饥将困，窘若拘囚；群疑众侮，积泪涨江，以求夺此一关而不可得，何其苦也！”他无时不想挂冠而去，“国藩昔在江西、湖南，几于通国不能相容。六七年间，浩然不欲复闻世事”。但时势之危与圣人之教又不容许，只好百般隐忍，甘受煎熬，常年寸心如焚。“虹贯荆卿之心，而见者以为淫氛而薄之；碧化苌弘之血，而览者以为顽石而弃之。古今同慨，我岂伊殊？屈累之所以一沉，而万世不复返顾者，良有以也。”委屈痛苦，溢于笔端。他甚至这样对好友刘蓉说：“所至龃龉，百不遂志。今计日且死矣，君他日志墓，如不为我一鸣此屈，泉下不瞑目也。”种种不平之鸣，证明这是他一生中精神最痛苦的时期之一。 这时候碰到父亲去世，心灰意冷的他给皇上上了一封《沥陈办事艰难仍恳终制折》，说自己办事多不容易，必须得拿到个独断专行的大官；如果皇帝不给他督抚之权，他就只能“在籍终制”，就是说不复出山。结果皇上给他辞了。 因为皇上有自己的江南江北两座大营。这也是清廷中满洲贵族集团对抗以曾国藩为首的新兴汉族地主军事集团—湘军集团的产物”。 让我们看看这位大人物当时有多颓废： 以前曾国藩以唯我独忠之态，居高临下，睥睨众人。而这次他们可抓住了把柄，举城跳着脚大骂曾国藩是假道学、假忠义。蛰居荷叶塘的曾国藩有口难辩，遂“得不寐之疾”，患了“怔悸之症”，卧病在床。 他在给郭昆焘的信中亦称：“以兴举太大，号召过多。公事私事，不乏未竟之绪；生者死者，犹多愧负之言。用是触绪生感，不能自克；亦由心血积亏，不能养肝。本末均失其宜，遂成怔悸之象。” 在他离开军队的这段日子，湘军攻陷九江，杨载福、李续宾皆赏穿黄马褂，官文、胡林翼皆加升太子太保，一时荣耀无比。湘军的手下也各各因功受赏。只有他这个湘军创始人冷冷清清地待在家里，受人嘲骂。曾国藩虽被视为理学名臣，但功名心一向极炽，失去这个永载史册的千载良机，他怎么能不懊悔莫及！ 原本自诩硬汉的他这回有点挺不住了，举动大异常态，整日生闷气，“心殊忧郁”，动不动就骂人。他数着江西的一帮文武骂，骂够了就找几个弟弟的碴儿吆喝，一年当中和曾国荃、曾国华、曾国葆都发生过口角。弟弟们走了后，他又开始骂几个弟媳妇。语言粗俗，蛮不讲理，理学家的风度荡然无存。 曾国藩反思到，自己在官场上一再碰壁，碰得鼻青脸肿，不光是皇帝小心眼，大臣多私心，自己的个性上的诸多缺陷，也是重要原因。曾以前为人处世，总是**怀着强烈的道德优越感，自以为居心正大，人浊我清，因此高己卑人，锋芒毕露，说话太冲，办事太直，**当然容易引起他人的反感。当日骆秉章批评他刚愎自用。回信的原话是说他：“行事犹是独行己见，不能择善而从，故进言者安于缄默，引身而退。 不光是对同僚，就是对自己的亲兄弟，他也成天一副“唯我正确”“你们都不争气”的神气，处处批评教训，弄得当年国荃、国华到北京投奔他，结果都待不了多久就返乡了。设身处地，推己及人，那些自尊心受挫的同僚当然也会以冷面冷心甚至排斥辱骂来对待他。 曾国藩在家中致信诸友，让大家给他提建议。 给他当过幕僚的罗汝怀来了个长信： 乃复追寻怨怼，苦索瘢疣，不用雅驯之辞，惟抒愤懑之气，见与人书。亦何弗游心广大之域，而欲与担夫争道悍妇诟室邪？是殆德性问学之中或有窒阂之未辟，渣滓之未融已？ (你内心如此不平静，给朋友的信中，用词非常不雅驯，找这个毛病找那个毛病，满纸都是愤懑不平。这就如同两个挑担的担夫在道路中对峙，谁也不给对方让路，或者像悍妇在家里骂人一样，都是你德行学问还不够纯粹，没有进入化境的原因。) 士气葸苶，百年不振，诚可痛矣。然欲矫之而一切屏弃不用，则亦安能？……若以一人者孤行其意，众咻而一傅，势固不行，万介而一通，又谁适从也？……今试有人焉，伏阙上万言书，谓悉除从来之法，而尽诛天下之吏，然后天下可得而治……其意既奇而古，其词复典而文，将世之庸庸者闻而骇走，而圣人者独从而取之乎？ （是的，现在世风日下，士风不振，官风不正，诚可痛惜。然而你想放着这些体制内的力量一切不用，赤手空拳成事，这可能吗？你一个人逆众人而独行，则一傅众咻（指一人施教时，众人在旁喧扰，形容由于环境的干扰，难以取得成绩），难以有成。比如今天有一个人上书皇上，说如果把所有的律法都废除，把所有的官员都杀了，天下才能大治，你说这能行吗？会有人听从吗？） 独识阁下为奇士，所见四方之士无出其右。何者？天下惟平实坚朴之人可以干事，军务尤然，阁下无大僚尊贵之习，行履部伍，亲操细事，庶几大禹之栉沐风雨手胼足胝，故能船炮坚利，壁垒峻固，即粪厕亦有方隅，所谓道在屎溺，此非高谈渺论不知而作者所能望见也。 (我之所以愿意为您服务，是因为我认为你是天下奇士，没有人能和你相比。为什么这样说呢**？天下只有平实朴素坚定的人能成事，特别是军务。你虽然品级很高，但是没有官僚习气，做什么事都是亲自动手，如同大禹治水那样不畏难苦，所以才能练成湘军。成语说道在屎溺，这对湘军来说居然不是比喻而是实指，也就是说湘军行军时所修的厕所，也有明确的尺寸标准。这是那些只会高谈阔论的人无法想象的。你同时又能做到谦虚谨慎、和蔼可亲，经常向别人请教，愿意让别人给你提意见。这些都是你的优点。但问题是，你有些太特立独行了。今天最严重的问题是筹集军饷。筹集军饷，一方面要靠百姓，另一方面要靠官员。要靠百姓，让百姓不怨恨你，这个你是知道的。要靠官员，要让官员不怨恨你，这个你就不够注意了。所以关于筹饷，抽漕银你想要自己来，抽税你想要自己来，募捐你想要自己来，总之是想踢开官员体系，根本不管地方官的存在。**你的本职是军事，民政是归地方官系统，你想把一切大权都由自己操持，这本身是违反体制，行不通的。) 曾国藩终于认识到，行事过于方刚者，表面上似乎是强者，实际上却是弱者。这片土地上真正的强者，是表面上看起来柔弱退让之人。所谓“天下之至柔，驰骋天下之至坚”，“江海所以能为百谷王者，以其善下之”。所谓**“大柔非柔，至刚无刚**”。 自从丁巳、戊午大悔大悟之后，乃知自己全无本领，凡事都见得人家有几分是处。？”平易近人，乐道人善，慎终如始，修节庄敬“。 他在给曾国荃的信中说，与人相处，不能过于拙直：“余生平不讲文饰，到处行不动，近来大悟前非。”在官场生存，必须习惯官场上虚与委蛇的那一套：“与官员及绅士交际，则心虽有等差而外之仪文不可不稍隆，余之所以不获于官场者，此也。” 曾国藩原“以忠诚为天下倡”，以为仅凭忠义相激，就可以让部下出生入死。但阅历既久，才发现**真正的抱道之士并不如他想象中那样多。**他认识到“**不妄保举，不乱用钱”，则“人心不附”。只有诱之以“名”，笼之以“利”，才能网罗天下英才。**因此复出之后，曾国藩“揣摩风会，一变前志”，大力保举，将朝廷名器当作自己的私恩。 3.顾全大局，欲立立人湖北巡抚空了。朝廷基于制衡曾的考虑，册封给了其手下胡林翼。当时湖北还在太平军手里，胡林翼为了到武汉当官，想管曾国藩要点精锐部队（罗泽南部）去攻打。 曾国藩当时一定是嫉妒的。并且此时的曾国藩正泥兵九江城下，进退不得。胡林翼请求罗泽南赴援，确实给曾国藩出了个难题。不放罗泽南，武汉确实一时难以拿下来；放走罗泽南，曾国藩自身安危难保。但是一番犹豫之后，曾国藩还是派出了罗泽南。因为从当时天下大局看，武汉确实更为重要，自己的安危则为次之。曾国藩不但同意派出罗泽南军，而且从塔齐布军中抽调彭三元部、普承尧部，编入罗军，以增强其实力。由此可见，曾国藩在关键时刻之顾全大局的胸怀实为普通人之所不及。 当时的幕府刘荣劝他，本来兵就不够用，为啥还借给人家用？有急事咋办啊。 曾是这样说的：”吾极知其然，计东南大局宜如是。今俱困于此无益，此军幸克武昌，天下大势可为，吾虽困犹荣也“。 当然，代价就是曾国藩差一口气就被太平军杀了。他的部队被困在南昌、南康两地，联系已经被切断了。 后来王闿运在写《湘军志》时，连夜阅读当时的文件，蒙眬之中好似见到曾国藩当年的窘迫之态。他在当天的日记中写道：“夜览涤公奏，其在江西时，实悲苦，令人泣下。……‘闻春风之怒号，则寸心欲碎；见贼船之上驶，则绕屋彷徨’。《出师表》无此沉痛。” 曾国藩也讲他在江西之时，“久困彭蠡之内，盖几几不能自克。”由此可见曾国藩当年的处境是何等狼狈！ 运气比较好的是，曾国藩的两个弟弟先后来救，而洪秀全、杨秀清等从西征战场大量抽调太平军回救天京，参加攻破江南大营的战斗，给曾国藩留了一口气。 4.以静制动、反客为主在具体作战原则上，曾国藩的战略思想是“以静制动、反客为主”。不主动出击，总是诱使敌人先来攻他，后发制人。曾国藩反复强调，湘军打仗，不能浪战，先不要急于进攻，而是先站稳脚步，等着敌人露出破绽，你再出手。 在《中国革命战争的战略问题》一文中，毛泽东引用《水浒传》中“林冲打洪教头”的故事。林冲和洪教头比武，一开始是洪教头主动，林冲被动。林冲先不出手，先往后退，观察洪教头。等洪教头进攻了几棒，林冲看清了他的套路，才出手，一出手，就把洪教头打倒了。 毛泽东引用了这个故事，说：“谁人不知，两个拳师放对，聪明的拳师往往退让一步，而蠢人则其势汹汹，劈头就使出全部本领，结果却往往被退让者打倒。”他由此得出一个结论，弱军通过诱敌深入可以后发制人、制胜强敌。他说：“楚汉成皋之战、新汉昆阳之战、袁曹官渡之战、吴魏赤壁之战、吴蜀彝陵之战、秦晋淝水之战等有名的大战，都是双方强弱不同，弱者先让一步，后发制人，因而战胜的。” 曾国藩的作战思想正是这样。他说：“两人持矛格斗，先动手戳第一下者为客，后动手即格开而戮者为主。”他又说：“主气常静，客气常动。客气先盛而后衰，主气先微而后壮。故用兵者喜为主，不喜作为客。 话说，曾国藩蛰伏两年，胡林翼举荐了他两年。胡曾两人真的是黄金搭档，互相理解，互相成就。 在胡的推动下，朝廷又任命了曾国藩。这时休息好的曾立马答应，当即出山。 这里也可以看出，不要纠结于一时的失败成功，此时的失败是为了日后的成功；此时的蛰伏是为了后续的发力。 祸兮福所倚，福兮祸所伏；失意不丧志，得意不忘形。 能屈能伸大丈夫。 古今中外，具有雄才大略的用兵者，无不能够始终从战略的高度来把握问题，能够透过暂时的纷乱看到重点，在利害交织中看清本质，牢牢把握好长远与眼前、全局与局部的关系。曾国藩对局势的分析能力和战略定力就很强。总结起来便是：不轻易出手，出手便咬死。 分析能力： 曾国藩始终具有强烈的全局观念，他曾经夫子自道地说：“我对于大利大害所在，都能悉心考究。”他还说，“用兵以审势为第一要义”，“‘势’则指大计大局”。还说应该从大的地方去分清界限，不要斤斤于小处去剖析微芒。这个大利大害、大计大局，就是战略重心的所在。所以湘军虽然在局部的战斗中会吃败仗，但在战略态势上却总是处于有利位置。而太平天国尽管在局部的战役上取得了一些胜利，但整个战略态势却越来越不利。这是湘军最终能够将太平天国镇压下去的重要原因之一。 战略定力： 王安定在《湘军记》中曾评曾国藩成功在于**“坚决不动摇，排众意而孤行己意，其成功亦卒以此，由学力胜也**”。李瀚章曾经说，曾国藩的过人之处，在于他的定力不是一般人所能比的。只要他认准的，他就会排除一切干扰，争取一切机会，去将胜利的可能变成胜利的现实。 眼看安庆围点打援的阳谋破不了，太平军围魏救赵，打武汉，一路连捷。 胡林翼身为湖北巡抚，看到陈玉成挥兵武汉，当然急得吐血，骂自己“笨人下棋，死不顾家”。他先调李续宜回援湖北，接下来还要调鲍超和多隆阿，撤安庆之围，回救武汉。但是均遭曾国藩坚决拒绝。 但曾国藩看出来，太平军即使有破湖北之势，却无守湖北之力，武汉即使一时失陷，也有能力马上收复，而围攻安庆的军队一撤，就再也没有拿下的机会了。“无论武汉之或保或否，总以狗逆回扑安庆时，官军之能守不能守以定乾坤之能转不能转。 多么巧妙！ 这两个人的想法真是”攻守异势也“。战略上有一条基本的原则，就是致人而不致于人，也就是要迫使对方按照自己的战略安排行动，迫使对方跟着我们的步子走，而不是按照对方的战略安排行动。说白了，就是将战略的主动权掌握在自己的手中。 最能体现定力的例子：英法联军快杀入北京了，皇帝叫他星夜驰援。”勤王保驾“的忠义和战略规划又冲突了。这时曾国藩用拖字诀，先晚回复，在不断给朝廷提问题，硬是拖到朝廷议和了。 曾国藩在奏折中说，鲍超人地生疏，长途远行，无法在指定时间到达京城。同时鲍超品级太低，在指挥作战中起不到什么太大作用，所以他请求朝廷在他和胡林翼二人中选定一人带兵进京。他预料这样经过几次奏折往返，不待湘军北上，大局应该已经尘埃落定。 5.外其身而身存，后其身而身先慈禧、慈安联合奕䜣发动两宫政变，把顾命八大臣给扫清了。曾国藩是汉臣，和肃顺是一条线上的。吓个半死，怕自己被连带着干掉。 咸丰想的这个三权制衡体系相当不靠谱。八大臣起诏，两宫盖章（慈禧那个是代理皇帝）。刚确立就被慈禧给扫掉了。 肃顺能办事，不会权谋；慈禧会权谋，办事不行。 结果不仅没被干掉，还拿到了期待无数年的两江总督。 他们做出这一决定，也与曾国藩“不结交京中权贵”这一一贯原则有关。肃顺虽然极推重曾国藩，但是曾国藩却与肃顺走得不近，因据说肃顺被诛后，“籍其家，搜出私信一箱，内唯曾文正无一字。太后叹息，褒为第一正人。 上任后便把对立面的何桂清党羽给干掉了。 疆吏以城守为大节，不宜以僚属之一言为进止；大臣以心迹定罪状，不必以公禀之有无为权衡。” 6.与沈葆桢的恩怨：能忍，能狠沈葆桢算是曾国藩的嫡系,为官干练清廉，甚得曾国藩欣赏。曾出任两江总督后第一次上折，就是奏调沈葆桢赴自己的安庆大营帮忙，奏折中说“该道器识才略，实堪大用，臣目中罕见其匹”。第二年又破格保举沈葆桢出任江西巡抚。没经过基层锻炼直接出任巡抚，在清朝历史上十分罕见。 按照官场传统，曾国藩是沈葆桢的“举主”。沈葆桢应该感激涕零并大力回报。结果沈葆桢直接把曾国藩的粮食断了，而且自建军队，希望不再依靠湘军。 这就叫自作聪明，聪明反被聪明误。 曾国藩破格保举的目的其实就是让他管理江西作为后方，给湘军提供军饷。但沈葆桢却不这样想。他想在这片土地上，建立属于自己的而不是曾国藩的功业，不想成为其附庸。此人极有主见，自视极高，凡事不做则已，要做就要做到最好。 由此可见，提携下属，除了能力之外，还要观其品性，是否能为我所用，或者为大局所用。这一点甚至和能力一样重要。 这下曾国藩相当郁闷：弟弟在安庆生死一搏，音信浮动；后方又把粮食给断了。 “以江西抚、藩二人似有处处与我为难之意，寸心郁郁不自得。因思日内以金陵、宁国危险之状，忧灼过度。又以江西诸事掣肘，闷损不堪。” “三更睡，五更醒，展转不能成寐，盖寸心为金陵、宁国之贼忧悸者十分之八，而因僚属不和顺、恩怨愤懑者亦十之二三。 这段时间是曾国藩一生最痛苦的时期之一。他白天频繁联系各处，全力保障曾国荃的供应，傍晚到后院的小房间里去，跪在蒲垫上默默对天祷告，求老天保佑弟弟平安。 内心愤怒纠缠如此，但是曾国藩的外在反应却没有任何失态之处。 他日记是这样写的： 日内因江西藩司有意掣肘，心为忿恚。然细思古人办事，掣肘之处，拂逆之端，世世有之。人人不免恶其拂逆，而必欲顺从，设法以诛锄异己者，权臣之行径也；听其拂逆而动心忍性，委曲求全，且以无敌国外患而无为虑者，圣贤之用心也。吾正可借人之拂逆以磨砺我之德性，其庶几乎！ 很多大人物都喜欢其他人如同秋草伏风一样，偃伏在自己脚下，让自己的所有决定都得到“坚决贯彻”，“理解的要执行，不理解的也要执行”。曾国藩却不是这样。他的斋名为求阙，一生勤求己过，最喜欢听别人的批评。越是位高权重，他越是主动听取逆耳之言，以克除自己身上的“意气”“客气”和“矜气”。 他曾说：“安得一二好友，胸襟旷达、萧然自得者，与之相处，砭吾之短。”他有意识地在身边安排几个耿直高洁之人，时时给自己指出缺点。“身旁须有一胸襟恬淡者，时时伺余之短，以相箴规，不使矜心生于不自觉。”在给朋友的信中，也经常请求他们“常惠箴言，并赐危论”。 经过反思和调整，他应对的态度非常理智平和。曾国藩的幕僚们纷纷大骂不已，要求曾国藩马上参奏。曾国藩却没有这样做。沈葆桢是他提拔起来的，现在又进行参奏，不光沈氏脸上不好看，他自己脸上也不好看。况且沈氏用钱也是为公，所争毕竟不过四万两，为数不算太多，随他去吧。曾国藩念起忍字诀，选择悄悄吞下这颗苦果，“遂未奏请，以全寅谊”。没有向外界公开他和沈氏的矛盾。 这是真能忍。 但是这一章故事，到这里结束，就太不精彩了——沈葆桢得寸进尺了。 江西巡抚沈葆桢突然又一次上奏朝廷，奏请将江西全省的厘金完全归本省处置，不再提供给曾国藩了。理由是江西受到来自江苏、浙江入侵叛军的威胁，而曾国藩已经有了上海等其他更为充沛的饷源。 曾国藩在日记当中说：日来因金陵未复，沅弟焦灼，饷项大亏，江西截留厘金，及杨复成饷侵饷见杀等事，寸心郁闷，常不自得。甚矣，任事之难也 这下曾国藩受不了了。 先力陈自己四处筹集粮食的合法性，再把先前沈葆桢办事差劲、有的没的都抖落出来了。言辞激烈，猛料详实。 除了这两次争饷中的公文之外，他与沈葆桢之间的公文来往还有很多。他也请沈葆桢都发给皇上，请朝廷看看其中有没有任何一句涉及挟权欺人、市德卖好、措辞不够客气的地方。如果有，请皇上指出，他甘受惩罚。 这是能撕破脸，能狠。 不过最后朝廷的解决方法是五五分，一人一半，做了和事佬。这么做实际上还是暗地支持了沈葆桢，于是曾国藩意识到自己尾大不掉了，这时朝廷分而治之的制衡之术。曾国藩转而和自己弟弟商量打完仗的进退权益之计了。 同时，曾国藩也开始安慰自己弟弟，不要急功近利，想着赶快结束。 他相信，太平天国何时能平，属于太大尺度的事件，不是某一个人甚至某一个集团能够决定的。在这些大事件背后，有着天时、历史、人心等诸多深层次力量在起作用，个人所能发挥的作用是很有限的。因此，他所要做的只是在可能的范围内尽自己的能力而已，而不必杞人忧天，将太多无法承受之重揽到自己肩上。 他对弟弟说：“凡成大事，人谋居半，天意居半……墙壕之坚，军心之固，严断接济，痛剿援贼，此可以人谋主张者也。克城之迟速，杀贼之多寡，我军士卒之病否，良将之有无损折……此皆由天意主张者也……弟现急求克城，颇有代天主张之意……愿弟常存畏天之念，而慎静以缓图之，则善耳。” 类似的劝言还有： “古来大战争、大事业，人谋仅占十分之三，天意恒居十分之七。往往积劳之人非即成名之人，成名之人非即享福之人。 ” “富贵功名皆人世浮荣，惟胸次浩大是真正受用。” “功不必自己出，名不必自己成，总以保全身体，莫生肝病为要。” 青年时代的曾国藩是“人定胜天”主义者，非常推崇意志的力量。：“志之所向，金石为开，谁能御之？”在湘军连获胜仗之际，曾国藩对自己的主观能动性相当自负。以为“天下事，果能坚忍不懈，总可有志竟成”。 但是从经历咸丰七年（1857）被皇帝罢黜回家的大挫折后，“天命”二字开始出现在曾国藩的辞典中。仰观宇宙之大，俯察品类之盛，他悟到，人力其实是很弱小的。 日记中写 “古今亿万年无有穷期，人生其间数十寒暑，仅须臾耳。……事变万端，美名百途，人生才力之所能办者，不过太仓之一粒耳” 时间亿万年没有穷尽，人生几十年实在是一瞬即过。天下至大，人力所能为者至小。 最后，相比之下我们看看会办事的人——李鸿章怎么对待曾氏兄弟的： 曾国荃一心想独占攻陷南京的“首功”，当然反对淮军染指，李鸿章当然也知道曾国藩兄弟的心理。 碍于曾国藩的情面，只得软磨硬抗，甚至不惜装病（他奏称“感冒风湿，眠食顿减”，即行回苏“就医”），一次次抗旨。他在致曾国荃的信中说：“屡奉寄谕，饬派敝军协剿金陵。鄙意以我公两载辛劳，一篑未竟，不敢近禁脔而窥卧榻。况入沪以来，幸得肃清吴境，冒犯越疆，怨忌丛生，何可轻言远略。常州克复，附片借病回苏，及奏报丹阳克复，折尾声明金陵不日可克，弦外之音，当入清听。” 这番话，一是表明他不愿前来抢夺曾国荃的战功；二是催促湘军加快攻城动作，以减轻朝廷对他的压力。 7.弟弟曾国荃：挥金如土，杀人如麻曾国藩一开始是严格管控弟弟曾国荃的经济问题的。后来罢黜两年大彻大悟后，就睁一只眼闭一只眼，允许曾国荃适当捞钱了。 书信：”弟之取与，与塔、罗、杨、彭、二李诸公相仿，有其不及，无或过也；尽可如此办理，不必多疑。” 不过此举乃是万全协调之策。对于曾氏家族而言，曾国藩克制，曾国荃不羁；曾国藩克己复礼，曾国荃慷慨好施。曾国荃没起来的时候，曾氏家族是很拮据的，即使大哥手握重权，家里条件也不好，支撑家族的父亲和大姐甚至贫苦以致抑郁。 这一点上，曾国藩是有愧疚心的。 因此曾国藩放松对曾国荃抢劫发财的约束，一定程度上是为了整个湘乡曾氏家族考虑。曾国荃性格慷慨，在自肥的同时，源源不断地大手笔资助同族以及亲友，弥补了曾国藩对家族的愧疚心理。因此曾国藩对曾国荃替他“照顾家族”的“功劳”是肯定的。 曾国荃的好杀，也受到过曾国藩的鼓励。曾国藩在镇压太平军期间，一直要求曾国荃在城破之日，太平军骨干不论降否，一律杀掉（白起坑杀）。 在南京围攻战的紧张时刻，太平天国因粮食紧张，从城内放出大批妇孺，一开始，曾国荃并没有阻止。他的部下陈湜等部“收留”了大量的年轻妇女。然而，曾国藩反对这样做。并不是因为这样会导致军纪败坏，而是不利于军事进展。 三月二十日，他在家书中说了这样一段让人毛骨悚然的话：城内放出之妇幼，迪庵前在九江一概不收，仍送进城内。一则城内饥饿者多可致内乱，二则恐贼之眷口从此得生也。望弟参酌。 曾国藩提到：李续宾围九江的时候，处理手段是不放城里人出来。一方面可以导致城中因饥饿内乱，另一方面怕太平军的家属趁乱逃出。你可以参考他的办法。 由此可见，曾国藩的残忍，比他弟弟有过之而无不及。 8.水满则盈，月满则亏；功成名遂身退，天之道 曾国荃每下一城，都会发一次财，回家买地建屋一次。咸丰九年（1859）冬，曾国荃在老家开建自己的住宅，名为“大夫第”。从那之后，几乎曾国荃每回家一次，大夫第就要扩建一次。大夫第修建总共历时八年，巍峨浩大，看上去犹如王宫帝府。曾纪芬在《崇德老人自订年谱》中回忆道：“前有辕门，后仿公署之制，为门数重。乡人颇有浮议。” 曾国荃的理学功夫没他哥哥深。曾家大楼盖的相当豪华。 曾国藩怕强极则辱，物极必反。总劝弟弟： 我家若太修造壮丽，则沅弟（曾国荃）必为众人所指摘，且乱世而居华屋广厦，尤非所宜。 无奈曾国荃对这位提携了他一辈子的老兄的话，总是当作耳旁风，回信蛮横地说： 外间訾议，沅自任之。 曾国藩又写信： “众口悠悠，初不知其所自起，亦不知其所由止。有才者忿疑谤之无因，因悍然不顾，则谤且日腾；有德者畏疑谤之无因，而抑然自修，则谤亦日熄。吾愿弟等之抑然，不愿弟等之悍然。” “至阿兄忝窃高位，又窃虚名，时时有颠坠之虞。吾通阅古今人物，似此名位权势，能保全善终者极少。深恐吾全盛之时，不克庇荫弟等，吾颠坠之际，或致连累弟等，惟于无事时，常以危词苦语，互相劝诫，庶几免于大戾” 劝弟弟不要做事太高调给人留下口实，形成舆论危机。又拿二十三史举例，到了曾国藩这个位置的臣子，很少有保全善终，怕自己垮台了连累弟弟等人。只好时时提醒自己。 **曾国藩表面上是说不要让自己连累了弟弟，实际上是告诉曾国荃，不要犯错误，连累了哥哥。**对于曾国藩的这些话，曾国荃一如既往地不往心里去。因此才有了攻入南京后对部下的肆意放纵。 打完太平军，朝廷最担心的便是曾国荃和曾国藩的军权。 对弟弟曾国荃: 不仅是老家的百姓、身边的臣子觉得曾国荃狂，全国人民和朝廷也看出来了。攻城成功后，城里的名贵大货，曾国荃得用一条条水路大船往老家运。 曾国藩真坐不住了，上奏朝廷让他弟弟离职。离职理由，自然是身体欠佳，“万难再当大任”。代曾国荃正式奏请“开缺回籍”，调理身体。不过他在奏折中也点明，此举也是“求所为善聚不如善散，善始不如善终之道”，说明了曾氏兄弟希望与朝廷有始有终的愿望。 对自己的湘军: 长江三千里上下，几乎没有一条大船不挂着“曾”字旗帜。曾国藩总结历史，得出一个结论：**“自古握兵柄而兼窃利权者，无一不凶于国，而害于家。”**因此毅然决定裁撤。 距离攻占金陵还不到一个月，曾国藩就下令裁撤曾国荃直接指挥的湘军两万五千人。一年多后，除湘军水师改编为经制长之水师，其余曾氏兄弟直辖湘军均被裁撤。与此同时，左宗棠部湘军也由六万余人裁去四万多，其余江西、湖南等地湘军也大部遣散。 曾国藩大规模自裁湘军，既减轻了朝廷对他的疑虑，也使湘军后期带来的诸多弊端一了百了。此时湘军已染上很深的暮气，纪律已经败坏，经常骚扰地方。随着军队的遣散，这些问题也就解决了。 朱东安说：“曾国藩主要依靠这条策略完成了政治上的退却，缓和了同清政府的矛盾，巩固了自己的地位，化险为夷，渡过难关。能够做到这一点绝非易事，在中国封建社会中，像曾国藩这样恰如其分地完成这种转变的事例是不很多的，而身败名裂、兔死狗烹者则史不绝书。此亦足见其历史经验之丰富、政治嗅觉之灵敏，审事详明，处事果断。” 朝廷因此对曾国藩态度大为改变，一是不再追究曾国荃的问题，放手让曾国藩治理两江，对湘军其他骨干照旧放手任用，也不再追究天京城内财宝的下落，还宣布湘军军费不必逐一造册送户部审查，直接报销，以表示对曾国藩的信任。曾国藩写信给他的财务总管李瀚章说：“各路军营免办报销，近日皇恩浩荡，此旨尤为出人意表。……闻此恩旨，直如罪人遇赦，大病将愈，感激涕零。 9.与左宗棠的恩怨:避其锋芒,大道感召曾国藩与左宗棠渊源也很深，他们也是湖南老乡，年龄只差一岁。左宗棠自幼聪明，才华出众，可惜中举之后三次会试都不能中进士，因此无法以正常方式进入仕途。后来左宗棠在曾国藩的推荐下破格担任巡抚。 咸丰二年（1852）底，曾国藩墨绖出山到长沙办团练之时，左宗棠正给当时的湖南巡抚张亮基当幕友。左宗棠以师爷身份，给曾国藩帮了很多忙。 咸丰九年（1859），左宗棠因为在巡抚幕府中盛气凌人，凌辱朝廷命官樊燮，朝廷发下谕旨，命人逮捕左氏，“果有不法情事，可即就地正法”(55)。曾国藩**闻讯“焦灼极切”，全力以赴，托关系走后门，帮左氏解脱。**在众人的帮助下，左宗棠最终化解了此难。左宗棠脱身以后，来到曾国藩大营。曾国藩保举左宗棠“刚明耐苦，晓畅兵机”皇帝于是命左氏作为曾国藩的助手，襄办湖南军务。曾国藩派左宗棠回到湖南募勇，募成楚军五千人，屡立战功。 咸丰十一年（1861），朝廷命曾国藩督办江苏、安徽、江西、浙江四省军事后,曾国藩决定将浙江军务全盘交给左宗棠，让他从此独当一面。不久清政府在曾国藩的建议下任命左宗棠为浙江巡抚，从此，举人出身的左宗棠正式步入大员系列。同治二年（1863）三月，清廷更超擢他为闽浙总督。 至于左宗棠对曾国藩的忿忿之处,主要有两点: 科举情节 左宗棠自幼就自命不凡，认为自己是天纵之才，以为自己肯定能早早科名发达，不料连年落第，因此对于那些高中科甲之人，下意识中一直有一股莫名的敌意。在他后来的家书中，经常能看到他对科名中人的讥评之语，比如：“人生精力有限，尽用之科名之学，到一旦大事当前，心神耗尽，胆气薄弱……八股愈做得入格，人才愈见庸下。” 换句话说，在他看来，科举越成功的人，能力往往就越差。曾国藩中进士，点翰林，很快做到侍郎。左宗棠才华横溢，却进身无门，只好充当幕僚。所以左宗棠看待曾国藩，**下意识地一直戴着有色眼镜，千方百计放大曾国藩身上的缺点和毛病，来验证自己的“上天不公论”和“科举无用论”，**为自己寻找一个心理平衡。 瑜亮情节 除了“科举情结”外，左宗棠内心还深藏着“瑜亮情结”。左宗棠平生以诸葛自命。“每与友人书，自署‘老亮’，以汉武侯自比。继又言：‘今亮或胜于古亮。’”每提起曾氏，他心中总会涌起一股难言的怨气。原因只有一个，就是**曾国藩在舞台当中占据了本来应该属于他的“主角”位置。**曾国藩正是直接阻碍他成为“今亮”的罪魁祸首。以主帅身份平定了太平天国，这就是曾国藩对不起他左宗棠之处。 左宗棠晚年，曾经为一幅叫《铜官感旧图》的画作序 , 画的就是曾国藩靖港之败字头湘江的自杀之事。左宗棠的序中有这样一句：“公（曾国藩）不死于铜官，幸也。即死于铜官，而谓荡平东南，诛巢馘让，遂无望于继起者乎？殆不然矣。” 这句话的意思是，曾国藩那次投水没死，当然是天下之幸。但是如果说他死了，天下就没救了，也不是那么回事儿。不难看出，左宗棠真恨不得曾氏死于当时。这样一来“荡平东南，诛巢馘让”的应该就是他了。 他相信，如果这出大戏由他来导演，一定会比曾国藩导得精彩许多。所以在平定太平天国的战争中，他多次在与朋友的通信中认为曾氏用兵呆滞，“非办贼之人”，以为曾氏之才不足以平定太平天国，要拯救大清王朝，还需要别人出手。 导火索: 南京城破,洪秀全的儿子被李秀成护送逃跑了。曾国荃放火把天王宫殿烧了,没看见幼王,就直接和大哥说烧死了。结果大哥禀报给了朝廷。 左宗棠没和曾氏兄弟打招呼,直接上报给朝廷,还夸大了逃跑的人数和景况。这样无非是为了贬低曾家的战功。于是朝廷下了一道严厉苛责曾国藩的奏折。说他欺君罔上。曾国藩没想到这一手, 恼羞成怒把左宗棠的屁事也上报了。(不给他藏着掖着着了) 后续 左宗棠如此对待曾国藩，可谓恩将仇报，实出乎常情常理之外。其实左宗棠一生于朋友之道不屑于用心讲求，先后绝交的朋友不止曾国藩一人。他和郭焘嵩、李鸿章、沈葆桢也无不闹翻。 相比之下，曾国藩一生朋友如云，且其所深交，都是相当杰出的人物。曾国藩一生功业，半受朋友之助。他事业的成功，从某个角度来说，是善于用人的成功。反过来说，他更善于设身处地为他人着想，对朋友提携报答，不遗余力。 失和之后，曾国藩从来没有公开说过左氏一句坏话，私下里也不怎么对人谈论他与左氏的是非短长，真的做到了“相忘于江湖”。然而，左宗棠停止不了对曾国藩的评论。许多笔记资料都记载，曾左失和之后，左宗棠每见一人，都要谈他与曾国藩关系的来龙去脉。每谈此事，则必“大骂”曾国藩。 对策: 面对左宗棠的不断攻击，曾国藩采取了如下对策： 一是要求自己的亲朋好友及家人不要回击左宗棠，避免火上浇油，反而鼓励他们尽量与左宗棠搞好关系。 他一再赞扬李鸿章：“阁下不与左帅争意气，远近钦企。”并说这是李进德甚猛的表现。他还嘱咐自己的儿子，不要因此与左宗棠、沈葆桢等人交恶：“余于左、沈二公之以怨报德，此中诚不能无芥蒂，然老年笃畏天命，力求克去褊心忮心。尔辈少年，尤不宜妄生意气，于二公但不通闻问而已，此外着不得丝毫意见。切记切记。” 二是对左宗棠的攻击不闻不问，不予回答。 曾国藩收到郭嵩焘的信后，并不生气，盖这早在他意料之中。他在复郭氏信中委婉地说：左公之朝夕诟詈，鄙人盖亦粗闻一二，然使朝夕以诟詈答之，则素拙于口而钝于辩，终亦处于不胜之势。故以不诟、不詈、不见、不闻、不生、不灭之法处之，其不胜也终同，而平日则心差闲而口差逸。年来精力日颓，畏暑特甚。虽公牍最要之件，浏览不及什一辄已弃去，即贺禀谀颂之尤美者，略观数语，一笑置之。故有告以詈我之事者，亦但闻其绪，不令竟其说也。 除此之外，**在左宗棠“剿”捻及西征中，曾国藩又将最得意的部下刘松山交给左宗棠使用。**刘松山屡立巨功，对左宗棠帮助极大。“又选部下兵最练、将最健者，遣刘忠壮公（松山）一军西征，文襄之肃清陕甘乃新疆，皆倚此军之力。是则文襄之功，文正实助成之。” **曾左晚年这最后一次交集，确实头一次感动了左宗棠。**左宗棠第一次对曾国藩产生了发自内心的敬重和钦佩。这是曾左关系上的一个重要转折点。 因此曾国藩去世后，身在西北前线的左宗棠派人千里迢迢送来一副谁也没有料到的挽联，其文曰： 谋国之忠，知人之明，自愧不如元辅。同心若金，攻错若石，相期无负平生。 左宗棠自愧不如。 后来郭嵩焘在曾氏大营中待了几天，在日记中记下他人如何评曾： 相国好谀而不废逆耳之言，好霸气而一准诸情理之正，是从豪杰入者。其于用人处事，大含元气，细入无间，外面似疏而思虑却极缜密，说话似广大不落边际而处事却极精细，可为苦心孤诣。尝言李申甫能知我深处，不能知我浅处。又尝言古人办事不可及处，只是运用得极轻，庖丁解牛，匠石运斤成风，有此手段，所谓不动声色措天下于太山之安者，轻而已矣。 也就是说，曾国藩喜欢听好话，也能听坏话。做事能决断有霸气，但都是凭情理。用人处事，从大的格局到小的细节，都值得学习。表面上看很疏朗大气，其实思维极缜密。说话表面上听起来不着边际，实际上办事极精细。他曾经说，李榕只了解我的深处，不了解我的浅处。又说，古人办事，之所以不可及，只是能够举重若轻。为什么能够不动声色就改变天下大势呢？举重若轻而已。 在另一处日记中，他这样评价曾左二人的不同：左帅以盛气行事而不求其安，以立功名有余，以语圣贤之道，殆未也。 (左宗棠做事，凭的是一股气，但不管这个事千万年后能否经得住评价。) 王船山说，圣贤一定是豪杰，而豪杰不一定是圣贤。 在郭嵩焘看来，曾国藩是圣贤，而左宗棠仅止于豪杰，这就是二人的根本区别。","tags":["曾国藩"],"categories":["传记"]},{"title":"曾国藩第一卷","path":"/2023/10/08/曾国藩第一卷/","content":"第一章 七次科举之痛家庭熏陶曾国藩他爸叫曾麟书，考了十六次也没考上，带着十四岁的小曾国藩赶考。曾国藩连考了五次，也是场场落第。 科举的传统来自曾国藩爷爷曾玉屏。曾玉屏年轻时是个纨绔子弟（没钱但纨绔），但听到了别人说自己的坏话，于是发奋图强。 曾玉屏：“吾少耽游惰，往还湘潭市肆，与裘马少年相逐，或日高酣寝。长老有讥以浮薄，将覆其家者。余闻而立起自责，货马徒行” 从那天开始，曾玉屏就像变了个人一样，“自是终身未明而起”。每日早睡早起，天天下地干活，发誓要兴家立业。 他后来对曾国藩说：“余年三十五，始讲求农事。……凿石决壤，开十数畛而通为一，然后耕夫易于从事。吾昕宵行水，听虫鸟鸣声以知节候，观露上禾颠以为乐。种菜半畦，晨而耘，吾任之；夕而粪，庸保任之。入而饲豕，出而养鱼，彼此杂职之。凡菜茹手植手撷者，其味弥甘；凡物亲历艰苦而得者，食之弥安也。” 经过自己的奋斗，曾玉屏成了小地主。 曾玉屏的上进心也体现在对后代科举的重视。是他推动了曾麟书的科举经学之路。 曾国藩的考到第五次还是落榜。同时还被“悬牌批责”为“文理欠通”。直接社会性死亡——这是曾国藩平生第一大挫折。 后来他在日记当中说自己是“受质本薄……志亢而力，不副识远而行不逮”“资质之陋，众所指视”。天赋太差，志向远大但能力不副。 这时爷爷的熏陶起作用了。 曾国藩很崇拜自己的爷爷。他后来在家书中经常谈到祖父的一些言行：“吾家祖父教人，亦以‘懦弱无刚’四字为大耻，故男儿自立，必须有倔强之气。“‘倔强’二字，却不可少。功业文章，皆须有此二字贯注其中，否则柔靡不能成一事。” 同时，小曾国藩还为自己取了个号，叫“涤生”。用他自己的话来说，“涤者，取涤其旧染之污也；生者，取明袁了凡之言‘从前种种，譬如昨日死，以后种种，譬如今日生也’”。 笨方法反而是捷径他考秀才考了七次，举人和进士却考得顺利，就是因为他基础打得牢，开了窍后，就能一顺百顺。相反，那些有小聪明的人不愿意下笨功夫，遇到困难绕着走，基础打得松松垮垮，结果就走不远。所以，“笨拙”的人看起来开始走得慢，其实越到后来就走得越快，就好比盖房子，因为基础打得牢，房子就盖得比别人高。 曾国藩的人生哲学是“尚拙”。既然天性钝拙，那么曾国藩就充分发挥钝拙的长处。他一生做事从来不绕弯子，不走捷径，总是按最笨拙、最踏实的方式去做。涓滴积累，水滴石穿，追求的是扎实彻底，一步一个脚印。 他做人讲究“拙诚”，人以伪来，我以诚往，不玩心眼。他带兵讲究“结硬寨、打呆仗”，从不凭奇谋诡计，只凭坚忍踏实，死磕到底。 这种方式正如“重剑无锋”，表面上看起来滞钝，实际上锋利；就好比郭靖的降龙十八掌，表面上简单笨拙，实际上却大气厚重，所向披靡。这是曾国藩一生成功的秘诀，也是他常向别人谈及的道理。 他在《送郭筠仙南归序》中这样说：“君子……赴势甚钝，取道甚迂，德不苟成，业不苟名，艰难错迕，迟久而后进。铢而积，寸而累，既其纯熟，则圣人之徒。”那意思就是说，君子不走捷径，不图虚名，锱铢积累，艰难前进。君子成功也许比别人晚，但一旦成功，就是大成功。 第二章 为什么学做圣人自卑和焦虑曾国藩以前曾非常自卑，但是科举的成功让他找到了自信。二十四岁中了举人后，曾国藩已经“锐意功名，意气自豪”。二十八岁中进士、点翰林，让曾国藩更是顾盼自雄，睥睨一世。 他离家进京的时候，曾请求老祖父给他两句嘱咐，曾玉屏虽然不识字，但是对他说了这样一句话：“尔的官是做不尽的，尔的才是好的……尔若不傲，更好全了。”就是说你是有才能的，做官肯定是有前途的，你要是把身上这个傲的毛病改了，就更好了。可见他言谈举止中已常露出飘飘然之概。 因为没读过什么书，入京为官以前的曾国藩，从气质到观念都是非常庸俗的。 出生在普通农家的他从小所听闻的，不过是鼓吹变迹发家的地方戏；头脑中所想的，不过是功名富贵。读书是为了当官，在他头脑中是天经地义的。好友刘蓉说他当时“锐意功名”，他自己也说当时最大的心事不过是“急于科举”。当然这也是无可奈何之事，因为人毕竟是受环境影响的。 在一封家书中他说：“兄少时天分不甚低，厥后日与庸鄙者处，全无所闻，窍被茅塞久矣。”然而，到了翰林院，他才知道什么叫学术，什么叫心性之学，才发现自己是多么鄙陋。他认真研读明代大儒王阳明的《传习录》。 王阳明少年时曾问自己的私塾老师：“何为第一等事？”什么是天下最重要的事？ 塾师回答说：“唯读书登第耳！” 王阳明却不以为然，回答说：“登第恐未为第一等事，或（也许是）读书学圣贤耳！” 科后来王阳明参加进士考试，也经过两次落第。人人都以落第为耻，但王阳明却说：“世以不得第为耻，吾以不得第动心为耻。” 读了这些，曾国藩悚然一惊。他这才发现和这些圣贤人物比起来，自己的视野多么狭窄，境界多么低劣. 于是如何洗刷自己身上的鄙俗之气，成了曾国藩新的焦虑。 三十而立，学做圣人曾国藩日记中的自我反省： 第一个毛病悬躁：静不下来，生活不规律。 翰林官员是非常清闲的，通常一个月只需要初一、十五上两天班，点个卯，其他时间都可以自由支配。 因此进士们刚进翰林院，很多都开始放任自己，曾国藩也是这样。 他在日记中说：留馆后，本要用功，而日日玩愒，不觉过了四十余天。前写信去家，议接家眷。又发南中诸信。比作季仙九师寿文一首。余皆怠忽，因循过日，故日日无可记录。在翰林院工作的开头四十天，除了写了几封家信和一篇文章外，什么正事都没做，每天就是串门聊天饮酒下棋。翻开曾国藩日记，我们会看到他责备自己“宴起”“无恒”“太爱出门”。 还爱看杀人。曾国藩住在城南菜市口附近，清代的时候那里是刑场。所以曾国藩隔三岔五，就和朋友们一起去看杀人。 为人傲慢，修养不好 如前所述，曾国藩是同学中唯一的进士，又点了翰林，因此难免觉得自己很了不起。到了北京之后，曾国藩交了很多朋友。他的两个最好的朋友都说他身上最大的毛病是傲慢。陈源兖说他“无处不着怠慢之气”。 因为修养不好，脾气暴躁，曾国藩到北京的头几年经常跟人发生冲突。有一次他跟一个同乡——刑部主事郑小珊，因为某事意见不一致吵起来了，隔着桌子就要动手，大家给拉开后，还彼此指着对方的鼻子破口大骂。曾国藩在日记当中说是“肆口谩骂，忿戾不顾，几于忘身及亲”，骂了很多非常难听的话，甚至于都**“问候”了对方的家人**。 虚伪奉承，夸夸其谈 在社交场合容易顺情说好话，发出一些言不由衷的赞美，而且还喜欢夸夸其谈，不懂装懂。邵懿辰有一次对曾国藩说，你的缺点，除了“自是”外，还有一条，就是“伪”，“谓对人能作几副面孔也”。 他在日记说，有一个叫黎吉云的朋友来拜访他，“示以近作诗。赞叹有不由中语，谈诗妄作深语”。黎吉云到家里来拜访他，拿了一沓刚写的诗，请曾国藩点评，曾国藩感觉这诗写得不怎么样，但是一开口，却言不由衷地夸奖起来。说着说着又开始显示自己在诗学方面的素养，说了一些故作高深的话。把黎吉云送走之后，曾国藩反思刚才自己的言谈举止，感觉脸上有点儿发烧。 好色 1.在朋友家看到主妇，“注视数次，大无礼。” 2.“友人纳姬，欲强之见，狎亵大不敬。” 3.朋友说起自己如何情场得意，曾国藩“闻色而心艳羡”，暗暗骂自己“真禽兽矣”. 4.参加进士同学的团拜，到了大富之家，发现此人家中姬妾如云，美女众多，曾国藩大开眼界，拼命看了好多眼。 《日记》中说：“是日，目屡邪视，直不是人，耻心丧尽，更问其他？” 5.曾国藩拜完年回到家里，看看自己的老婆，再想想人家的姬妾，感觉自己太亏了。人比人，气死人。碰巧欧阳氏身体不好，正在闹病，曾国藩更加厌恶，“夜，心情不畅，又厌闻呻吟声”，干脆出门到朋友处聊天，“更初归”。 出村读书长见识湖南人虽然有倔强、坚韧的特性，但也有封闭、褊狭的弱点。湖南人将走出湖南叫作“出湖”，湖南历史上有一个规律，一个人只有出湖，才能褪却身上那种在闭塞环境下产生的狭隘偏执，变得大气宽广，有所作为。 曾国藩也是这样。京师乃人文荟萃之地，曾国藩在这里眼界大开。他兴奋地在家书中对弟弟们说：“京师为人文渊薮，不求则无之，愈求则愈出。” 到了翰林院，曾国藩如饥似渴地开始读书，认真研究理学经典。曾国藩拜访大儒唐鉴，请教读书学习之法。唐鉴建议他先读《朱子全集》，以朱熹之学为宗。“道此书最宜熟读，即以为课程，身体力行，不宜视为浏览之书。” 因此曾国藩从这一年起，“以朱子之书为日课，始肆力于宋学矣”。通过读书与交友，曾国藩的视野和见识与以前大不相同。 他在家书中说：“近年得一二良友，知**有所谓经学者、经济者，有所谓躬行实践者，始知范、韩可学而至也，马迁、韩愈亦可学而至也，程、朱亦可学而至也。慨然思尽涤前日之污，以为更生之人，**以为父母之肖子，以为诸弟之先导。” 也就是说，到了北京，他才知道学问的门径，也才知道原来范仲淹、韩琦那样的大政治家和司马迁、韩愈那样的大文学家也不是高不可及。如果我们切实努力，一步步踏实用功，也可以达到他们那样的高度。 “做个光明磊落神钦鬼服之人，名声既出，信义既著，随便答言，无事不成，不必爱此小便宜也。“ 学会写日记第一次记日记，曾犯了两个错误：坚持不下来，记成流水账。 第一次没坚持下来的理由：”误置箱内，不能逐日取出，随意记载”，这个借口显然很牵强，这次日记中断其实是因为偷懒。 流水账则是只记录自己吃什么干什么，没有思考。 在第一次日记中断了半年之后，曾国藩重新发愤图强，决心不再因循过日.他在日记中说：兹拟自今以后，每日早起，习寸大字一百，又作应酬字少许；辰后，温经书，有所知则载《茶余偶谈》；日中读史亦载《茶余偶谈》；酉刻至亥刻读集，亦载《茶余偶谈》；或有所作诗文，则灯后不读书，但作文可耳。 计划得不错，但是实践了多少呢？我们看这个月，从初八日记起到二十四日开始生病，十六天中，他日记中关于“宴起”的记载是八次，起床失败率高达百分之五十。他说要天天记《茶余偶谈》，结果这个月，他只记了两次。至于写字，他大部分天数都有写应酬字的记载，但是“习寸大字一百”，只有一天完成了。 唐鉴和倭仁告诉他，日记不是这个写法。记日记最主要的目的是反省自己。 “静海先生每夜必记‘日省录’数条，虽造次颠沛，亦不闲一天，甚欲学之。”唐鉴每**天晚上都要记几条自省录，来督责、规范自己。**即使在路上，或者有什么紧急事务，也不打破这个规律。 唐鉴还推荐他向倭仁学习写日记之法：“又言近时河南倭艮峰仁前辈用功最笃实，每日自朝至寝，**一言一动，坐作饮食，皆有札记。**或心有私欲不克，外有不及检者皆记出。” 第三章 曾老师的进阶之道自我管理翰林阶段，最重要的任务仍然是学习。曾国藩刚到北京的时候，自我管理能力比较差，散漫无恒，用于学习的时间不多。但是立志“学做圣人”之后，他自我管理能力迅速提高。在日记当中，他给自己立下了十二条做人的规矩： (1)敬。整齐严肃，无时不慎。无事时心在腔子里，应事时专一不杂。清明在躬，如日之升。 (2)静坐。每日不拘何时，静坐四刻，体验来复之仁心。正位凝命，如鼎之镇。 (3)早起。黎明即起，醒后勿沾恋。 (4)读书不二。一书未完，不看他书。东翻西阅，徒徇外为人。 (5)读史。丙申年购《廿三史》，大人曰：“尔借钱买书，吾不惜极力为尔弥缝，尔能圈点一遍，则不负我矣。”嗣后每日圈点十叶，间断不孝。 (6)谨言。刻刻留心，第一工夫。 (7)养气。气藏丹田，无不可对人言之事。 (8)保身。十月二十二日奉大人手谕曰：“节劳，节欲，节饮食。”时时当作养病。 (9)日知所亡。每日读书记录心得语，有求深意是徇人。(10)月无忘所能。每月作诗文数首，以验积理之多寡，养气之盛否。不可一味耽着，最易溺心丧志。 (11)作字。饭后作字半小时。凡笔墨应酬，当作自己功课。凡事不留待明日，愈积愈难清。(12)夜不出门。旷功疲神，切戒切戒。 交朋友清代名臣张英在《聪训斋语》中说：“人生以择友为第一事。” 朋友的多少、朋友的质量，决定了一个人的视野能有多宽广。 在闭塞的湖南乡下，曾国藩最大的遗憾是交不到有质量的朋友。 所以后来他在致诸弟的家信中谈及自己当年的感受：“乡间无朋友，实是第一恨事。不惟无益，且大有损。习俗染人，所谓与鲍鱼处，亦与之俱化也。”“同学之人，类皆庸鄙无志者，又最好讪笑人。其笑法不一，总之不离乎轻薄而已。”可见他对自己当年那些庸鄙的同学是十分看不上眼的。 到了北京之后，曾国藩迅速结交了一大批好朋友。曾国藩在家书中常介绍他的交友情况。 他说：“现在朋友愈多，讲躬行心得者，则有镜海先生、艮峰前辈、吴竹如、窦兰泉、冯树堂；穷经知道者，则有吴子序、邵慧西；讲诗、文、字而艺通于道者，则有何子贞；才气奔放，则有汤海秋；英气逼人志大神静，则有黄子寿。又有王少鹤，名锡振，广西主事。 曾国藩为人特别爱交往。入京之初，他为人处世不够周到，经常得罪朋友。而在立志“学做圣人”之后，曾国藩不断反省自己的缺点，与人相处越来越注意替他人着想，朋友越来越多。 他和朋友们经常在一起吟诗作赋，切磋学问。他也经常请客吃饭，邀人听戏下棋。我们看他的日记，几乎没有一天不社交的，经常交往的朋友有一百多人。最多的一天，接待或者拜访朋友几十人。道光二十三年(1843)三月他升为翰林院侍讲那次，因为朋友多，人缘好，所以大家都来祝贺，以至于他二十二日那一天，跑了五六十家去回拜。 曾国藩朋友之所以多，还在于他效法祖父，急公好义，特别爱助人。 “同乡有危急事，多有就男商量者，男效祖大人之法，银钱则量力佽助，办事则竭力经营。”[插图]挚友刘传莹病死，曾国藩搜集其遗文，为他刻印出版了遗著；同乡举人邹兴愚（柳溪）会试不售，在北京贫病而死，曾国藩为他料理了后事，撰写了墓志铭，并出钱为他制作石碑；新宁人邓铁松在北京患病吐血，情况危重，已不可挽回，曾国藩筹钱将他送回湖南…… 声望一个人的声望是晋升的重要基础。在曾国藩所处的晚清，虽然今天提起来，总说那是一个政治腐败、社会黑暗的时代，但实际上和后来的某些历史时段比起来，是非尚有一定公论，黑白尚未完全颠倒。曾国藩结交师友，潜心治学，提高了他在士林中的声望。 理学修养曾国藩在做翰林期间，在理学方面下了很大功夫，他由朱熹开始，上溯张载、周敦颐等人的著作，并对它们产生了越来越浓厚的兴趣。同时，他还究心汉学，在学术上走上全面发展的道路。每次翰林考试道光皇帝都要亲自看试卷，曾国藩的成绩很好，就是因为有理学修养做基础。 第四章 以前的官场愣头青直言皇帝咸丰上任第一把火罢了穆彰阿，第二把火请求上言。 于是曾国藩： “京官之办事通病有二，曰退缩，曰琐屑。外官之办事通病有二，曰敷衍，曰颟顸。退缩者，同官互推，不肯任怨，动辄请旨，不肯任咎是也。琐屑者，利析锱铢，不顾大体，察及秋毫，不见舆薪是也。敷衍者，装头盖面，但计目前剜肉补疮，不问明日是也。颟顸者，外面完全，而中已溃烂，章奏粉饰，而语无归宿是也。有此四者，习俗相沿，但求苟安无过，不求振作有为，将来一有艰巨，国家必有乏才之患。” 又上《备陈民间疾苦疏》。他在奏疏中提出现在百姓生活有“三大疾苦”，一是银价太贵，百姓负担太重，交不起国税。“民之完纳愈苦，官之追呼亦愈酷。……百姓怨愤，则抗拒而激成巨案。”“真有日不聊生之势。”二是盗贼太多，良民难安。强盗土匪“愈酿愈多，盗贼横行，而良民更无安枕之日。臣所谓民间之疾苦，此又其一也”。三是冤狱太多，司法腐败严重，民气难申。 后来咸丰无能。在强烈的责任感支配下，以谨慎闻名的曾国藩做出了一个晚清官场极为罕见的举动：直言批评皇帝。他上了一道惊世骇俗的《敬陈圣德三端预防流弊疏》。 从此之后，小心眼的咸丰就不断给曾国藩小鞋穿。但同时为他赢得了很高的政治声望。特别是在湖南，他的奏折内容经老乡和朋友们的传播，为湖南通省所知，湖南士人对曾国藩更加敬佩，曾国藩在湖南的知名度和威望一下子迅速提高，这对他后来组建湘军、吸收人才有很大作用。 批评同僚琦善和赛尚阿犯事，大伙抢着做人情。曾国藩要求公事公办，打破官官相护，败了朝廷里的人缘。 案子审完之后，许多人与曾国藩拉开距离，甚至不再往来。“诸公贵人见之或引避，至不与同席。”有一次有人请客，曾国藩也去了，见一个桌子上还有空位，桌上坐的，还都是自己认识的人，于是一屁股坐到那了。正想跟大家打招呼，结果他一坐下，这一桌人纷纷站起来，一言不发，都跑到别的桌上去了。 木秀于林，风必摧之，锋芒毕露，人必非之。 给皇帝画图画丑了，成了北京官场议论的中心。大家议论的不是他的赤心血诚，而是讥笑他“画图太陋”。 曾国藩在奏折中把所有的官员都骂了一顿，说京官办事退缩、琐屑，外官办事敷衍、颟顸，科道官员也没有一个人敢对皇帝上直言。 于是曾成了北京官场议论的中心。大家议论的不是他的赤心血诚，而是讥笑他“画图太陋”。 皇帝下了一个求言诏，你就真的独抒己见，把大家一竿子全打倒？因此，曾国藩的这个“笑话”很快腾于众口，风传全城。人们见了他，都“目笑存之”，笑眯眯地看着他，谁也不说话，显然他们在背后议论他已经很久了。这令曾国藩无地自容。 第五章 曾剃头的长沙之辱曾国藩到长沙大刀阔斧改革，触及到了当地官僚们的利益，成为众矢之的。 于是绿营军经常借故与湘勇发生械斗。鲍起豹的卫队寻衅攻打湘勇，双方各有负伤。于是曾国藩向鲍起豹发去文书，要求他逮捕带头闹事的绿营兵，以杜私斗之风。鲍起豹决意要借这个机会好好教训教训曾国藩。他故意将几名肇事士兵五花大绑捆起来，大张旗鼓地押送到曾国藩的公馆，同时派人散布曾国藩要严惩这几个绿营兵的消息，鼓动军人闹事。绿营纷纷上街，游行示威，要求曾国藩释放绿营兵。 长沙城中一时大乱。张亮基调走之后，湖南通省官员都和曾国藩气味不投。出了这个事，“营兵既日夜游聚城中，文武官闭门不肯谁何。”等着看曾国藩的笑话。绿营兵见状，胆子更大，居然开始公然围攻曾国藩的公馆。 曾国藩的公馆就临时设在巡抚衙门的射圃里，与巡抚骆秉章的办公室仅一墙之隔。曾国藩以为绿营兵胆子再大，也绝不敢武装攻击他这个二品大员。所以被绿营兵包围后，他还若无其事地处理公文。不料绿营兵竟然破门而入，连伤了他的几个随从，连曾国藩自己都差点挨刀。曾国藩夺门而逃，几步跑到隔壁巡抚办公室门前，连连急叩。 绿营兵在门外闹事，巡抚骆秉章听得一清二楚，但是他装聋作哑，暗暗发笑。他早应该出来调停，却一直假装不知。直到曾国藩来叩门，他才故作惊讶，出来调停。绿营兵一见巡抚驾到，马上规矩了。骆秉章的调处办法是命人把鲍起豹捆送来的那几个绿营兵带过来，他亲自上前松绑，还连连向他们道歉，说让兄弟们受委屈了！绿营兵面子挣足，兴高采烈地拥着这几人而去 “好汉打脱牙和血吞。”这是一句湖南土话，好汉被人家打掉了牙，不要吐出来让别人看到，要咽到肚子里，继续战斗。他不再和长沙官场纠缠争辩，而是卷起铺盖，带着自己募来的湘军，前往僻静的衡阳。全省官员瞧不起我，我不争一日之短长。等到我在衡阳练成一支劲旅，打几个胜仗给你们看看，那时自会分出高下。这才是挽回面子的最好办法！ 第六章 湘军为什么牛气1.创建湘军的苦心和良心①维护清王朝统治 ​ 维护社会稳定。 ②建立事业，施展抱负 天下大乱，秩序崩解，皇帝对各地的控制力已经大不如前，为他赤地立新、开创局面提供了难得之机。 ③维护中国传统文化 为了统一思想，洪秀全却宣称中国传统文化均为“妖”书“妖”术，要焚毁所有中国经典，扫灭所有中国传统信仰。 如果太平天国起义成功，中国将陷入巨大的蒙昧。这是曾国藩决定挺身抵抗的根本原因。他在《讨粤匪檄》中说，太平天国不仅是大清这个王朝的敌人，也是中国这个文化体的敌人。“举中国数千年礼义人伦、诗书典则，一旦扫地荡尽。此岂独我大清之奇变，乃开辟以来名教之奇变，我孔子、孟子之所痛哭于九原。” 古往今来即使是乱臣贼子穷凶极恶之人，也往往敬畏神明。李自成到曲阜，不敢冒犯孔庙；张献忠到梓潼，也祭祀文昌帝君。而太平军却焚毁郴州的学舍、毁坏孔子的神位，两廊屋中供奉十位哲人之处，也是遍地狼藉。自郴州起，凡他们所经过的郡县，一定先烧毁庙宇，即使是忠臣义士，像关羽、岳飞等也都被污毁了庙宇，砍掉了神像的脑袋；其他的佛寺、道院、城隍庙、土地庙，更是没有一座寺庙不被烧毁，没有一座神像不被毁灭。 太平天国在镇江金山、北固山寺院到处放火，甘露寺“仅存天王殿、长廊及石帆楼数椽，余则荡然无存”。太平军经句容，毁曲山宫观，“茅山自西汉迄今数千年，灵贶照耀寰宇……贼遂将山下宫观数十区，投诸一炬”。在常州，“凡寺院神庙无得免者”。有名的天宁禅寺，“庚申之变，案卷沦失，碑毁无存”苏州寒山寺，“咸丰十年被毁”，“虎丘唯剩一塔”。洪秀全在南京倾全城之力营造天王府的过程，更是几乎将六朝以来的古建筑拆光，如举世闻名的南京大报恩寺塔被炸掉，明代故宫被拆毁得只剩一座门，所有“寺观庙宇，或焚或拆。 起义军进驻宁波，浙东天一阁一半珍本或被毁或流失。存放四库全书的江南三阁两阁荡然无存，一阁损失多半。因此苏南知识分子叹息：“经典书籍，弃等秽污。自古流寇之毒祸，未有如是烈者。” 2.与咸丰帝的博弈咸丰帝给的权力远远不够，只是团练完全满足不了咸丰真正的需求，也不够曾国藩施展拳脚。所以这里我们要学习曾国藩面对领导给的难题时**“明修栈道、暗度陈仓**”的策略，感受“管理层和执行层天然的割裂”这一矛盾。 这里倒不是曾阴奉阳违。他是真正以解决问题的角度，从实践出发的。 一个汉人要跳出国家体制，自创一支军队来取代国家军队，这是大清二百年来没有过的，绝对是大逆不道的行为，实在是挑动着清代统治者最敏感的那根神经。 ①含糊其辞，用词暧昧而灵活 为了含糊其词，曾国藩说： “臣拟现在训练章程，宜参访前明戚继光、近人傅鼐成法，但求其精，不求其多；但求有济，不求速效。” 戚继光练的是新军，傅鼐办的是民团，根本是两码事。曾国藩却把二者混在一起，揣着明白装糊涂，有意误导皇帝。他这样一和稀泥，要独立建军的目的就看不清楚了。 湘军成军之后，曾国藩多次谈起戚继光理论，但是再没有提傅鼐一字。很显然，他打起傅鼐的招牌就是为了瞒天过海。曾国藩当了十三年京官，凭着他对官僚体系的了解，知道如果按常规办事，是永远不可能建成湘军的。因此曾国藩虽然以诚自命，这次却不得不欺骗皇帝。 咸丰帝或者是因为不够精明，或者是在焦头烂额中根本没有细看这份奏折，感觉这反正不是坏事，就在上面草草批示了十一个字：“知道了。悉心办理，以资防剿。” ②拖字诀 咸丰让他火速支援。但准备没做足，时机不允许。 他精心上了一道奏折，说我积极准备出兵，现在正在筹集饷银和购买洋炮，等大炮安上，军饷到手，就马上出发。“拖”字诀发挥了作用。这道奏折上了没多久，军势形势发生变化，太平军离开湖北，开赴安徽，曾国藩这才放下心来。 ③以退为进 : 死猪不怕开水烫 咸丰着急了。勒令曾国藩必须出兵，还骂了他一通。 字字怒火，字字刻薄。当年被曾国藩在《敬陈圣德三端预防流弊疏》中批评时所受到的委屈怨恨喷薄而出。从这种讥讽的口吻中我们可以发现，在咸丰皇帝看来，曾国藩不过是一个好高骛远、纸上谈兵的书生。 奉到如此严苛之旨，曾国藩毫不害怕，他于十二月二十一日上了一封表面诚恳、实则强硬的回奏。 微臣有数条，不得不逐条陈明： 一、起行之期，必俟解炮到楚。臣所办之战船，新造者九十号，改造者百余号，合之雇载者共四百号，可于正月中旬一律完毕。惟炮位至少亦须八百尊，乃敷分配，计算正月之末，总可陆续解到。 二、黄州以下，节节有贼，水路往援之兵，不能遽达皖境。臣奉命由水路前往，阻隔黄州一带，何能遽行扫清，直抵安徽？ 三、三省合力防堵之说，系臣骆秉章与臣函内言之；四省合防之说，系臣江忠源与臣函内言之。臣之才力固不能胜，臣之见解亦不及此，此系吴文镕、骆秉章、江忠源三臣之议论。然舍此办法，则南数省殆不可问矣。 四、饷乏兵单，微臣竭力效命，至于成效，则不敢必。臣以丁忧人员，**去年奏明不愿出省办事，仰蒙圣鉴在案。此次奉旨出省，徒以大局糜烂，不敢避谢。**然攻剿之事，实无胜算。且贼势猖獗如此，岂臣区区所能奏效。臣自维才智浅薄，惟有愚诚不敢避死而已。至于成败利钝，一无可恃。 皇上若遽责臣以成效，则臣惶悚无地。与其将来毫无功绩，受大言欺君之罪，不如此时据实陈明，受畏葸不前之罪。臣不娴武事，既不能在籍终制，贻讥于士林；又复以大言偾事，贻笑于天下。**臣亦何颜自立于人世乎！**中夜焦思，但有痛哭而已。 （摘录） 奏折要点有四。 一是**“拖字诀”**：他确实还没有完全准备好，正在兴办战船，“昼夜催赶，尚不迟缓”，明年正月底才能装齐大炮出征； 二是据理力争：咸丰的指示不符合实际情况，长江沿岸，到处都是太平军，“何能遽行扫清，直抵安徽？” 三是分摊矛盾，甚至踢皮球：辩白四省合防论不是我自己的看法，而是这几个省的总督巡抚的一致意见。 四是表明心迹的同时，以退为进。宁愿你说我怂，把我辞了，也不愿意仓促失败、让你说我欺君之罪，办事差劲。 最后说两句贬低自己的自谦话，让领导无评可批：我不熟悉打仗事，我还话多事也多”，你敢把我辞了吗，我好没面子啊 这封奏折写得强硬而又沉痛，句句顶着咸丰来，这是一副死猪不怕开水烫的劲头。咸丰早就知道曾国藩的脾气，现在一看这封奏折，知道曾国藩是不可能让步了，只好自己给自己找台阶，反过来说曾国藩说得有理，让步抚慰，还说“汝之心可质天日，非独朕知” 3.”长沙之辱”的财富可以说，没有长沙之辱，就没有曾国藩后半生的功名事业。这一次挫而后奋的成功，给了曾国藩另一次印象极深的自我教育，更强化了他愈挫愈奋、百折不挠的性格特点。多少年后，曾国藩对他的心腹幕僚赵烈文深有感慨地说，天下事有所激有所逼而成者居多。 从这次经验中，曾国藩更是领悟到，对于有志者来说，挫辱是最大的动力，打击是最好的帮助。咬紧牙关，把挫辱活生生吞下，就成了滋养自己意志和决心的营养。这构成了曾国藩生命经验中最核心的部分。 几十年后，他还在家书中教育儿子说：“天下事无所为而成者极少，有所贪有所利而成者居其半，有所激有所逼而成者居其半。”百端拂逆之时……亦只有逆来顺受之法。”所谓‘好汉打脱牙和血吞’……真处逆境之良法也。” 前文聊到，曾国藩凭借惊人的定力，不惜牺牲老师和同好争取到的完全体军队，这次终于准备出击。太平军打到了湖南，准备打长沙。 被太平军包围的曾老准备主动攻打湘潭，突破包围圈。这时有个小兵说靖港的太平军貌似没什么人，很松散，挺好打。曾国藩当即让部下塔齐步打湘潭，自己去打靖港。 这里魄力有余，思虑欠缺了。应该再派两个士兵去探查的。贻误军机也比轻信一个小卒要强。 但分派两路是很好的想法。 结果情报有误，天气骤变，大风把船兵吹到了兵强马壮的太平军面前，全线失败，逃跑不及。 厚积薄发，首战大败。 来看看什么是真正的丢人，社恐： 湖南提督鲍起豹说曾国藩是引狼入室，劳民伤财，所以关上城门，不让曾国藩进城。此时湖南按察使陶恩培荣升山西布政使，长沙官场送往江边登舟赴任，湘江码头离曾国藩的座船咫尺之遥，但所有的官员竟然就像没看见曾国藩，无一人顺道过来拜访一下。长沙通城官员在传曾国藩的笑话，说什么早就知道这个二愣子成不了事。甚至曾国藩的亲兵想进城都进不了，在城门口被老百姓追着打，人们纷纷说他们是废物，白吃老百姓给的粮饷。以布政使徐有壬为首的长沙几个官员，幸灾乐祸，煽风点火，准备起草奏折，弹劾曾国藩。曾国藩自己回忆说：“甲寅年（咸丰四年）岳州、靖港败后栖于高峰寺，为通省官绅所鄙夷。”曾国藩年谱也载：“公之回长沙也，驻营南门外高峰寺。湘勇屡溃，恒为市井小人所诟侮，官绅之间，亦有讥弹者，公愤欲自裁者屡矣。 曾国藩羞愧至极，那身湿衣服说什么也不脱下来，他不吃不喝，不洗头不洗脸，只是坐在那奋笔疾书，起草遗折，也就是写给皇帝的遗书，打算再找机会寻死。他的老部下李元度描述当时的情景说：“文正衣湿衣，蓬首跣足，劝之食不食。乃移居城南妙高峰，再草遗嘱，处分后事，将以翼日自裁。”曾国藩在遗疏中说：“为臣力已竭，谨以身殉……臣愧愤之至，不特不能肃清下游江面，而且在本省屡次丧师失律，获罪甚重，无以对我君父。谨北向九叩首，恭折阙廷，即于△△日殉难。”他还嘱咐弟弟曾国葆护送自己的棺材回老家，还嘱咐不可办葬礼，不收礼金。一通安排搞得大家都提心吊胆。 4.湘军团队的设计晚清军营的两个怪现状：士兵们都专心副业，部队经营第三产业。 军队实行薄赋制，士兵没钱养家糊口，就搞第二产业。军队训练旷掉或找人顶替。部队高层则把练武操场租借出去，建造的军船也租给商人运送货物。军队也会收受贿赂，让运送鸦片等违禁物的商人钻空子。 曾国藩的湘军特点： ①钱多 ②将必亲选，兵必自募 ③选士人领山农 钱多解决薄赋制，亲选自募则保证兵与将之间，兵与兵之间更有凝聚力。士人领山农则提高了军队的精神力量，让文化人提供智力支持。 诗人代表：罗泽南。 罗泽南：”知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。“朝出鏖兵，暮归讲道”，秉承湖南理学将生死置之度外，并且重视实践。 每营门夜扁，书声琅琅出壕外，不知者以为村塾也。”故有人说：“湘军自讲学起，修道为教。”曾国藩也说：“吾湖南近日风气蒸蒸上。凡在行间，人人讲求将略，讲求品行，并讲求学术。” 山农： “山僻之民多犷悍，水乡之民多浮滑，城市多游惰之习，乡村多朴拙之夫，故善用兵者，尝好用山乡之卒，而不好用城市、近水之人。 绝对不收当过兵的人，不收退伍军人。“不杂一卒，不滥收一弁。”因为他怕这些绿营兵把绿营的习气带到湘军中来。 另外治军还要讲究思想政治工作的教育。 太平军：所有军前临阵生擒及地方拿获奸细，加以刑拷，毫不知所惊惧及哀求免死情状，奉其天父天兄邪谬之说，至死不移。 太平天国规定，加入太平军后第一件事就是要掌握教义：“凡兄弟俱要熟读赞美天条，如过三个礼拜不能熟记者，斩首不留。”虽然战事倥偬，但是他们坚持每天早晚都要敬拜上帝，每七天举行一次集体礼拜。礼拜之时一定要虔诚郑重，“凡闻锣不至或稍涉嬉戏者杖责数百，无故缺席三次则斩首示众”。太平天国还建立了“讲道理”制度，即定期将军队召集在一起训话，以通俗的语言，理论联系实际，来进行深入浅出的思想动员，要求他们放弃杂念为天国事业忘我牺牲。 湘军：曾国藩把军队的训练，分成了“训”和“练”这两个部分。所谓“训”，就是“训话”，也就是政治思想教育。“练”，才是练习军事技术。“训”和“练”相比，曾国藩更重视“训”。 杀身成仁，舍生取义”的孔孟之道和“不要钱，不怕死”的岳飞精神; 曾国藩：“古来名将得士卒之心，盖有在于钱财之外者；后世将弁专恃粮重赏优，为牢笼兵心之具，其本为已浅矣。是以金多则奋勇蚁附，利尽则冷落兽散。” 对待问题的稳重务实。 建战船的时候： 找来湖南全省的能工巧匠，居然没有一个人知道怎么造战船。于是曾国藩自己设计，首先用木排，不行；然后参考龙舟：实验以后还是不堪大用。 从长沙前来的守备成名标向曾国藩介绍了广东快蟹船和舢板船的大概样子。又过几天，同知褚汝航从桂林前来，向曾国藩介绍了长龙船的造法。于是曾氏大雇衡州、永州的能工巧匠，在湘潭设立两个船厂，大量制造快蟹、长龙、舢板战船。“两厂之船，往来比较，互相质证。”两位军官本身并非工匠，他们只介绍了外地舰船的大体模样，至于船的具体结构尺寸，乃至每一个部件，他都要和有经验的工匠反复设计，不断试验。 史载曾国藩“创建舟师，凡枪炮刀锚之模式，帆樯桨橹之位置，无不躬自演试，殚竭思力，不惮再三更制以极其精”。字字不虚。曾国藩身上有着突出的试验精神和开放态度，凡事总愿意亲身经历，亲自体验，勇于尝试，勤于尝试。做事讲究身到、心到、口到、眼到，特别强调要“苦下身段去事上体察一番”。经过反复试验，终于建成十营水师。曾国藩建军，确实筚路蓝缕。 没钱的时候： 创建湘军之后，关于军饷，曾国藩想来想去，还是只有劝捐这一个办法。他在衡阳设立劝捐总局，派人四处劝捐筹饷。回报是由国家授予他们一些荣誉性的虚职。然而，曾国藩本身非官非绅，权力不明，收据由曾国藩自己刊印，信用不高。从咸丰三年（1853）八月到咸丰四年（1854）底，总局费尽口舌，一共才弄到一万九千多两银子，根本无济于事。劝而不动，他只好强行勒派。巨绅们如果拒不捐款，他就派兵动用拘押手段。结果虽然弄到了一些钱，却招致地方大户的重重怨恨。曾国藩因此叹息：“劝捐之难，难于登天，费尽心力，迄无一获。” 没有办公场所，他就借住在一户祠堂里。 没有名位，他只好照旧用长沙时用过的“湖南审案局”五个字来接送公文。 没有经验，曾国藩就自己在黑暗中摸索。在具体实践过程中，曾国藩不断失败，不断犯错。","tags":["曾国藩"],"categories":["传记"]},{"title":"心钝","path":"/2023/10/02/心钝/","content":"心钝首先阐明词义：何为心钝？ 我的理解：心钝乃是 好奇心模型和成长模型 不足带来的麻木和懒惰。 举个例子：问你最近对生活的新发现，有趣的事物，偶然悟出的妙理，跳出舒适区的新体验等等，如果你不能自如回答，信手拈来。我想你在这一类问题上的认知模型是匮乏的。 为什么是好奇心和成长两个模型？ 好奇心保证你能在表面上古井不波、枯燥无味的环境里发掘出各种信息。 如果生命是海，我们总希望生活是轰轰烈烈、汹涌澎湃的。“乘风破浪会有时”、“乱石穿空、惊涛拍岸”云云。可多数时间里大海都是一览无余的平静。 这里引用李银河老师的一句话：所有暂时的热闹都只不过是海水撞击岩石时溅出的浪花,生命的本质却永远像海洋深处一样的沉寂。 所以如何在平静的海面上找到属于自己的快乐呢？这就需要好奇心。只有在好奇的状态下，你才会近乎本能的去看，去做，去体验。你才能感受到隐藏在生活之下，汹涌澎湃、钟鼓齐鸣的灵感音符。 这种力量是任何强制力、功利心、攀比虚荣都难以企及的。 就像饿了吃饭、渴了喝水、困了睡觉一样自然。 仅仅是由着性子去体验。还有比这更美妙的事情吗？ 这也将人的生活分成“三六九等”。艺术家的生活大喜大悲；逻辑学家的生活狡黠思辨；音乐家的生活富于韵律而美食家的生活充满芳香。不过注意哦，某某家完全不靠某个职业身份证书的认定；而仅仅在于你是否乐于去做—— 每个人都具备“多面手”的潜力。大脑的发育完全支持我们做到这一点。你总能在不经意间做十分钟的乐手、二十分钟的厨师。 乐趣源自哪里？好奇心。 如果你觉得吃饭只是求饱，说话只是你好。那你不仅丢掉了让自己的生活丰富多彩、有滋有味的天然权利， 还将迟早面临被功利心反噬的风险。 下面看一个实例。 问你最近对自己的生活有什么想说的想表达的，这个同学是一时半会说不出来的。就你会沉浸在这样一种状态：这个事没什么好说的，这个事没什么好惊讶的，今天也没什么好讲的，我的生活是平平无奇的。 仅从情商上讲，举个比方：今天周五，你在北京打车去见一个客户。 这个客户的办公室很大但是人很少，不知道客户去哪了。 今天北京的天气很好，阳光明媚，没有沙尘暴也没有雾霾。 你下午两点打的车，路上很堵 这个客户的办公桌上摆了一堆绿萝、绿植。 今天周五。 上面五条是一个素材，至少从这五条里，你和素未谋面的客户并不是无话可说的，不是吗？ 无非是你观察力不细致，或者你觉得办公室人少没什么好说的，天气好没什么好说的，等等等等。 这种观察力的缺失就会带动思考力、表达力的缺失，就像一个心智上的“过滤器”。抱着这种心态，我再问你今天周五感觉如何，你便会迟钝麻木，无话可说。 这里给大家一个建议：“仰观宇宙之大，俯察品类之盛。”也就是善于敏于乐于观察生活中的细节，这样你才不会自怨自艾觉得四面无趣，你才能到任何环境都能保持好奇心，你的眼睛才有光。 有了这个能力，你就能吸收到很多一般人看不到的细节和信息。吸收信息抽象来看是个输入的过程。那输入了这么多的信息，咱们要做的就是整理。就像吃完饭还要把营养吸收掉，去粗取精。这里用到的认知模型是“费曼学习法”，即教就是最好的学，输出带动输入。 上述内容来自b站up主广智的销售宇宙,我只是略微整理、打些比方而已。 好奇心的重要性咱聊完了。接下来说说成长。 如果说好奇心是生活美好所在的敲门砖，那成长意识就是敲开门后的金刚钻。 种下一颗种子意味着你要身披四季风雨冷暖，呵护挂念它直至开花结果。 好奇心只是让你有了种下种子的动机。而要达到收获果实的目的，靠的是汗水的灌溉 —— 汗水的源泉即成长意识。 拥有成长意识，你才能站在全局出发，跳出现有的视角框架，去为自己的目标理想而奋斗。而对自怨自艾、妄自菲薄天然的嗤之以鼻：“我tm忙活半天到底是为了什么，我为什么天天折磨自己，躺床上它不香吗巴拉巴啦……”。 这也是区分强者弱者，智者愚者，乐者苦者的关键所在 —— 成长意识下的大格局、大视野、大框架。 兴趣的多少只是决定了你能开始这段成长旅程，以及旅程之中的难易程度、趣味多少而已。 至于好奇心延伸出的勇气、学习能力（又名信息整合能力）、革命性、思辨力、包容度等，以及成长意识下延伸出的吃苦耐劳、定力韧性等等等等，这里受限于篇幅笔力，不再赘述，有缘补充。 两者共同决定了你生命的质感，你生活的乐趣程度。 私货：也不怪乎人的境界与厚度分三六九等，酒囊饭袋、声色犬马之徒和格物修身之辈的矛盾天然不可调和，兼顾也只是落个礼节。两类人住的完全不是一个地球。 修行人性和顺从欲望的差别就如同猪狗与人的差别。不过区分点并不是爱不爱喝酒，爱不爱做爱这类表面事情。而是观其心。但大家知道想摸透别人的心，得到的只有偏见。唯有观自己的心才是十拿九稳。 观自在，诚意正心，格物致知，修身齐家。 “所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善，而著其善。　人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。” ————《大学》 自己是什么货色伸手便知喽。 **好奇心保证广度，成长保证深度。**深广兼备，博学多才、遍地开花，趣味横生、喜不胜收。 仰观宇宙之大、俯察品类之盛，且歌且行、快雪时晴。 这里说的有些雅了。补一句：懒逼不配幸福，无论精神身体理论实践。一言以蔽之。 颗粒度好奇心和成长属性说了很多。 在两者的趋势下，我们已经建立了不错的认知模型了。接下来的一步呢？ 在健康向上积极自洽的认知地基上，不断的打磨自己，愈加成熟。 “如切如磋，如琢如磨” “君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉” 打磨的本质便是实践。 按孔老的话说，你如果把你想的那些事都大大方方的做出来，你就上道儿了。 修身功夫越深的朋友，他的生活颗粒度会越细。开始刚刚有了信仰的雏形，每天只能付诸于一件事，坚持一两天。慢慢的，能够付诸两件事、三件事，直到生活的方方面面，持续恒久。 这是颗粒度细了，所谓生活精致是也。 干净卫生，摆放有序的人至少能说明一点：在物件规划这件事上，他是极其有功力的。这已经十分宝贵了。 颗粒度粗糙的朋友，会不可避免的在新手期持续打脸。发现自己总是在某个节点失败。 程序员有句话：发现问题是解决问题的一半。 如果你敢于承认自己对待生活的粗糙，那你就已经开始走向了精致。 这个节点极易出现一种神经官能症：即理想与现实的不统一。 这里的理论来自卡尔霍尼的《我们内心的冲突》，极端严重推荐的好书。地基级别思想建构且简单好懂。 简单说就是自己主动打自己的脸。 举个例子： 我可以得到很高的分数，但我就是不学。 我是一个干净人，但我就是不收拾。 我很专一，只是敏感多情而已。 这类朋友的矛盾是很明显的，除了自己以外，基本身边深入接触的人都可以察觉。 但社交距离感决定了其他人没有任何义务指明你的缺点。最好的修正方式是自我革命，即自己针对自己的纠察反省审视总结。 奥，遇到指正你缺点的朋友多加珍惜吧。当然，他甚至可能是你的“敌人”。 当你不断反思和进步，你的生活会不可避免的精致起来。 就像一栋结实的房子，不断装修、翻新、收拾，理所当然变得更加宜居。 **醉心理论甚至幻想，心有余温而不实行是成长的大忌。**诸位共勉。 一些典型语录： “不在意这些细节” “可以做但没必要” “状态不好以后再说（然后没下文）” 这里还可以补充一个知乎博主9qadg(john hexa)的文章：（较真这种性格好吗？在什么情况下需要较真？- q9adg的回答 - 知乎）https://www.zhihu.com/question/27111858/answer/2588179268奥对了，对一些事情较真是雕琢颗粒度的表现 这里可以引申另一个话题，什么时候较真什么时候不较真。 但能判断不较真是最好的解决方案的前提是，你较真过“啥时候不较真”这个问题。 较真才是能力的分水岭。 甚至较真后的结果是躺床上。这些无所谓。只要判断合理。 有始有终。没有开始，何来最终？有了开始，请用心走到终点。 走路就是实践啦。 前方坦途，诸位慢走。 敏锐如果具备前文的好奇心和成长意识。 并且已经不但打磨了自己的生活颗粒度的话：你将在颗粒度高的这个方向，有远高于常人的敏锐性。 那回归到一个人身上，表现出了即为气质 到这一步，长时间雕琢于一件爱好的气质已经藏不住了，你身上的方方面面都会被你常常做的事情所熏陶，形成一种文化气息。这种看不清、摸不着但“触目所及”的东西就是文化啦。 那文化有哪些表现形式呢？ 歌曲背后的风格、节奏、编曲、乐器； 画作背后的背景、创作心态、技法； 美食背后的营养、步骤、选材； 衣服背后的面料、量裁、版型； … 文化背景有了，交织起来，你这个人不就鲜活了吗？ 一个人的体态、神态、心态会合力展示出此人的生活状态。 这里的合力就像物理不同方向不同大小的力作用到同一件物品上的最终呈现。 这也是磁场相同的人互相吸引的原理。 有了文化底蕴，你也能从根本上避免媚俗这件事。 弱者才会本能的寄希望于依附更强大的力量。 弱：指文化属性上的弱，或者说精神力的弱小。无褒贬含义，乃必经之路。 孔老讲话了：“己欲立而立人，己欲达而达人” 强大自我没错的。 从这个角度来看，处于“认识你自己”阶段的朋友，个性一点是无可厚非的啦，开心就好。 只要不违法乱纪、不波及他人、不伤害生命健康。 所以无论如何： 敏锐是建立在兴趣与爱好之上的生活的人，本身的一种很自然的表现。 此处的延伸话题：痛苦挫折之上的趣味怎样发觉？（暂不赘述） 你会对所有事物感兴趣，眼睛滴溜溜的转，小脑袋瓜里的灵气也会越来越浓。 所谓灵气、天赋当然有靠先天带来，但后天的培养更加重要。相信我。 并且这种东西并不是一成不变的，相反它是随时变化的。 “众人皆是佛” 你的正向思维模型如同“造轮子”一样，不断的推动你进步。你的力量会越来越强大： 表达能力、 沟通能力、艺术理解力、共情能力(情商)、学习接收能力，表现力，精神意志力，体力，思考力，行动力 …… 人生百味。 知行合一 到这里，该表达的已经表达完了。能读到这里是我们两个人的缘分。笔者随时欢迎各位任何形式的沟通，以及沟通之上的挑战、质疑、批评。 最后希望大家能够理论与实践相统一，认识自己，发现自己，爱上自己，最后成就自己。 最后分享一个小心得： 人这一辈子，将始终在不同领域扮演“弱者”。**不要害怕弱小，不要担心无助。**自渡者天渡之，时来天地皆同力。天地有正气，杂然赋流形。希望我们都能在兴趣中探索新的体验，在反思总结中收获成长。 逆境沉淀积累，顺境乘势而上。 “ 惟江上之清风,与山间之明月,耳得之而为声,目遇之而成色,取之无禁,用之不竭,是造物者之无尽藏也 。” 最后用教员的话结尾吧: “1917年4月，毛泽东在《新青年》发表《体育之研究》一文，其中论及“体育之效”时指出：人的身体会天天变化。目不明可以明，耳不聪可以聪。生而强者如果滥用其强，即使是至强者，最终也许会转为至弱；而弱者如果勤自锻炼，增益其所不能，久之也会变而为强。因此，“生而强者不必自喜也，生而弱者不必自悲也。吾生而弱乎，或者天之诱我以至于强，未可知也”。 “","tags":["随笔","成长"],"categories":["认知"]},{"path":"/more/index.html","content":"𝐹𝒶𝓃𝒸𝓎 𝒵𝒽𝒶𝓃𝑔简介运动阅读音乐一个人的内在的价值感和意义感是无法被灌输的，只能在一步步的践行中亲身体悟。本站是@fancy的个人站，博主目前刚刚考完研，在家中准备发展自己的爱好，同时继续保持学习状态，发展自己的技术栈。无论是费曼学习法还是通过写作梳理自己、认识自己的需求，输出已经是我离不开的生活方式。从说说、qq空间私密日志、微信公众号到个人网站，博主的写作需求和文字也渐渐随成长的足迹堆叠了成一条清晰可见的路……非常热爱运动，喜欢的品类很多。最喜爱篮球和跑步，在学游泳和羽毛球，最希望自己的身体能够在功能性、柔韧、核心力量的发展中达到一种自然的协调。生而强者如果滥用其强，即使是至强者，最终也许会转为至弱；而弱者如果勤自锻炼，增益其所不能，久之也会变而为强。因此，“生而强者不必自喜也，生而弱者不必自悲也。吾生而弱乎，或者天之诱我以至于强，未可知也运动乃是我生命力的源泉，是我勤加思考背后的燃料，是我得以亲近这个世界的一个不可或缺的角度。豆瓣ID：211783344 (FancyIsNotPig)书名推荐指数介绍The Inner game of tennis★★★★★从运动心态切入，由术入道！《论语》《大学·中庸》《道德经》★★★★★我的精神地基级读物，每年都要看小镇喧嚣★★★★★办公室入门书，涨知识了！不原谅也没关系★★★★☆解决我考研时情绪闪回的宝藏书。我们内心的冲突★★★★☆心理学入门第一本书。稻盛和夫的人生哲学★★★★☆告诉了我何为踏实，何为做事。人类简史★★★★☆洞察所有包装叙事背后的目的。沧浪之水★★★★☆放下面子，融入规则体系，内外统一。邓小平时代★★★★★政治入门书，打开了新世界。喜欢唱歌。喜欢听歌。梦想是能自己掌握乐器，和大家共同感受音乐的魅力。民族的，传统的，红色的，流行的，古典的，世界的……梁博万能青年旅店David TaoAdele邓丽君Nujabes 伍佰ColdplayKanye WestWestlife罗大佑Carpenters Eaglesハンバート ハンバート蓝色多瑙河逛新城(西藏民歌)姑苏行(俞逊发)走西口(龚琳娜)网易云音乐ID：309174330文章项目微信公众号csdn知乎留言 儿时 高三 知足常乐，难得糊涂。 我认为的： 最好的境界：忘记时间，忘记过去和未来。 最酷的状态：平静而有价值感。 忘记并非回避，无视；而是直面，接受。 不评价，无差别，投入做事而不外求。 nonjudgemental resilience 知行合一 即兴赋诗一首 专气致柔，能如婴儿乎？涤除玄鉴，能无疵乎？众人熙熙，如享太牢，我独泊兮其未兆。沌沌兮如婴儿之未孩；傫傫兮若无所归。知止而后有定，定而后能静，静而后能安，然后能虑。众人皆有余，而我独若遗。无他，修身齐家治国平天下。愚人有足乐者不足为道也。Fancy2026/1/28 一些很有感触的句子：1.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先，外其身而身存。非以其无私邪？故能成其私。2.以瓦注者巧，以钩注者惮，以黄金注者殙。其巧一也，而有所矜，则重外也。凡外重者内拙。 好了歌注曹雪芹陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说什么脂正浓，粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛，昨怜破袄寒，今嫌紫蟒长。乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳！清节选 如何联系博主 QQ：1415455617 Wechat：childlikeflow 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎在对应的文章下面留言互动一下。"},{"path":"/about/index.html","content":"𝐹𝒶𝓃𝒸𝓎 𝒵𝒽𝒶𝓃𝑔简介运动阅读音乐一个人的内在的价值感和意义感是无法被灌输的，只能在一步步的践行中亲身体悟。本站是@fancy的个人站，博主目前刚刚考完研，在家中准备发展自己的爱好，同时继续保持学习状态，发展自己的技术栈。无论是费曼学习法还是通过写作梳理自己、认识自己的需求，输出已经是我离不开的生活方式。从说说、qq空间私密日志、微信公众号到个人网站，博主的写作需求和文字也渐渐随成长的足迹堆叠了成一条清晰可见的路……非常热爱运动，喜欢的品类很多。最喜爱篮球和跑步，在学游泳和羽毛球，最希望自己的身体能够在功能性、柔韧、核心力量的发展中达到一种自然的协调。生而强者如果滥用其强，即使是至强者，最终也许会转为至弱；而弱者如果勤自锻炼，增益其所不能，久之也会变而为强。因此，“生而强者不必自喜也，生而弱者不必自悲也。吾生而弱乎，或者天之诱我以至于强，未可知也运动乃是我生命力的源泉，是我勤加思考背后的燃料，是我得以亲近这个世界的一个不可或缺的角度。豆瓣ID：211783344 (FancyIsNotPig)书名推荐指数介绍The Inner game of tennis★★★★★从运动心态切入，由术入道！《论语》《大学·中庸》《道德经》★★★★★我的精神地基级读物，每年都要看小镇喧嚣★★★★★办公室入门书，涨知识了！不原谅也没关系★★★★☆解决我考研时情绪闪回的宝藏书。我们内心的冲突★★★★☆心理学入门第一本书。稻盛和夫的人生哲学★★★★☆告诉了我何为踏实，何为做事。人类简史★★★★☆洞察所有包装叙事背后的目的。沧浪之水★★★★☆放下面子，融入规则体系，内外统一。邓小平时代★★★★★政治入门书，打开了新世界。喜欢唱歌。喜欢听歌。梦想是能自己掌握乐器，和大家共同感受音乐的魅力。民族的，传统的，红色的，流行的，古典的，世界的……梁博万能青年旅店David TaoAdele邓丽君Nujabes 伍佰ColdplayKanye WestWestlife罗大佑Carpenters Eaglesハンバート ハンバート蓝色多瑙河逛新城(西藏民歌)姑苏行(俞逊发)走西口(龚琳娜)网易云音乐ID：309174330文章项目微信公众号csdn知乎留言 儿时 高三 知足常乐，难得糊涂。 我认为的： 最好的境界：忘记时间，忘记过去和未来。 最酷的状态：平静而有价值感。 忘记并非回避，无视；而是直面，接受。 不评价，无差别，投入做事而不外求。 nonjudgemental resilience 知行合一 即兴赋诗一首 专气致柔，能如婴儿乎？涤除玄鉴，能无疵乎？众人熙熙，如享太牢，我独泊兮其未兆。沌沌兮如婴儿之未孩；傫傫兮若无所归。知止而后有定，定而后能静，静而后能安，然后能虑。众人皆有余，而我独若遗。无他，修身齐家治国平天下。愚人有足乐者不足为道也。Fancy2026/1/28 一些很有感触的句子：1.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先，外其身而身存。非以其无私邪？故能成其私。2.以瓦注者巧，以钩注者惮，以黄金注者殙。其巧一也，而有所矜，则重外也。凡外重者内拙。 好了歌注曹雪芹陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说什么脂正浓，粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，转眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛，昨怜破袄寒，今嫌紫蟒长。乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳！清节选 如何联系博主 QQ：1415455617 Wechat：childlikeflow 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎在对应的文章下面留言互动一下。"},{"title":"Vim 学习笔记","path":"/wiki/NOTE/Vim 学习笔记.html","content":"Vim 学习笔记 b站用户：木羽寻清 vim普通模式的理念是：移动和操作移动：就是光标移动，快速定位光标操作:操作后接范围，这个范围①以当前光标为起点，以一次移动为终点。②可以以文本对象作为范围文本对象：官方定义为双引号“”，单引号’’，大括号{}小括号【】等里面的内容。文本对象才是能极大提高编辑速度的关键，我们首先要搞清楚vim可以解决的文件编辑问题:一个文件对于操作系统是最小的单位，对于里面的字符却是最大的单位。我们可以将整个文件逐级分割来更准确的编辑:屏幕、段落、行、单词、字符。我们的上下左右hjkl对应的是字符级。e，w，b对应单词级。$，0，f对应行级。{}对应段落级。反正随你怎么分，只要能理解这些都是文本对象就好，文本对象可以确定操作范围 三种模式：普通模式、命令模式、文本编辑模式、可视模式。 h j k l 普通模式下的文本移动键。 输入一个数字，再按移动键，可以跳行。 比如 4j 是向下跳4行。 w 键可以跳到下一个单词的开头，b 键跳到上一个单词的开头 双击 G ：回到最上方，对应home键 大写的G：回到最下方，对应 end 键 Ctrl+U Ctrl+d ：Page Down 向下翻页 单击 f ：寻找键。 f + 字母：寻找到最近的字母开头的单词位置。 单击 y：复制 yaw: yank all word ，复制整个单词 y4j: 复制下 4 行的内容 yfr：复制到 r 为止的内容 单击 p：粘贴 单击 d：删除 delete 单击 u：撤销 undo 单击 i：光标之前输入 单击 a: 光标之后输入 单击 c：change caw:删除光标所在处的词并进入编辑模式 cc删除这一行并进入编辑模式 按 v 进入可视模式"},{"title":"OKR & 日常","path":"/life/index.html","content":"OKR O1 2026年的小目标：执行>空想。 多多收集数据集，拿机器学习练自己。 正常 54% KR0 观自在：不附加多余的意义。 很多时候我把一个普通的事情夸张化了。把所谓的失误放大然后惩罚自己。这是所谓“超我”的心理机制，是不长久的内耗调节方式。抱抱你，请走吧。 已完成 100% KR1 自然睡眠，内务清爽。 摆脱睡眠焦虑。晚睡没关系，午睡也挺好。每日八段锦+单杠立马整理内务，想到立马去做，否则不想。 正常 50% KR2 适量运动，一定不要急功近利。运动的前提是平和。 前提：跑步，跳绳，或者跳有氧操。核心力量下肢俯卧撑 + 平板支撑 + 死虫下肢——[力量 稳定 速率] 延期 30% KR3 主线任务：学习。 离散数学英语演讲算法设计WebServer 风险 12% KR4 日记，阅读 / 写作，剪辑视频。 未完成 78% 修养心性 经历了在机构中备研的洗礼，我深知自己身上有很多不足，尤其是有一些课题我还在有意无意的逃避。但我深信，我会在一次又一次的跌倒中爬起来，慢慢的成为一个圆融的人。 生存欲：害怕不确定，不安全感需要继续修炼心力，在不危及现实生命健康的情况下勇敢挑战任何想做的事。手脚懒惰至极只说不做，只计划不执行，幻想占据大部分精力。稍微做了一点就急功近利，有始无终。嘴比脑子快CPTSD完美主义+内在批判者(自我客体化)+情绪闪回。 最近的照片"},{"title":"Crash Course CS","path":"/wiki/NOTE/Crash Course CS.html","content":"二进制byte 在电脑中的单位换算： kilobyte 千字节megabyte 兆字节gigabyte 千兆字节 1kb2^10^bit 1024byte 1000b 1Mb 2^20^bit 1024kb 1Gb 2^30^bit 1TB1000GB 1GB十亿字节1000MB10^6KB Gb 和 GB 一般而言GB用于文件，Gb用于通信。B代表Byte，b代表比特bit，两者是八倍的关系。如果考虑到通信过程中的校验码等信息，这个实际关系差距是在十倍。 1GBps的传输速率＝ 8Gbps 100MBps ＝ 800Mbps 运营商所谓的百兆宽带，千兆宽带，也都是b结尾。百兆宽带，实际上只有12.5MB每秒的文件传输速度。 32 位与 64 位电脑的区别 32 位的最大数为 43 亿左右 32 位能表示的数字：0——2的32次方-1，一共2的32次方个数 64 位的最大数为 9.2*10^18 浮点数（Floating Point Numbers）： 定义：小数点可在数字间浮动的数（非整数） 表示方法：IEEE 754 标准下 用类似科学计数法的方式，存储十进制数值 浮点数有效位数*指数 32 位数字中：第 1 位表示正负，第 2-9 位存指数。剩下 23 位存有效位数 eg.625.90.6259（有效位数）*10^3（指数） 美国信息交换标准代码-ASCⅡ，用来表示字符 1 全称：美国信息交换标准代码 2 作用：用数字给英文字母及符号编号 3 内容：7 位代码，可存放 128 个不同的值。 4 图示： UNICODE，统一所有字符编码的标准 1 诞生背景：1992 诞生，随着计算机在亚洲兴起，需要解决 ASCⅡ不够表达所有语言的问题。 为提高代码的互用性，而诞生的编码标准。 2 内容：UNICODE 为 17 组的 16 位数字，有超过 100 万个位置，可满足所有语言的字符需求。 算术逻辑单元 ALU背景 表示和存储数字是计算机的重要功能，但真正的目标是计算，有意义的处理数字 —— 比如把两个数字相加。 这些操作由计算机的”算术逻辑单元”处理，即ALU（Arithmetic and Logical Unit）。 ALU即计算机里负责运算的组件。 Intel 74181 ：1970 年发布时，它是第一个封装在单个芯片内的完整 ALU。 本章我们用前面的布尔逻辑门，做一个和 74181 功能一样的 ALU 电路。 介绍 ALU有2个单元： 算术单元(Arithmetic Unit) ：算术单元负责数字操作 逻辑单元(Logic Unit) ：逻辑单元执行逻辑操作 算术单元算术单元负责计算机里的所有数字操作 像加减法，还有增量运算（给某个变量+1） 实现加减法可以用单个晶体管一个个拼，做成电路。但那太麻烦了，这里用更高层的抽象，即逻辑门来做。 逻辑门有： AND 、OR、XOR、NOT 半加器 通过观察单个1和0之间的运算，发现异或可以满足前三个输入输出，第四个1+1的输出需要进位。 所以需要一根额外的进位线。让组件满足只有输入是1和1时，进位才是“True”。 发现这个条件，AND 门刚好能满足。于是加入电路中，组成半加器。 半加器：个人理解，完成加法的一半，也就是一位的运算以及进位。 多位计算需要全加器。 全加器 将半加器抽象为名为 HALF ADDER 的单独组件，进行更高层抽象：处理超过1+1的运算，需要全加器。 全加器表格： 最大的数是1 + 1 +1 ，总和是1，进位也是1 。 即两条输出线：SUM CARRY。 利用半加器组装全加器。 先输入A+B到一个半加器上，然后把C输入到第二个半加器上。最后用一个OR门检查进位是不是True。 8位加法器 把全加器进行更高一层抽象，也就是作为一个独立组件 Full Adder，三个输入 ABC，输出总和和进位。 前两位数A0、B0的加和用一个半加器 Half Adder 就好。因为前两位肯定没有进位。 A0和B0 的和即 输出的第一位。 将两者的进位，作为全加器的一个输入A。而输入B、C则是第三、第四位数据A1、B1的加和。 第三位开始有进位了。 然后将A1和B1的进位连接到A2和B2的输入A中，如此循环往复…… 注意每个进位是怎么连到下一个全加器的，所以叫“8位行波进位加法器(8-bit ripple carry adder)。 如果最后两位加和后还有进位，就不需要连接了。 因为出现了 溢出 Overflow 现象，8位已经不足以表示更高位的结果了。 这种加法器的缺点： 表达的位数越多，需要的全加器越多。 每次进位都要一点时间，虽然因为电子移动很快用不了多少时间，但还是承受不了当今几十亿次运算的量级。 所以，现代计算机用的加法电路有点不同：使用的是更快的超前进位加法器Carry-Look-Ahead Adder 。 ALU的算术单元也支持做一些其他的运算，一般都支持这8个操作： 加法、带进位加法、减法、带进位减法， 增量、减量：+1，-1 PASS THROUGH：All bits of A are passed through unmodified NEGATE：A is subtracted from zero, flipping its sign(from-to +,or +to -) 简单ALU不会专门为加法减法设计，而是通过循环加法或循环减法来实现。 例如电视遥控、恒温器、微波炉 有些ALU为了运算速度，会有专门的乘除法ALU。只是需要的逻辑门更多。 电脑、手机。 逻辑单元逻辑单元执行逻辑操作。 例如AND，OR 和 NOT 操作，或者一些简单的数值测试：是不是负数？ 示例：下面是一个检查输出结果是不是负数的电路。 以上即ALU的全部内容。 值得一提的是，Inter 74181 只能处理4位输入。所以你刚刚做了一个比 74181 还好的 CPU！ 74181 用了大概 70 个逻辑门，但不能执行乘除,但它向小型化迈出了一大步。 工程师在使用ALU时，不需要理解ALU内部构造。所以用一个大V字来表示。 图中的8位ALU有两个8位输入。通过操作代码OPERATION CODE来告知ALU将进行哪种操作。 例如，1000代表加法，1100代表减法。输出结果也是8位。 好了。你已经掌握了ALU的大致内容了，也能够了解计算机里一批批单晶管是怎样协作运算数据的。 但制作一个CPU不仅要会运算，还要能记忆。 下一章我们将学习存储功能的实现。 寄存器内存ALU能执行算术(Arithmetic)和逻辑(Logic)运算，ALU 里的 A 和L因此得名。 但是结果算出来不能仍掉，还需要找地方存储。这就需要内存了。 前置知识 只能存 0 的ALU。 只能存 1 的ALU。 两个合体，变成锁存器：能存储 1 0 的ALU。 锁存器 门锁 和锁存器区别： 锁存器的“RESET复位”还不能达到“是否允许写入”的要求。 例如 : Set 为1 时，Reset 的改变会导致结果的改变。而门锁就能避免这种情况。 下面两次取反： 数据输入不变，改变允许写入时，结果不变； 数据输入改变，允许写入为 0 时，结果不变； 数据输入改变，允许写入为 1 时，结果改变； 实现了“只有允许写入改变为1后，数据输入的改变才有效。” 其他情况结果不变：如允许写入线改变，允许写入线为 0 时的数据输入改变。 所以从命名也可以看出来： Reset 复位 可以看成是重置输出为0，且锁定为0； WRITE ENABLE 允许写入 自身的改变不影响输出，只影响数据的输入是否改变输出。 这里也能看出下面两个连续取反的ALU的意义： ①当允许写入为0，结果锁定； ②当允许写入为1，数据输入为1，结果为1；数据输入为0，结果为0。 一个门锁只能存1bit数据。8个并列的门锁能存储8位的信息。 一组这样的锁存器就是寄存器。 寄存器能存一个数字，这个数字有多少位，叫”位宽。 早期电脑用 8 位寄存器，然后是16 位，32 位。如今许多计算机都有 64 位宽的寄存器。 我们可以用一根线连接所有”允许输入线”，把它设为 1。 接着用8 条数据线发送数据，然后将“允许写线”设回0。 这样，一个8位信息就被记录好了。 矩阵 但很显然，上面那种并排门锁的8位寄存器还远远不够用。64 位寄存器要 64 根数据线，64 根输出线，还有一根允许输入线。这样加起来也有129根。如果存 256 位要 513 条线。 解决方法就是矩阵。 通过“门锁矩阵”能节省很多线，表达更多的位数。 “12行 8列”可以写成 11001000 例如 16x16 256 位，只需要 16 根行线 + 16 根 列线 + 1根数据线 + 1根允许输入线 + 1根允许读取线 35 根线。 256个门锁构成 256-bit 寄存器，但八个输入接口通过十六位多路复用器(multiplexer)，每次只能激活其中一个门锁。也就是一次只能存储256位中的一位，不能并行处理了。 两个多路复用器分别处理行和列。 把上面的能表示256位的内存抽象成 “256-BIT MEMORY”。通过8个内存并列实现8位数字的存储。 为了实现8位数字的存储，数字的每一位依次由其中一个256-BIT 内存存取。 由于每个内存只能表示一位，所以我们同时给 8 个 256 位内存一样的地址，让他们各取一位就好了。 这意味着这里总共能存 256 个字节(byte)。 256 bit x 8个 256 byte 一个8位的二进制数分别被写入到8个内存的同一二进制位来记录，8个256位内存则可以存储256个8位二进制数。 或者说，一byte的数据分八bit存八个memory里面，读写时地址共用（8个register 都是同一二进制位），就到一起了 再次抽象，不看作是一堆独立的存储模块和电路，而是看成一个整体的可寻址内存。 这就构成了一个能存储 256B 的内存条。 实例： 这是一条真的内存，上面焊了8个内存模块。 打开其中一个，然后放大： 可以看到32个内存方块。 放大其中的一个方块，可以看到还有4个小块。 四个小块再放大，就可以看到矩阵了。 这个矩阵是128位x64位，总共8192位。 每个方格 4 个矩阵，所以一个方格有 32768 个位(8192x432768) 每个内存模块32个方格，所以一个内存模块大约有 100 万位。 RAM有8个内存模块，所以大概能存储800万位。 800万位大概1MB左右吧。 1GB的内存，能存数十亿字节。 我们用锁存器做了一块 SRAM(静态随机存取存储器)。还有其他类型的 RAM，如 DRAM，肉存和 NVRAM。它们功能上相似，但用不同电路存单个位。比如用不同的逻辑门，电容器，电荷捕获或忆阻器（logicgates,capacitors, charge traps, or memristors.） 但根本这些技术都是矩阵层层嵌套，来存储大量信息 就像计算机中的很多事情，底层其实都很简单，难以理解的只是一层层的抽象。 CPU 中央处理器指令程序由一个个操作，也就是指令构成。 数学指令，CPU会让ALU进行数学运算 内存指令，CPU会和内存通信，然后读写值 通过指令表可以了解到指令名、对应描述、4位操作码和需要的地址寄存器。 也就是说，计算机给CPU支持的所有指令都分配一个ID，实现区分。 本例中指令的前4位为操作码(opcode)，后4位代表数据来自哪里。 CPU结构下面CPU结构中的线只是所有必须线路的抽象，即“微体系架构(microarchitecture)” CPU内部划分为三大板块：运算器、控制器、存储器。（冯诺依曼结构）下面的例子中，ALU扮演了运算器，RAM和四个数据寄存器则扮演了存储器。控制器由控制单元CU以及两个控制寄存器扮演。 示例中的地址有一个16位置，每个位置能存8位的内存，还有四个8位寄存器。 还有两个帮助操作的寄存器，一个追踪程序运行地址的指令地址寄存器PC，一个存当前指令的指令寄存器IR。 当启动计算机时，所有寄存器从0开始。 运行命令CPU的运行共三个阶段：取指令、解码、执行。 以LOAD_A 为例: Read RAM location into register A 取指令阶段：本阶段负责拿到指令 将 指令地址寄存器 连接到 RAM 。 寄存器地址值为0，因此 RAM 返回地址 0的值。 可以看到地址0的数据 00101110会复制到 指令寄存器 里 解码阶段：解释指令内容 前4位0010是 LOAD A 指令。通过指令表可知，能将RAM的值放入寄存器A。 后4位1110是 RAM 的地址，十进制为14. 区分指令内容后，由控制单元（Control Unit） 解码，识别指令，检查操作码。 控制单元同样由很多逻辑门组成。(不是很多啦)。 控制单元指挥着CPU的所有组件 执行阶段 用控制单元中”检查是否是 LOAD A 指令的电路”，可以打开 RAM 的允许读取线，把地址 14 传过去。RAM 拿到值，0000 0011，十进制的 3。 因为是 LOAD_A指令，所以把读取到的值 3 只放到寄存器 A ，其他寄存器不受影响。 此时问题来了：需要一根线，把 RAM 连接到4个寄存器，让我们传值过去！ 还是用控制单元中”检查是否是 LOAD A 指令的电路”，连接启动寄存器A的允许写入线。 于是把 14 放到了寄存器A中，LOAD_A 14 指令执行完成 收尾：关掉所有线路，去拿下一条指令（也就是指令地址寄存器+1) 以ADD为例：Add two registers , store result into second register. 取指令: 指令地址寄存器指向2,读取 10000100到指令寄存器中。 解码： 前四位 : 1000 ADD命令 后四位 : 0100 , 01 为寄存器B，00为寄存器A。 通过控制单元，解码，识别指令，检查操作码。 执行：把 register B的值加到 register A 中。 启动寄存器B，作为ALU的第一个输入；启动寄存器A，作为ALU的第二个输入。 ALU可以执行不同操作，所以控制单元必须传递ADD操作码告诉它要做什么 最后，结果存到寄存器A。 **注意:**不能直接写入寄存器A，因为寄存器A此时正在作为输入，写入后新值会进入ALU，导致A不断和自己相加。 因此，控制单元用一个自己的寄存器暂时保存结果，关闭ALU，然后把值写入正确的寄存器。再由寄存器赋值到寄存器 A。 收尾：关掉所有线路，去拿下一条指令（也就是指令地址寄存器+1) 以store A 为例：Write from register A into RAM location 取指令: 指令地址寄存器指向3,读取 01001101到指令寄存器中。 解码： 前四位 : 0100 STORE A 指令 后四位 : 1101 , 01 为寄存器B，00为寄存器A。 通过控制单元，解码，识别指令，检查操作码。 执行： 把地址传给RAM，这次不是允许读取，而是允许写入。 同时打开寄存器A的允许读取，这样可以把寄存器A的值传给RAM。 完成了！ 总结： 1.通过上例可以了解，CPU运行指令，通过RAM和寄存器之间的数据传输，以及控制单元和ALU的检验、运算，从而完成一次操作。 2.RAM有配合控制单元的 允许写入线、允许读取线、地址输入线； 还有配合数据寄存器以及指令寄存器的 DATA 线。 寄存器也有允许写入线、允许读取线。 时钟时钟负责管理CPU的节奏，区分每一步操作。 时钟以精确的间隔触发电信号，控制单元会用这个信号，推进 CPU 的内部操作，确保一切按步骤进行。 CPU”取指令一解码一执行”的速度叫 时钟速度。 单位是赫兹。 赫兹是用来表示频率的单位。1 赫兹代表一秒1个周期 超频： 意思是修改时钟速度，加快 CPU 的速度。芯片制造商经常给CPU 留一点余地，可以接受一点超频。但超频大多会让CPU 过热，或产生乱码，因为信号跟不上时钟。 降频: 有时没必要让处理器全速运行。把 CPU 的速度降下来，可以省很多电。 为了省电，很多现代处理器可以按需求 加快或减慢时钟速度，这叫动态调整频率。 高级CPU设计 从前面几章，我们从一秒一次的运算，到现在有千赫甚至兆赫CPU。现在的单位是GHz，1秒10亿次运算。多么大的计算量！ 为 CPU 提升速度早期计算机到现代计算机厂商和科学家们发明了各种新技术来提高性能。 减少晶体管切换时间 早期提速的方式便是减少晶体管的切换时间，使晶体管组成了逻辑门，ALU 以及前几集的其他部件。 这种提速方法会遇到瓶颈。于是处理器厂商不仅让简单指令运行更快，还让它能支持更复杂的运算。 利用复杂电路实现算法 例如除法和乘法需要程序多次运行减法和加法，为了省去循环的功夫，现代 cpu 直接在硬件层面上设计了除法等复杂电路以节省某些运算。这让ALU更大更复杂，但也加快了运行速度。 复杂度和速度的矛盾一直存在。 举例，现代处理器有专门电路来处理图形操作，解码压缩视频,加密文档 等等。如果用标准操作来实现，要很多个时钟周期。 某些处理器有 MMX, 3DNOW, SSE，他们就拥有额外电路用于处理游戏和加密等场景。 随着指令不断增加，为了兼容旧指令集，指令数量越来越多。 英特尔4004,第一个集成CPU，有 46 条指令,足够做一台计算机。 现代处理器有上干条指令和更多巧妙复杂的电路。 给 CPU 增加缓存 超高的时钟速度带来另一个问题：如何快速传递数据给 CPU？ 就像有强大的蒸汽机 但无法快速加煤。 RAM成了瓶颈。RAM 是 CPU 之外的独立组件，意味着数据要用线来传递，叫”总线“。总线就几厘米，而电信号传输接近光速。 但CPU每秒可以处理上亿条指令，两者执行任务的速度还是过于悬殊。一条”从内存读数据”的指令可能要多个时钟周期，CPU只能苦苦等待。 RAM 是 CPU 之外的独立组件，通过总线 (Bus) 传递数据，为了避免数据传输带来的延迟，解决的方法是为 CPU 增加一点RAM作为缓存。 读取时 RAM 将一批数据提前传入 CPU 缓存，这样处理的时候 CPU 直接从离得近的缓存中获取数据就比从 RAM 中获取数据要快。 处理器空间不大，缓存一般只有KB或MB。 于是数据传输单位从一个变成了一批。 缓存命中 如果想要的数据已存在缓存中则叫做缓存命中，否则叫做缓存未命中。 同步更新： 缓存也可以作为临时空间存储一些运算过程中的中间值，适合长 复杂的运算。但是计算完后的值想要存储会先存入缓存中，而缓存中的值可能还有运算的中间值导致缓存和 RAM 内数据不一致，因此缓存里的数据要对 RAM 里的数据进行同步更新。 脏位： 对此缓存里的每块空间都有一个叫做脏位的标记声明该数据是否修改过。同步更新一般是发生在缓存满了，又需要缓存时。这时会检查缓存中的脏位，如果是脏的就将数据写回 RAM 中。 另一种提升性能的方法：instruction pipelining 指令流水线。 可以通过不同的指令运行方式以提升 CPU 速度。 顺序串行执行 严格按照顺序上一条命令结束才执行下一条命令 顺序并行执行 在上一条指令执行时就处理下一个指令的解码步骤，下下条指令的读取步骤。 乱序执行 第一个问题：指令之间的依赖性 问题举例：在读取的同时，正在执行的指令在改这个数据。 这种情况需要搞清楚数据之间的依赖性，必要时停止流水线，避免出问题。 解决： 高端CPU会通过动态调整，进一步动态排序有依赖关系的指令。最小化流水线的停工时间。这叫乱序执行。 电路复杂，但很高效。几乎每个现代处理器都有流水线。 推测执行 | 分支预测 第二个问题：条件跳转 这些指令会改变程序的执行流。简单的流水线处理器，看到 JUMP 指令会停一会儿，等待条件值确定下来。但空等会有延迟。所以高端CPU会用一些技巧： 解决： 遇到岔路口时，猜测 JUMP 指令走哪条路的可能性更大一些，然后提前把指令放进流水线，这叫“推测执行。 猜对了可以直接执行，猜错则要清空流水线（就像走错路掉头）。 为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法来猜测：分支预测。 现代 CPU 的正确率超过 90%！ 超标量处理器SUPERCALAR PROCESSOR 理想情况下，流水线一个时钟周期完成1个指令。 即便有流水线设计，在指令执行阶段,处理器里有些区域还是可能会空闲。 比如，执行一个“从内存取值”指令期间，ALU会闲置。 所以一次性处理多条指令(取指令+解码) 会更好,如果多条指令要 CPU 的不同部分，就多条同时执行。 借助超标量处理器SUPERCALAR PROCESSOR 一次性处理多条指令 (类似多线程)。为出现频率很高的指令加多几个相同的电路，ALU 执行。 目前说过的方法，都是优化1个指令流的吞吐量。 另一个思路是运行多个指令流，也就是多核处理器。 CPU 芯片内的多个独立处理单元 (多核) 就像有多个 CPU 能够合作运算 (共用一个 CPU 的缓存)。如果多核还不够就用多个 cpu。 集成电路 在大概50年里，软件从纸带打孔变成面向对象编程语言，在集成开发环境中写程序，没有硬件的大幅度进步，软件不可能做到这些。 回到电子计算机的诞生年代： 电子管大约 1940年代~1960年代中期这段时间里 ， 计算机都由独立部件组成。 这些独立部件叫”分立元件” ，然后不同组件再用线连在一起 举例, ENIAC 有1万7千多个真空管, 7万个电阻 , 1万个电容器, 7千个二极管, 5百万个手工焊点 如果想提升性能，就要加更多部件。 这导致更多电线，更复杂；这个问题叫 “数字暴政’’。 晶体管 1950 年代中期，晶体管开始商业化（市场上买得到） \\N 开始用在计算机里。晶体管比电子管 更小更快更可靠。但晶体管依然是分立元件 1959年，IBM 把 709 计算机从原本的电子管全部换成晶体管。诞生的新机器 IBM 7090 速度快 6 倍，价格只有一半！ 晶体管标志着”计算 2.0 时代”的到来。 虽然更快更小 但晶体管的出现 还是没有解决”数字暴政”的问题。 有几十万个独立元件的计算机不但难设计，而且难生产。 集成电路 1960 年代，这个问题的严重性达到顶点 电脑内部常常一大堆电线缠绕在一起。看看这个 1965 年 PDP-8 计算机的内部： 解决办法是封装复杂性：也就是电路的所有组件都集成在一起。 与其努力把多个独立部件用电线连起来，拼装出计算机，还不如专注于把多个组件包在一起，变成一个新的独立组件。 这就是 **集成电路（Integrated Circuit）**的诞生。 几个月后，在1959年 Robert Noyce 的仙童半导体 ，让集成电路变为了现实。Kilby 用锗来做集成电路，锗很稀少而且不稳定。仙童半导体公司用硅 \\N 硅的蕴藏量丰富，占地壳四分之一，也更稳定可靠。所以 Noyce 被公认为现代集成电路之父，他开创了电子时代，创造了硅谷（仙童公司所在地） 起初，一个 IC 只有几个晶体管。例如这块早期样品，由西屋公司制造： 即使只有几个品体管也可以把简单电路，第 3 集的逻辑门，能封装成单独组件。 IC就像电脑工程师的乐高积木，可以组合出无数种设计。 印刷电路板 PCB Printed Circuit Board 为了解决集成电路仍需通过电路连接制造计算机的问题，工程师们制造了印刷电路板PCB，PCB 可以大规模生产而无需焊接或用一大堆线，它通过蚀刻金属线的方式将零件连接到一起。 把 PCB 和 IC 结合使用 \\N 可以大幅减少独立组件和电线，但做到相同的功能。 而且更小，更便宜，更可靠. 三赢！ 许多早期 IC 都是把很小的分立元件 \\N 封装成一个独立单元，例如这块 1964 年的IBM样品： 光刻 不过，即使组件很小 , 塞5个以上的晶体管还是很困难。为了实现更复杂的设计，需要全新的制作工艺 \\N “光刻”登场！ 光刻简单说就是把复杂图案印到如半导体等材料上，可以通过这种技术将复杂金属电路印在半导体上面以集成个多的元件制造复杂电路。 光刻机光刻电路的流程： 首先是一块硅 (晶圆)： 硅很特别。它有时导电，有时不导电。我们可以控制利用其特性控制导电时机。 我们可以用晶圆做基础，把复杂金属电路放上面，集成所有东西 。 在硅片顶部加一层薄薄的氧化层,作为保护层。 加一层特殊化学品，叫”光刻胶”。 光刻胶被光照射后 会变得可溶。可以用一种特殊化学药剂洗掉。 把光掩膜盖到晶圆上，用强光照射。挡住光的地方，光刻胶不会变化。光照到的地方，光刻胶会发生化学变化洗掉它之后，暴露出氧化层。 用另一种化学物质·通常是一种酸，可以洗掉”氧化层”露出的部分，蚀刻到硅层。 注意，氧化层被光刻胶保护住了。 为了清理光刻胶，我们用另一种化学药品洗掉它 现在硅又露出来了。我们想修改硅露出来的区域 ，让它导电性更好。 所以用一种化学过程来改变它，叫”掺杂” “掺杂”通常用高温气体来做，比如磷渗透进暴露出的硅，改变电学性质。 但我们还需要几轮光刻法 来做晶体管。 过程基本一样，先盖氧化层，再盖光刻胶。然后用新的光掩膜，这次图案不同。 在掺杂区域上方开一个缺口，洗掉光刻胶，然后用另一种气体掺杂把一部分硅转成另一种形式。 为了控制深度，时机很重要我们不想超过之前的区域。 最后一步，在氧化层上做通道这样可以用细小金属导线，连接不同品体管。再次用光刻胶和光掩膜蚀刻岀小通道。 现在用新的处理方法 叫”金属化”放一民道道的全属，比如铝或铜。 但我们不想用金属盖住所有东西我们想蚀刻出具体的电路。 所以又是类似的步骤：用光刻胶+光掩膜，然后溶掉暴露的光刻胶，暴露的金属 我们可以把光掩膜聚焦到极小的区域，制作出非常精细的细节。 一片晶圆可以做很多IC整块都做完后，可以切割然后包进微型芯片。 微型芯片就是在电子设备中那些小长方体 。 记住，芯片的核心都是一小片IC 芯片放大： 摩尔定律1965 年，摩尔看到了趋势：每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍数量的晶体管。这叫摩尔定律。芯片的价格也不断下降。即集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍 但是摩尔定律现在也在接近极限，进一步做小，会面临两个问题。 用光掩膜把图案加到晶圆上，因为光的波长，精度已经达到极限。 当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，叫量子隧道贯穿效应 控制单元（Control Unit) : 负责程序的流程管理。正如工厂的物流分配部门，控制单元是整个CPU的指挥控制中心，由指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)三个部件组成，对协调整个电脑有序工作极为重要。 控制单元可以作为CPU的一部分，也可以安装于CPU外部。"},{"title":"程序是怎么跑起来的","path":"/wiki/NOTE/程序是怎么跑起来的.html","content":"前言一个小原理 CPU在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指令从内存或IO中把数据输入到CPU中，在CPU内部进行运算，再把运算结果输出到内存或IO中。无论是小型微型计算机，还是个人的高性能计算机，原理都基本相同。 计算机的三个根本基础 计算机是执行输入、运算、输出的机器。 计算机的硬件由大量集成电路 IC(intergrated Circuit) 组成。每块 IC 上都有很多引脚。 无论多么复杂的程序，最终都是由一个个 “输入、运算、输出” 组合出的流程单位实现的。 三者必须成套出现，缺一不可。 程序是指令和数据的集合 指令：控制计算机进行输入、运算、输出的命令。 数据：分两类。一类作为指令执行对象的输入数据，一类是从指令的执行结果得到的输出数据。 计算机的处理方式和人们的思维习惯不同 “汉诺塔”问题 硬件和软件，好比小霸王游戏机和插入游戏机的游戏卡一样。 也可以比作人的肉体和精神。缺一不可，相辅相成。 应用 根据三大原则理解一项“不好理解”的话： 2020年2月14日 微软公司率先提出了作为新一代互联网平台的*.NET*技术。作为.NET核心的XML Web服务使用通用技术SOAP、XML,促使企业间的计算机协同工作。 三大原则的理解： 计算机只是个执行程序的机器，程序是指令和数据的集合。 指令：SOAP是关于调用指令的规范， 数据：XML是定义数据格式的规范， 更方便执行程序：部署在其他计算机上能执行某种运算的程序叫做 XML Web 服务。 TCPIP 网络的简单理解TCPIP：传输控制协议和网际协议：Transmission Control ProtocolInternet Protocol。 LAN ：Local Area Network （局域网）把办公室内的小规模网络称作LAN； WAN：Wide Area Network (广域网) 把互联网一样联结企业和企业的大规模网络叫做WAN。 以家用路由器为例，WAN口连光猫，从而连接到网络。LAN口连电脑之类的电子设备，即有线网络。 MAC : Media Access Control：标识网卡的编号。 几乎所有网卡上市前都分配了一个不可变更的 MAC 地址。 网卡 NIC Network Interface Card ：每一块网卡的ROM（Read Only Memory 只读存储器）里，都预先烧录了唯一的MAC地址。 由制造厂商的编号和产品编号两部分组成，所以独一无二。 服务器 Server ：服务的提供者。 客户端 Client ：服务的利用者。 在服务器上运行的程序为客户端提供服务。 集线器 Hub：把各台计算机的网线相互连接在一起的集线设备。 路由器 Router：把局部区域内的网络和互联网连接起来的设备。 路由器则负责把LAN接入到WAN上：一端连接互联网提供商的路由器，服务商继续将他们的路由器连接到其他地方，直到汇入互联网主干线缆上。 以企业内的LAN为一个基本单位，通过服务提供商的路由器把他们和其他企业的LAN互连起来，共同组成互联网。 光猫 Optical Network Unit，ONU：通常由网络服务提供商提供给用户。它充当了将光纤信号转换为电信号的桥梁，以便我们可以连接到宽带互联网。 光猫通常与光纤入户（FTTH）连接，并将光信号转换为以太网信号，以供我们使用。 IP 地址：MAC地址花样繁多，查找效率太慢。因此必须对计算机进行分组管理，除了硬件上的MAC地址，还需要设定一个软件编号，即IP 地址。 设定好 IP 地址的计算机为 ”主机(Host)“ 。路由器也是计算机，也有IP地址。IP地址的值也是独一无二的。 IP 地址中，把表示分组（LAN）的部分叫做”网络地址“，把表示计算机的部分叫做“主机地址”。 **子网掩码：**标识出 32 byte 的IP地址里，哪一位到哪一位是网络地址，哪一位到哪一位是主机地址。 转换成二进制后，值为1的则是网络地址，值为0的即主机地址。 DHCP ：Dynamic Host Configuration Protocol（动态主机设置协议） 记录着可以被分配到 LAN 内计算机的 IP 地址范围和子网掩码的值 默认网关 Gateway：通常把路由器 IP 地址设置在网关上。可以说 路由器就是从 LAN 通往互联网世界的入口（网关）。 路由器的 IP 地址也可以从 DHCP 服务器获取。 向路由器更进一步路由器是决定数据传输路径的设备。 分组管理下，IP 地址中的网络地址部分能代表一个 LAN 中的全体计算机。 互联网则是路由器把多个LAN连接起来的大网。 路由器的工作原理是查看附加到数据上的IP地址中的网络地址部分。 不属于LAN内计算机的ip地址，会被附加到数据的发送目的地字段上。这会被LAN内计算机忽略，但不会被路由器忽略。 只要不是发给LAN内的，就发送到LAN外。 分布在世界各地的 LAN 中的路由器交换着信息。这种信息叫做“路由表”，用来记录数据应该转发到哪里。 路由器的路由表中只会记录通往相邻路由器的路径，而不会记录世界上所有传输路径。 几条命令： route print #输出路径 该指令将输出五列： Network Destination 网络目标 Netmask 子网掩码 Gateway Interface 接口 Metric 跃点数（权值） 数据发送的目的地 区分网络地址主机地址 路由器IP地址 路由器要转发的目的端口 路径权重，由算法决定选择传输最优路径 如果目的地的IP就在本LAN中，则无需路由器转发，直接到达。 tracert host_name #追踪路由转发过程,主机名是一个网址/计算机名 可以看到互联网服务商到本计算机LAN内的过程。 DNS服务器DNS ：Domain Name System 域名系统。 FQDN ：Fully Qualified Domain Name 完整限定域名：把主机名和域名结合起来的域名。 DNS 如同助记符一样，代替了难以记忆的 IP 地址。DNS 服务器能够自动把 FQDN 解析为 IP 地址（此过程为域名解析）。 DNS 服务器通常部署在各个 LAN 中，里面记录着 FQDN 和 IP 地址的对应关系表。 世界范围内，各个DNS服务器是相互合作的，一台DNS服务器解析不了，就会询问另一台。询问成功后就会存储在本地DNS服务器中。 通常《主机名.域名》即FQDN。 nlookup #询问DNS服务器 默认输出本机 LAN 内的 FQDN 和 IP 地址。 也可以查询其他域名的 FQDN 和IP。 IP 地址和 MAC 地址的对应关系作为被标识为最终接收者的网卡是MAC。 IP地址转换到MAC地址，需要一个程序：ARP（Address Resolution Protocol 地址解析协议） ARP会向所有LAN内计算机广播（broadcast）询问，如果有某台计算机回复了 MAC 地址，则该计算机的 IP 和 MAC 对应明确了。 为提高查询效率，ARP会缓存。缓存构成的表叫ARP缓存表。 arp -a #查询ARP缓存表 TCP 的作用以及 TCPIP网络的层级模型IP 协议：指定数据发送目的地的IP地址 以及通过路由器转发数据。 TCP 协议：通过数据发送者和接收者相互回应对方发来的确认信息，可靠的传输数据。（握手 handshake） TCP协议还有一个规定是先把原始的大数据分割成以“包”（packet）为单位的数据单元，然后再发送。接受者则需要把收到的包重新拼装在一起还原原始数据。 计算机发送的数据，是以包为单位的，附加了各种各样信息的数据。 硬件上发送数据的是网卡，网卡之上是设备驱动程序（控制网卡这类硬件的程序），驱动程序之上是实现了IP协议的程序，IP程序之上是实现TCP协议的程序，再往上才是应用程序。 TCP协议使用TCP端口号识别上层应用程序，并且预先定义好了一些端口用于专门用途。 基本概念的阐述概念： 机器语言：用0和1两个二进制数书写的编程语言。 最贴合硬件。机器语言相同，不同的CPU类型会得到不同的结果。 汇编语言：亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或数字代替指令或操作数的地址 人类所能读懂的，最贴合底层的语言。设备不同，机器语言指令集也不同。 语法：标签，操作码，操作数。 标签为某行代码对应的内存地址起名字。 操作码是 做什么 的指令。 操作数是 指令执行对象。 编译：把 C语言 等编程语言编写的文件（源文件）转换成用机器语言（原生代码）编写的文件。 编码：计算机用数字表示一切。 以字符举例：计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫做“字符编码”。 面向组件编程：通过将组件（程序零件）组装到一起完成程序； 面向对象编程：对现实世界的业务进行建模，再把模型搬到程序中。 IC 卡：IC card。计算机内部主要由各种 IC 元件 组成。 功能各异的 IC 主要有三种：CPU、内存、IO 。 CPU（central processing unit）中央处理器 : 运算数据并控制内存和IO。（解释执行程序内容） 内存：存储指令和数据 IO：负责数据的输入和输出工作。 时钟信号: 含义 是 由内含晶振的、被称为时钟发生器的元件发出的滴答滴答的电信号。 作用 是 作为计时器，保证电子组件同步运作。 单位 是 Hz 频率。即时钟发生器发送给 CPU 的电信号的频率。 把发出一次滴答的时间称作一个时钟周期。 频率大小可以衡量CPU的运转速度。 XML定义xml：Extensible Markup Language 可扩展标记语言 ：用于定义任意标记语言的元语言 html：HyperText Markup Language 超文本标记语言 ：一般用来标记编写网页 把通过添加标签为数据赋予意义的行为称为 ”标记“。为标记定义规则的语言 即标记语言。 html用于编写网页，或者说决定了可用于编写网页的标签。 优势可使用的标签种类决定了标记语言的规范及用途。 web浏览器会对html的标签进行解析，把由它们标记的信息渲染成我们乐于阅读的网页。 XML 的最大优越性便是，其使用者可以随心所欲的创造标签，这也是它作为元语言的根本。 XML 仅仅限定了进行标记时标签的书写格式，其数据是纯文本格式的，只包含字符。 遵循xml约束所写的文件就是xml文件。 现在的web服务器都集成了xml解析器，可以用这个功能来检查xml文件的书写格式。 xml主要用途：为在互联网上交换的信息赋予意义。 W3C的推荐标准是不依赖于特定厂商的通用规范。XML即是一种通用的数据交换格式。 万维网联盟（World Wide Web Consortium，简称 W3C）创建于1994年，是Web技术领域具有权威和影响力的国际中立性技术标准机构。 CSV也是通用的数据交换格式之一。 缺点：因为创造了标签，xml文件的尺寸也往往更大。 结构命名空间 标签名字相同，每个人赋予它的意义并不一定相同。所以一个W3C推荐标准是 XML命名空间（Namespace in XML）。 命名空间通常是一个能代表企业或个人的字符串，用于修饰限定标签的名字。 xmlns=namespace_name 完整的XML文档有三个部分：XML声明、XML实例、DTD（Document Type Definition 文档类型描述） XML声明形如： ?xml version=1.0 encoding=Shift_jIS? XML实例是文档中通过标签被标记的部分 DTD负责定义XML实例的结构 形如： !DOCTYPE xxx[一些格式要求] 可以省略。 解析XML的组件 DOM（Document Object Model，文档对象模型） SAX（Simple API for XML) 分布式计算 SOAP（Simple Object Access Protocol，简单对象访问协议）可用于 分布式计算。 分布式计算：把程序分散部署在用网络连接起来的多台计算机上，相互协作，发挥整体计算能力 调用程序时所需的参数信息 和 程序执行后的返回结果 都可以用通用数据格式 XML 标识。 往往多台计算机协作使用时，XML这种通用传输协议会非常实用。 就好比上大学遇到五湖四海的朋友时，普通话沟通往往最有效率。"},{"title":"script","path":"/wiki/NOTE/script.html","content":"欠缺的知识点（算法不包括在内）： 计算机组成原理： MITS6.004 哈工大网课 135P 《CSAPP》 操作系统： 南京大学网课：计算机系统基础(一)（二） （袁春风） MIT6.S081 MIT 6.828 哈工大网课 32P 新竹清华65P linux ： 兄弟连112p 《鸟哥的linux私房菜》 《linux 高性能服务器编程》 《linux 内核设计与实现》 sql ： 尚硅谷99p视频 + sql题 + sql笔记 黑马程序员 Redis 175p 《High Performance MYSQL》 《MYSQL必知必会》 《mysql是怎样运行的》 计算机网络： 湖科大微课堂73p 《网络是怎样连接的》 CS144网课 《图解HTTP》《图解TCPIP》 《TCPIP网络编程》 编译原理： CS143网课 127P github 项目：tiny-compiler 其他： 《CPP primer》 《STL源码剖析》 STL泛型编程、C++11新特性、内存管理与分析 ； 《深度探索C++对象模型》第三章 《more effective c++》 《大话数据结构》 《大话设计模式》 扩展： 《POSIX多线程程序设计》 《UNIX 环境高级编程》 《UNIX 网络编程》 TiDB数据库，MongoDB 视频 makefile ，CMake CICD 侯捷C++视频《生前死后》 《编译原理》（机械工业） 《操作系统导论》（机械工业） 《计算机网络 自顶向下》 （机械工业） Wireshark 网络分析就这么简单 《TCPIP详解》 《设计数据密集型应用》 《数据密集型应用系统设计 》 欠缺的工具： VIM QT Git Nginx Docker WSL"},{"title":"线性代数3b1b","path":"/wiki/NOTE/线性代数3b1b.html","content":"博客的这个数学语言太难用了，改半天显示不好。 可参考：https://blog.csdn.net/m0_59298585/article/details/142888232 前言： 一个很久之前截的B站评论: @？ 很多人学不懂线代(高代)的原因是，线性代数这门课本质上来说是 具体-抽象-再具体 的回旋过程首先从线性方程组开始讲起，讨论矩阵，方阵的性质然后再由矩阵上升到线性空间上的线性映射线性变换，在研究线性映射和线性变换时又会通过和数域K的联系再具体化到矩阵所以入门学习矩阵的时候，很容易迷失在处处严谨的证明细枝未节里，从而没法把握核心的思路与研究目的; 而矩阵没学好，后面的线性空间更难理解，因为线性空间研究往往是再具体化到矩阵上来进行的 所以我建议朋友们学习高代(线代)的时候，在初期就把这门课当作一门外语来学在矩阵部分对每一条定理每一个命题都把他当作单词吃透当你带着扎实的矩阵功底去接触线性空间的时候，马上如拨云见日般。你也会很快感受到代数学具体抽象再具体的魅力。 @吸猫群众QAQ: 数无形时少直觉，形少数时难入微，数形结合百般好。越学习越惊叹于古人的智慧，三百多年的科学史，孕育出了多少绝妙的思想。想到了年纪轻轻却在数学体系不完善的年代创造出微积分，用古老的几何证明法得出若干现在仍被奉为真理的几大定律，却在晚年困惑于神与世界本质的思辨中的牛顿;还有靠现有的数学工具以及其绝妙的思维创造出广义相对论，以一人之力颠覆了人类对空间和时间这两个玄妙概念的理解，在晚年试图创造出可以解释世界的终极定理却终究敌不过时间的爱因斯坦;还有那些出于对一个奇怪的物理现象的探究，却揭示出一个光怪陆离，极度违背常识，连创始人都无法理解，却又无数次被证实是正确的理论的一众量子力学的奠基人们。人类文明的智慧闪光真的令人叹为观止，或许无尽岁月之后，有足够辨析能力的另一个文明看到或许已经灭绝的人类残存的信息，也会惊叹或惋惜于这个文明曾经的智慧吧。 @卧三： 我所理解的秩，是在某个维度下所固定的条件个数，比方说，三维空间我们有x，z，y三个线性无关的条件，三个条件对应着秩为3，即秩为3时我们可以确定空间的一个点。对应此时我们只有唯一解，即为R(A) n ，假如三维空间中，我们秩为2 即为R(A) n ,我们们只有两个量假设x，y是固定的或者说已知的，此时我们将会有一个平面的点z不确定的点。所以我们将有一个自由变量，即为z方向上的自由变量，我们用一个向量表示这些有的点，则为我们的通解。所以维度 秩（确定的量）+ 基础解系个数(不确定的量) 目录： [TOC] 0.线性代数的“线性” “线性”的严格定义如下若一个变换工满足两条性质：齐次性和可加性。 可加性:$$L(\\vec{v} +\\vec{w}) L(\\vec{v})+L(\\vec{w})$$ 齐次性（成比例）$$L(c\\vec{v}) cL(\\vec{v})$$ 则称L是线性的。 从几何角度看， 将i向量固定，移动 j向量，将形成一条直线； 将j向量固定，移动 i向量，将形成另一条直线； 每次移动向量，都是对应基向量的倍数（成比例），而基向量之间可以相加形成新的向量。 可加、可乘（成比例） 如果固定其中一个标量，让另一个标量自由变化，所产生的向量的终点会描出一条直线。 基向量线性组合的向量的集合，被称为给定向量张成的空间(span) 线性的词源:出于线性方程组。线性方程组在二维情况下，有形如ax+byc的子方程 所谓线性关系，简单地讲就是比例关系，即两个变量按一定的比例增加或减少。 **这种关系若用图形来表示，就是一条直线，故称线性关系。**这种关系若用方程来表示，就称为线性方程 线性代数 这门学科之所以包含“线性”二字，是因为它主要研究的是**向量空间（或称为线性空间）、线性变换以及线性方程组等概念。**这些概念都涉及到线性关系： 1.线性相关可以理解为线性相关意味着停留在这个维度不增维。当一组向量成线性相关时，其中至少有一个向量能由其它向量线性表示 2.基向量空间的一组基的严格定义是这样的:张成该空间的一个线性无关向量的集合。 （向量空间的一组基是张成该空间的一个线性无关向量集） 3.线性变换（劲爆）严格意义上说，线性变换是将向量作为输入和输出的一类函数。 线性变换是操纵空间的一种手段。 它具备两个性质： ①保持网格线平行且等距分布，②保持原点不动。 这两点性质保证了：只要记录下i帽和j帽变换后的位置，你就能计算出一个坐标为(x,y)的向量变换后的坐标。 令人高兴的是，这种变换只需要几个数字就能描述清楚，这些数字就是变换后基向量的坐标。线性变换由它对空间的基向量的作用完全决定。 习惯上，我们将变换后i帽和j帽的坐标作为一个矩阵的列，并且将两列分别与x和y相乘后加和的结果定义为矩阵向量乘积 这样，矩阵代表一个特定的线性变换。而矩阵与向量相乘，就是将线性变换作用于那个向量。 因此**可以将线性变换看作对空间的挤压伸展。**这是因为其他任意向量都能表示为基向量的线性组合。 线性相关时，如果变换后的i帽和变换后的j帽是线性相关的，意味着其中一个向量是另一个的倍数，那么这个线性变换将整个二维空间挤压到它们所在一条直线上。也就是这两个线性相关向量所张成的一维空间。 以这些坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言，而矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。 这里重要的是。每当你看到一个矩阵时，你都可以把它解读为对空间的一种特定变换。 矩阵相乘：两个变化相互作用，即复合变化。这里可以联想复合函数。 这样也可以解释矩阵的两个性质： 不具备交换律 AB ≠ BA 也就是为什么矩阵乘法有严格顺序要求。例如 先旋转、再剪切 和 先剪切、再旋转是不同的。 具备结合律 A(BC) 和 (AB)C 三个线性变化的相对顺序不变， 线性代数中的“剪切”通常指的是剪切矩阵（shear matrix）或剪切变换（shear transformation），这是一种线性变换，它将一个图形沿着某一轴或平面进行倾斜，而不改变图形的大小或形状 这是通过矩阵在几何上的线性变换，证明矩阵乘法具有结合性的一个实实在在的证明。我真的鼓励你在这种想法上多做尝试，想象两个不同的变换，思考他们依次作用后会发生什么，最后用数值方法计算出矩阵乘积。 4.观察基向量的运算和线性变换，**“缩放再相加”**的过程在变换前后均适用。 对于一个矩阵，用一个元素均为x、y、z这种未知数的向量相乘，得到的新矩阵就是新的基向量。 线性变换矩阵 * 输入向量 输出向量。 （线性变换和函数的功能是类似的，输入-处理-输出。但变换一词更强调变换本身的过程，也就是几何而非数值上的变化。） 4.行列式不同矩阵代表的线性变换中，有的将空间向外拉伸，有的将空间向内挤压。理解这些线性变换的关键一点，是测量变换对空间拉伸或挤压的程度。也就是测量一个给定区域面积增大或减小的比例。 这个特殊的缩放比例，即线性变换改变面积的比例 , 被称为这个变换的行列式 注意： 无论一个方格如何变化，对其他大小的方格来说，都会有相同变化。 这是由“网格线保持平行且等距分布”这一事实推断得出的 对于不是方格的形状（存在曲线的），可以用很多小方格近似。 对所有小方格都进行等比例缩放，缩放的越小，精度越高。 如果一个二维线性变换的行列式为0，说明它将整个平面压缩到一条线，甚至是一个点上。 表现在几何上就是面积为0，没有面积。 这意味着一个矩阵的行列式如果为0，这个矩阵所代表的变换就能将空间压缩到更小的维度上（降维）。 二维空间的行列式负值： 定向 行列式有负值。缩放一个负数是什么意思? 这会涉及到一个叫“定向”的概念。 如里你将二维空间想象为一张纸，这个变换像是将纸翻转到了另一面。 根据i帽和j帽来考虑。 初始状态下，显然 j-hat 在 i-hat 左边，形成一个直角。 如果在变换之后，j帽处于i帽的右边，那么空间定向就发生了改变 j 帽就是y轴基向量，i -hat 就是x轴基向量 我们称类似这样的变换改变了空间的定向。 当空间定向改变的情况发生时，行列式为负。 此时，行列式的绝对值依然表示区域面积的缩放比例。 比如说，我告诉你由(1,1)和(2,-1)为列的矩阵所代表的线性变换的行列式是-3. 这就是说变换后空间被翻转，并且面积放大为原来的3倍。 负的面积为什么和定向有关？ 这里强烈建议看3blue1brown原视频。 《线性代数的本质》行列式 5：05 当i帽靠近j帽时，空间也被压缩地更严重，这意味着行列式趋近于0； 当i帽与j帽完全重合时，行列式为0。 如果i帽继续沿着这个方向运动，行列式继续减小为负值将是一件很自然的事。 换一个角度看，二维的压缩，从三维视角看，就是一种旋转。 压缩时，向量j 不动，向量 i 逐渐靠近 j。 想象 i 靠近 j ，越过 j 的过程： 二维视角下，以i 和 j 为基 的坐标系接近时压缩，越过时拉伸。 三维视角下，把红向量j当做Z轴，想象绿向量在XOY平面上旋转—— 就像一个圆柱绕圆心的Z轴旋转，你只能看到 XoY 这一个侧切面的变化。 三维空间，行列式意味着什么？ 依然是变换前后的缩放比例，不过这次缩放的是体积。 二维空间，我们考虑的是基向量i 和 j 组成的面积为1的正方形，并观察变换对它的影响。 三维空间，我们考虑的是基向量 i , j , k 组成的体积为1 的立体正方形。 三维空间的行列式负值： 有一种方法来描述三维空间的定向，那就是“右手定则—— 右手食指指向i帽的方向； 伸出中指指向j帽的方向； 当你把大拇指竖起来时，它就正好指向k帽的方向。 如果线性变换后，你还可以用右手这么做，那么定向没有发生改变，行列式为正。 如果变换后，只能用左手描述了，那就是定向发生了改变，行列式为负。 行列式的求值公式： ad - bc$$(a+b)(c+d)-ac-bd-2bc ad-bc$$坐标系中， 小正方形凑成的网格面积 减去 平行四边形周围的三角形面积 平行四边形的面积 行列式的一个性质证明：$$det(M1M2) det(m1) det(m2)$$ det行列式，M1、M2是矩阵 数值计算很麻烦。但从几何上理解： 两个相继作用的总的线性变换对空间中几何维度造成的影响等于他们单独作用时造成影响的乘积。 两次空间放缩引起的面积变化 是 两次单独放缩面积变化 倍数的乘积 在同一个变换下任何一个图形的拉伸倍率都是一样的，所以M1M2两次变换后的面积倍率结果是一致的。 注意：det乘det本质不是面积相乘，而是面积倍率相乘。 5.线性方程组用一个式子概括：$$A\\vec{x} \\vec{v}$$ $$\\left(\\begin{matrix}1 2 3 \\4 5 6 \\7 8 9\\end{matrix}\\right) \\left[\\begin{matrix}x_1 \\x_2 \\x_3 \\end{matrix}\\right] \\left[\\begin{matrix}a \\b \\c \\end{matrix}\\right]$$ A 是未知数系数的矩阵，x 是未知数向量{x,y,z或x1,x2,x3……}， v是常数向量，如果是齐次的话，v 就是 很多 0 的 向量。 这个式子阐明了线性方程组问题中优美的几何直观部分： 矩阵A代表一种线性变换，所以 求解Axv意味着我们去寻找一个向量x，使得它在变换后与v重合。 这个时候逆矩阵的几何意义也很清晰了！ 当你逆向进行变换时，它实际上对应了另一个线性变换 —— 用v经过线性变换（矩阵）去寻找x。 也就是等式两边同乘A逆，v逆向进行变换并跟踪x的动向。 这个线性变换就叫作A^-1^ A的逆矩阵！ 比如说，如果A是逆时针旋转90度的变换,那么A的逆就是顺时针旋转90度的变换。 总的来说，A逆是满足以下性质的唯一变换： 首先应用A代表的变换，再应用A逆代表的变换，你会回到原始状态。 A逆乘以A等于一个“什么都不做”的矩阵，这个“什么都不做”的变换被称为“恒等变换” x和v重合有两种情况： 降维，两者变成一条线或一个点从而重合。 不降维，在原有维度（二维、三维）上通过线性变换重合。 不降维，即存在唯一解的情况，这时存在A逆。 A^-1^ 使得应用A变换再应用A逆变换之后，结果与恒等变换无异。 降维即行列式为 0的情况； 与这个方程组相关的变换将空间压缩到更低的维度上，此时没有逆变换，你不能将一条线“解压缩”为一个平面，也不能将一个点“回溯”成一条线（至少这不是一个函数能做的），你不能进行升维。 降维会损失信息。 空间坍缩为更低的维度后，变换信息有所丢失，无法得到其逆变换，也就是逆矩阵不存在 这样就会要求将一个单独的向量变换为一整条线的向量，但是函数只能将一个输入变换为一个输出。 关于列空间（下面理解方程组求解要用）： 所有可能的变换结果(输出向量)的集合 被称为矩阵的“列空间。 不管是一条直线、一个平面还是三维空间等。 矩阵的列告诉你基向量变换后的位置，这些**变换后的基向量张成的空间就是所有可能的变换结果 **; 换句话说**，列空间就是矩阵的列所张成的空间。** 列张成的空间 span of columns↔️列空间 Column space 0向量一定包含在列空间中。 因为线性变换要求原点位置不变。 结合这里的几何特性你可以理解： 对于线性方程组的求解情况—— 非齐次 增广矩阵r(A,v) 的秩和矩阵的秩r(A) 是否相等： r(A,v) == r(A)说明 v 和A在一个维度上 ，至少有一个解 r(A,v) r(A) :说明 v 比 A 的维度要高 ，无解 列空间：列向量张成的空间span，忘记的看第 0 条 。 列空间是所有可能的 A 的列向量的线性组合构成的集合。 假设矩阵 A 是一个 m×n 的矩阵，那么它有 n 个列向量。这些列向量可以看作是 R^m^ (m维空间）中的向量。 如果这些列向量线性无关，它们可以张成一个 n 维的子空间，这个子空间就是 A 的列空间。 现在，当我们说向量 v 不在矩阵 A 的列空间中，这意味着没有一种方式通过 A 的列向量的线性组合来得到向量 v。 换句话说，v 向量的维度高于 A，于是不存在一个向量 x 使得 Ax v 成立。 如果我们将 A 的列向量看作是定义了一个平面或者高维空间中的一个超平面，那么 b 就是位于这个平面或超平面之外的点。 r(A,v) r(A) 时，意味着 v 的维度比 A 的维度要高，A经过初等行变换会存在 全 0 行。 A如果线性相关，则必然存在 全 0 行； A如果线性无关，但比我们要追踪的 v 向量 少一行，也意味着A、v两者比较时，A下面要补充一个全0行。 总之就是少一个维度。 r(A) 里存在线性相关的列向量。于是 A 的线性变换相比 v向量 少了一个维度，找不到 x向量 经过低维线性变换 追踪到 v。 在 r(A,v)==r(A) 的情况下，秩的数量(A)是否和未知数n (x向量)一样： 如果一样，说明 A 和 x 在同一维度，x可以通过有限线性变化A 与 v重叠，这时是唯一解。 如果不一样，说明 A 比 x 维度低 ，x 想与 v 重叠，只能通过“降维”，这时是无穷多解。 可以想象，物体投影到平面上只有一个影子；而从投影去猜测物体，物体可以有无限种形状。 同样地，经过降维压缩变换后，能够和低维的 v 重叠的 高维 x 有无穷多种。 例如三维→二维， 立体被压缩成一条线； 例如二维→一维，一条线被压缩成一个点。 都是无穷多解的情况。 提问：增广矩阵的秩为n时，什么时候有解？ 答：增广矩阵在n维度， A在n-1维度时无解。 只有当增广和A都在n维度时 才有解 齐次 一定有解。 n 是 未知数个数。 r(A) n ， A 和 x 在同一维度 ，因为 v 向量是0，x 作为 0 向量，经过任何线性变换都和 v 重叠。 是的，只有一个 唯一解，那就是0向量。 r(A) n , A 比 x 维度低 ，x 想与 0向量 重叠，只能通过线性变换来 “降维”，这时是无穷多解。 这无穷多个解不是整个二维平面，而是二维平面三维空间上的一条线，叫做零空间。 于是不难理解行列式为 0 时的意义： 行列式为0 时，意味着变换前后的面积倍率为0（压缩后面积为0），一定有维度变化。 对线性方程组，表现在齐次上就是无穷多解（线性变换降维），表现在非齐次上要么无解（v 比 A 维度高），要么也无穷多解(线性变换降维)。 6.秩 (Rank)“秩”代表着变换后空间的维度So the word “rank” means the number of dimensions in the output of a transformation. 列向量所张成空间的维度（基向量个数） 举例： 比如说对于2x2的矩阵，它的秩最大为2,意味着基向量仍旧能张成整个二维空间，并且矩阵的行列式不为零 但是对于3x3的矩阵，秩为2意味着空间被压缩了，但是和秩为1的情况相比，压缩并不是那么严重。 如果一个三维变换的行列式不为零，变换结果仍旧充满整个三维空间，那么它的秩仍为3。 所以更精确的秩的定义是列空间的维数。 当达到最大值时，意味着秩与列数相等，我们称之为“满秩” 对一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。 但是对一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上。也就是说会有一系列向量在变换后成为零向量。 举个例子，如果一个二维线性变换 将 非满秩（秩为1，两个基向量线性相关）平面压缩到一条直线上，那么沿某个不同方向直线上的所有向量就被压缩到原点。 就好像柱子的侧面（直线）经过线性变换（旋转）变成了一个点（底面）。 如果一个三维线性变换将空间压缩到一个二维平面上，同样也会有一整条线上的向量在变换后落在原点。 压缩成二维直线也一样。 零空间： 变换后落在原点的向量的集合，被称为矩阵的“零空间”或“核。变换后一些向量落在零向量上，而“零空间”正是这些向量所构成的空间 比如上面例子中那一整条直线就是零空间。 列空间的概念让我们清楚什么时候存在解，零空间的概念有助于我们理解所有可能的解的集合是什么样的。 7. 非方阵矩阵举例分析 3x2矩阵：是一个面，但仍然满秩。几何意义是将一个二维空间映射到三维空间上。 二维空间输入 ，三维空间输出。 矩阵有两列表明输入空间有两个基向量，有三行表明每一个基向量在变换后都用三个独立的坐标来描述。 2x3矩阵： 三维空间输入 ，二维空间输出。 几个基向量说明空间是几维；有两行表明这三个基向量在变换后都仅用两个坐标来描述，所以他们一定落在二维空间中。 解线性方程 3×2矩阵解线性方程：3个方程式，2个未知数，将二维空间投射到三维空间，要么无解，要么一个解 2×3矩阵解线性方程：2个方程式，3个未知数，将三维空间压缩成二维空间，要么无解，要么无穷多解 8.点乘和线性变换（相当劲爆）点乘标准形式：$$\\left[\\begin{matrix}a \\b\\end{matrix}\\right]\\cdot\\left[\\begin{matrix}c \\ d\\end{matrix}\\right](a\\cdot c)+(b\\cdot d)$$点乘几何形式： 二维坐标系里进行演算可知，点乘就是其中一个向量在另一个向量上的投影长度，乘以被投影向量长度的成绩。 这一章的思想跨度较大（可以说很惊人、很震撼且富有美感），可以配合3b1b的图形化视频食用。 这里总结一下就是，用一个向量点乘另一个向量，实质上是做了一个线性变换。 点积可以看作是矩阵向量乘法的一个特例，是投影到一维的线性变换。 所以矩阵向量乘法的本质是线性变换。 线性变换的“物质载体“ ，则是其中一个向量扮演的。 考虑一个问题 为什么点乘的运算过程：对应坐标相乘并将结果相加，和投影有所联系？ 让我们试着证明一下： 还是老样子， 前提：等距分布的点保持等距分布，从而为我们保证线性变换的基础。 否则线性变换，或者说高维向量在一维空间（数轴）上的投影就不是线性的，而是离散的。 视角：这些线性变换完全由它对i帽和j帽的变换决定，所以只关注i帽、j帽。 由 i帽 和 j帽 的变换，可以推出二维向量的变换。这也是以前对线性变换的分析方法，不拘泥于过程，由基向量推其他向量。 （u的坐标体现的是i,j向量的变化，而i,j向量就可以反映其余的改变） 为什么要找i-hat和j-hat投影在斜数轴上？因为一开始那个把二维变一维的函数作的变换就是投影，而投影后的i-hat和j-hat的位置表示这种投影变换。 i-hat 和 j-hat 的变换则代表了对应的所有列空间向量的变换。 定义一个从二维向量到数的线性变换，找到描述这个变换的1x2矩阵 Projection matrix 投影矩阵 Transformation matrix 变换矩阵。 所以描述投影变换的1x2矩阵的两列，也就是 i-hat和j-hat在斜数轴上的投影的值，根据对称性，正好分别是斜数轴u-hat的点的横纵坐标 ux , uy 。 因此空间中任意向量经过投影变换的结果，也就是投影矩阵与这个向量相乘。 也就是投影矩阵[ux , uy]与这个向量[i-hat, j-hat]相乘 这意味着，当一个二维向量v和另一个1x2的矩阵A 相乘时，这和基向量与u帽的点积在计算上完全相同。 选择u帽长度为1并且落在一维数轴上，主要是为了体现后续u帽和i帽、j帽相互映射的对偶性 这就是为什么与单位向量的点积可以解读为将向量 v 投影到投影矩阵代表的单位向量 u 所在的直线上所得到的投影长度。 点积是一种将二维向量投影（降维）成一维向量（数轴）的线性变换。 （高维向量在一维的投影） 矩阵向量相乘 Matrix-vector product 点积 Dot product$$\\left[\\begin{matrix}u_x u_y \\end{matrix}\\right]\\left[\\begin{matrix}x \\y \\\\end{matrix}\\right]u_x \\cdot x+u_y \\cdot y$$↑等价↓$$\\left[\\begin{matrix}u_x \\u_y \\end{matrix}\\right]\\left[\\begin{matrix}x \\y \\\\end{matrix}\\right]u_x \\cdot x+u_y \\cdot y$$ 你在任何时候看到一个线性变换，它的输出空间是一维数轴。无论它是如何定义的，空间中会存在唯一的向量v与之相关，就这一意义而言，应用线性变换和与向量v做点积是一样的。 它是数学中“对偶性”的一个实例。 你可以说一个向量的对偶是由它定义的线性变换； 一个多维空间到一维空间的线性变换的对偶是多维空间中的某个特定向量 两个向量点乘，就是将其中一个向量转化为线性变换 有时你就会意识到，不把向量看作空间中的箭头，而把它看作线性变换的物质载体，会更容易理解向量 向量就仿佛是一个特定变换的概念性记号。因为对我们来说，想象空间中的向量比想象整个空间移动到数轴上更加容易。 举个例子：$$\\vec{x}\\times\\vec{v}\\left[\\begin{matrix}1 \\ -2 \\\\end{matrix}\\right]\\left[\\begin{matrix}4 \\ 3 \\\\end{matrix}\\right]\\left[\\begin{matrix}1 -2 \\end{matrix}\\right]\\left[\\begin{matrix}4 \\ 3 \\\\end{matrix}\\right]4\\times1+3\\times(-2)$$将列向量 [1 -2] “横过来“ 看作是线性变换矩阵（Transformation matrix），此时，向量 v 的基向量 i-hat 和 j-hat 由默认的[1,0] ,[0 1] 经过线性变换 (乘变换矩阵) 变成了 [1 0],[0 -2] 。 这个线性变换的效果，实际上是“降维”，将两个二维基向量压缩成一条线（数轴）了，用点来表示，一个指向+1 , 一个指向-2。 [4,3]这个向量跟随基向量一起线性变换（降维），变成了指向-2的向量。 4*(+1 0) 表示 i-hat 长度变成4倍， 3 *(0 -2)表示 j-hat 长度变 3 倍，叠加在一起就是 - 2 。 当你完全从数值角度进行计算时，它就是矩阵向量乘法，而点积可以看作是矩阵向量乘法的一个特例。 但从几何角度出发，向量[1 -2]转化为线性变换的载体，使另一个向量[4 3]的基向量变换了，于是 向量[4 3]的基向量线性变换后进行放缩（乘以对应倍率），得到的新向量，数值结果和向量乘法一样。 9.叉乘叉乘标准形式：$$\\left[\\begin{matrix}a\\b\\\\end{matrix}\\right]\\times\\left[\\begin{matrix}c \\ d \\\\end{matrix}\\right](a\\times d)-(b\\times c)$$ $$\\vec{a}\\times\\vec{b}\\left[\\begin{matrix}a1 \\ a2 \\ a3\\end{matrix}\\right]\\times\\left[\\begin{matrix}b1 \\ b2\\b3\\end{matrix}\\right]\\left|\\begin{matrix}\\widehat{i} \\widehat{j} \\widehat{k}\\ a1 a2 a3\\ b1 b2 b3\\end{matrix}\\right|$$ i 的余子式 + j 的余子式 + k 的余子式 叉乘几何意义： a1b1两个向量分别平移相交成 a2b2，四个向量a1a2b1b2围成的平行四边形的面积就是叉乘的绝对值。 正负性（定向问题）：以a * b为例。如果在二维平面上，a 在 b 右边（b需要经过右旋转到a），那么a*b就是正值。 如果a 在 b 左边（b需要经过左旋转到a），那么a*b就是负值。 注意：这是说顺序对叉乘有影响。 几何角度观察定向： i-hat 在 j-hat 右边，i * j = +1 。那么 a 在 b 右边，a * b = + 基向量的顺序就是定向的基础 行列式的面积和叉乘有很大关系。$$\\left[\\begin{matrix}a\\b\\\\end{matrix}\\right]\\times\\left[\\begin{matrix}c \\ d \\\\end{matrix}\\right]\\left|\\begin{matrix}a c\\ b d\\end{matrix}\\right|(a\\times d)-(b\\times c)$$ a,b两个向量相乘 ，你只需要将 a向量作为行列式第一列，b向量作为行列式第二列，然后直接计算行列式。 所以： 这里可以一个解释行列式性质：交换任意两行，行列式正负性改变。 几何上，两个向量叉乘交换顺序了，定向改变了，向量的基改变了，行列式为负不是很自然的吗？ 你可能注意到一点，**当两个向量接近垂直时，他们的叉积最大。**因为此时构成的平行四边形面积最大。 放大其中一个向量3倍，那么叉乘也增大3倍。从面积上理解也很自然。 根据上面的二维向量叉乘，如果让我们猜测三维向量的叉乘，大概是：$$\\left[\\begin{matrix}u_1 \\ v_1 \\ w_1\\end{matrix}\\right] \\times \\left[\\begin{matrix}u_2\\ v_2 \\ w_2\\end{matrix}\\right] \\times \\left[\\begin{matrix}u_3 \\v_3 \\ w_3\\end{matrix}\\right] \\left|\\begin{matrix}u_1 u_2 u_3\\ v_1 v_2 v_2\\w_1 w_2 w_3\\end{matrix}\\right|(这里是错误的猜想)$$输入三个向量，输出一个行列式（数值），这个行列式的数值是三维空间里，三个向量组成的体积。 虽然这么想很自然，却又还不是真正的叉积，但已经很接近了。 真正的叉积是通过两个三维向量生成一个新的三维向量。 叉积的结果不是一个数，而是一个向量。很奇怪吧？ 这个向量的长度就是平行四边形的面积，而这个向量的方向与平行四边形(所在的面)垂直。 垂直方向有两个，至于是哪一个，要靠“右手定则”： 食指指向i帽的方向； 伸出中指指向j帽的方向； 当你把大拇指竖起来时，它就正好指向k帽的方向。 注意：第4节行列式也出现了右手定则。 这里要证明一件事：为什么叉积生成的新三维向量有这个性质？ 思路一：直接数值运算 很直接很暴力，也很麻烦。这不是我们今天要讨论的。 思路二：几何思路 前提：对偶性思想——上一节点乘用到的思想。 每当你看到一个(多维)空间到数轴的线性变换时，它都与空间中的唯一个向量对应，也就是说应用线性变换和与这个向量点乘等价，数值上说，这是因为这类线性变换可以用一个只有一行的矩阵描述，而它的每一列给出了变换后基向量的位置。 这里的收获在于，每当你看到一个从空间到数轴的线性变换，你都能够找到一个向量，被称为这个变换的对偶向量（dual vector），使得应用线性变换和与对偶向量点乘等价。 叉积的运算同样体现了对偶性思想。 现在，我们将刚刚上面的猜想叉积的第一个向量u看作可变向量，比如(x,y,z)，而v和w保持不变，那么我们就有一个从三维空间到数轴的函数了。 这个函数根据v和w来定义（因变量），输入(x,y,z)（自变量）产生行列式（结果）。 你输入一个向量(x,y,z)，然后通过矩阵的行列式得到一个数，这个向量的第一列是(x, y,z)，其余两列是常向量v和w的坐标。 $$f\\left(\\left[\\begin{matrix}x \\ y \\ z\\end{matrix}\\right]\\right)det\\left(\\left[\\begin{matrix}x v_1 w_1 \\y v_2 w_2 \\z v_3 w_3\\end{matrix}\\right]\\right)$$ $$变量variable\\vec{u}\\left[\\begin{matrix}x \\ y \\ z\\end{matrix}\\right] \\vec{v} \\left[\\begin{matrix}v_1 \\ v_2 \\ v_3\\end{matrix}\\right] \\vec{w} \\left[\\begin{matrix}w_1 \\ w_2 \\ w_3\\end{matrix}\\right]$$ 这里将向量写作矩阵的列，而教科书中大多将向量写作矩阵的行。两种结果没有差异，因为转置不改变行列式的值。这里选择按列处理向量是为了更加直观。 这个函数的几何意义是，对于任一输入的向量(x, y,z), 考虑由它和v与w确定的平行六面体,得到它的体积，然后根据定向确定符号。 这个函数是线性的，由行列式性质可知： 行列式就是三个向量所夹的平行六面体的体积。这个平行六面体的底面积是定下来的，所以如果高是线性的体积就是线性的。 一旦知道它是线性的，你就知道可以通过矩阵乘法来描述这个函数。 即这个函数从三维空间到一维空间的每个线性变换，都存在一个1x3矩阵来代表这个变换。 对偶性告诉我们，你可以将这个1*3矩阵立起来，并且将整个变换看作与这个特定向量的点积。 $$\\overbrace{\\left[\\begin{matrix}? \\ ? \\ ?\\end{matrix}\\right]}^{神秘1\\times3矩阵} \\left[\\begin{matrix}x \\ y \\ z\\end{matrix}\\right] \\overbrace{\\left[\\begin{matrix}p_1 \\ p_2 \\ p_3\\end{matrix}\\right]}^{这是\\vec{p}} \\left[\\begin{matrix}x \\ y \\ z\\end{matrix}\\right] det\\left(\\left[\\begin{matrix}x v_1 w_1 \\y v_2 w_2 \\z v_3 w_3\\end{matrix}\\right]\\right)$$ 我们要找的就是这个特殊的三维向量——我称之为p向量。由上式可知，p与其他任一向量(x,y,z)的点积等于一个3x3矩阵的行列式。 对于这个式子，有两种理解角度：计算和几何 计算 上式经过点乘：$$p1\\cdot x+p2\\cdot y+p3\\cdot z\\begin{matrix}x(v2\\cdot w3-v3\\cdot w2)+ \\y(v3\\cdot w1-v1\\cdot w3)+ \\z(v1\\cdot w2-v2\\cdot w1)\\end{matrix}$$所以很明显可以看出，我们要找的 p向量 的值就藏在右边的v和w坐标的线性组合中。$$\\vec{p}\\left[\\begin{matrix}p1 \\ p2 \\ p3\\end{matrix}\\right]\\begin{cases}p1 v2\\cdot w3-v3\\cdot w2 \\p2v3\\cdot w1-v1\\cdot w3 \\p3v1\\cdot w2-v2\\cdot w1\\end{cases}$$ 点积本是上是替换掉了原有的基向量，而叉积的行列式定义中有三个基向量正好可以用点积操作替换掉。 像这样合并x、y和z前面的常数项，和把i帽、i帽和k帽放进矩阵第一列进行计算，然后合并各项前面的系数没有区别。 把i帽、i帽和k帽放进矩阵第一列进行计算，正是老师根据教科书，叫我们死记硬背的叉积公式！ 在矩阵中插入i帽、j帽和k帽不过是在传递一个信号，告诉我们应该把这些系数解读为一个向量的坐标。 好了，推导结束了。总结一下： 当你将向量p和某个向量(x,y,z)点乘时，所得结果等于一个由(x,y,z)和v与w确定的平行六面体的有向体积，数值上是一个3x3矩阵的行列式，这个行列式第一列为(x,y,z)，其余两列为v和w的坐标。 这是计算角度的总结。 让我们从几何角度看看，什么样的向量p才能满足这一特殊性质 ? 几何 对于点积，向量p与其他向量的点积的几何解释，是将其他向量投影到p上，然后将投影长度与p的长度相乘。 而对于叉积，上文中我们用一个线性函数来代表它。 我们找到的线性函数对于给定向量的作用，也就是 p 作为一个 1x3矩阵，代表着一个线性变换；这个线性变换将向量投影到垂直于v和w的直线上，然后将投影长度与v和w张成的平行四边形的面积相乘。 这和(x,y,z) 与 垂直于v和w且长度为平行四边形面积的向量点乘是同一回事。 首先获得由v和w确定的平行四边形的面积，乘以向量(x,y,z)在垂直于平行四边形方向上的分量(不是(x,y,z)的长度，是投影)，我们就可以得到这个平行六面体的体积， 总结一下就是底面积(v,w)乘高(p投影)。 更重要的是，如果你选择了合适的向量方向(点积为正)就会与(x,y,z)、v和w满足右手定则的情况相吻合。 这意味着我们找到了这个p，使得p与和某个向量(x,y,z)点乘时，所得结果等于和上面计算得来的3x3矩阵的行列式是一致的。 这就是我们要找的，计算和几何得出的同一个向量 p 。 10.基变换同一个向量，在基向量不同的坐标系，会有不同的表达方法。这就像不同的语言，虽然我们都在关注空间中的同一个向量，但是我们可以用不同的语言和数字来描述它。不同的基向量，坐标轴的方向与网格间距会有所不同。 于是一个很自然的问题：如何在不同坐标系之间进行转化? 假设你的朋友詹妮弗自己建立了一个坐标系，第一个基向量b1 (2,1) , 第二个基向量b2 (-1,1) 在她的坐标系中，这两个向量的坐标为(1,0)和(0,1) 对于向量[-1 2] ，她的坐标系里，这个向量是-1乘以b1加上2乘以b2。 此时，坐标系背后的“网格”也发生了变化，不再是由基向量(1,0)、(0,1)构成的正方形，而是由(2,1)、(-1,1)构成的平行四边形。 所以她的坐标轴的方向和网络间距会有所不同。 从我们的角度来看，b1的坐标为(2，1)，b2的坐标为(-1，1)，所以实际上，我们可以直接计算-1乘以b1加上2乘以b2，因为它们都是在我们的坐标系中表示的。计算后得到的是[-4 1] 的向量。 这里发生的过程，也就是用某个向量的特定坐标与她的基向量数乘，这不就是矩阵向量乘法吗？ 这个矩阵的列代表的是用我们的语言表达的詹妮弗的基向量。 一个矩阵的列为詹妮弗的基向量,这个矩阵可以看作一个线性变换。 它将我们的基向量i帽和j帽，也就是我们眼中的(1, 0)和(0,1)变换为詹妮弗的基向量，也就是她眼中的(1,0)和(0，1) 这里有一个疑惑：$$Our ; grid \\longrightarrow Jennifer’s;grid \\\\left(\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right)\\Jennifer’s;language \\longleftarrow Our ; language$$从几何上说，这个矩阵将我们的网格变换为詹妮弗的网格, 但是从数值上说，这是用她的语言来描述转化为用我们的语言来描述。 让我们恍然大悟的是，把它看作将我们对詹妮弗的向量的误解，也就是在我们的坐标系中具有相同坐标的向量，变成她真正想要表示的向量。 那么反方向呢？ 我们的坐标系中的(3，2)的向量，怎么得到詹妮弗坐标系中的(5\\3, 1\\3) 之前的基变换矩阵是从詹妮弗的语言转化到我们的语言，那我们对矩阵取个逆不就好了 ！ 记住一点，一个变换的逆是一个新的变换,他讲对应的变换逆向进行。 以上就是如何在坐标系之间对单个向量的描述进行相互转化。 总结：一个矩阵的列代表的是詹妮弗的基向量，却是用我们的坐标来描述；对于一个向量，这个矩阵将她的语言描述转化为我们的语言描述。逆矩阵则相反。 向量并不是唯一用坐标表示的东西。线性变换同样要用坐标向量表示。 这就涉及到了基向量问题(看待坐标的视角) 考虑某个线性变换，譬如逆时针旋转90你我用矩阵代表它的时候，我们是在跟踪i帽和j帽的去向。 i帽在变换后处于坐标(0，1) 而j帽在变换后处于坐标(-1，0)。 这些坐标也就成为了矩阵的列 $$\\left(\\begin{matrix}0 1 \\ -1 0\\end{matrix}\\right)$$ 但是这种表示与我们对基向量的选择密切相关。因为我们跟踪的是i帽和j帽,并且是在我们自己的坐标系中记录它们的去向。 而詹妮弗如何描述同样的空间90°旋转呢? 你可能会尝试只将旋转矩阵的列转化为用詹妮弗的语言描述——因为这些列代表的是i帽和j帽的去向。 但是这些列代表的仍然是我们的基不是她的基。而詹妮弗想要的矩阵需要代表她的基向量的去向,也就是用她的语言描述。$$\\overbrace{\\left[\\begin{matrix}-1 \\ 2\\end{matrix}\\right]}^{Vector;in;Jannifer’s;language}\\longrightarrow\\overbrace{\\underbrace{\\left[\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right]}{基变换矩阵}\\left[\\begin{matrix}-1 \\ 2\\end{matrix}\\right]}^{Same;vector;in;our;langugae}\\longrightarrow\\quad\\overbrace{\\underbrace{\\left[\\begin{matrix}0 -1 \\ 1 0\\end{matrix}\\right]}{变换矩;in;our;language}\\left[\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right]\\left[\\begin{matrix}-1 \\ 2\\end{matrix}\\right]}^{变换后向量;in;our;language}$$ $$\\left[\\begin{matrix}0 -1 \\ 1 0\\end{matrix}\\right]\\left[\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right]\\left[\\begin{matrix}-1 \\ 2\\end{matrix}\\right]\\longrightarrow\\overbrace{\\underbrace{\\left[\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right]^{-1}}_{基变换矩阵的逆}\\left[\\begin{matrix}0 -1 \\ 1 0\\end{matrix}\\right]\\left[\\begin{matrix}2 -1 \\ 1 1\\end{matrix}\\right]\\left[\\begin{matrix}-1 \\ 2\\end{matrix}\\right]}^{变换后向量;in;Jannifer’s;language}$$ 因为我们能够对詹妮弗语言描述的任一向量做同样的事: 基变换 → 线性变换 → 基变换的逆 这三个矩阵的复合给出的就是用詹妮弗语言描述的线性变换矩阵。 它接收用詹妮弗语言描述的向量，并输出用詹妮弗语言描述的变换后的向量。 所以，如果詹妮弗用这个矩阵与她的坐标系中的一个向量相乘，结果就是在她的坐标系中描述的该向量旋转90°的结果。 总结：每当你看到这样一个表达式:A逆乘以M乘以A*(P^-1^AP B),这就暗示着一种数学上的转移作用。 中间的矩阵代表一种你所见的变换，而外侧两个矩阵代表着转移作用，也就是视角上的转化。 矩阵乘积仍然代表着同一个变换，只不过是从其他人的角度来看的。 基变换两个应用实例： 1.特征值与特征向量 2.相似对角化。 11.特征值和特征向量 引言 首先，考虑二维空间中的某个线性变换：$$\\left[\\begin{matrix}3 1 \\0 2\\end{matrix}\\right]$$ 它将基向量i帽变换到坐标(3,0)，j帽变换到坐标(1,2) 我们关注它对一个特定向量的作用，并且考虑这个向量张成的空间，也就是通过原点和向量尖端的直线。大部分向量在变换中都离开了其张成的空间； 所以如果向量正好落在这条直线上，感觉更像是巧合。不过，某些特殊向量的确留在它们张成的空间里，意味着矩阵对它的作用仅仅是拉伸或者压缩而已，如同一个标量。 在这个例子中，基向量i帽就是这样一个特殊向量。i帽张成的空间是x轴，i帽变成了原来的3倍，仍然留在x轴上。 此外，因为线性变换的性质，x轴上的任何其他向量都只是被拉伸为原来的3倍，因此也就留在它们张成的空间里。 有一个略显隐蔽的向量(-1,1)，它在变换中也留在自己张成的空间里，最终被拉伸为原来的2倍； 同上，线性性质暗示着，处在它所张成的对角线上的其他任何一个向量，也仅仅被拉伸为原来的2倍。 所以你猜到了吗？这两个保持在自己的span的特殊向量就被称为特征向量。每个特征向量都有一个所属的值，被称为“特征值”, 即衡量特征向量在变换中拉伸或压缩比例的因子。 如果特征向量是负值12 ，意味着这个向量被反向，并且被压缩为原来的12。 重点在于，它仍然停留在它张成的直线上，并未随着线性变换发生旋转。 特征向量的一个应用：三维空间旋转。 例如一个立方体，旋转的话，如果你能找到这个旋转的特征向量，那么你找到的就是旋转轴。这种情况下，相应的特征值必须为1，因为旋转不缩放任何一个向量。 旋转的应用告诉我们： 对于任一矩阵描述的线性变换，你可以通过将矩阵的列看作变换后的基向量来理解它。但今天我们学习了特征向量，那么在不依赖于特定坐标系（基向量变化）的前提下，一种更较好且常用的的理解方式就是特征向量和特征值。 对于一个矩阵A有两种理解方式 一种理解方式是基于坐标系的，认为矩阵的每一个列向量是线性变换后的基向量；另一种理解方式使用特征向量和特征值。 概念 $$\\overbrace{A}^{变换矩阵};\\vec{v}\\lambda\\overbrace{\\vec{v}}^{特征值} \\\\quad\\searrow\\quad\\swarrow\\\\quad;特征向量$$ 矩阵向量乘积 = 向量数乘 。因此求解矩阵A的特征向量和特征值，实际上就是求解使得这个等式成立的向量v和数λ。 想理解这个式子，首先要解决乘积类型不同的问题。 所以我们首先将等号右侧重写为某个矩阵向量乘积，让 λ 当成某个矩阵。 其中，矩阵的作用效果是将任一向量乘以 λ，这个矩阵的列代表着变换后的基向量，而每个基向量仅仅与λ相乘所以这个矩阵的对角元均为λ，其余位置都是0。 无非是 λE，乘以一个单位矩阵E。 我们就能将等号右侧的东西移到左侧，然后提出因子v$$(A-\\lambda I)\\vec{v} \\vec{0}$$左括号里的矩阵类似于下面这种矩阵$$\\left[ \\begin{matrix}3-\\lambda 1 4\\1 5-\\lambda 9\\2 6 5-\\lambda\\end{matrix}\\right]$$于是我们可以寻找一个向量v，使得这个新矩阵与v相乘结果为零向量。 首先是v自己是零向量。这时等式恒成立。 这种情况比较无聊，看下面。 v不是零向量。这时考虑前面学到的内容，当且仅当矩阵代表的线性变换将空间压缩到更低的维度时，才会存在一个非零向量使得矩阵和它的乘积为零向量。 简单说，非零向量是有长度滴。线性变换想让它变成一个点，只能通过降维压缩。 那么考考大家，什么特性的矩阵能降维压缩？——行列式为0的矩阵（压缩完面积为0）。 观察括号式子代表的矩阵，有一个变量λ。在上面那个例子中，λ1时行列式为 0。 当然，对于其他矩阵，特征值不一定是1，λ取其他值时才能使行列式为零。 这里3b1b的原视频有一个随着λ变化，向量逐渐线性变换的过程，很精彩！ 这个 λ 值保证了概念式子的成立，也就说明此时向量v是A的一个特征向量，在变换中停留在它张成的空间里。 在这个例子中，v对应的特征值是1，所以它实际上保持不变 举例说明：$$det\\left(\\left[\\begin{matrix}3 1 \\0 2\\end{matrix}\\right]\\right)(3-\\lambda)(2-\\lambda)0$$还是开头这个例子，求解它的特征值，将对角元减去λ，然后计算行列式。这样我们就得到了一个关于入的二次多项式(3-入)(2-入)。由上面的推论可知，只有行列式为零时，λ 才会是特征值。所以这个矩阵的λ 2 或 λ 3。$$\\left[\\begin{matrix}3-\\lambda 1 \\0 2-\\lambda\\end{matrix}\\right]\\left[\\begin{matrix}x \\ y\\end{matrix}\\right]\\left[\\begin{matrix}0 \\ 0 \\end{matrix}\\right]$$为了求出属于特征值的特征向量，将 λ 代入到矩阵中，然后求解出在能经过个矩阵的线性变换后成为零的向量。于是得到x+y = 0 你会发现所有的解全部落在由向量(-1,1)张成的对角线上 与之对应的，就是原始的矩阵[(3,0)，(1,2)]将这些向量拉伸为原来的2倍。 三个特征向量的特殊情况 1.二维线性变换不一定有特征向量 比如正交变换：$$\\left[\\begin{matrix}0 -1 \\-1 0\\end{matrix}\\right]$$它并没有特征向量，因为每一个向量都发生了旋转并离开了其张成的空间。硬去求特征值，会得到 λ^2^+10 。有两个虚数解而没有实数解。没有实数解表明它没有特征向量。 扩展：但虚数和复平面有关系。与1相乘在复平面中表现为90度旋转和i是这个二维实向量旋转变换的特征值有所关联。特征值出现复数的情况般对应于变换中的某种旋转大。 具体细节这里不深究了。 2.剪切变换：$$\\left[\\begin{matrix}1 1 \\0 1\\end{matrix}\\right]$$所有x轴上的向量都是属于特征值1的特征向量，因为它们都保持不变 当你将对角元减去入，然后计算行列式,你得到的是 (1-λ)^2^ —— λ 是重根。 几重根就表明最多对应几个线性无关的特征向量 这与几何上得到的“所有特征向量均属于特征值1”的结果一致。 3.可能会出现只有一个特征值，但是特征向量不止在一条直线上的情况:$$\\left[\\begin{matrix}2 0 \\0 2\\end{matrix}\\right]$$一个简单的例子是将所有向量变为两倍的矩阵。 唯一的特征值是2，但是平面内每一个向量都是属于这个特征值的特征向量。 如果的基向量都是特征向量，会发生什么？$$\\left[\\begin{matrix}-1 0 \\0 2\\end{matrix}\\right]$$比如说，可能i帽变为原来的(-1)倍，j帽变为原来的2倍，将它们的新坐标作为矩阵的列。 注意，它们的倍数-1和2，也就是i帽和j帽所属的特征值，位于矩阵的对角线上，而其他元素均为0。 像这种除了对角元以外其他元素均为0的矩阵被称为对角矩阵, 解读它的方法是，所有基向量都是特征向量。矩阵的对角元是它们所属的特征值 对角矩阵有很多有趣的性质： 其中一个重要的方面是，对角矩阵与自己多次相乘的结果更容易计算 因为对角短阵仅仅让基向量与某个特征值相乘,所以多次应用矩阵乘法，比如100次，也只是将每个基向量与对应特征值的100次幂相乘。 但这种基向量是特征向量的情况，你可能很难遇到。 如果你的变换有许多特征向量，就像上面有两条的矩阵，多到你能选出一个张成全空间的集合，那么你就能变换你的坐标系，使得这些特征向量就是基向量 空间有几维，就找出几个线性无关的特征向量。 二维找两个特征向量，三维找三个。 所以又想到相似对角化了吗？矩阵A能对角化的充要条件是A有n个线性无关的特征向量!!! 这里还用到了上一节的基变换。 基变换矩阵是特征向量构成的，而特征向量是当前空间进行中间矩阵变换时不空间不变化的向量。 所以把当前空间的变换转换到特征基的空间后，变换就变成了对基的放缩操作，也就是特征值构成的矩阵 用特征向量作为基向量，变换只对基作伸缩。所以这个新矩阵必然是对角的，并且对角元为对应的特征值 所以一组基向量(同样是特征向量)构成的集合被称为一组“特征基” 所以如果你要计算这个矩阵的100次幂，更容易的做法是先变换到特征基，在那个坐标系中计算100次幂。然后转换回标准坐标系。 不是所有变换都能进行这一过程。比如说剪切变换，它的特征向量不够多，并不能张成全空间。但是如果你能找到一组特征基，矩阵运算就会变得非常轻松 12.抽象向量空间向量根本上并不是由一组实数构成，它们的本质其实更具空间性。 从某种意义上说，函数实际上只是另一种向量。函数既满足向量的可加性，又满足成比例。而对向量所能进行的操作不过相加和数乘两种。 所以，最初以空间中的箭头为背景考虑的线性代数的合理概念和解决问题的手段，应该能够原封不动地被我们取出来用于函数。 比如： 线性变换：函数的线性变换接收一个函数，我并把它变成另一个函数。微积分中的导数满足这个性质。 关于这点，有时你听到的是“算子”而不是“变换” 。（线性算子） 注意：导数既满足可加，又满足成比例。所以求导是一种线性运算。 基向量：函数空间倾向于无穷维，整个空间包含了任意高次的多项式。 我们见到的多项式往往是有限项。 我们要做的是给这个空间赋予坐标的含义，这需要选取一个基。因为多项式已经是数乘x的不同次幂再做加和的形式，所以我们很自然地取x的不同次幂作为基函数。 基函数举例：$$1x^2+3x+5$$第一个基函数是常函数：b0(x) 1 (5*15) 第二个基函数是b1(x) x 第三个基函数是b2(x) x^2^ …… 基函数在这里起到的作用，和i帽、j帽和k帽在向量(箭头)的世界中起到的作用类似。 因为多项式的次数可以任意高，所以这个基函数集也是无穷大的。 上述多项式的坐标就是 5、3、1、0、0、0…… 多项式4x^5^-5x^2^的坐标就是0、0、-5、0、0、4，然后加上一串无限长的0。 总的来说，因为每一个多项式都只有有限项，所以它的坐标就是有限长的一串数，再跟上无限长的一串零。 矩阵求导：在这个坐标系中，求导是用一个无限阶矩阵描述的。 你可以用这种方法构建这个矩阵:求每一个基函数的导数，然后把结果放在对应列。$$\\begin{matrix}b_0(x)1\\b_1(x)x\\b_2(x)x_2\\b_3(x)x_3\\\\end{matrix}\\qquad\\frac{d}{dx}b_0(x)\\frac{d}{dx}(1)\\left[\\begin{matrix}0 \\ 0 \\ 0 \\0\\end{matrix}\\right]\\qquad\\frac{d}{dx}b_1(x)\\frac{d}{dx}(x)\\left[\\begin{matrix}1 \\ 0 \\ 0 \\0\\end{matrix}\\right]\\qquad$$ $$\\frac{d}{dx}b_2(x)\\frac{d}{dx}(x^2)2x\\left[\\begin{matrix}0 \\ 2 \\ 0 \\0\\end{matrix}\\right]\\qquad\\frac{d}{dx}b_3(x)\\frac{d}{dx}(x^3)2x\\left[\\begin{matrix}0 \\ 0 \\ 3 \\0\\end{matrix}\\right]\\qquad\\frac{d}{dx}b_4(x)\\frac{d}{dx}(x^4)2x\\left[\\begin{matrix}0 \\ 0 \\ 0 \\4\\end{matrix}\\right]$$ 最终得到一个矩阵：$$\\left[\\begin{matrix}\\ 0 1 0 0 0\\0 0 2 0 0\\0 0 0 3 0\\0 0 0 0 4\\end{matrix}\\right]$$ 总结： 乍一看，矩阵向量乘法和求导像是毫不相干的。 线性代数 函数 Linear transformations 线性变换 Linear operators线性算子 Dot products 点积 Inner products 内积 Eigenvectors 特征向量 Eigenfunctions特征函数 向量空间： 我想在这里指出的是，数学中有很多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念。 不管是空间中的箭头、一组数、函数的集合，还是你定义的其他奇怪东西的集合。线性代数中所有关于向量、线性变换和其他的概念都应该适用于它。这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间’ 针对向量空间，数学家们建立了一系列向量加法和数乘必须遵守的规则，这些规则称为“公理”。 只要你定义的新家伙满足这些规则，那你就可以称它为向量，并运用我们学到的那些线性变换之类的工具。 在线性代数的现代理论中，果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足这八条公理，类似“入场券”似的东西。 这些公理并非基础的自然法则，它们是一个媒介。一边连接着你，也就是发现这些结论的数学家，另一边连接着其他人，也就是想要把这些结论应用于新的向量空间的人。只要向量的定义满足这些公理，就能顺利地应用我们发现的的所有关于向量的结论。 向量不止是某个“熟面孔” 这就是为什么你阅读的每一本教科书都会根据可加性和成比例来定义线性变换，而不是用网格线保持平行且等距分布什么的来定义。即便后者更加直观。 **向量的形势并不重要。**只要尚量相加和数乘的概念遵守以上规则即可。 **所以对于“向量是什么”这个问题，数学家会直接忽略不作答。**就好像问 3 这个抽象数字是什么含义一样。 因此，你往往会把你的所有结论抽象地表述出来，也就是说仅仅根据这些公理表述。而不是集中于某一种特定的向量上，像是空间中的箭头或者函数等 13.Cramer法则(克拉默克莱姆)计算线性方程组，往往用高斯消元法，而不用克拉默法则。但了解它的几何意义会帮你加深对线性方程组的理解。 一个线性方程组的小例子；$$\\left{\\begin{aligned}3x+2y-4 \\-x+2y-2\\end{aligned}\\right.$$ **可以把这个方程组看作对[x y]向量的一个已知的矩阵变换:**而且变换后的结果已知 在这里是[-4;-2]$$\\left[\\begin{matrix}3 2\\-1 2\\end{matrix}\\right]\\left[\\begin{matrix}x \\ y\\end{matrix}\\right]\\left[\\begin{matrix}-4 \\ -2\\end{matrix}\\right]$$ 注意：矩阵的列向量反映了矩阵是如何变换的，分别告诉了你基向量变换后的位置——也就是求[2,2] [3,-1]坐标系中的[-4，-2]对应到直角坐标系中是多少 所以问题变成了 哪个输入向量[x,y] 在变换后会成为[-4;-2]。 由5.线性方程组那一节，矩阵A代表一种线性变换，所以 求解Axv意味着我们去寻找一个向量x，使得它在变换后与v重合。 这里有两种结果，取决于矩阵变换是否降维（行列式是否为0）。 如果行列式为0，意味着要么任何输入向量都不会变换到给定的输出向量，要么有无数个向量都会变换到给定的向量。 以二维空间为例。前一种是二维输入向量的空间压缩成了一条线，而输出向量在线之外；后一种是输出向量恰好在线内，所以所有输入向量都满足。 行列式不为0是我们今天重点探讨的，意味着线性变换后维数依然相同。 每一个输入向量都对应一个输出向量，反之亦然。 下面是行列式不为0（不降维）的情况。 来看一个猜想：$$\\left[\\begin{matrix}x\\y\\end{matrix}\\right]\\left[\\begin{matrix}1 \\ 0\\end{matrix}\\right]x\\longrightarrow T\\left(\\left[\\begin{matrix}x\\y \\end{matrix}\\right]\\right)\\cdot T\\left(\\left[\\begin{matrix}1\\0\\end{matrix}\\right]\\right)x\\\\left[\\begin{matrix}x\\y\\end{matrix}\\right]\\left[\\begin{matrix}0\\1\\end{matrix}\\right]y\\longrightarrow T\\left(\\left[\\begin{matrix}x\\y\\end{matrix}\\right]\\right)\\cdot T\\left(\\left[\\begin{matrix}0\\1\\end{matrix}\\right]\\right)y\\T(向量)是指向量线性变换后$$如果这个情况合理的话，我们能很轻松算出[x;y]的解。因为目标向量[-4 -2] ，两个基向量线性变换后的状态(矩阵)都是已知的。 可惜这个猜想是错误的。对大多数线性变换来说 点积会随着变换而改变。 比如说，有两个向量大致指向同一个方向，点积为正，变换后被拉远，像这样它们的点积就变成负数了。类似的就算两向量相互垂直 点积为零 比如两个基向量，我们也无法保证它们在变换后依然相互垂直。 那些不改变点积的矩阵变换，有一个特殊的名字：正交变换。 它们使基向量在变换后依然保持单位长度、且相互垂直，可以想成是旋转矩阵， 相当于作刚体运动没有拉伸压缩或变形。 在正交变换中求解非常简单。因为点积不变，所以已知的输出向量和矩阵的列向量的点积，分别等同于未知输入向量和各个基向量的点积。 举例：$$\\left[\\begin{matrix}cos(30°) -sin(30°)\\sin(30°) cos(30°)\\end{matrix}\\right]\\left[\\begin{matrix}x \\ y\\end{matrix}\\right]\\left[\\begin{matrix}1 \\ 2 \\end{matrix}\\right]\\x\\left[\\begin{matrix}1 \\ 2 \\end{matrix}\\right]\\cdot\\left[\\begin{matrix}cos(30°) \\ sin(30°)\\\\end{matrix}\\right]\\qquady\\left[\\begin{matrix}1 \\ 2 \\end{matrix}\\right]\\cdot\\left[\\begin{matrix}-sin(30°) \\ cos(30°)\\end{matrix}\\right]$$虽然这个思路对大多数线性方程组都不成立，但它给了我们一个方向去思考，有没有另一种对输出向量坐标值的几何解释。 这个由第一个基向量i和未知的输入向量「x;y]组成的平行四边形。面积是x轴基向量i 乘以 输入向量 的y值。 于是我们可以用这个平行四边形的面积来表示y值。 当然面积是有向的。如果向量的v坐标为负，则四边形面积也为负。 （前提是你把基向量i放在第一位来定义平行四边形） 同样观察由未知的输入向量，和第二基向量j组成的平行四边形。 以此类比：看三维空间。 对于向量的z轴坐标，可能你的第一反应是向量在z轴上投影的坐标值，是它与第三个基向量k的点。但…… 更好的方法还是考虑基向量：考虑向量与另外两个基向量i和i所组成的平行六面体，底面是由基向量i和i组成的正方形，面积是1。 所以它的体积值等同与它的高 也就是我们这个向量的z坐标 同样的，用这个奇怪的方法来描述向量在某一个轴上的坐标值，可以先考虑向量本身，和除这个轴之外的两个基向量组成的平行六面体，然后其体积就是对应的坐标值。 另外 我们可以讨论平行六面体体积的有向性，就是之前在行列式视频中提到的右手法则。于是列向量的顺序就很重要了，坐标的正负性也有了意义。 注意考虑有向面积，这对于我们拓展到高维的计算很有用，也就会明白“为什么变换后行列式是这么算的。 $$\\mathbf{x}det\\left(\\left[\\begin{matrix}\\mathbf{x} 0 0 \\y 1 0 \\z 0 1\\end{matrix}\\right]\\right)\\qquad\\mathbf{y}det\\left(\\left[\\begin{matrix}x 0 0 \\\\mathbf{y} 1 0 \\z 0 1\\end{matrix}\\right]\\right)\\qquad\\mathbf{z}det\\left(\\left[\\begin{matrix}x 0 0 \\y 1 0 \\\\mathbf{z} 0 1\\end{matrix}\\right]\\right)$$ 注意加粗。 好了 为什么要把坐标值和面积或体积联系起来呢？因为当你做矩阵变换后，平行四边形的面积不一定保持不变，可能成比例增大或减小。 成比例放缩意味着，我们要引入行列式了—— 由4.行列式那一节：行列式代表测量一个给定区域面积增大或减小的比例 举个例子(一个新的平行四边形)：$$\\left[\\begin{matrix}2 -1\\0 1\\end{matrix}\\right]\\left[\\begin{matrix}x \\ y\\end{matrix}\\right]\\left[\\begin{matrix}4 \\ 2\\end{matrix}\\right]$$比如 考虑一个新的平行四边形，第一条边是变换后的第一基向量(也就是矩阵的第一列)[2 0]。第二条边是变换后的[x,y] 那它的面积是多大呢？ 变换前的面积是未知输入向量的y坐标值，所以变换后的面积等于矩阵的行列式乘以y值 所以可以用输出的平行四边形面积，除以矩阵的行列式计算出y。$$y \\frac{area}{det(A)}$$那怎么求变换后的面积area呢？ 因为这是一个线性方程组，我们知道线性变换后的向量[4 2]。 既然我们已知最终变换后的向量,那么 可以构造一个新矩阵 第一列和我们原先的矩阵相同[2 0],而第二列是输出向量。 然后取这个新矩阵的行列式—— 你看，我们只需使用到变换后的两个向量，也就是矩阵的列向量们和已知输出问量，就能计算得出未知输入向量的y值。方程已经解好一半了。 $$area \\left(\\left[\\begin{matrix}2 4 \\0 2 \\end{matrix}\\right]\\right)\\qquad y \\frac{area}{det(A)}$$我们可以用同样方法得到 x 值。 我们之前定义的平行四边形回头来看。 (有向)面积为输入向量的x值 由未知向量和j基向量构成，而变换后的它 由输出向量和矩阵的第二列组成。面积增大的比例是矩阵的行列式，所以输入向量的x值是新的面积除以变换矩阵的行列式。 于是可以创造一个新矩阵来计算变换后的平行四边形的面积，这个新矩阵第一列为输出向量 第二列和变换矩阵相同。 所以和上面的错误猜想一样，我们仅使用到输出部分的数值(这些我们在最初线性方程组里已知的数值) ， **就能解出x值。**是不是很神奇！ 这个线性方程组的解法 被称为克莱姆法则"},{"title":"英语随笔","path":"/wiki/NOTE/英语随笔.html","content":"Day1 Day2you are such cunning and eccentric. you know society is turbulent now,you still rob the peasant’s beast. This guy is really poverty and just eat cabbage dipped in vinegar everyday. i think you are discriminate with him. he is crude and naive like a primitive person. so you should esteem him in an appropriate way.i will appreciate you for him.i bet you will become a society prime prototype. this will facilitate social atmosphere about personal virtue. believe me. this is social transition. everything is transient. In retrospect, i know you are a earnest man with good prestige precedent. that’s all. i am not malignant to told above. this is a towel,wipe the sweat off your face and beard. you are thirsty,isn’t you? i am going to buy a beverage for you. 英语中 “I”（我）无论在句首还是句中，均需大写，属于基础语法规则。 Day3During the process of being granted this honor,i encountered many obstacles. An impressive curriculum is no matter how you eminent or having a great deal of wealth,you must heighten your inward stability and spiritual strength, retort that with your actions when faced with doubts. Not being scolded by others is transparent person. Well, i always record my fragmented rational thought in my pamphlet. For those merchant who report revenue in accordance with the law, we should grant the badge to them. This can spur their enthusiasm , credibility and initiative. At that novel murder ,the girl strolled with her friend . it was a damp rainy day. the suspect peep at them and utilize his instrument to approach them without a sound. With a gunshot , all youngsters gallop to all directions. Then that girl’s belly got injured. The criminal suspect linger at the crime scene for a few minutes. Cops think that her good friend has a criminal prone. The public hope to uncover the truth as soon as possible. Otherwise,the citizen(civilian) would fright by the murderer and the city’s civilization will distort. 为了背单词，动词没加过去时。 cue plot , rake sake , belly abdomen , mud clay , mechanism merchant mechanical , bandage badge Day4plug bolt , fell brutal reckless ruthless , strip shedding When Little Gezz sent a fax to his foreign friend, he received a photo of an exotic view. He still remembers the embarrassing time he spent fooling around with his friends. He was running, turned around, and wasn’t paying attention to what was behind him—so he bumped into a girl. He apologized for the foolish behavior caused by his carelessness. The head teacher convicted him without hesitation, as this anticipation was what all his classmates had expected. His behavior lowered the school’s criterions. embrrassed修饰人 embrrassing 修饰物 ，事 This is the warehouse’s inventory ,please sign your signature . Besides(additionally), this is the directory of your superiors. If something happens,call them promptly. After a short while ,they will come to have a rehearsal. the majority of civilians have their ballot. Because of your vulgarity, recklessness and vanity, you are the exception. You have the typical traits of someone from the lower class. Maybe you have the syndromes of flash back. Even a butcher can become a pilgrim. Awakening is the process of shedding labels and letting go of all attachments. Eating bacon and drinking tea both have a sense of tranquility. Even the most insignificant and marginal matters should be fully immersed in. should be approached with full engagement 全身心投入 Mr.Detective ,don’t let your hound hound me or else i will put my stick penetrate into it as easily as i would pinch a mosquito. peasant had swept the weed and irrigate the field,the land is slippery and full of damp mud .This will augment crops’ nutrition and harvest. Let’s look forward to their maturity and ripe. His dad is a navy colonel configuring any naval resources and a magistrate appointed by coalition and summit. He keep us away from strife. Maybe he have internal discounts or coupons. If you want to buy a McLaren, contact with him. granted - appointed column 柱子专栏 colonel 上校 weapon coupon Don’t be pessimistic .This herb can cure the herd’s plague and infections. I have obtained the testimony to prove it by spying day by day. Your thinking is too rigid. When you do pull-ups and hang,don’t shrug definitely. This way you can engage your back muscle and stiff spine. If you just watch and don’t act, you’ll always be a spectator. （一）必须加冠词的情况 不定冠词（aan）：泛指 “一个”，用于单数可数名词前 定冠词（the）：特指 “这个 那个 这些 那些”，或指代已知、唯一的事物 （二）不加冠词（零冠词）的情况 不可数名词表泛指时 复数可数名词表泛指时 专有名词前 固定搭配中 Day5Under the indication of God,Mr.Hospitt alleged to dedicate all his body and mind to the cause(enterprise) as a candle（wax) burning itself. He wants to release periodicals periodical . But as soon as he engage in work, he finds he is tired. If the work time is over , He is kidnaped by his phone and social apps , instantaneous lying on the couch. This has become a vicious circle. So this day he goes outing. This aggravate him and he frequently wander alone the inlet when he feel hysteria. Beside the inlet is a cemetery which is full of various tombs. He just thinks that why people are keen to make distinctions even after death? These little cement stones segregate humans from paradise and hell. He fills a jug with water and sprinkles the flowers. Maybe this is the only way to repay nature and console his broken heart because of malpractice. He doesn’t want to become a notorious guy that lives in shames. The tide rolls in and rolls out, just like the ups and downs in life. This time , he deems that he has got the tranquility from the tide wave——not about maintaining fragile perfection but keeping positive even if at lowest ebb. Satire ,cheer , doubt ,urge ,conceit（arrogant） , inferiority……all voices was receding. Only the peaceful self stands still, accompanied by the gentle breeze, accepting everything. The tide rises and falls， comes and goes…… satire , irony Have you digested the superb digest from the periodical that I selected for you carefully? Don’t be harassed by external disturbances.（你理解了我从这个期刊精心挑选的高质量摘要了吗？） I managed to wedge the last book into the already full shelf.（我好不容易把最后一本书塞进了已经满了的书架。）We wedged ourselves into the crowded subway car during rush hour. I incorporate a corporation with my partner , and we cooperate coordinately. My duty is to audit bills and Michael is responsible for legal counsel（like a attorney）. We communicate swiftly and share information transparently .All plights or dilemmas’ intimidation is nothing. We bond with each other. In front of the fence is the river contaminated by litter（garbage,trash) thrown and discarded away by rural neighbours. This is the small river where my parents used to swim and play when they were children. The ecology in rural areas is polluted like this, and no one is taking care of it or disposing of it. rural rival , paw claw flaw. The Formula 1 racing car is roaring and the racing athlete is mutter. Rio is not Brazil’s capital. All people forge a stereotype and prejudice about this tropical city by coincidence without prior agreement（不约而同）. and so forth , and so on , etc , the case in point is，for instance ,such as . providing …… in case …… hence (因此；从现在起) henceforth day6 by degree There is an important distinction between this kind of role-playing and what is normally called positive thinking. In the latter, you are telling yourself that you are as good as Michael Jordan, while in the former you are not trying to convince yourself that you are any better than you believe you are. 行为 She was discharged from the police force for bad conduct. 实施 Laboratory and field tests have been conducted. 引导 The guide conducted us around the ruins of the ancient city. The whole article highlighted the center, lateral expressed you to dad’s care. The rocket then took a lateral course straight for the Moon. At the gloomy pit (mine cave), this pitman’s sole(唯一的) shoes of the sole(鞋底) is worn(磨) flat(平). So he just walking barefoot with many blisters on his foot. After this experience, he detemines to depart the pit and set up a stall. blister swelling sore Numerous anonymous letters of complaint pointed to this man from different perspectives simultaneously. Apparently they are stepping up their demands for local autonomy. The shepherd is tending to his sheep. He sets up the tent at every new place. put the cart before the horse. 本末倒置 Once more, puffs of cooking smoke curled up in the air. The fragrance of food permeated and diffused in the air. But Jake,the school bully who want to torture Dave. Dave’s hands shook as he walked to the tree, where Jake leaned against the trunk, his stern eyes fixed on him.”Give me your lunch money,” he growled, reaching for his bag. Suddenly, a person appeared behind the tree, gazing at him. The mysterious person said “F*ck you piece of shit.” in an indignant tone. Jake cheeks’ expression changed and his rage started to decay. “I… I’m sorry,” he murmured, galloping away. The mysterious man is Dave from ten years later who came to cure him. Along the shore, there are many straws and wheat, supporting a group of people. This isle country hasn’t many population, but all domestic resident both have patriotic heart and they hate traitor. They worship their culture, unite as one to repel any conquest. v. hate n. hatred wheat 不可数 literally At the chamber, Louis is lying on the chair ,depressed. A4 paper is prone to scratching his fingers. This prize is set for these sophomores who have good quality as models for students. The recipients of prizes had their names printed in the paper. The mayor would give them a compass embeded with rubies. In the village, I use a water pump to pump water on fixed days of the week. I listen to the sound of sneakers rubbing against the ground,which induces me to play against with my friends on the court. But I still did not idle for a single minute. This apparatus produces explosive missile. According to the statute, It was decreed that the following day would be a holiday. You have breached it and make the staff gloomy(dim) . day7This stock is exceedingly awesome which gives me dividend, i even intend to emigrate. Now with innumerable money , i want to buy a helicopter , hovering around the blue sky like an eagle sheering in front of sheer mountain. every dialect has its own idiom. Every insect has its antenna. Reckon the circumference of this circle and the volume of this sphere or else you are the coward. In this progress you need get the radius or diameter of circle. The love and support of his family sustained him during his time in school. This sustain his argument that “love is biggest power propelling anybody” my milk is expired and i need handful cash to buy new. Beside i am supposed to dump the trash to dump. In this bizarre serial , This feeble juvenile with worn-out and shabby clothes submerge on bush when detective detect him. Unfortunately, he wrenched his ankle. Because he made the fraud. This mortal has a shield like Captain America and shield all mortal assault. Killer hurl to him. The progressive have progressive and advanced idea. They don’t allowed ambiguous people to join their department even their college dean and colleague in corporation. In this corporation,everyone is a coordinate counterpart. 这句话的意思是 “在这家公司里，每个人都是彼此协作的对应角色”。 Even if the tariffs are high, we conclude a transaction and are exempt from reproach from boss. The strategy of alternating negotiations is effective. We get our copyright and we will get the publicity belonging to us . This magic is optical illusion and we can’t find any indicative clue to expose the truth utter. Don’t lower your head, the crown will fall off. Emperor (monarch) is liberal who is keen on supporting jump-rope amateur. House ‘s ornament is beautiful especially the China knot. wagon withstand the heavy weight .You should replace it with cart. Four seasons remain the same every quarter. bacterium germ mutter murmur abdomen heel day8This project’s essence is an intrigue. That stupid guy deceived us to come to this bleak site which is so barren that any crops or seeds can’t sprout. He should be sent to gaol. How disappointing that our big deal is postponed again! Henceforth I will never trust this dude. Apply cement and plaster on the wall and then paint it, then pick up the axe to chop, cut and hack woods. This solitary old person gets out of bed with messy hair and sleepy eyes, puts on slippers, picks up a broom and sweeps the floor. There’s nothing like a brisk walk on a cold day! You can open the amplifier and play pleasant music. Don’t attempt to tempt me into drinking that poisonous wine. It spills on the table. This is a cheque and that’s already your legal possession of property. This brutal superior picks up the whip and whips his inferiors to tame them and humiliate them in front of the public, which is snapped by the patriots. The siren of the police car is getting closer and closer. Come to Shandong and you will receive a cordial welcome there. After three hours of intermittent rain, the game was abandoned. Punctual people are discreet about their time and will often add a few extra minutes to give themselves some ample room. This is not a drawback. This wind is spectacular, magnificent, grand, splendid, majestic. He takes a nod. Boss declares his intention and gets unanimous agreement because everyone wants to end this session early. The Golden Hook is a touching story. lap abdomen belly shank butt hip elbow back shoulder ankle knee， forearm ，upper arm , neck ,eye ear nose mouth, throat,chin brow eyebrow forehead beard chin jaw rib thick thin deep shallow wide narrow bird nest day9Peter is contemplating and groaning while closing the shutter. His intuition tells him that something is wrong. He is thinking why this kid betraysrebels him? That’s sarcastic. Peter just endows her and covers her with a quilt(blanket) in the middle of the night when this girl is an infant. Peter thinks she is his intimate intimate. Now he concedes he has been cheateddeceived, which is obviously certified countless times. She clearly said his advent is glittering to her and has the prospect that they can accompany each other. Maybe he is not good at articulating, but he is rigorous. Surely it doesn’t mean that this makes her feel oppressed or inhibited? Is he a dull man? Thinking of this, he becomes irritated and doesn’t want to pay attention to these trivial matters. “Screw it! I don’t give it a shit.” Next, he wants the woman to reclaim the money for him. The government took a hard line on the strike and tried to rein back inflation. To a society which has lost its orientation, people of all ages and both sexes are boycotting this unreasonable measure. For merchant，this hen is the best merchandise. Trim the shrubs with shears. young fellow , based on my experience,your bribe will yield unexpected gains that cannot be express numerical. You will be designated a superior! torture torment suffering oval traydishplatesaucer tubbowlbasinpotpan dumb deaf mute lame limp blind cripple day10This adolescent is undergraduate who is hypocrisy. fabricating a procedure to sign a deed which is unfair for peasant. He is such tiresome and nasty so that I will burn all my contracts with him to ashes. Corruption corrodes public confidence in a political system. oriental has a long and rich history,survived by growing grains. History moves in zigzags and by roundabout ways. This ancient country has huge potential and latent benefits in this field. orthodox recipe is put peeled pea into the pan and fry it. This is perpetual flavor in my hometown. Snow is melting , he contrive to rally us in the valley and exchange the hostage to cops. My patron send me the correspondence that appoint me as an embassy. This elegant lady wearing a pearl necklace and violet wrap(scarf) is a writer. She stuff a lot of new elements and omitted old ones in her literature. It can be seen that she relish this career very much dentist is no need to wear helmet. So he has been layoff and can’t get his allowance. He is ashamed by the scandal which may be his lifetime(lifelong) stain. If it got out now, that would be disastrous. She slipped to the toilet and turned on the projector to project onto the wall. simplicity and plain color is actually the revolutionary design. This is a matter of the utmost choice so that he do his utmost to persuade me not to go. No player has a divine right to be in this team. His ideology is so plain that she could divine what he was thinking just by looking at him. One harsh criticism would send her into the depths of despair. She just thinks she is discarded from community, pleading for her mistake. By the way, maybe you are too rigid to treat her because you always wants to impose your will on other people. merit virtue advantage latent lateral …… so that …… 为了 so……that 太……以至于 hysteria hypocrisy obsolete omit eliminate defect drawback shortcoming flaw disadvantage （区分claw flaw paw） vase drum drug drag divine day11For this robust and vigorous man, his beloved country is filled with his advocates adoring him. The pond‘s water looks transparent, reflecting a faint light. Suddenly there is a little foam on it like the foam on yesterday’s reservoir. The curtains are tightly closed and there is no light. He is on the mat, stooping to pick up the handy rag then his arm hits the stool leg, creating a bruise that makes him sore. The short paradox information is scattered, which fusses me into thinking. He had no news to impart, just put forward (propose) a proposal, which can be the paradigm. We have been accustomed to his bureaucracy. I feel sorrow for the odds you have suffered, and I make an oath it will never happen again. Please don’t discourage us. She is so fatigued that she was absent for nine consecutive days. Oil and grease will rot and corrode the rubber of your tires. After receiving a summons from court, he even couldn’t summon the energy to get out of bed. Cosmic gauges are innumerable. This circus has tiger specimens. Veins showed through her pale skin. secretary. She intrigues to refute the appeal. Don’t be dubious or suspicious. After the tumour is cured, you should refresh your life and commence to do something different. He was charged with charging unreasonable fees at a car charging station. Set sail and cruise. sole sore gadget guage day12he is shrewd and perceive hazard in advance(ahead of time), calling on everyone to reach a consensus on retreat. After prudent thinking , he proclaimed that bid 2000RMB for the painting. Everyone thought he was clumsy but he thought that he is sober. Police suspect a local gang which distort the truth and incentives of government decisions. Giving you a counsel: you should boil a kettle of hot water and wear a scarf , wrapping your wool overcoat tightly. At last, take off your socks and switch to long stocking. If you disregard me, you’ll get flu. The old woman was proficient in her loom which is auxiliary tool. A clay mould is used for casting bronze and brass statues . The woman looked at me with a twinkle in her brilliant green eyes. You just touched the threshold of this domain and started preparing to surrender. you will lagged behind your peer. This legendary pirate with a glorious history was ultimately expelled. The eagle soaring and hovering. I offered my heart to the bright moon, yet the moon shines on the ditch instead. I must go now. incidentally, if you want that comb I’ll buy it to you. Just wait for my envelop and come to my banquet. The development of things usually advances in a tortuous way and rises in a spiral manner; it can never be smooth sailing. She cast a worried look, her brow frowned as she thought about the so-called correlation between late nights and poor health—an idea that tightened its grip on her. Yet she couldn’t ignore her obligation to finish the work, so she stayed grounded and focused on her tasks. He cast the rugby ball to me, and I gripped it. correlation correspond day13 His standpoint swings abruptly and he spit on the ground, conceiving he was innocent without any guilt. She undertakes the task, prepares for the preliminary work with missionary zeal like a clergy(priest) in cathedral, and keeps herself discreet. It seems that her lamp of life flares brightly. I’d rather not dwell on the past in which I dwelled in the Northwest as a refugee for ten years. There was a moan of pain from the injured man. This tool’s usage is originated by me and I hope it’s intelligible to you guys. It was up to him to take the initiative in repairing relations. This is just an initiative thought. The speech found an echo in the hearts of many of the audience although it was an echo of what she had talked about many times before. You have indulged in cyberspace and been addicted to Grand Theft Auto IV. That’s obsessive. This slender girl escaped the slaughter(massacre). This wretched princess was not recognized and mingled with the crowds whose tears mingled with the blood on her face. When enemy troops with rifles launched a radical offensive against the headquarters, the youngster, who regarded the battlefield as his tomb and followed the imitation of the martyrs(predecessor) he admired, was determined to contribute to his country; his exemplary role finally helped invert the battle situation, pushing the army’s morale to the climax, with cheers of victory hailed around. This girl, whose hair fell over her shoulders in a mass of curls, curled into a ball and went to sleep. The tanker began to spill its cargo of oil. fixture 固定的xx pregnant conceive prudent discreet day14The two corporations have been fused into a single organization. The mayor was present and cut the ribbon for the combination. Two cooperative cooperate with each other cooperative, menacing the other companies. ribbon rubbish Let’s put some music on the stereo. There is a frog in cave. He staggered into the room, naked except for a ragged garment; a glance at his flushed face told everyone he was unwell. His spouse is running in the meadow lawn. Buying a cigarette at grocer The sovereign bureau, which is notable for respecting regional autonomy, will exert strict checks when allowing institutions to enroll students, and no entity is exempt from this rule, inspiring awe among the public. If the steamer is unavailable, taking the shuttle is a practical alternative. Farmers checked the optimum time for harvest via aerial surveys, and the fresh crops were then transported through the mountain corridor to the city; the marks on the box clearly denote their origin and quality. Guests sat in the warm lounge by the fireplace, chatting with the amiable host. Someone accidentally knocked over a razor on the table, and when they reached for it, a vague shadow seemed to vanish at the door—no one paid it much mind. When writing about capitalism, the professor reminded students to include a detailed bibliography. The school will soon nominate candidates for the academic award, and the competition is expected to be fierce; no one wants their hard work to end up as a forgotten skeleton of an essay. A new monument was built to honor those who fought for water conservation. Nearby, the once dry brook has slowly regained moisture, becoming a small heaven for local wildlife. kidney stomach lung liver day15第一段：节日前夕的公园场景 On the eve of the festival, families gathered in the park—children scramble to sit on the bench, while parents pretend to be amused by their games, though a faint perplex lingers, worried about the remnant tension from the recent small riot. The benign breeze carries the scent of fresh flour from nearby bakery, and the gorgeous sunset casts a warm glow over everyone. 第二段：维护和平与日常节奏 A militant group once tried to disturb the peace here, but the locals’ reciprocal support helped disperse them quickly. Now, the park’s attendant checks the infrared cameras regularly, and a locomotive’s distant horn sometimes breaks the quiet, a gentle reminder of the city’s rhythm. disperse dispute 第三段：老人的日常与处事态度 An old lady keeps a small purse in her bosom, its brim frayed but clean, and she never lets a lapse in attention make her lose it. She doesn’t believe in superstition, but she always asks for consent before sharing her homemade snacks with strangers, her enthusiasm for connecting with others never fading. 第四段：路边摊区域 The government set up a special zone nearby to boost local businesses, with tax breaks as an incentive for new shops. 第五段：公共设施与安全提示 The community added a slot for reporting safety issues at the entrance. Posters nearby clearly state that any act like rape will be severely punished, to keep the neighborhood safe. 第六段：一个爱憎分明的正常人 A sane person will not seek others’ consent for everything. For the wicked, it always pricks them; for the good, this blow comes like a gentle spring breeze. landlord landlady inhibit inhabit exhibit virtual virtue day16第一段：中世纪城堡的建设与防御 The lord allied with the nearby tribe to consolidate his castle—they used timber and cement to build a solid wall, dug a deep trench around it, and ensured no one could easily breach it. 第二段：顾问的假期规划与日常s The consultant planned a vacation abroad for his vocation (to cooperate with overseas clients), so he first applied for a visa; during the trip, he dined with locals, raised a toast to friendship, and later retrieved a piece of cloth with unique texture to knit a small bag and tie a neat knot. 第三段：未开发小岛的自然探索与景象 On the virgin island, a young maiden walked along the shore—she could sniff the fresh moss on rocks, spot a distant whale spraying water, and used a canvas to sketch the beautiful scenery. spot n. 斑点污渍， 地点场所 v.注意到，发现 第四段：叛国争议引发的激烈冲突 A dispute over treason broke out in the kingdom; the lord mobilize his men to stop the vicious rebels—some rebels were lash to control them, the intense chaos made people shout in panic, and a few soldiers were even paralyze by fear. 第五段：建筑群的维护与单调任务 The solid compound needs regular care—workers ventilate the inner rooms, use a hose to clean the yards, and the muscular guard checks every detail; whereas the monotonous cleaning work feels tedious, everyone knows it’s necessary to keep the place safe. day18第一段：教育场景——学生训练与考核 The foremost requirement for pupils in the training camp is to control their impulse; they undergo strict drills and face close scrutiny during every proceeding, irrespective of their background.训练营学生的首要要求是控制冲动；他们接受严格训练，每一项流程都要接受细致审查，不论出身如何。 第二段：乡村农业场景——自然与劳作 In the humid jungle on the edge of the county, farmers apply fertilizer to the fields, and soon the pear trees blossom; they store mutton and fresh pears in the cellar, while a coil of rope hangs on the porch near the bulb.在县城边缘潮湿的丛林里，农民们给田地施肥，不久梨树便开花了；他们把羊肉和新鲜的梨存放在地窖里，门廊上靠近灯泡的地方挂着一卷绳子。 第三段：医疗健康场景——病症与补救 The toxic plant’s odor can sting the skin and even handicap function of breathing; the doctor wrote a prescription for the remedy, and the thermometer showed the patient’s fever was starting to diminish—the wholesome tea proved apt for recovery.这种有毒植物的气味会刺痛皮肤，甚至损害呼吸功能；医生开具了药物处方，温度计显示患者的体温开始下降——这款有益健康的草药茶被证明非常适合恢复。 第四段：社会安全场景——防范与处置 A burglar attempted to break into the enclosure of the joint flat, but the veteran security guard acted without hasty decision—he used an elastic rope to restrain the thief, which warranted no violent action, and then detached the surveillance footage as evidence.一名窃贼试图闯入联合别墅的围栏，但资深保安并未仓促行动——他用弹性绳索制服了窃贼，这种方式无需使用暴力，随后拆卸了监控录像作为证据。 第五段：社交情感场景——婚礼与氛围 The bride in a noble dress stood on the verge of the garden, her beauty dazzled everyone; albeit the groom was late due to a trivial matter, she remained tender and didn’t grieve. The humorous toast by the best man evoked bursts of laughter, making the reception warm and joyful.身着高贵礼服的新娘站在花园边缘，美貌令人眩晕；尽管新郎因琐事迟到，她依然温柔，并未悲伤。伴郎幽默的祝酒词唤起阵阵笑声，让接待仪式温馨又欢乐。 第六段：职业与行业场景——航空与革新 The aviation company decided to streamline its gross operating procedures; the experimental project, led by a technical veteran, was on the verge of success notwithstanding initial setbacks. Employees needed to assimilate new technical standards quickly, and the internal bulletin used mild satire to criticize inefficient practices, which was apt for promoting change.这家航空公司决定精简其总体运营流程；尽管初期遭遇挫折，但由技术老手主导的实验性项目已接近成功。员工需要快速吸收新的技术标准，内部公告用温和的讽刺批评了低效做法，这对推动变革非常恰当（合适）。 irrespective indifferents albeit albeit tender mild county country verge boundary elastic plastic mutton pork chicken beef day19第一段：边界冲突与威慑行动 The enemy’s formidable forces approached the boundary, a daunting threat that filled soldiers with dread; they deployed cannons and swarmed to defend, hoping to deter the invaders. The conspicuous military buildup failed to stop the desperate attack, which nearly led to a catastrophe—only international sanctions and last-minute negotiations eased the anguish of war. 第二段：果园农事与团队协作 In the sunlit orchard, farmers tended to poultry and picked crisp fruits, while a cohesive team worked to weld broken tools; they stored harvested produce in barrels with tight lids, avoiding thorns on the ground, and the cottage’s chimney curled with thin smoke, marking a peaceful afternoon. 第三段：政治决策与事务维度 The premier insisted on adhereing to principles when handling state affairs, emphasizing that every facet of policy must balance justice and practicality. Even in the face of pressure, he maintained diplomatic dignity, refusing to compromise on core interests. 第四段：认知心理与共情表达 Her cognitive ability to distinguish discrete ideas helped her elicit deep empathy from others; when listening to their anguish, she never diminished their feelings, instead respecting their dignity and offering sincere comfort. 第五段：技术应用与风险防控 The team used a drone to monitor environmental risks, and they had to dilute toxic substances found in the soil—this technical support complemented ground efforts, ensuring the safety of both people and crops. thrust stab poke pierce prick sting bite core interest complement compliment poultry portray day20第一段：正义领域的审判与抗争 In the arena of social justice, the court delivered a fair verdict—those who had persecuted innocent people and inflicted deep wounds were finally held accountable. Their hatred-driven actions failed to crush the public’s will; the authority decided to suspend the unjust policies that had fueled conflict, vowing to eliminate such cruelty. 第二段：文化遗产的传承与推广 The exquisite ancient artifact embodied the intrinsic value of a lost civilization, not a hollow decoration. A cultural foundation agreed to sponsor its exhibition, distributing a brochure to introduce its history. The ticket seller trumpeted its significance and exemplify how traditional crafts could be passed down(传承) as a precious legacy. 第三段：个人道德与生活抉择 Adhering to morality means resisting the lure to indulge in selfish desires or deviate from principles. A moderate lifestyle, not extreme behavior, shapes(v.) noble bearing(举止）; those who remain indifferent to others’ hardships will never elevate their spiritual realm. She wore an elegant gown with embroidered sleeves, living in a conveniently located cottage that reflected her simple yet dignified life. 第四段：政治经济的事务推进 The government decided to convene a meeting to discuss the subsidy policy for small businesses. Amid concurrent challenges, experts adjusted the configuration of resources to avoid contingent risks. This measure helped bolster market confidence and provided a strong impetus for economic recovery; thereafter, many enterprises regained vitality. 第五段：日常场景的细节补充 The obedient apprentice carefully collected every silver of rare material, fearing to waste anything. His humble bearing and rigorous attitude won the master’s trust, proving that even trivial actions can reflect one’s commitment to excellence. lure tempt evoke elicit inflict suspend sustain decoration description embed embody silver sliver suicide subsidy contingent continual exemplify exempt enterprise entrepreneur day21第一段：医疗场景 —— 手术与康复 The complex surgery in the hospital ward aimed to mend the patient’s injured palm; though he endured great agony during the process, the treatment’s positive impact soon became evident, and he gradually regained mobility. 第二段：居所日常 —— 舒适与生活细节 In the cosy cottage with a reasonable layout, she placed the ancient manuscript on the table, its pages damp with morning dew. Outside, a fluffy lamb grazed nearby, while she sliced fresh cucumber, sprinkled a pinch of powder on the dish, and used a rubber mat to prevent slipping—simple joys filled the air. 第三段：自然现象 —— 日食与未解之谜 A rare eclipse darkened the continent, leaving people pondering the ancient riddle of celestial movements. Such astronomical events were once scarce in recorded history, making this sight both awe-inspiring and thought-provoking. 第四段：社会秩序 —— 承诺与礼仪 During the king’s long reign, he urged citizens to pledge respect for others, as mutual courtesy would constitute the foundation of a harmonious society. He also warned against petty conflicts that could disrupt public peace. 第五段：情感与成长 —— 坚持与代价 She was reluctant to swallow her pride and admit mistakes, but the fear of letting her team collapse forced her to reflect. She then elaborated on her plans during the interim period, adjusting the tempo of work to ensure retention of key tasks. The hard work took a toll on her, but beneath her fatigue, she continued to nurture her skills and grow. parliament(Washington,D.C.) day22第一段：冲突与流亡的危机时刻 Enemy forces launched a sudden raid, triggering a fierce clash that filled people with rage. The authoritarian regime issued a mandate to exile dissenters, while some tried to smuggle relatives to safety to preclude harm from the imminent danger. 第二段：乡村小屋的日常图景 Beyond the hedge stood a cozy cabin by the brook; inside, stacks of lumber leaned against the wall, and a shelf held a bottle of ink and a folded handkerchief. She tasted the spicy sauce, her tongue tingling, and did not presume to add more—she then tucked the blanket around her knees, listening to the wind rustle through the shed nearby. 第三段：个人情感与生活坚守 The pregnant woman felt weary but refused to give up—she strived to overcome hardships, though some jealous neighbors spread rumors. She clutched her husband’s handkerchief, showing obedience to moral principles and refusing to struggle with trivial conflicts; a gentle rub of her eyes wiped away fatigue, not despair. 第四段：职业技能与艺术表现 The skilled acrobat wore a bright cap, performing rotary spins and smooth curves alongside linear movements—his synthesis of skills was deep, not superficial, earning cheers from the crowd as he hoisted a small flag mid-air. 第五段：社会认知与群体凝聚 False propaganda often reinforces stereotypes, but the homogeneous community maintained solidarity to resist such biases. They rejected stale ideas, used monetary support to help those in need, and overcame inertia to promote progress, proving that unity can break prejudice. 第六段：规则与行为的边界 The school mandate required strict obedience to safety rules, which helped preclude accidents during outdoor activities. Students did not presume to violate the regulations, and their steady adherence reflected a sense of responsibility beyond their years. invoke evoke day23学术研讨与规范坚守 The symposium focused on academic integrity, with experts emphasizing that plagiarism—an overt violation of ethics—must be firmly rejected. The predominant view was that a coherent research paper should reflect one’s own speciality, and the implication of improper citation could harm academic credibility; moreover, scholars should guide intermediate researchers to uphold principles. 战友使命与传承信仰 Comrades gathered in the dim light of a lantern, their faces solemn as they recalled how their predecessors had fought to smash oppression. It was imperative to honor their legacy, and no one dared to evade their responsibilities—even when facing a torrent of difficulties, they would not kneel to fate. Their descendants still cherish the spirit of unity, proud to be part of this noble group. 自然边缘的户外图景 On the fringe of the forest, a graceful deer wandered through the underbrush, while a nimble squirrel scurried up a tree. The air was cool, and the branches hung stiff with morning dew; as night fell, the glamor of the starry sky made passersby forget their fatigue, though a faint envy arose for the creatures living freely in nature. 人际摩擦与体面坚守 Her decent demeanor and unique glamor often sparked envy, but she never let friction with others turn her furious. When facing the plight of being wronged, she refused to evade communication, believing that sincere dialogue could resolve misunderstandings—she never let petty conflicts prolong unhappiness. 事务执行与合同规范 The project team comprised professionals from multiple fields; the contract clearly stipulated the timeline, and despatch of materials must be completed on schedule. Due to market changes, costs might fluctuate, so the intermediate supervision link was crucial to avoid delays. All members understood that strict adherence to the agreement was the key to success. day24自然生态 —— 沙漠牧场的栖息地 The camel’s natural habitat in the pasture relies on just enough humidity and moisture to survive; beneath the sand, archaeologists used a spade to uncover a marvelous fossil, evidence of ancient life in this harsh land. The immense desert, though dry, supports a multitude of creatures that have adapted to the bleak resources. 城市图景 —— 设施与区域百态 At the busy intersection near the harbor, a garage stands beside a small pharmacy—residents can bypass the crowded slum area via a new road. Inside the nearby apartments, carpet covers the floors, a clean sheet lies on the bed, and a lamp with a metal rim casts warm light; pipes and a old furnace in the basement ensure basic utilities, while such living conditions are prevalent in the urban fringe. 社会治理 —— 规则与公益行动 The social hierarchy did not hinder the charity parade; volunteers marched throughout the city, calling for care for the vulnerable. During the public health crisis, quarantine measures proved to avail, but any attempt to cover up risks was a sin and a disgrace, sparking public outrage that manifested in peaceful protests. The multitude of participants showed solidarity against injustice. 学术传播 —— 理论与技术应用 Scholars held a discourse on Einstein’s relativity, discussing how to propagate this profound theory without redundant explanations. The appraisal of the new technology showed it was versatile—it could not only duplicate complex data but also simplify analysis, making it prevalent in scientific research. 个人行止 —— 情感与行动选择 She refused to be bound by trivial grievances, choosing to meditate rather than resent others’ mistakes. Though a rash decision once made her regretful, she soon stride forward to ascend the career ladder; the vibrate of enthusiasm in her heart and the surge of motivation drove her to overcome immense difficulties, proving courage conquers hesitation. 节日氛围 —— 日常与欢庆时刻 Amid the merry festival, people hung a wreath on the door, wearing fitting costumes and gear for the celebration. A comedian with a funny accent told comic stories that made everyone laugh—his jokes were literally the highlight of the party. The joy spread throughout the crowd, and every small interaction availed to strengthen bonds. propaganda immense immerse day25医疗场景 —— 治疗与隐患修正 This district‘s therapy center aimed to alleviate patients’ suffering by addressing underlying health issues, not just symptoms. A massive study tested the hypothesis that a small flaw in treatment protocols had led to unnecessary casualty; doctors rushed to rectify the error, though the (grim reality) was that some harm could scarcely be undone. The magnitude of the neglect shocked staff, who vowed to improve safety measures. 社区生活 —— 好客与人际温情 In the affluent vicinity of the city’s upper class residents were known for their warm hospitality—the gracious neighbor often shared homemade cream pastries on her balcony, and even the timid sibling would pat strangers’ shoulders in greeting. The local chancellor made a concession to fund community activities, discouraging children from mischief and promoting mutual respect. No one cared about status whatsoever; kindness was the universal language here. 经济与工作 —— 繁荣与停滞困境 The factory used to prosper, but it began to stagnate due to outdated gear and lack of innovation, eventually falling into a slump. Workers toiled overtime, their sweat soaking through coarse sweaters, as managers debated how to reverse the decline. They had to lubricate old machines and shear redundant costs, but the grim market conditions meant success was uncertain. The factory emitted thick smoke, and some workers chewed tobacco to cope with fatigue, while the magnitude of the crisis weighed on everyone. 突发场景 —— 奇特与正义干预 A peculiar figure in a shady coat wandered the streets, his queer behavior and sham smile raising suspicions—he seemed to target the vulnerable as prey. When he tried to start a flame near a wooden building, a passerby let out a loud scream, and a brave elder rushed to intervene. The man limped away in panic, his mischief failed. The prophet later used vivid metaphor and sharp rhetoric to warn the community about such dangers. hostage hospitality day26封建时代的权力博弈 In the feudal kingdom, the rebel leader signed a pact with the crown’s heir, which stipulated shared control of the regional axis. The former ruler’s arbitrary decisions had fueled rebellion, and the temporal truce(休战) aimed to avoid further bloodshed—rebels agreed to lay down arms(放下武器), while the heir promised to reform unjust laws. 孤儿的荒凉居所 The orphan lived in a desolate cottage with a vacant attic（阁楼）; she would preserve leftover bread, spread a slice with butter, and eat in the spacious kitchen. Though life was harsh, she never lost hope, often cleaning the dusty rooms to chase away rats with sharp claws. 排练场上的小插曲 During the drama rehearsal, a actress grew hysterical after her toe was scraped by something, leaving a small lump on her foot. Her face turned pale with pain, while her partner made her blush by cracking a joke—his striking calmness helped ease the tension, and they resumed practice soon. 日常物品与环境特征 His masculine outfit included striped trousers and a leather accessory; the black-and-white stripes were invariably eye-catching. He careful handled the brittle vase, fearing it would shatter if dropped. 健康与暂时的期许 She suffered from a chronic illness, but the forthcoming treatment offered a temporal hoper. The doctor advised against arbitrary use of medication, emphasizing that patience would help alleviate symptoms."},{"title":"2022蓝桥真题题解","path":"/wiki/algorithm/2022蓝桥真题题解.html","content":"第一题：进制转换 2022 九进制转十进制 为 1475 不解释第二题：用手数 ，4个。 该题有歧义，012X 不算顺子日期就离谱 第三题：刷题统计考试代码： #includeiostreamusing namespace std;long long a,b,n;int total;bool flag=false;int main(void) cinabn;\twhile(1) if(!flag) for(int i=1;i=5;i++) total++; //天数 n=n-a; if(n=0) flag=true; break; if(!flag) for(int i=1;i=2;i++) total++; n=n-b; if(n=0) flag=true; break; if(flag) break; couttotal; 得了80分，剩余时间超限。 正解： #includeiostreamusing namespace std;int main(void)\tlong long a,b,n;\tcinabn;\tlong day_7 = a*5+b*2;\tlong sumday = (n /day_7)*7;\tn=n%day_7; if(na*5) sumday += 5; n-=a*5; if(nb) sumday+=2; else sumday+=1; else sumday += n/a; if(n%a0) sumday+=1; coutsumday; 总结： for 循环多了会超限。 这题解开始都是int类型，我觉得 数据范围是 1~1081 ，怎么也不会超限。 结果还就是超限了。乘法很可怕，long long有奇效。 第四题 修剪灌木枚举 #includebits/stdc++.husing namespace std;long long tree[10100][10100]=0; //记录每一天轨迹 long long maxnum[10100]=0; // 记录每一位 的 最大值 int tail=0; //记录 爱丽丝 坎位置 int N; //多少棵 bool flag=true;bool findx(int locate) //是否重复？ locate = y值 bool ok;\tfor(int i=1;ilocate;i++) ok=1; for(int k=1;k=N;k++) if(tree[locate][k]!=tree[i][k]) ok=0; if(ok==1) return true; return false;int main() int y=1;\tcinN;\twhile(1) if(flag) tail++; //flag 决定 正向进行 反向进行 else tail--; //一轮一天 if(tail==N) flag=false; //到头了 if(tail==0) flag=true; tail=2; //回来了 for(int i=1;i=N;i++) // 这一轮，每棵树 长1cm tree[y][i]=tree[y-1][i]+1; if(tree[y][i]maxnum[i]) maxnum[i]=tree[y][i];\t//最大值 记录 tree[y][tail]=0; //让砍位 为0 if(y1findx(y)) break; //寻找重复点 （重复后结束循环） else y++; //下一天！ for(int i=1;i=N;i++) coutmaxnum[i]; if(i!=N) coutendl; return 0; 这个代码输出的是正确答案。但是运行超限，很伤。 如果把long long 改成 int ，能得这道题一半的分！ 面向规律: #includeiostream#includevectorusing namespace std;int main(void)\tvectorlong long v;\tbool flag;\tlong long n;cinn;\tif(n%2==0) flag =true; v.push_back(n); //奇数偶数 else flag = false; v.push_back(n-1); int mid_num = *v.begin();\tif(flag) v.push_back(mid_num); //偶数就多加一个 for(int i =1;i=(n-1)/2;i++) v.push_back(mid_num+2*i); //倒着输出一遍 正着输出一遍\tfor(vectorlong long::reverse_iterator rit = v.rbegin();rit!=v.rend();rit++) cout*ritendl; for(vectorlong long::iterator it = v.begin();it!=v.end();it++) if(*it!=mid_num) cout*itendl; 面向规律2.0 #includeiostream#includevectorusing namespace std;vectorint getmaxdata(int N)\tvectorint ret(N + 1, 0);\tfor(int i = 1; i = N; i++) ret[i] = 2 * (N - i); for(int i = 0; i N / 2; i++) ret[N - i] = ret[i + 1]; return ret;int main() int N;\tcin N;\tvectorint ans = getmaxdata(N);\tfor(int i = 1; i = N; i++) cout ans[i]; if(i != N) cout endl; return 0; 总结：不要着急写题，在纸上跟着示例模拟一下过程，可能会有数学规律。发现规律后解题会出乎意料的简单。 第五题 X进制数 位数少的数高位补0，然后在进制上 跟随位数多的数 比如 A是 123 B是 4567 A → 0123 ，进制上和4567一样 每一位上的数都是其所有低位数的累计。 比如 123 的 X进制 ，第一位 十进制 ，第二位八进制，第三位五进制 则 123 1 * 8 * 5+ 2 * 5 + 3 如果 进制分别为 a b c ，则 123 1 * b * c + 2 * c + 3 代码： 第六题 统计子矩阵DFS 骗分 #includebits/stdc++.husing namespace std;int mmap[510][1010];int K,N,M;long long total;void dfs(int tx,int ty,int h,int w) if(tx+h=N||ty+w=M) return ; int num=0; for(int k=0;k=h;k++) for(int j=0;j=w;j++) num+=mmap[tx+k][ty+j]; if(num=K) total++; dfs(tx,ty,h+1,w); dfs(tx,ty,h,w+1); else return;int main(void) cinNMK; for(int x=0;xN;x++) //赋值 for(int y=0;yM;y++) cinmmap[x][y]; for(int x=0;xN;x++) for(int y=0;yM;y++) dfs(x,y,0,0); couttotal; 针对列的一维前缀和 + 针对行的滑动窗口 #includeiostreamusing namespace std;int num[550][550];int main(void)\tlong long int total=0;\tint N,M; int K;\tcinNMK;\tint temp;\tfor(int i=1;i=N;i++) for(int j=1;j=M;j++) cintemp; num[i][j] = temp; num[i][j]+=num[i-1][j]; //纵向拉伸 for(int i=1; i=N; i++) //纵向每个点作为初始点 for(int\tj=i;j=N; j++) //横向拉伸 for(int left=1,right=1,sum=0; right=M; right++) //右扩 sum+=num[j][right]-num[i-1][right]; //加右扩值 while (sumK) //左缩 sum-=num[j][left]-num[i-1][left]; //减左缩值 left++; total+=right-left+1; //每次都右扩，直到满足K条件。不满足即为0 couttotal; /*3 4 101 2 3 45 6 7 89 10 11 12*/ 总结： 学到了前缀和（也就是打表） 数据类型选择：今天我写了三道题，都因为 int , short , long long int 这种类型的差别，丢了分。引以为戒。太大了容易爆，太小了有些大数输出不出来。创数组也是这样，长度和数据大小都要考虑。 第七题典型DP 两个思路 考虑2xN和积木的拼接方式，有矩形 和 矩形后多一个方块儿 两种拼接情况出现。 上方块和下方块合并的方式： #includestdio.h#define mod 1000000007long int a[10000001][2];int main() int n; a[1][0]=1,a[2][0]=2,a[1][1]=2,a[2][1]=4; scanf(%d,n); if(n==1)printf(1); else if(n==2)printf(2); else for(int i=3;i=n;i++) a[i][0]=(a[i-2][0]+a[i-2][1]+a[i-1][0])%mod; a[i][1]=(a[i-1][0]*2+a[i-1][1])%mod; printf(%ld,a[n][0]%mod); return 0; 上下方块分明的方式 class Solution public: int numTilings(int n) long long dp[1005][3]=0; int mod=1e9+7; dp[0][0]=1;dp[0][1]=1;dp[0][2]=1; dp[1][0]=1;dp[1][1]=0;dp[1][2]=0; for(int i=2;i=n;i++) dp[i][0]=(dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-2][0])%mod; dp[i][1]=(dp[i-2][0]+dp[i-1][2])%mod; dp[i][2]=(dp[i-2][0]+dp[i-1][1])%mod; return dp[n][0]; ; 数学规律找 Fn class Solution const int MOD = 1e9 + 7;public: int numTilings(int n) if (n == 1) return 1; long f[n + 1]; f[0] = f[1] = 1; f[2] = 2; for (int i = 3; i = n; ++i) f[i] = (f[i - 1] * 2 + f[i - 3]) % MOD; return f[n]; ; 第八题 扫雷暴力() #includebits/stdc++.h #includequeueusing namespace std;int n,m;int total;class nodepublic:\tint x,y;\tint r;\tbool flag; //引爆标志 node(int xx,int yy,int rr,int ff):x(xx),y(yy),r(rr),flag(ff);\t;vectornode q1; //雷 queuenode q2; //排雷int main(void) cinnm; for(int i=1;i=n;i++) int x,y,r;cinxyr; q1.push_back(node(x,y,r,0)); for(int i=1;i=m;i++) int x,y,r;cinxyr; q2.push(node(x,y,r,0)); while(!q2.empty()) int tx=q2.front().x; int ty=q2.front().y; int tr=q2.front().r; for(int i=0;in;i++) if(tr=sqrt((tx-q1[i].x)*(tx-q1[i].x)+(((ty-q1[i].y))*((ty-q1[i].y))))) q1[i].flag=true; total++; q2.pop(); for(int i=0;in;i++) if(q1[i].flag) for(int k=i;kn;k++) int tx=q1[k].x; int ty=q1[k].y; if(!q1[k].flagq1[i].r=sqrt((tx-q1[i].x)*(tx-q1[i].x)+((ty-q1[i].y)*(ty-q1[i].y)))) q1[k].flag=true; total++; couttotal;"},{"title":"其他DP","path":"/wiki/algorithm/其他DP.html","content":"区间dp石子合并 数据范围 ： 1≤N≤300 闫氏dp分析： 状态表示：f(i,j) 集合 ：所有将[i,j]合并成一堆的集合 j-i+1的块，共 !(j-i) 种可能的情况 属性 ：min 状态计算： ( i |i+1|i+2| … | j-1 | j | ) f(i,j) 划分依据为左边的最后一堆 的下标 每一类的最小值 中，再取最小值即答案。 min ( min (i,k) , min (k+1,j) ) 分析第 k 类： f (i,j) f(i,k) + f(k+1, j) + s[ j ] - s[i-1] 求权值时，用前缀和优化一下 #includeiostreamusing namespace std; const int N = 305;int f[N][N];int s[N];int n;int main(void) cinn; for(int i=1;i=n;i++) scanf(%d,s[i]); for(int i=1;i=n;i++) s[i] += s[i-1]; //区间dp 第一步：枚举区间长度 (区间长度为1不用枚举) for(int len = 2;len=n;len++) for(int l=1;l+len-1=n;l++) //最后只剩一堆，所以是=n int r = l+len-1; f[l][r] = 1e8; //截k点 for(int k=l;k+1=r;k++) //对于[l, k] k可以取到 l 对于[k+1, r] ，因为k+1 = r, 所以 k = r - 1, 即 k r f[l][r] = min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); coutf[1][n]; f[l] [r] = 1e8 这一步相当于初始化所有k的集合为最大值，这些集合还没有赋值。 答案则是在所有赋值后的k的集合中取最小值 复杂度： n * n *k , O(n^3) 。 n300 , 两百七十万的运算量。 计数dp整数划分一个正整数 n可以表示成若干个正整数之和，形如：nn1+n2+…+nk 其中 n1≥n2≥…≥nk, k≥1。 我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。 输入格式 共一行，包含一个整数 n。 输出格式 共一行，包含一个整数，表示总划分数量。 由于答案可能很大，输出结果请对 109+7109+7 取模。 数据范围 1≤n≤1000 输入样例: 输出样例： dp写法： 状态表示： 集合 ：f( i , j ) : 所有总和是 i ，恰好表示成 j 个数的和的方案 属性 ：sum 状态计算： ​ f(i , j) ： 根据最小值是1还是最小值大于1划分 ​ （最小值是1|最小值大于1） 最小值是1：数量等同于f[i-1,j-1] 也就是总和是 i-1,用 j-1 个数表示的方案 最小值大于1 ：数量等同于 f( i-j , j) 大于1的每个数，减去一个1，还是有j个数。 所以综上，sum = f(i , 1) + f(i , 2) + f(i , 3) +... f(i , i) . const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main() cin n; f[1][1] = 1; for (int i = 2; i = n; i ++ ) for (int j = 1; j = i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for (int i = 1; i = n; i ++ ) res = (res + f[n][i]) % mod; cout res endl; return 0; 完全背包解法： 把这题抽象成，一个容量为 n 的背包，有 n 个物品 ：体积分别是1、2、 3 … n 。 状态表示： 集合 ：f( i , j ) : 所有从1到 i 中选，体积恰好是 j 的选法的数量 属性 ：sum 状态计算： f(i , j) ： 根据最后一个物品选择了几个来定义划分区间。 ​ （0|1|2|3|...|s） ​ f(i-1,j) | f(i-1,j-i)| f(i-1, j-2i)|...| f(i-1,j - s i) 故有： f[i] [j] = f[i-1] [j] + f[i-1] [j-i] + f[i-1] [j-2i]+... f[i-1] [j-si] //1f[i] [j-i] = f[i-1] [j-i] + f[i-1] [j-2i]+... f[i-1] [j-si] //2 1-2 f[i] [j] - f[i] [j-i] f[ i-1 ] [j] 所以可得 f[i] [j] = f[i] [j-i]+ f[ i-1 ] [j] 同完全背包一样，压缩成一维： f[j] = f [j-i]+ f [j] #includeiostreamusing namespace std;const int N = 1010;int n;int f[N][N]; // 使用前i个数恰好能组成数j的方案数int mod = 1e9 + 7;int main() cinn; for(int i = 0; i = n; i++) f[i][0] = 1; // 使用前i个数组成0，每一个都有1种解法（都不选） //f[0][0] = 1; for(int i = 1; i = n; i++) for(int j = 1; j = n; j++) // 注意，使用二维时需要一个优化，需要考虑当i比j小时的情况和i=j的情况: //如果 ij，就意味着一个也选不上，只能和 (i,i-1) 相同。 f[i][j] = (f[i-1][j]) % mod; if(j = i) f[i][j] = (f[i][j] + f[i][j-i]) % mod; // or f[i][j] = (f[i][j-i] + f[i-1][j])%mod; coutf[n][n]; return 0;/*一维： cinn; for(int i=1;i=n;i++) f[0] = 1; for(int i=1;i=n;i++) for(int j=i;j=n;j++) f[j] = (f[j]+f[j-i])%mod; coutf[n];*/ 数位统计dp计数问题给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。 例如，a1024，b1032，则 a 和 b 之间共有 99 个数如下： 1024 1025 1026 1027 1028 1029 1030 1031 1032 其中 0 出现 1010 次，1 出现 1010 次，2 出现 77 次，3 出现 33 次等等… 输入格式 输入包含多组测试数据。 每组测试数据占一行，包含两个整数 aa 和 bb。 当读入一行为 0 0 时，表示输入终止，且该行不作处理。 输出格式 每组数据输出一个结果，每个结果占一行。 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。 数据范围 0a,b100000000 核心思想：分情况讨论 核心函数 ：count(n,x) : 计算 1~n ，x出现的次数。 题解即 count(b,x) - count(a,x) 。 1~n , x 1 n abcdefg 分别求出1在每一位上出现的次数 举例： 求1在第4位上出现的次数： 1=xxx1yyy = abcdefg xxx 000abc-1 , yyy 000999 ：abc*1000 xxxabc : d1 , abc1yyy abc0efg : 0 d1, yyy000~efg ： efg+1 d1, yyy000~999 : 1000 复杂度：10 * 2 * 8 * 10 1600 10个数字，2次调用函数，8位 ， 10次函数内循环 边界问题： 枚举数字在最高位，情况一 不存在 2.枚举数字 0 ，从001开始取到 abc 。因为不能有前导0。 #include iostream#include algorithm#include vectorusing namespace std;const int N = 10;int get(vectorint num, int l, int r) //数字 l~r 位的数字 int res = 0; //注意：由于vector是逆序存数，所以这里也要逆序 for (int i = l; i = r; i -- ) res = res * 10 + num[i]; return res;int power10(int x) // return 10^x int res = 1; while (x -- ) res *= 10; return res;int count(int n, int x) //1~n 中 x出现的次数 if (!n) return 0; //1~0不计数 vectorint num; while (n) //反转数组，从右往左数 num.push_back(n % 10); n /= 10; n = num.size();//记位数 int res = 0; //special 1 ↓ for (int i = n - 1 - !x; i = 0; i -- ) //从最左边开始遍历计数:求x在第i位的数量 //（针对所有范围内的抽象数) if (i n - 1) res += get(num, n - 1, i + 1) * power10(i); if (!x) res -= power10(i); //special 2 //这里上下是两种情况，上为x左位是 00...x~ab..x的情况，下为x..~x..ef的情况 //逻辑上是两个并列循环，循环条件相同所以放在一个循环中。 //1.num[i] x:0 不计数，不考虑 if (num[i] == x) res += get(num, i - 1, 0) + 1;//2. else if (num[i] x) res += power10(i); return res;int main() int a, b; while (cin a b , a) if (a b) swap(a, b); for (int i = 0; i = 9; i ++ ) cout count(b, i) - count(a - 1, i) ; cout endl; return 0; count函数里，两个!x出现的位置即对于两个特殊情况的解。 1.枚举数字在最高位，情况一 不存在。 for (int i = n - 1 - !x; i = 0; i -- ) 最左位不能是 0 (前置0)，如果 x 为 0，则遍历从 n-2开始；不为 0 则从 n-1开始。 2.x==0时 ，需要从001开始取到 abc if (!x) res -= power10(i); 注意： count(b, i) - count(a - 1, i) ;res += get(num, n - 1, i + 1) * power10(i);if (num[i] == x) res += get(num, i - 1, 0) + 1; 这三个边界是否要 +1、-1 很容易出差错。 树形dp没有上司的舞会Ural 大学有 NN 名职员，编号为 1∼N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 HiHi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式 第一行一个整数 N。 接下来 N 行，第 i 行表示 ii 号职员的快乐指数 Hi。 接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。（注意一下，后一个数是前一个数的父节点，不要搞反）。 输出格式 输出最大的快乐指数。 数据范围 1≤N≤6000，−128≤Hi≤127 状态表示：f(u, 10) 集合 ： f( u , 0 ) : 从以u为根的子树当中选择，并且不选 u 的方案 ; f( u , 1 ) : 从以u为根的子树当中选择，并且选 u 的方案。 属性 ：max 状态计算： f( u , 0 ) : 不选 u，为了最大值，要选择子树中的最大值。(对每个子树，既可以选，也可以不选) f(u , 0) = ∑ max( f( si,1 ) ， f( si , 0) ) f( u , 1 ) : 已经选u了，子树不能选了。 f(u,1) = ∑ f(si,0) 时间复杂度：每个结点状态计算的是它的儿子，所以计算所有状态相当于遍历一遍，即 O(n) 此题画图更好理解。 类似状态机，但和状态机没什么关系。 #include cstring#include iostream#include algorithmusing namespace std;const int N = 6010;int n;int happy[N]; //开心值int h[N],e[N],ne[N],idx;//邻接表bool has_fa[N];//判断有无父节点，从而寻找根节点int f[N][2]; //dp喽void add(int a, int b) e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;void dfs(int u) f[u][1] = happy[u]; for (int i = h[u]; ~i; i = ne[i]) //~i = i!=-1 int j = e[i]; dfs(j); f[u][1] += f[j][0]; f[u][0] += max(f[j][0], f[j][1]); int main() scanf(%d, n); for (int i = 1; i = n; i ++ ) scanf(%d, happy[i]); memset(h, -1, sizeof h); for (int i = 0; i n - 1; i ++ ) int a, b; scanf(%d%d, a, b); add(b, a); has_fa[a] = true; int root = 1; while (has_fa[root]) root ++ ; dfs(root); printf(%d , max(f[root][0], f[root][1])); return 0; 记忆化搜索滑雪给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。 在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 2525 个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数 R 和 C。 接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 1≤R,C≤3000≤矩阵中整数≤10000 输入样例： 5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例： 状态表示：f ( i , j ) 二维路径嘛。 集合 ：所有从( i,j )开始滑的路径中的最大值 属性 ：max 状态计算： ( ↑ | ↓ | ← | → ) 时间复杂度：每个结点状态计算的是它的儿子，所以计算所有状态相当于遍历一遍，即 O(n) 存在一个最大值，如果所有结点的值都减去固定值，该值仍然作为最大值。 同理：如果你要求 (i , j) 点的最大值，假设向右遍历，则需要 (i+1, j ) 的最大值，也就是所谓的 : f(i , j) = f( i+1 , j) +1。 但向右遍历只是一种情况。 考虑四种情况的式子为：f[i][j] = max(f[i][j],f[tx][ty]+1); 举个例子： 对于 25−24−23−…−3−2−1 ，这个路径的求取过程就是从右往左。 递归程序从 25 调用，一直到 1，再从右往左 加和 并回溯。 #includeiostream#includememory.husing namespace std ;const int N = 310;int n,m;int g[N][N];int f[N][N];int dir[4][2] = 0,1,1,0,0,-1,-1,0;int dp(int x,int y) int v = f[x][y]; if(v!=-1) return v; //每个点只求一次路径最大值 v = 1; for(int i=0;i4;i++) int tx = x + dir[i][0], ty = y + dir[i][1]; if(tx=1ty=1tx=nty=mg[tx][ty]g[x][y]) v = max(v,dp(tx,ty)+1); return v;int main(void) cinnm; for(int i=1;i=n;i++) for(int j=1;j=m;j++) cing[i][j]; memset(f,-1,sizeof f); int res =0; for(int i=1;i=n;i++) for(int j=1;j=m;j++) res = max(res,dp(i,j)); //dp：所有以(i，j)为起点滑的路径中的最大值 coutres; return 0; 状态压缩dp蒙德里安的梦想求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。 例如当 N2，M4 时，共有 5 种方案。当 N2，M3 时，共有 3 种方案。 如下图所示： 输入格式 输入包含多组测试用例。 每组测试用例占一行，包含两个整数 N 和 M。 当输入用例 N0，M0 时，表示输入终止，且该用例无需处理。 输出格式 每个测试用例输出一个结果，每个结果占一行。 数据范围 1≤N,M≤11 输入样例： 1 21 31 42 22 32 42 114 110 0 输出样例： 最短Hamilton路径给定一张 n 个点的带权无向图，点从0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。 Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。 输入格式 第一行输入整数 n。 接下来 n 行每行 n 个整数，其中第 i 行第 j 个整数表示点 i 到 j 的距离（记为 a[i,j]）。 对于任意的 x,y,zx,y,z，数据保证 a[x,x]0，a[x,y]a[y,x] 并且 a[x,y]+a[y,z]≥a[x,z]。 输出格式 输出一个整数，表示最短 Hamilton 路径的长度。 数据范围 1≤n≤200≤a[i,j]≤107 输入样例： 0 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例："},{"title":"双指针","path":"/wiki/algorithm/双指针.html","content":"第一天刷题。一个平实的开始，希望能坚持下来，不求波涛汹涌，大浪淘沙，但求静水流深，川流不息。 先学习双指针。题目方向分为两个：链表和数组。 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。 所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。 链表中的双指针第一道：21.合并两个有序链表思路一：申请第三个链表的空间，拷贝两个链表中较小的一个。 代码v1.0： class Solution public: bool comp(ListNode* l1, ListNode* l2) if(l1-val l2-val) return true; else return false; bool Empty_Judge(ListNode* l) if(l-val==0) return true; else return false; ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) if(Empty_Judge(list1)) return list2; if(Empty_Judge(list2)) return list1; ListNode* list ; ListNode* head = list; while(list1!=nullptrlist2!=nullptr) list = new ListNode; if(comp(list1,list2)) list-val = list2-val; list = list-next; list2 = list2-next; else list-val = list1-val; list = list-next; list1 = list1-next; while(list1!=nullptr) list = new ListNode(list1-val); list=list-next; list1=list1-next; while(list2!=nullptr) list = new ListNode(list2-val); list=list-next; list2=list2-next; return head; ; 问题：返回的 head 没有任何数值。 解决： 链表到下一个结点前需要空间，否则指向NULL就是野指针，也就不可能连上。 代码开始，head 指向了没有初始化的 list ，即指向一个（指向null的）野指针，它自己也变成了野指针。如果初始化工作做好，不解决后续连接过程的“先申请空间，再连接”，就会只有一个数据。 条件判断分不清 NULL 、nullptr 及其背后的 true 、false，造成代码冗余。 Empty_judge 和 comp 函数是完完全全的多余代码，因为本可以直接在原代码中判断。 代码V2.0： class Solution public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) if(!list1) return list2; if(!list2) return list1; ListNode* list = new ListNode ; ListNode* head = list; while(list1list2) if(list1-val list2-val) list-val = list2-val; list2 = list2-next; else list-val = list1-val; list1 = list1-next; list-next = new ListNode; list = list-next; while(list1) list -val = list1 - val; if(list1-next) list-next = new ListNode; list=list-next; list1=list1-next; while(list2) list -val = list2 - val; if(list2-next) list-next = new ListNode; list=list-next; list2=list2-next; return head; ; 规避了野指针问题和相对的代码冗余问题。 思路二：在两个指针现有的空间上，只做穿针引线的工作（连接起来） ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) if(!list1) return list2; //可以省略 if(!list2) return list1; ListNode* list = new ListNode; ListNode* head = list; while(list1list2) if(list1-val list2-val) list - next = list2; list = list2; //这里可以配合下面简化 list2 = list2-next; else list - next = list1; list = list1; //简化 list1 = list1-next; //list = list-next list - next = list1 ? list1 : list2; return head - next; 问题： 开始的判断是否为空可以省略。 while 中出现重复点（只是需要一点点直觉） 解决： 看思路三。 **思路三：**labuladong ，虚拟头结点值得注意。整体与思路二没什么区别。 ListNode mergeTwoLists(ListNode l1, ListNode l2) // 虚拟头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2;while (p1 != null p2 != null) // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if (p1.val p2.val) p.next = p2; p2 = p2.next; else p.next = p1; p1 = p1.next; // p 指针不断前进 p = p.next;if (p1 != null) p.next = p1;if (p2 != null) p.next = p2;return dummy.next; } 代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。 拓展： 思路四：递归 struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-val l2-val) l1-next = mergeTwoLists(l1-next,l2); return l1; else l2-next = mergeTwoLists(l1,l2-next); return l2; 类似汉诺塔的思路。 第二道：分割链表V1.0 class Solution public: ListNode* partition(ListNode* head, int x) //初始化 ListNode* tail = head; while(tail-val x ) tail=tail-next; ListNode* temp = tail; ListNode* maxdot = tail;//大于值开始的结点 while(head-val x) head = head-next; tail = head; //小于值开始的结点 while(temp) //x if(temp-val x) //如果是小于值结点 tail -next = temp; tail = tail-next; //x if(temp-val x temp-next-val x ) tail-next = temp-next; if(temp-next-next) temp-next = temp-next-next; else tail-next = temp-next; temp-next = nullptr; break; temp = temp-next; tail-next = maxdot; return head; ; 现在思路也不是很清晰 思路二：双头结点 ListNode partition(ListNode head, int x) // 存放小于 x 的链表的虚拟头结点 ListNode* dummy1 = new ListNode(-1); // 存放大于等于 x 的链表的虚拟头结点 ListNode* dummy2 = new ListNode(-1); // p1, p2 指针负责生成结果链表 ListNode* p1 = dummy1, p2 = dummy2; // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 ListNode* p = head; while (p != null) if (p.val = x) p2.next = p; p2 = p2.next; else p1.next = p; p1 = p1.next; // 断开原链表中的每个节点的 next 指针 ListNode temp = p.next; p.next = null; p = temp; // 连接两个链表 p1.next = dummy2.next; return dummy1.next; 创建两个头结点，先断开，后连接。 思路三：递归 class Solution public: ListNode* small = nullptr; pairListNode*, ListNode* helper(ListNode* head, int x) if (head == nullptr) return make_pair(nullptr, nullptr); if (head-val x) small = head; pairListNode*, ListNode* next = helper(head-next, x); if (head-val x) head-next = next.first; next.first = head; else head-next = next.second; next.second = head; return next; ListNode* partition(ListNode* head, int x) pairListNode*, ListNode* nodes = helper(head, x); if (nodes.first) small-next = nodes.second; return nodes.first; else return nodes.second; ; 大多数链表题递归的时候可以无脑写一句，然后只要让思路从后向前进行就可以了。 cppListNode* node = func(head-next); // func为递归函数 这里返回值选择了两个pair，first保存小于x的结点，second保存大于x的结点。 思路四:原地连接 // 1 4 3 2 5 2 struct ListNode* partition(struct ListNode* head, int x) if(!head || !head-next) return head; struct ListNode *p = head, *q = head, *temp = NULL; if(p-val x) while(p-next-val x)//此循环让 p 到达最远小值 1 p = p-next; if(p-next == NULL) return head; q = p-next; //让 q 到达最近大值 4 else p = NULL; while(q-next) //q存在下一个结点 if(q-next-val x) //如果最近大值下一个为小值 temp = q-next; //temp为小值了 q-next = temp-next;//跳过小值 if(p == NULL) //如果起始值为大值（即p 为空情况） temp-next = head; //头插法：第一个插入的小值连接起始大值 head = temp; p = head; else//起始值小值（存在了） temp-next = p-next; //头插法：小值后 p-next = temp; p = temp; else //为大值就串下去 q = q-next; return head; p指针指向小于 x 的值，p null 就连接第一个大于x的值，p!null 就按顺序进行尾插法；(只是 p 的”尾”是 q 的”头”)q指针指向大于 x 的值，初始是第一个大于x的值， 尾插法依次往后放;temp 服务于p的尾插法，作为中间变量。（q 尾插循环的前面，是p,q 的初始化工作，分别指定小于x值的尾端 和 大于x值的尾端） 第三道：合并K个升序链表思路一：遍历合并两个链表到第一个链表中去 class Solution public: ListNode* merge(ListNode* list1,ListNode* list2) //这里和合并有序链表的code一模一样 ... ListNode* mergeKLists(vectorListNode* lists) //遍历合并 if(lists.empty()) return nullptr; vectorListNode*::iterator it = lists.begin(); vectorListNode*::iterator next = lists.begin()+1; for(;next!=lists.end();next++) *it = merge(*it,*next); return *it; ; **思路二：**labladong ：配合优先队列的二叉堆，获取最小k结点 ListNode mergeKLists(ListNode[] lists) if (lists.length == 0) return null; // 虚拟头结点 ListNode* dummy = new ListNode(-1); ListNode* p = dummy; // 优先级队列，最小堆 PriorityQueueListNode* pq = new PriorityQueue( lists.length, (a, b)-(a.val - b.val)); // 将 k 个链表的头结点加入最小堆 for (ListNode head : lists) if (head != null) pq.add(head); while (!pq.isEmpty()) // 获取最小节点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if (node.next != null) pq.add(node.next); // p 指针不断前进 p = p.next; return dummy.next; 思路三：分治递归 class Solution public ListNode mergeKLists(ListNode[] lists) if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; if(lists.length == 2) return mergeTwoLists(lists[0],lists[1]); int mid = lists.length/2; ListNode[] l1 = new ListNode[mid]; for(int i = 0; i mid; i++) l1[i] = lists[i]; ListNode[] l2 = new ListNode[lists.length-mid]; for(int i = mid,j=0; i lists.length; i++,j++) l2[j] = lists[i]; return mergeTwoLists(mergeKLists(l1),mergeKLists(l2)); public ListNode mergeTwoLists(ListNode l1, ListNode l2) if (l1 == null) return l2; if (l2 == null) return l1; ListNode head = null; if (l1.val = l2.val) head = l1; head.next = mergeTwoLists(l1.next, l2); else head = l2; head.next = mergeTwoLists(l1, l2.next); return head; 思路四：STL中的优先队列 class Solution public: ListNode* mergeKLists(vectorListNode* lists) auto head = ListNode(0); auto comp = [](ListNode* const a, ListNode* const b)return a-val b-val;; priority_queueListNode*, vectorListNode*, decltype(comp) q(comp); for (auto h : lists) if (h != nullptr) q.push(h); auto p = head; while (!q.empty()) p-next = q.top(); p = p-next; q.pop(); if (p-next != nullptr) q.push(p-next); return head.next; ; 第四道：单链表的倒数第 k 个节点ListNode* removeNthFromEnd(ListNode* head, int n) if(n==0||!head) return head; //0元素 或 不动 if(!head-next) return NULL; //1元素 且 动 ListNode* fformer = head; ListNode* former = head; ListNode* latter = head; while(--n0) latter = latter-next; while(latter-next) if(former!=head) fformer = fformer-next; latter = latter - next; former = former - next; //1元素 if(former == fformer) head = former-next; //2元素 else fformer-next = former-next; //3+元素 return head; 第五道：链表的中间结点ListNode* middleNode(ListNode* head) ListNode* fast = head; ListNode* slow = head; while(fast-next) fast = fast-next; if(fast-next) fast=fast-next; slow = slow-next; return slow; 第六道：相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) /** 定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差) 两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度 **/ if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null while(pA != pB) pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; return pA; 这个赋值和 ？条件判断 的配合非常有趣。 简短的 if 语句可用 ？来代替。 思路二： public ListNode getIntersectionNode(ListNode headA, ListNode headB) int lenA = 0, lenB = 0; // 计算两条链表的长度 for (ListNode p1 = headA; p1 != null; p1 = p1.next) lenA++; for (ListNode p2 = headB; p2 != null; p2 = p2.next) lenB++; // 让 p1 和 p2 到达尾部的距离相同 ListNode p1 = headA, p2 = headB; if (lenA lenB) for (int i = 0; i lenA - lenB; i++) p1 = p1.next; else for (int i = 0; i lenB - lenA; i++) p2 = p2.next; // 看两个指针是否会相同，p1 == p2 时有两种情况： // 1、要么是两条链表不相交，他俩同时走到尾部空指针 // 2、要么是两条链表相交，他俩走到两条链表的相交点 while (p1 != p2) p1 = p1.next; p2 = p2.next; return p1; 第七道：判断是否为环形链表boolean hasCycle(ListNode head) // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null fast.next != null) // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; // 快慢指针相遇，说明含有环 if (slow == fast) return true; // 不包含环 return false; 不解释 第八道：找到环形链表的起点流程起始同上，先让快慢指针相遇。 设相遇点距离头结点为 k ,即慢指针的路程。快指针速度是慢指针二倍，路程即 k+k2k 设环形起点距离相遇点为 m , 则慢指针距离起点 k-m。巧合的是，相遇点指针不断向后走，距离起点同样为k-m 。 所以让其中任意一个指针回到起点，经过k-m位移，另一个指针就会到达环形链表起点。 ListNode detectCycle(ListNode head) ListNode fast, slow; fast = slow = head; while (fast != null fast.next != null) fast = fast.next.next; slow = slow.next; if (fast == slow) break; // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) // fast 遇到空指针说明没有环 return null; // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) fast = fast.next; slow = slow.next; return slow; 数组中的双指针 在数组中并没有真正意义上的指针，但我们可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧。 第一道： 删除有序数组中的重复项基本的快慢双指针。 int removeDuplicates(int[] nums) if (nums.length == 0) return 0; int slow = 0, fast = 0; while (fast nums.length) if (nums[fast] != nums[slow]) slow++; // 维护 nums[0..slow] 无重复 nums[slow] = nums[fast]; fast++; // 数组长度为索引 + 1 return slow + 1; 大同小异的一个链表题： 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) struct ListNode* deleteDuplicates(struct ListNode* head) typedef struct ListNode ListNode; if(!head) return head; ListNode* slow = head; ListNode* fast = head; while(fast) if(fast-val!=slow-val) slow=slow-next; slow-val=fast-val; fast=fast-next; slow-next = NULL; return head; 第二道：移除元素左右指针： class Solution public: int removeElement(vectorint nums, int val) int j = nums.size() - 1; for (int i = 0; i = j; i++) if (nums[i] == val) swap(nums[i--], nums[j--]); return j + 1; ; 快慢指针： while(fastnumsSize) if(nums[fast]!=val) nums[slow] = nums[fast]; slow++; fast++;return slow; 扩展：保留重复k个元素的基础上删除多余元素 class Solution public: int work(vectorint nums, int k) int len = 0; for(auto num : nums) if(len k || nums[len-k] != num) nums[len++] = num; return len; int removeDuplicates(vectorint nums) return work(nums, 2); ; 第三道:移动零v1.0 void moveZeroes(vectorint nums) int fast = 0,slow=0; while(fastnums.size()) if(nums[fast]!=0) nums[slow++] = nums[fast]; fast++; while(slowfast) nums[slow++]=0; v2.0 int left = 0;int right = 0;while(right nums.size()) if(nums[right]) swap(nums[left], nums[right]); left++; right++; 遇到非0直接交换就可以 第四道：最长回文子串string longestPalindrome(string s) string res = ; for(int i=0;is.size();i++) string s1=palindrome(s,i,i); string s2=palindrome(s,i,i+1); res = s1.size()res.size()?s1:res; res = s2.size()res.size()?s2:res; return res; string palindrome(string s,int l,int r) while(l=0rs.size()s[l]==s[r]) l--; r++; ; return s.substr(l+1,r-l-1); 左右指针，向两侧扩散。 遍历中心点。 中心点分奇数、偶数两种情况，依次比较即可。"},{"title":"搜索","path":"/wiki/algorithm/搜索.html","content":"前言：1.最短路问题和DP的关系： 最短路问题包含DP问题，DP问题可以看做最短路问题的特殊情况。 DP是没有环的最短路问题。 2.不是所有最短路问题都能用bfs来做。 只有所有边权重一样的时候才能用bfs做。 3.几种剪枝 最优性剪枝：当前路径一定可以判断出不如最优解 可行性剪枝：当前路径一定不合法 搜索DFS全排列 朴素版:简单递归 #includeiostreamusing namespace std ;const int N = 10;int n;int path[N];bool flag[N];void dfs(int u) if(u==n) for(int i=0;in;i++) printf(%d,path[i]); if(i!=n-1) printf( ); else printf( ); for(int i = 1;i=n;i++) if(!flag[i]) //标志数组意味着在dfs过程中不会发生数据重复。 path[u] = i; flag[i] = true; dfs(u+1); //path[u] = 0; flag[i] = false; int main(void) cinn; dfs(0); //下标从0开始（与数据从1开始 区分开） 位运算版：只是将朴素版的标志数组 以整数位运算的方式表示了。 #include iostreamusing namespace std;const int N = 10;int n;int path[N];void dfs(int u, int state) if (u == n) for (int i = 0; i n; i ++ ) printf(%d , path[i]); puts(); return; for (int i = 0; i n; i ++ ) if (!(state i 1)) //查询第i位是不是0 path[u] = i + 1; dfs(u + 1, state + (1 i)); int main() scanf(%d, n); dfs(0, 0); return 0; state存的是当前i位的是否被填了的状态，但是state是一个整数，所以用state第i位是不是零存第i位的状态，查询第i位是不是零就是用!(state i 1) 把具体的值加到path中去了之后，把下一个值递归到下一个dfs循环中，这时候把当前i左移一位加到state中就表示这一位已经被占用了。 n皇后 把不放皇后看成0， 放皇后看成1，所有的情况就成了一个二叉树，每次都是向左（0）遍历，到了终点再回溯到能向右（1）遍历的节点开始向右遍历，是个二叉树的先序遍历算法。 —— acwing-user : Hsezr 这里需要注意，n皇后需要规避三种情况：横线，对角线，反对角线。 可以开辟三个数组，分别存储当前下标状态，是否已经存在皇后了。 横线好说，对角线如何处理呢？ col是Column（列）的缩写，dg是diagonal（对角）的缩写，反对角线为 udg 设 udg 的坐标系方程为yx+b，则by-x。 替换后即 bu-i，防止出现负数，则加上n，则有bu+n-i（其实bn+i-u也可，目的是一个对角线能单独映射） 设 dg 的方程为y-x+b,by+x,替换后 bi+u 注意：图中行为 n , 列为col。 下面的代码中，我们设置行为 u ，列为 i 全排列做法 #includeiostreamusing namespace std ;const int N = 20;char graph[N][N];bool col[N],dg[N],udg[N]; //标志数组，分别对应行、对角线和反对角线int n;void dfs(int u) //u : 到多少行了？ if(u==n) for(int i=0;in;i++) coutgraph[i]endl; coutendl; return ; for(int i=0;in;i++) //i 仅仅是多少列 if(!col[i]!dg[u+i]!udg[u+n-i]) //y=x+b : b=y-x : b = u-i (规避负数+n) | y=-x+b :b = x+y : b=u+i col[i]=dg[u+i]=udg[u+n-i] = true; graph[u][i] = Q; dfs(u+1); graph[u][i] = .; col[i]=dg[u+i]=udg[u+n-i] = false; int main(void) cinn; for(int i=0;in;i++) for(int j=0;jn;j++) graph[i][j] = .; dfs(0); 注意：开始我初始化N10 ，有些样例是过不了的。对角线长度约1.414*10（根号2），经过测试，在1n9 的情况下， N16 会WA掉n9 ，N17 就能 AC 。 复杂度：n*n! 朴素暴力做法 #includeiostreamusing namespace std ;const int N = 20;int n;char g[N][N];bool row[N],col[N],dg[N],udg[N]; //相比全排列多了一个行void dfs(int x,int y, int s) if( sn ) return; if( y==n ) y=0; x++; if(x==n) if(s==n) for(int i=0;in;i++) puts(g[i]); puts(); return ; g[x][y] = .; dfs(x, y + 1, s); if (!row[x] !col[y] !dg[x + y] !udg[x - y + n]) row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; g[x][y] = Q; dfs(x, y + 1, s + 1); g[x][y] = .; row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; int main(void) cinn; dfs(0,0,0); // 参数1,2分别为x，y。 参数3为 当前有几个皇后 复杂度：2^(n^2) 为什么第一种写法不用考虑行，而第二种则要考虑行？ 第一种是我们已经知道一行只能放一个皇后才这么写，第二种是更朴素的想法一个格子一个格子往下走。 这里你还可以参照，第一种写法的状态参数是if : u==n ，第二种写法则是 if( sn ) return;if( y==n ) y=0; x++; if(x==n) if(s==n) ... 简单来说： 全排列写法是一行一行往下走，一旦放置皇后就下一行。 朴素写法是一格一格移动着走。 前者不需要考虑同一行里是否发生重复皇后，后者则需要考虑。 全球变暖你有一张某海域 NxN 像素的照片，”.”表示海洋、”#”表示陆地，如下所示： ……. .##…. .##…. ….##. ..####. …###. ……. 其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 2 座岛屿。 由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。 例如上图中的海域未来会变成如下样子： ……. ……. ……. ……. ….#.. ……. ……. 请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 输入描述 第一行包含一个整数 N* (1≤N≤1000)。 以下 N 行 N 列代表一张海域照片。 照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。、 输出一个整数表示答案。 #includeiostreamusing namespace std;const int N = 1010;int n;bool flag;int res;bool vis[N][N];char m[N][N];int h[4][2] = 0,1,1,0,0,-1,-1,0;void dfs(int x,int y) vis[x][y]= true; if(m[x][y]==.) return ; bool temp = true; for(int i=0;i4;i++) int tx = x+h[i][0] , ty = y+h[i][1]; if(m[tx][ty]==.) temp = false; if(!vis[tx][ty]) dfs(tx,ty); if(temp) flag = true; int main(void) scanf(%d,n); for(int i=0;in;i++) for(int j=0;jn;j++) cinm[i][j]; for(int i=0;in;i++) for(int j=0;jn;j++) if(!vis[i][j]m[i][j]==#) flag = false; dfs(i,j); if(!flag) res++; coutres; BFS走迷宫 普通版本： #include cstring#include iostream#include algorithm#include queueusing namespace std;typedef pairint, int PII;const int N = 110;int n, m;int g[N][N], d[N][N];int bfs() queuePII q; memset(d, -1, sizeof d); d[0][0] = 0; q.push(0, 0); int dx[4] = -1, 0, 1, 0, dy[4] = 0, 1, 0, -1; while (q.size()) auto t = q.front(); q.pop(); for (int i = 0; i 4; i ++ ) int x = t.first + dx[i], y = t.second + dy[i]; if (x = 0 x n y = 0 y m g[x][y] == 0 d[x][y] == -1) d[x][y] = d[t.first][t.second] + 1; q.push(x, y); return d[n - 1][m - 1];int main() cin n m; for (int i = 0; i n; i ++ ) for (int j = 0; j m; j ++ ) cin g[i][j]; cout bfs() endl; return 0; 手搓队列的朴素版本 //朴素版本#includeiostream#includecstringusing namespace std ;const int N = 110;typedef pairint,int PII;int g[N][N];int d[N][N];int n,m;//手搓队列queuePII q[N*N];int bfs() int hh=0,tt=0; memset(d,-1,sizeof(d)); q[0]=0,0; d[0][0] = 0; int dir[4][2] = 0,1,1,0,-1,0,0,-1; while(hh=tt) auto t = q[hh++]; for(int i=0;i4;i++) int tx = t.first +dir[i][0],ty = t.second+dir[i][1]; if(tx=0txnty=0tymg[tx][ty]==0d[tx][ty]==-1) q[++tt] = tx,ty; d[tx][ty] = d[t.first][t.second]+1; return d[n-1][m-1];int main(void) cinnm; for(int i=0;in;i++) for(int j=0;jm;j++) scanf(%d,g[i][j]); coutbfs(); return 0; 八数码问题 这里搜索需要处理两个点： 1.状态表示。 —— queue队列 2.状态之间的距离如何记录。 —— dist数组 答案： 1.将二维网格降维成一个字符串来表示，如上面1~8的示例，可以用字符串“123x46758” 来表示。 即queue 2.用C++里的哈希表STL ： unordered_mapstring,int 最后一个问题：状态转移 ①复原状态：将一维字符串还原成二维（至少先从脑子里） ②更新状态：枚举空格上下左右移动后的状态。 ③存入队列：移动后把二维结果恢复成字符串，存入bfs队列。 #includeiostream#includequeue#includealgorithm#includeunordered_map#includestringusing namespace std ;#define NUM 3queuestring q;unordered_mapstring,int d; //dist int bfs(string state) string end = 12345678x; //预定结果 了 q.push(state); d[state] = 0; int direct[4][2] = 0,1,1,0,0,-1,-1,0; while(q.size()) //队列操作 string str = q.front(); q.pop(); //判断是否结束 if(str == end) return d[str]; //枚举前的初始化 int distance = d[str]; int key = str.find(x); int x = key/NUM, y = key%NUM; //更新数据 for(int i=0;i4;i++) int tx = x + direct[i][0], ty = y + direct[i][1]; if(tx=0txNUMty=0tyNUM) swap(str[key],str[tx*NUM+ty]);//交换完成，更新状态 if(!d[str]) d[str] = distance +1; q.push(str); swap(str[key],str[tx*NUM+ty]);//更新完成，复原状态 return -1; //枚举完成，没有找到结果，返回-1。int main(void) string start; for(int i=0;i9;i++) char s[2]; cins; start += *s; coutbfs(start); return 0; 迷宫问题描述 这天, 小明在玩迷宫游戏。 迷宫为一个 n x n 的网格图, 小明可以在格子中移动, 左上角为 (1,1)(1,1), 右 下角 (n, n)(n,n) 为终点。迷宫中除了可以向上下左右四个方向移动一格以外, 还有 m 个双向传送门可以使用, 传送门可以连接两个任意格子。 假如小明处在格子(x1,y1), 同时有一个传送门连接了格子 (x1,y1) 和 (x2,y2), 那么小明既可以花费 1 的步数向上下左右四个方向之一走一格 (不能 越过边界), 也可以花费 1 的步数通过传送门走到格子 (x2,y2) 去。 而对于同一个迷宫, 小明每次进入的初始格子是在这n*×n 个格子中均匀随 机的 (当然运气好可以直接随机到终点), 他想知道从初始格子走到终点的最短 步数的期望值是多少。 输入格式 输入共 1+m1+m 行, 第一行为两个正整数 n, mn,m 。 后面 mm 行, 每行四个正整数 x1,y1,x2,y2 表示第 ii 个传送门连接的两个格子坐标。 输出格式 输出共一行, 一个浮点数表示答案 (请保留两位小数)。 #include iostream#includedequeusing namespace std;const int N = 25;int a[N];int b[N];int vis[N][N];int n;int dis[4][2] = 0,1,1,0,0,-1,-1,0;dequeint d;bool dfs(int x,int y) if(x==n-1y==n-1) for(int i=0;in;i++) if(a[i]||b[i]) return false; return true; for(int i=0;i4;i++) int tx = x+dis[i][0],ty = y+dis[i][1]; if(tx=0ty=0txntyn!vis[tx][ty](a[ty])(b[tx])) a[ty]--;b[tx]--; vis[tx][ty]=1; d.push_back(tx*n+ty); if(dfs(tx,ty)) return true; a[ty]++;b[tx]++; vis[tx][ty]=0; d.pop_back(); else continue; return false;int main() cinn; for(int i=0;in;i++) cina[i]; for(int i=0;in;i++) cinb[i]; d.push_back(0); vis[0][0]=1; a[0]--;b[0]--; if(dfs(0,0)) for(auto it = d.begin();it!=d.end();it++) cout*it ; return 0;"},{"title":"每日一题","path":"/wiki/algorithm/每日一题.html","content":"1608. 特殊数组的特征值思路一：暴力 int specialArray(vectorint nums) for(int i = 1;i1000;i++) int count = 0; for(int j =0;jnums.size();j++) if(nums[j]=i) count++; if(count == i) return i; return -1; **思路二：**降序排序+一次遍历 class Solution public: int specialArray(vectorint nums) sort(nums.begin(), nums.end(), greaterint()); int n = nums.size(); for (int i = 1; i = n; ++i) if (nums[i - 1] = i (i == n || nums[i] i)) return i; return -1; ; **思路三：**模拟（计数+枚举） V1.0 class Solution public: int specialArrayvectorint nums) int cnts[1010]; for (int x : nums) cnts[x]++; for (int i = 1009, tot = 0; i = 0; i--) tot += cnts[i]; if (i == tot) return i; return -1; 为什么说如果存在一定是唯一的呢？个数和值的单调性是相反的，参考判断的值越大，那对应满足条件的个数就越小。而将数组降序或者升序排序后，判断个数与值大小的顺序就要与数组的升降序相反。个数的变化是严格单调的。因此如果有满足条件的交点特征值，那这个值一定也是唯一的！ 可以理解为两条线的n个点：横坐标范围为1到n，一条是可能不严格单调的折线纵坐标为排序后的数组值nums，另一条是严格单调(斜率为1)纵坐标为1到n的直线，这样最多只会有一个交点。 V2.0 class Solution public: int specialArray(vectorint nums) sort(nums.begin(), nums.end()); for (int x = 1, n = nums.size(); x = n; ++x) if (x == n - (lower_bound(nums.begin(), nums.end(), x) - nums.begin())) return x; return -1; ; 思路四: 排序+枚举+二分** V1.0 ： int specialArray(vectorint nums) int n = nums.size(); sort(nums.begin(),nums.end(),greaterint()); for (int x = 0; x 1010; x++) int l = 0, r = n - 1; while (l r) int mid = (l + r) 1; if (nums[mid] = x) r = mid; else l = mid + 1; if (nums[r] = x x == n - r) return x; return -1;; 排序的基础上，二分暴力。 V2.0 放弃枚举，在枚举数据上继续二分(两次二分)。 670.最大交换思路一：将原 int 放到数组里，再copy 一份降序数组，比对两数组，生成int V1.0 class Solution public: int maximumSwap(int num) //初始化数组和数组副本 vectorint v,v1; int count = 1 , dummy = 10; while(num/dummy!=0)count++; dummy*=10; while(count--)dummy/=10;v.push_back((num/dummy)%10); v1 = v; sort(v1.begin(),v1.end(),greaterint()); if(v1==v) return num; //正着找最大值交换 for(count=0;v[count]==v1[count];count++); //这里是找到数据直接定位 swap(v[count],v1[count]); //可以遍历if来替代，更好理解。 //倒着找被交换数 for(int i = v.size()-1;i=0;i--) if(v[i]==v[count]) swap(v[i],v1[count]); //输出 num = 0; for(int i=0;iv.size();i++) num = num*10 + v[i]; return num; ; 这道题用了1h 。 比想象中要多得多。做题太慢了。以后做题要计时。 V2.0 class Solution public: static char cmp(char a , char b) //辅助将string从大到小排序 return ab; int maximumSwap(int num) string change = to_string(num); string exchange = change; sort(exchange.begin(),exchange.end(),cmp); char small = ; char big = ; for(int i = 0 ; i change.size(); i++) if(exchange[i] != change [i]) small = change[i]; big = exchange[i]; change[i]= exchange[i]; break; for(int i = change.size()-1 ; i =0; i--) if(small!= change[i] == big) change[i] =small; break; int res = stoi(change); return res; ; 优化： 用 string 替代 vector 容器，从而规避了对 int 数据逐个写入数组的过程。 通过if语句的使用，兼容了 要求数据和原数据相同的情况。（1.0版本在中间单独穿插了if，冗余） V3.0 class Solution public: int maximumSwap(int num) string str = to_string(num); string tmp = str; sort(tmp.rbegin(), tmp.rend()); for (int i = 0; i str.size(); ++i) if (str[i] != tmp[i]) for (int j = str.size() - 1; j = 0; --j) if (str[j] == tmp[i]) swap(str[i], str[j]); return stoi(str); return num; ; 减少代码长度而已。效率上和2.0一样。 思路二：暴力重排列两两交还，记录最大值。 class Solution public: int maximumSwap(int num) string charArray = to_string(num); int n = charArray.size(); int maxNum = num; for (int i = 0; i n; i++) for (int j = i + 1; j n; j++) swap(charArray[i], charArray[j]); maxNum = max(maxNum, stoi(charArray)); swap(charArray[i], charArray[j]); return maxNum; ; 思路三：贪心 : 将最大值和最前面的值交换 V1.0 class Solution public: int maximumSwap(int num) string charArray = to_string(num); int n = charArray.size(); int maxIdx = n - 1; int idx1 = -1, idx2 = -1; for (int i = n - 1; i = 0; i--) if (charArray[i] charArray[maxIdx]) maxIdx = i; else if (charArray[i] charArray[maxIdx]) idx1 = i; idx2 = maxIdx; if (idx1 = 0) swap(charArray[idx1], charArray[idx2]); return stoi(charArray); else //遍历后都相等，idx没变 return num; ; V2.0: class Solution public: int maximumSwap(int num) string s = to_string(num); for(int i=1;is.size();++i) if(s[i]s[i-1]) //如果大于前面的值 int idx = i; for(int k = idx + 1;ks.size();k++) if(s[idx]=s[k])//等号意味着相等的选靠后的 idx = k; //找到后面的值的最大值 int j = i-1; while(j=0 s[j]s[idx]) j-= 1; //到数据最前面 char c = s[idx]; //交换最前面的值 和 后面的最大值 s[idx] = s[j+1]; s[j+1] = c; break; return atoi(s.c_str()); ; 总结： atoi()函数和to_string()函数的使用 int 为了利用 string 容器特性的转换。 双指针强化。 按照频率将数组升序排序哈希表+排序+模拟 vectorint frequencySort(vectorint nums) multimapint ,int,lessint order; int rate = 0; sort(nums.begin(),nums.end(),greaterint()); for(int i=0;inums.size();i++) if(i!=0nums[i]!=nums[i-1]) order.insert(make_pair(rate,nums[i-1])); rate = 0; rate++; //记录频率 order.insert(make_pair(rate,nums[nums.size()-1]));//最后一个数 //记录完毕，开始整理 int flag = 0; for(auto it = order.begin();it!=order.end();it++) for(int i = it-first;i!=0;i--) nums[flag++] = it-second; return nums; 用到了map容器，哈希表+排序+模拟 优化版：（官方题解） vectorint frequencySort(vectorint nums) unordered_mapint, int cnt; for (int num : nums) cnt[num]++; sort(nums.begin(), nums.end(), [](const int a, const int b) if (cnt[a] != cnt[b]) return cnt[a] cnt[b]; return a b; ); return nums; 桶排序： vectorint frequencySort(vectorint nums) int rate1[110] = 0; int rate2[110] = 0; for(auto num:nums) if(num=0) rate1[num]++; else rate2[abs(num)]++; int flag = 0; for(int j = 1;j=100;j++) for(int i = 100;i=0;i--) if(rate1[i]==j) while(rate1[i]--) nums[flag++] = i; for(int i = 0;i=100;i++) if(rate2[i]==j) while(rate2[i]--) nums[flag++] = -i; return nums; 带分数 100 可以表示为带分数的形式：100 3 + 69258 714。还可以表示为：100 82 + 3546 197。注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。类似这样的带分数，100 有 11 种表示法 输入一个整数num ，求它有多少种表示法。 全排列 + 枚举 #includeiostreamusing namespace std;//全排列//分三部分: (1,i) (i+1,j) (j,9) 两层循环， 1=i=7 , i+1=j=8//判断是否满足: f + (f1/f2) == numint num,a[15];int res;int toNum(int a[],int l,int r) int temp = 0; while(l=r) temp = temp*10+a[l]; l++; return temp;void swap(int a,int b) int temp = a; a = b; b = temp;void judge() for(int i=1;i=7;i++) for(int j=i+1;j=8;j++) int f = toNum(a,1,i); int f1 = toNum(a,i+1,j); int f2 = toNum(a,j+1,9); if(f+(f1/f2)==num f1%f2==0) res++; void perm(int a[],int l,int r) if(l==r)//到达二叉树根 judge(); //已经拥有一个全排列数据了，判断是否满足 else //还没有到二叉树根 for(int i=l;i=r;i++) swap(a[l],a[i]); //原地修改 perm(a,l+1,r); //递归深度遍历 swap(a[l],a[i]); //回溯 int main(void) for(int i=0;i=9;i++) a[i] = i; cinnum; perm(a,1,9); coutres;"},{"title":"滑动窗口","path":"/wiki/algorithm/滑动窗口.html","content":"滑动窗口做题笔记 模板/* 滑动窗口算法框架 */void slidingWindow(string s) unordered_mapchar, int window; int left = 0, right = 0; while (right s.size()) // c 是将移入窗口的字符 char c = s[right]; // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(window: [%d, %d) , left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... 最小覆盖子串string minWindow(string s, string t) unordered_mapchar, int need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right s.size()) // c 是将移入窗口的字符 char c = s[right]; // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (need.count(c)) window[c]++; if (window[c] == need[c]) valid++; // 判断左侧窗口是否要收缩 while (valid == need.size()) // 在这里更新最小覆盖子串 if (right - left len) start = left; len = right - left; // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (need.count(d)) if (window[d] == need[d]) valid--; window[d]--; // 返回最小覆盖子串 return len == INT_MAX ? : s.substr(start, len); 找到字符串中所有字母异位词class Solution public: vectorint findAnagrams(string s, string p) unordered_mapchar,int need,window; for(char c:p) need[c]++; int left,right; left = right = 0; int valid = 0; //1. vectorint res; while(rights.size()) char r = s[right]; right++; if(need.count(r)) window[r]++; if(need[r]==window[r]) valid++; while(right-left=p.size()) if(valid==need.size()) res.push_back(left); char L = s[left]; left++; if(need.count(L)) if(need[L]==window[L]) valid--; window[L]--; return res; ; 无重复字符的最长子串class Solution public: int lengthOfLongestSubstring(string s) unordered_mapchar,int window; int left,right;left = right = 0; int res = 0; while(rights.size()) char r = s[right]; right++; window[r]++; while(window[r]1) char L = s[left]; window[L]--; left++; res = max(res,right-left); return res; ;"},{"title":"混元形意太极门之红烧翅膀我最爱吃","path":"/wiki/algorithm/混元形意太极门之红烧翅膀我最爱吃.html","content":"[TOC] 算法 暴力1.排序2.动态规划(DP) 3.深度优先搜索 4.广度优先搜索 5.暴力枚举，搜索 数据结构类1.二叉树 ⒉.链表 3.栈和队列 4.哈夫曼 5.STL6.最小生成树 7.B+树8.KMP.算法 9.哈希表 高效算法类1.递归(分治)+回溯2.贪心算法3.最短路径 DJ、BF、Floyd 4.双指针5.滑动窗口 过程概要 汇总算法信息资料 规划时间，不同时期练啥算法; 找对应算法精确资料，如博客、书、视频等学习。 掌握思想后，收集题型，大量刷题。 第1，2 为前期短时间合理规划 第3, 4为后期循环上升式进步 路线：博客 kuangbin 专题：https://github.com/Zen-w/kuangbin labuladong 专题：https://labuladong.github.io/algo/1/ 某个人刷题笔记（洛谷） ：https://studyingfather.com/archives/category/%E7%AE%97%E6%B3%95 动态规划专题 ：https://cloud.tencent.com/developer/article/1538177 视频 左程云力扣： https://www.bilibili.com/video/BV13g41157hK?share_source=copy_webvd_source=858f79141b0ff902c365efd90ac76a55 https://www.bilibili.com/video/BV1YL4y1v7Hy?share_source=copy_webvd_source=858f79141b0ff902c365efd90ac76a55 acwing试听课： https://space.bilibili.com/7836741?spm_id_from=333.337.search-card.all.click 一些比较吊的 oj CodeForce , 洛谷 ， leetcode ， 牛客网 参考资料 书 ​ 《算法竞赛入门经典》 刘汝佳 ​ 《啊哈！算法》 ​ 《大话数据结构》 上述路线 上述视频 时间安排（空）： 附赠惊喜： 一个科班CPP路线：https://github.com/tomstillcoding/cs-roadmap/blob/main/c++/2022_%E6%9C%80%E6%96%B0C++%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF_%E7%A7%91%E7%8F%AD%E7%89%88.md"},{"title":"线性DP","path":"/wiki/algorithm/线性DP.html","content":"DP前言下面一系列的线性dp问题更依赖闫氏dp分析法的发挥。 这里记录几条经验： 当状态计算方程中，在遍历时出现了 f[i-1] 的字样，那么数组下标就要从1开始，来防止负数下标和越界。 状态表示，我们划分集合的原则为 “不重不漏”：不重复，不遗漏。 当状态属性 要求取 sum 集合的总和时，不重复的原则很重要。 但状态属性取 maxmin 集合的最值时，集合间元素发生重复不会影响结果。 举个例子： 1,2,3 求最值：max max(max (1,2) , max (2,3) )。 这里2发生了重复，但不影响最大值3的求取。 求总和：sum sum(sum (1,2) , sum(2,3) )。 这里2发生了重复，影响了总和的求取（2被加了两次） 状态表示分为三部分： 集合的维度：一维数组 f[i] 能求出答案吗？不能的话就用二维数组f[i] [j] ，还不行就三维。 集合的表示：每个集合，它的意义是什么？这个意义要能概括题目的所有情况。 集合的属性：求sum还是max？属性有时会影响状态计算方程的展开。 一个简单的数学模型： 集合A：a1,a2,a3 … an 集合B：a1+w,a2+2, … an+w 则有：min(A)+w = min(B) 或 ：min(A) = min(B) - w C++语言，一秒处理数据大小为 10^8^左右，尽量把复杂度控制在10^7^，最多10^8^ 线性DP数字三角形 DP分析 状态表示： 1 状态转移： 朴素做法#includeiostreamusing namespace std ;const int N = 510 , INF = 1e9;int f[N][N];int a[N][N];int n;int main(void) //初始化数据 cinn; for(int i=1;i=n;i++) for(int j=1;j=i;j++) scanf(%d,a[i][j]); //dp数组赋初值 (下标从1开始，不会产生越界问题。但下标为0的数据要提前赋初值，也就是INF) for(int i=0;i=n;i++) for(int j=0;j=i+1;j++) //初值范围是[0,i+1] ，左右端点 0和i+1 都会用到。 f[i][j] = -INF; f[1][1] = a[1][1]; //转移方程的初值。 //状态转移 for(int i=2;i=n;i++) for(int j=1;j=i;j++) f[i][j] = max(f[i-1][j]+a[i][j],f[i-1][j-1]+a[i][j]); //输出 int res = -INF; for(int i=1;i=n;i++) res = max(res,f[n][i]); coutres; 更优雅的写法#include bits/stdc++.husing namespace std;const int N = 510;int f[N][N];int n;int main() cin n; for (int i = 1; i = n; i++) for (int j = 1; j = i; j++) cin f[i][j]; for (int i = n - 1; i = 1; i--) for (int j = 1; j = i; j++) f[i][j] = max(f[i + 1][j + 1], f[i + 1][j]) + f[i][j]; cout f[1][1] endl; 该做法是从最下方，向上推。 朴素做法是从第二层，向下推。 一维优化(朴素版本) #include iostream#include algorithmusing namespace std;const int N = 510, INF ..................................................................... = -1e9;int a[N][N];int f[N];int n, m;int main() cin n; for (int i = 1; i = n; i ++) for (int j = 1; j = i; j ++) cin a[i][j]; for (int i = 0; i = n + 1; i ++ ) f[i] = INF; f[1] = a[1][1]; for (int i = 2; i = n; i ++) for (int j = i; j = 1; j --) f[j] = max(f[j] + a[i][j], f[j - 1] + a[i][j]); int res = INF; for (int i = 1; i = n; i ++) res = max(res, f[i]); cout res endl; return 0; 最长上升子序列 朴素做法闫氏dp： 状态表示： f[i] , 1.集合：所有以第i个数字结尾的上升子序列 ​ 2.属性：max 状态计算：（注意，本题dp未用到 i-1 的递增公式，故 i 的下标从0开始） ​ 分析集合： （ 0 | 1 | 2 | 3 |…| i-1） 在该集合中，题目要求数字大小逐渐上升，即 An-1 An 。 如果出现An-1An的情况，我们不会把它包含在集合中去，换言之，所求的都是满足题意的某个集合的最大值。 对于形如 AiAj 的上升子序列，可知f[j]的最长上升子序列，即f[i]的最长上升子序列+1。 故计算方程：f[ i ] max( f[ j ] +1 ), j 0,1,2,3… i-1 且 ( a[i]a[j] ) 。 二分（数据加强版） 思路： 在朴素做法的基础上，我们需要追加一个集合,再次分析，来达到优化剪枝的效果。 分析：以 3 1 4 8 5 为例。 如果一个子序列的长度为1，那该序列的末尾值可以取 1 ，也可以取 8。 如果要最长子序列，那末尾值就必须最小，也就是min(1,8) 1 ，取1不取8。 为了实现该功能： 追加一个数组q[i] ,这个数组表示长度为i时，结尾最小的序列值为q[i]。所以该数组有效值的长度，就是最长上升子序列的长度。 遍历a数组里面的数，然后在q（这个数组的长度就是答案）这个数组里面查找是否存在一个大于且最靠近他的数，若果不存在话，说明这个数是在q所有的数中是最大的（这时下标也已经扫描到q数组的最右边，r这个下标已经定位到q的最右边，将其+1，更新q长度（即：更新答案）和新元素的值），若存在（即：该点的值不是上升地），r+1也不会增加q的长度（因为不是上升的情况，所以这里答案不会更新），说明该点最长子序列一定是前面其中的某个答案，只需要将里面地最靠近的那个元素进行更新即可 #include iostream#include algorithmusing namespace std;const int N = 100010;int n;int a[N] = 7,3,4,5,1,8,3;int q[N];int main() n=7; int len = 0; for (int i = 0; i n; i ++ ) int l = 0, r = len; while (l r) // q里有无大于当前a[i]: 存在原地，不存在的话更新 // 不存在的话就是 r = 0 // 存在的话就是 r != 0 ，即大于1的线段，更新len // （当然，如果有多个大于a[i]的数，则选择最靠近a[i]的。） int mid = l + r + 1 1; if (q[mid] a[i]) l = mid;// check() else r = mid - 1; len = max(len, r + 1); q[r + 1] = a[i]; printf(i = %d ,r = %d ,a[i]=%d , len = %d; ,i,r,a[i],len); for(int i=0;in;i++) coutq[i] ; coutendl; ///a[N] = 7,3,4,5,1,8,3;\tfor(int i =0;in;i++) printf(q%d=%d ,i,q[i]);\tcoutendl; printf(%d , len); return 0; 注：此代码并非最终题解，因为保留了调试部分的输出语句和注释。 结果展示： 最长公共子序列 闫氏dp： 状态表示： f[i] [j] , 1.集合：字符串A的前i个字符，和字符串B的前j个字符的公共子序列 ​ 2.属性：max 状态计算： 以两个字符串的末位字符，即A[i] 和 B[j] 划分，有四种情况： 00 ：最长公共子序列的末尾字符，即不是A[i],也不是B[j] 。所以很自然，有 f(i,j) f(i-1,j-1) 11 : 最长公共子序列的末尾字符,即是A[i],又是B[j]。所以必然有A[i] B[j] 且f(i,j) f(i-1,j-1)+1 01 : 末位不是A[i] ，但却是B[j]。经下面的分析，此种情况为 f(i,j) f(i-1,j) 这里我们会想当然认为，f(i,j) f(i-1,j)。但不是这样的。因为f(i-1,j) 同样包含了 不选择B[j]的情况，这与我们的集合情况不符。但由于此题求的是最大值，根据前言原则2，所以重复不影响结果。 10 : 与01同理，重复无所谓，全覆盖就行。此种情 况为 f(i,j) f(i,j-1) ​ 分析集合： （ 00|01|10|11） ​ 集合00是被包含在01和10的集合中的。所以在状态转移方程中省去00。 状态转移方程： f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); 朴素做法枚举i，j —— 状态转移 #includeiostreamusing namespace std ;const int N = 1010;int n,m;char a[N],b[N];int f[N][N];int main(void) cinnm(a+1)(b+1); //下标从1开始 for(int i=1;i=n;i++) for(int j=1;j=m;j++) f[i][j] = max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j] = max(f[i][j],f[i-1][j-1]+1); printf(%d,f[n][m]); 最短编辑距离 朴素做法闫氏dp： 状态表示：f(i,j) ​\t1.集合：将A[1i] 操作后与B[1j]相等的操作方式 的集合 ​\t2.属性：min 状态计算： ( 删 | 增 | 改 ) 删：删除之后匹配。删除多余的A[i]，即前面的最小值+1即现在的最小值。则有f(i,j ) = f(i-1,j)+1 ; 增：增加之后匹配。即A增加的值恰好是B[j] ,则有f(i,j) = f(i,j-1)+1 ; 改：更改（末尾值A[i])之后匹配。即要保证A[1i-1] 和 B[1j-1]是匹配的，再去改末位。 则有f(i,j) = f(i-1,j-1)+1 。 注意：这一步要判断。当A[1i-1]与B[1j-1]匹配时，如果A[i]B[j] 那就不需要再改末位，所以此时情况是f(i,j) f(i-1,j-1) 代码： #includeiostreamusing namespace std ;const int N = 1010;int f[N][N] ; //dp数组要建好char A[N],B[N];int main(void) int n,m; scanf(%d%s,n,A+1); scanf(%d%s,m,B+1); //dp前的初始化 for(int i=0;i=m;i++) f[0][i] = i; //当A的字符串是空，B的字符串长度为i，操作数即i（第i步增加B[i]），i=m B的长度 for(int j=0;j=n;j++) f[j][0] = j; //当B的字符串是空，A的字符串长度为i，操作数即j (第j步删除A[i]) ，j=n A的长度 for(int i=1;i=n;i++) for(int j=1;j=m;j++) //增删 f[i][j] = min(f[i-1][j]+1,f[i][j-1]+1); //改要判断 if(A[i]==B[j]) f[i][j] = min(f[i][j],f[i-1][j-1]); else f[i][j] = min(f[i][j],f[i-1][j-1]+1); //输出结果：把A的前n个字母变成B的前m个字母 coutf[n][m]; 编辑距离 时间复杂度 ：n个字符串 , 每个字符串有 m次询问 n1000,m1000 字符串长度为10，比对时是n^2 ,即10^2 100 所以复杂度为： 1000 * 1000 * 100 10^8 , 有点紧。 给定 n个字符串，和当前字符串进行比较，求边界距离。 关键点在于求边界距离 边界距离的求法，可参考上一题“最短编辑距离“ 朴素做法#includeiostream#includecstringusing namespace std ;const int N = 1010;const int M = 15; //10int f[N][N]; //dp数组char str[N][M];//字符串数组，存储询问//这里是最短编辑距离的算法。int edit_distance(char a[],char b[]) int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i = lb; i ++ ) f[0][i] = i; for (int i = 0; i = la; i ++ ) f[i][0] = i; for (int i = 1; i = la; i ++ ) for (int j = 1; j = lb; j ++ ) f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); return f[la][lb];int main(void) int n,m; cinnm; for(int i=0;in;i++) scanf(%s,str[i]+1); while(m--) //开始询问：求给定 n 个字符串中，谁可以在上限操作次数内变成询问给出的字符串。 char s[M]; int limit; //上限次数 scanf(%s%d,(s+1),limit); int res = 0; for(int i=0;in;i++) //遍历“给定字符串” if(edit_distance(str[i],s) = limit ) //在边界范围内 res++; coutresendl; return 0;"},{"title":"背包DP","path":"/wiki/algorithm/背包DP.html","content":"B递归问题特性 ①问题有最优子结构：问题存在最优解，且与其子问题最优解重合 ②无后效：前后状态值只和值本身有关，和问题无关。 解决思路： ①将原问题分解为子问题 ②确定状态 ③确定初始状态值 ④确定状态转移方程（由最优子结构推到其父结构，直到目标状态） 四个背包问题01背包 题目： 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0N,V≤10000vi,wi≤1000 朴素做法既然是动态规划，我们就要找到 i 和 i-1 之间的关系嘛。观察会发现， 对于第 i 件物品，只有选或不选两种选择： 不选：f[i][j] = f[i-1][j] 即最优解和前 i-1 个物品的情况一样。 选：f[i][j] = f[i-1][j-v[i]]+w[i] 即最优解包含了选择第 i 个物品的情况。 这样的话dp的关键：状态转移方程 就成型了： f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 暴力dp，因为有两个限定条件 ： 前N件物品和前M个重量，所以空间设为二维数组。 建立一个二维数组 N [ i ] [ j ]，含义为前i件物品和j重量时的最优解。 这里还需要两个一维数组 v [n] 和 w [n] 来分别存储第 i 个物品的 体积和价值。 #includeiostreamusing namespace std ;const int N = 1010;int a[N][N];int v[N],w[N]; int n,m;int dp() for(int i=1;i=n;i++) for(int j = 1;j=m;j++) a[i][j]=a[i-1][j]; if(j=v[i]) a[i][j] = max(a[i][j],a[i-1][j-v[i]]+w[i]); return a[n][m];int main(void) cinnm; for(int i = 1;i=n;i++) cinv[i]w[i]; cout dp(); return 0; 空间优化（一维数组）两个关键点： 优化原因：朴素做法中，二维数组只用到了 a[i][j] 和 a[i-1][j] ,这里可以优化一下，利用一个一维数组实现状态更新。 你可以理解为二维数组 a[N][N] 变成了 a[1][N] 倒序更新：使用一维数组，则必然要在更新数据时使用倒序。 1.正序为啥不行？ 二维状态转移方程为 a[i][j] = max(a[i][j],a[i-1][j-v[i]+w[i]) 一维数组，正序更新则变为 a[i][j] = max(a[i][j],a[i][j-v[i]+w[i]) 因为没有二维数组记录，导致一维的数据由第i-1层，跳到了第i层。 (你也可以这样理解，正序会导致前i个数据里的某个数据由于满足条件而重复使用。！想到了完全背包没有？) 2.倒序为啥行？ 计算 a[i][j] 需要 a[i-1][j-v[i]]，而倒序的情况下，a[j-v[i]] 恰好是“未被污染的”，我们所需要的数据。 #includeiostreamusing namespace std ;const int N = 1010;int a[N];int v[N],w[N]; int n,m;int dp() for(int i=1;i=n;i++) for(int j = m;j=v[i];j--) a[j] = max(a[j],a[j-v[i]]+w[i]); return a[m];int main(void) cinnm; for(int i = 1;i=n;i++) cinv[i]w[i]; cout dp(); return 0; 完全背包 问题同上，只多了一个条件： 每种物品都有无限件可用。 作者：yxc 链接：https://www.acwing.com/video/945/ 请教一个问题，A式中的dp[i−1] [j]，和实际上B式替换后中的dp[i−1] [j−kv]+(k−1)w后面应该还有一项dp[i−1] [j−(k+1)v]+kw,在转换到C式时，这两项怎么处理的。视频中没有看明白。 答： B式仅从数学上来看，好像末尾缺少了一项 dp[i-1] [j-v-kv] + kw 。 但换元后要考虑取值范围的变化。 因为两者的 j 是一样的，对应了 1⩽k⩽T，让 j 变成 j−v 就等同于让 k 的范围缩小为 0⩽k⩽T−1 了。 简而言之就是原来的背包容量 j 最多可以承受 T 个 v，而替换成 j−v 后，最多就只能承受 T−1 个 v 了，把式子最后一项化简消去，就成这样了。 B式最后一项少了一个 w 怎么理解？ B式的第一项和A式第二项对应，而 w 前的系数也就差 1，直到最后一项。所以B式 + w 才能替换A项。 代码示例： 朴素做法 for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) int t = j / v[i]; for (int k = 0; k = t; k++) dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]); ————————————————原文链接：https://blog.csdn.net/raelum/article/details/128996521 一维优化#include iostream#include algorithmusing namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main() cin n m; for (int i = 1; i = n; i ++ ) cin v[i] w[i]; for (int i = 1; i = n; i ++ ) for (int j = v[i]; j = m; j ++ )//正序了 f[j] = max(f[j], f[j - v[i]] + w[i]); cout f[m] endl; return 0; 番外： 1.为什么一维背包的 j ，可以从v[i]开始，“跳过”jv[i]的情况？ 关键在这里。二维不能从v[i]开始，因为有一个赋值语句为jv[i]的数据赋初值。 2.一维的情况下，赋值语句从f[i] [j] f[i-1] [j] 变成了 f[ j ] f[ j ] ,两者等价，但右式可以消掉。 判断语句挪到循环里，结束。 3.省略的f[i] = f[i] 等价于 f[i][j] = f[i-1][j] 因为赋值语句里的 f[i] f[i] ,右值为上一层循环里的 f[i] ，即 i - 1 。 这个f[j]还没有在第 i 层的循环里被更新过。 多重背包 多重背包增加的条件： 第 i 种物品最多有 si 件，(每件体积是 vi，价值是 wi)。 朴素做法这时需要增加一层循环，即枚举第 i 种物品的 【0,si】件时的最优解，再从最优解中找到更优解。 (注意：一个限制条件是，选择k个物品势必会引起背包体积问题，需要在该循环中增加体积限制条件) #includeiostreamusing namespace std; const int N = 110;int f[N][N];int v[N],w[N],s[N];int main(void) int n,m; cinnm; for(int i=1;i=n;i++) cinv[i]w[i]s[i]; for(int i=1;i=n;i++) for(int j=0;j=m;j++) // for(int k=0;k=s[i] k*v[i]=j;k++) // k*v[i]=j 防止下标为负数，即装不下的情况出现 f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); coutf[n][m]; return 0; k从0开始：k0 时，包含了不选择第 i 件物品的情况。 一维优化#include bits/stdc++.husing namespace std;const int N = 110;int v[N],w[N],s[N];int dp[N];int main() int n, m; cin n m; for(int i = 1; i = n; i++) cin v[i] w[i] s[i]; for(int i = 1 ;i = n; i++) for(int j = m; j = v[i] ; j--) // for(int k = 1; k = s[i] k * v[i] = j; k ++) dp[j] = max(dp[j], dp[j- k * v[i]] + k * w[i]); cout dp[m] endl; return 0; 这里有两个点： 倒序遍历，直到 v[ i ] 。 同上 k1开始 实际上，k0开始和k1开始，结果是一样的。把k0带入，发现赋值语句变成了： dp[j] = max(dp[j],dp[j]) 所以你是否想起了完全背包里被省略的那个 dp[j] = dp[j]? 二进制优化 数据范围增强了： 0N≤10000V≤20000vi,wi,si≤2000 思路： 这是0—1背包的，原来你解决多重背包是把n份物品分为n个1份，现在是分成2^0 2^1 2^2 2^3 2^4……2^n个，分好后把它们重新看做一个整体，这些整体相加可以等于[1,n]中任何物品一份份总和的集合，简单讲就是 n 1+1+1+1 …(执行n次) 1 2 4 8 …（执行log n 次） #includeiostream#includevectorusing namespace std ;struct good int v; int w;;vectorgood goods;const int N = 2023;int f[N];int main(void) int n,m; cinnm; for(int i = 1;i=n;i++) int v,w,s; //不需要数组，而是转化成二进制数统一存到vector中去 cinvws; for(int k=1;k=s;k*=2 ) s-=k; goods.push_back(v*k,w*k); if(s0) goods.push_back(v*s,w*s); for(auto good:goods) //不需要 i / n 了。传统笨蛋线性数目已经没用了 for(int j=m;j=good.v;j--) f[j] = max(f[j],f[j-good.v]+good.w); coutf[m]endl; return 0; 分组背包 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 分组背包实际上是多重背包的变种。多重背包的解决思路是，将k*v[i](k0,1,2…..) 打包起来，形成v[ i ]集合中的一部分，我们要做的就是在v [ i ] 集合中选择一个最优解。 这不正是分组择其一的过程吗？ 结论：我们可以把分组背包看成多重背包理由：我们把每组看做一个“物品”，而这个物品我们可以选择0到si个；通过从后向前的遍历顺序来确保，我们对组的决策只有一种：要么选这个组，要么不选；然后在通过枚举组内的情况，来对组内进行决策：要么选0个，选1个…..； 来自 acwing：@WZ 朴素做法#include iostreamusing namespace std;const int N = 110;int n, m;int dp[N][N];int v[N][N], w[N][N], s[N];int main() cin n m; for(int i = 1; i = n; i++) cin s[i]; for(int j = 1; j = s[i]; j++) cin v[i][j] w[i][j]; for(int i = 1; i = n; i++) for(int j = 0; j = m; j++) for(int k = 0; k = s[i]; k++) if(j = v[i][k]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i][k]] + w[i][k]); cout dp[n][m] endl; return 0; 一维优化#include iostream#include algorithmusing namespace std;const int N = 110;int n, m;int v[N][N], w[N][N], s[N];int f[N];int main() cin n m; for (int i = 1; i = n; i ++ ) cin s[i]; for (int j = 0; j s[i]; j ++ ) cin v[i][j] w[i][j]; for (int i = 1; i = n; i ++ ) for (int j = m; j = 0; j -- ) for (int k = 0; k s[i]; k ++ ) if (v[i][k] = j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout f[m] endl; return 0; 一维再优化一个都不选的方案在状态优化成1维的时候就可以省略了，因为本层的f[j]就是上一层的f[j]。 #includeiostreamusing namespace std ;const int N = 110;int n,m;int f[N],v[N],w[N];int main(void) cinnm; for(int i =0;in;i++) int s; cins; for(int j = 0;js;j++) cinv[j]w[j]; for(int j = m;j=0;j--) for(int k=0;ks;k++) if(j=v[k]) f[j] = max(f[j],f[j-v[k]]+w[k]); coutf[m]endl; return 0; 总结几个关键点正序逆序问题：优化成一维数组的情况，只有完全背包会正序遍历 j 。 因为一维数组的情况下，正序遍历如果背包剩余容积足够（jv[i]），会重复装入一个物品，这是完全背包的思路。 逆序遍历则不会有重复的现象，因为前面的数据都为 0 。 从左往右更新有脏数据。 从右往左更新都是 0 。 小规律： 四种背包的朴素做法，也就是二维状态都是正序，一维都是倒序。 下面是一个很有参考价值的例子和过程模拟。 例子：假设有3件物品，背包的总体积为10 物品 体积 价值 i 1 4 5 i 2 5 6 i 3 6 7因为 f[0][j] 总共0件物品，所以最大价值为 0， 即 f[0][j] 0 成立 如果 j 层循环是递增的： for (int i = 1; i = n; i++) { for (int j = v[i]; j = m; j++) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 当还未进入循环时: f[0] = 0; f[1] = 0; f[2] = 0; f[3] = 0; f[4] = 0; f[5] = 0; f[6] = 0; f[7] = 0; f[8] = 0; f[9] = 0; f[10] = 0; 当进入循环 i == 1 时： f[4] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5; f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5; f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5; f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5; 重点来了！！！ f[8] = max(f[8], f[4] + 5); 即max(0, 5 + 5) = 10; 即f[8] = 10; 这里就已经出错了 因为此时处于 i == 1 这一层，即物品只有一件，不存在单件物品满足价值为10 所以已经出错了。 如果 j 层循环是逆序的： for (int i = 1; i = n; i++) { for (int j = m; j = v[i]; j--) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 模拟过程如下： 当还未进入循环时: f[0] = 0; f[1] = 0; f[2] = 0; f[3] = 0; f[4] = 0; f[5] = 0; f[6] = 0; f[7] = 0; f[8] = 0; f[9] = 0; f[10] = 0; 当进入循环 i == 1 时：w[i] = 5; v[i] = 4; j = 10：f[10] = max(f[10], f[6] + 5); 即max(0, 5) = 5; 即f[10] = 5; j = 9 ：f[9] = max(f[9], f[5] + 5); 即max(0, 5) = 5; 即f[9] = 5; j = 8 ：f[8] = max(f[8], f[4] + 5); 即max(0, 5) = 5; 即f[8] = 5; j = 7 ：f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5; j = 6 ：f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5; j = 5 ：f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5; j = 4 ：f[6] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5; 当进入循环 i == 2 时：w[i] = 6; v[i] = 5; j = 10：f[10] = max(f[10], f[5] + 6); 即max(5, 11) = 11; 即f[10] = 11; j = 9 ：f[9] = max(f[9], f[4] + 6); 即max(5, 11) = 5; 即f[9] = 11; j = 8 ：f[8] = max(f[8], f[3] + 6); 即max(5, 6) = 6; 即f[8] = 6; j = 7 ：f[7] = max(f[7], f[2] + 6); 即max(5, 6) = 6; 即f[7] = 6; j = 6 ：f[6] = max(f[6], f[1] + 6); 即max(5, 6) = 6; 即f[6] = 6; j = 5 ：f[5] = max(f[5], f[0] + 6); 即max(5, 6) = 6; 即f[5] = 6; 当进入循环 i == 3 时: w[i] = 7; v[i] = 6; j = 10：f[10] = max(f[10], f[4] + 7); 即max(11, 12) = 12; 即f[10] = 12; j = 9 ：f[9] = max(f[9], f[3] + 6); 即max(11, 6) = 11; 即f[9] = 11; j = 8 ：f[8] = max(f[8], f[2] + 6); 即max(6, 6) = 6; 即f[8] = 6; j = 7 ：f[7] = max(f[7], f[1] + 6); 即max(6, 6) = 6; 即f[7] = 6; j = 6 ：f[6] = max(f[6], f[0] + 6); 即max(6, 6) = 6; 即f[6] = 6; 就模拟一下发现没有错误，即逆序就可以解决这个优化的问题了。 从1开始从v[i]开始 从1开始的都是朴素二维数组做法。因为二维数组在jv[i]时也要有数据，供后续状态转移时使用。 一维数组不需要。因为一维的情况下，赋值语句从f[i] [j] f[i-1] [j] 变成了 f[ j ] f[ j ] ,两者等价，但右式可以消掉。 判断语句挪到循环里，结束。 同理，省略的f[i] = f[i] 等价于 f[i][j] = f[i-1][j] 因为赋值语句里的 f[i] f[i] ,右值为上一层循环里的 f[i] ，即 i - 1 。 这个f[j]还没有在第 i 层的循环里被更新过。 k的出现k在多重背包、分组背包（特殊多重背包）、完全背包单独的朴素形式出现。 01背包只有选或不选两种情况，不需要 k 的引入。 完全背包一维形式在循环中已经包含了“重复调用，向上更新”的目的，不需要再引入 k。 这一点可以参考 正序逆序问题。 实战演练最大数字（蓝桥杯2022国赛-D）【问题描述】给定一个正整数 N。你可以对 N 的任意一位数字执行任意次以下 2 种操作：1.将该位数字加 1。如果该位数字已经是 9，加 1 之后变成 0。2.将该位数字减 1。如果该位数字已经是 0，减 1 之后变成 9。你现在总共可以执行 1 号操作不超过 A 次，2 号操作不超过 B 次。请问你最大可以将 N 变成多少？【输入格式】第一行包含 3 个整数：N, A, B。【输出格式】一个整数代表答案。【样例输入】123 1 2【样例输出】933【样例说明】对百位数字执行 2 次 2 号操作，对十位数字执行 1 次 1 号操作。【评测用例规模与约定】对于 30% 的数据，1 ≤ N ≤ 100; 0 ≤ A, B ≤ 10对于 100% 的数据，1 ≤ N ≤ 1017; 0 ≤ A, B ≤ 100 有A和B两种选择； 对于第 i 位数字， 选 j 次 A ，相当于一件物品： 花费是 j ，价值是 10^n-1 * num (num:当前位的数字) 选 k 次 B，相当于一件物品： 花费是 k，价值是 10^n-1 * num 数据结构：f[i] [j] [k] : jA , kB 。含义为第 i 位数字拥有 j 次 A 和 k 次 B的最大值。 状态转移： f[i] [j] [k] = max(f[i] [j] [k] , f[i][j-x][k]);f[i] [j] [k] = max(f[i] [j] [k] , f [i][j][k-y]); #includeiostream#includecmathusing namespace std;const int N = 20,M = 110; //N 最大数字位数 ， M 选择最大次数long long f[N][M][M]; //f(i,j,k) : 第 n 位 拥有 j 次 选择A 和 k 次 选择B 的最大值int A,B;string s; //char s[N] 也ok int getMod(int x,int mod)//取模 return (x%mod+mod)%mod;int main(void)\tcins;\tcinAB;\tint n = s.size();\tfor(int i = 1;i=n;i++) for(int p = 0;p=9;p++) int x = s[i-1] - 0; //Str 从0开始！ //这里注意前后顺序，从x加到a /从x减到a int a = getMod(p-x,10); // 通过选择A从t取到p位的花费 int b = getMod(x-p,10); // 通过选择B从t取到p位的花费 //枚举当拥有价值 a，b 的情况 for(int j=0;j=A;j++) for(int k=0;k=B;k++) //pow:更新到当前值的价值 if(j=a) f[i][j][k] = max(f[i][j][k],f[i-1][j-a][k]+ (long long)pow(10,n-i)*p); if(k=b) f[i][j][k] = max(f[i][j][k],f[i-1][j][k-b]+ (long long)pow(10,n-i)*p); coutf[n][A][B]; return 0; 为什么背包里， if(j = x) f[i][j][k] = max(f[i][j][k] , f[i - 1][j - x][k] + f10[n - i] * p) ;if(k = y) f[i][j][k] = max(f[i][j][k] , f[i - 1][j][k - y] + f10[n - i] * p) ; 不写成下面的形式？ max(f[i-1][j][k] , f[i - 1][j - x][k] + f10[n - i] * p) ;// ↑ 因为 j 和 k 从0开始遍历，已经把不选择A或B的情况包括了。 这就好比多重背包里，选择 0 个背包（k0) 时，已经囊括了 f[i][j] = f[i-1][j] 的情况。 f[i-1] [j-k* v[i]]+k*w[i]); 在 k 0 时不正是那种情况？"},{"title":"递归 —— 反转链表","path":"/wiki/algorithm/递归 —— 反转链表.html","content":"反转链表不要跳进递归，而是利用明确的定义来实现算法逻辑。你的脑袋有几个栈啊！ 基本上，所有的递归问题都可以用递推公式来表示。有了这个递推公式，我们就可以很轻松地将它改为递归代码。。所以，遇到递归不要怕，先想递推公式。 递归是一种关于某个重复动作(完成重复性的功能)的形式化描述。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。 将问题抽象化，可以将问题抽象为f(n)（或者其他的数学符号）, 然后用f(n)代表欲求的问题，然后去发现和子问题（比如f(n-1)）的递推关系！（这一点在写动态规划的时候特别有用，其实动态规划就是记忆化的递归！） 递归函数是带语义的，但是记住一个递归函数只有一个语义，如果在写递归函数实现的时候，发现出现了多个语义，需要对新出现的语义重新定义一个函数！ 作者：Chuancey链接：https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/kan-bu-dong-di-gui-de-kan-guo-lai-xi-wan-1akq/ 进入正题：反转链表题 class Solution public: ListNode* reverseBetween(ListNode* head, int left, int right) if(left==1) return reverselist(head,right); head-next = reverseBetween(head-next,left-1,right-1); return head; ListNode* reverselist(ListNode* head,int n) if(n==1) last2 = head-next; return head; ListNode* last = reverselist(head-next,n-1); head-next-next = head; head-next = last2; return last; private: ListNode* last2;; 反转链表的思路是 全反转 → 从1到n 的反转 → 从m到n的反转 全反转的代码： reverse(ListNode* head) if(head==NULL||head-next==NULL) return head; ListNode* last = reverse(head-next); head-next-next = head; head-next = NULL ;//这里是区分反转链表范围的关键点 return last; //返回“头结点” 1到n： ListNode* last2;reverseN(ListNode* head, int n) if(n==1) last2 = head-next; return head; ListNode* last = reverseN(head-next,n-1); head-next-next = head; head-next = last2; return last; 和全反转相比，要区分 last: 反转的头结点(原最后结点) , last2:反转的尾结点的next(原起始结点的next) m到n：照顾头结点， ListNode* reverseBetween(ListNode* head, int left, int right) if(left==1) return reverseN(head,right) //老样子了 让left定位为“1” //注意 reverseN 和 reverseBetween 的区别 head-next = reverseBetween(head-next,left-1,right-1); //正好在m点接受 “1”到 n return head; 拓展：同样的问题有个迭代的法子： 全反转： ListNode* prev = nullptr;ListNode* curr = head;while(curr) ListNode* n = curr-next; //记录点位 curr-next = prev; //分成两部分。 prev = curr; curr = next;return prev; mn反转（头插法）： class Solution public: ListNode *reverseBetween(ListNode *head, int left, int right) // 设置 dummyNode 是这一类问题的一般做法 ListNode *dummyNode = new ListNode(-1); dummyNode-next = head; ListNode *pre = dummyNode; for (int i = 0; i left - 1; i++) pre = pre-next; ListNode *cur = pre-next; ListNode *next; for (int i = 0; i right - left; i++) next = cur-next; cur-next = next-next; next-next = pre-next; pre-next = next; return dummyNode-next; ; 此时把线拉直就是变化后的效果。 反转一组固定长度为K的链表 ListNode* reverseKGroup(ListNode* head, int k) if(!head) return head; ListNode* a = head; ListNode* b = head; for(int i=0;ik;i++) //扩展b顺便检查 if(!b) return a; b=b-next; ListNode* newHead = reverse(a,b); //newHead是反转后头结点 a-next = reverseKGroup(b,k); //a 是反转后尾结点 return newHead; ListNode* reverse(ListNode* a,ListNode* b) //反转a到b ListNode* cur = a; ListNode* pre = NULL; while(cur!=b) ListNode* n = cur-next; cur-next = pre; pre = cur; cur = n; return pre; //reverse返回的是反转后的头结点 判断回文链表思路一： 链表不能直接走，但可以借助后序遍历的思路，左指针为头结点，后序遍历比较 class Solution public: bool isPalindrome(ListNode* head) left = head; return traverse(head); bool traverse(ListNode* right) //后序遍历比较 if(right == NULL) return true; bool res = traverse(right-next); res = res(left-val == right-val); left = left-next; return res; private: ListNode* left ; //左指针; 思路二：反转链表后模仿双指针（从中间向两边） 三步走： 找到中间结点：快慢指针 反转链表 前半部分和后半部分逐个对比。 class Solution public: bool isPalindrome(ListNode* head) ListNode* left = head; //no.1 ListNode* right = midpointer(head); //no.2 right = reverse(right); //no.3 return compnode(left,right); //1. 找到中间结点：快慢指针。 ListNode* midpointer(ListNode* head) ListNode* slow = head; ListNode* fast = head; while(fast!=NULLfast-next!=NULL) slow = slow-next; fast = fast-next-next; if(fast!=NULL) slow=slow-next; return slow; //2.反转后半部分链表。 ListNode* reverse(ListNode* head) ListNode* pre = NULL; ListNode* cur = head; while(cur!=NULL) ListNode* n = cur-next; cur-next = pre; pre = cur; cur = n; return pre; //3.前半部分和后半部分逐个对比。 bool compnode(ListNode* left,ListNode* right) while(right!=NULL) if(left-val!=right-val) return false; left = left-next; right = right-next; return true; ;"},{"title":"贪心","path":"/wiki/algorithm/贪心.html","content":"贪心 贪心：每一步行动总是按某种指标选取最优的操作来进行， 该指标只看眼前，并不考虑以后可能造成的影响。 局部最优 → 整体最优。 区间问题区间选点给定 N 个闭区间 [ai,bi ]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。 位于区间端点上的点也算作区间内。 输入格式 第一行包含整数 N，表示区间数。 接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。 输出格式 输出一个整数，表示所需的点的最小数量。 数据范围 1≤N≤105,−109≤ai≤bi≤109 此题同理：最大不相交区间数量 给定 NN 个闭区间 [ai,bi][ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。 思路： 右端点排序，直接对比。下面是题解 左端点排序的话，逆序对比。 #includeiostream#includealgorithmusing namespace std;const int N = 1e5+10;pairint,int v[N];bool cmp(pairint,int a,pairint,int b) return a.secondb.second;int main(void) int n;scanf(%d,n); for(int i=0;in;i++) cinv[i].firstv[i].second; sort(v,v+n,cmp); int res = 0,ed = -2e9; for(int i=0;in;i++) if(v[i].firsted) res++; ed = v[i].second; coutres; 区间合并给定 N 个闭区间 [ai,bi][ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。 输出最小组数。 输入格式 第一行包含整数 N，表示区间数。 接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。 输出格式 输出一个整数，表示最小组数。 数据范围 1≤N≤105,−109≤ai≤bi≤109 左端点排序： 1.逻辑解释： 当第cnt个区间的左端点小于前cnt - 1个区间的最小的max_r时，前cnt -1个区间的左端点不一定都小于第cnt个区间的左端点，因为是按照右端点排序的。如果有些区间的左端点大于第cnt个区间的左端点，并且大于另一些区间的max_r，就不能保证这cnt个区间都有一个共同点（就是第cnt个区间的左端点）。 2.反证解释： 按照右边排序的话，各个区间的左端点不能保证单调性，所以有可能第三个区间的左端点比第一个区间的左端点还要左边，它可以特别长。 反例： [1, 3], [2, 5], [4, 100], [10, 13] 3.比喻： 比如，有n个人需要用教室，每个人占用教室的起始时间和终止时间是不一样的。1、如果想知道只有一间教室，能安排下的最多不冲突人数（不是所有的人都有机会，有的会被舍掉）是多少（区间选点和最大不相交问题），那么当然是最先结束的人排在前面，这样后面的人才有更多机会。如果是按左端点排序，那么如过一个人0点开始用，那么肯定他排在最前面，但是如果他自己就占用了24小时，那么只能给他一个人用了，这样就达不到最大的效果。所以按左端点排序。2、如果想知道这些人都必须安排，没有人被舍弃，至少需要多少个教室能安排下（区间分组问题）。那么肯定是按照开始时间排序，开始时间越早越优先。这样每间教室都能得到最充分的利用。 偷偷说：实际按左右无所谓的。这题的区间只是一个一维坐标系，如果要按右端点排序，那你就从右往左找 min_r 好了。只是一个方向问题。 思路： 1.将所有区间按左端点从小到大排序 2.从前往后判断 ： if L[i] Max_r ，即是否能将其放到某个现有的组中 ​ ①如果存在，将其放进去，并更新当前组的 MAX_r ​ ②如果不存在，开新组，然后再将其放进去 #include iostream#include algorithm#include queueusing namespace std;const int N = 100010;int n;struct Range int l, r; bool operator (const Range W)const return l W.l; range[N];int main() scanf(%d, n); for (int i = 0; i n; i ++ ) int l, r; scanf(%d%d, l, r); range[i] = l, r; sort(range, range + n); priority_queueint, vectorint, greaterint heap; for (int i = 0; i n; i ++ ) //小根堆里存的是每个分组的最大右端点， //当前要判断的区间的左端点至少要大于其中一个分组的最大右端点，才会用更新替代开新组。 auto it = range[i]; if (heap.empty() || heap.top() = it.l) heap.push(it.r); //开新组 else heap.pop(); //不开组，更新当前组的MAX_r。 heap.push(it.r); printf(%d , heap.size()); return 0; 区间覆盖给定 N 个闭区间 [ai,bi][ai,bi] 以及一个线段区间 [s,t][s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。 输出最少区间数，如果无法完全覆盖则输出 −1。 输入格式 第一行包含两个整数 s 和 t，表示给定线段区间的两个端点。 第二行包含整数 N，表示给定区间数。 接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。 输出格式 输出一个整数，表示所需最少区间数。 如果无解，则输出 −1。 数据范围 1≤N≤105,−109≤ai≤bi≤109,−109≤s≤t≤109 思路： 1.从左到右按左端点排序 2.从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间， 然后将start更新成右端点最大值 #includeiostream#includealgorithmusing namespace std;const int N = 1e5+10;int st,ed;int n;typedef pairint,int PII;PII range[N];int main(void) scanf(%d%d,st,ed); cinn; for(int i=0;in;i++) int a,b;cinab; range[i] = a,b; sort(range,range+n); bool success = false; int res = 0; for(int i=0;in;i++) int j=i, r = -2e9; while(jn range[j].first=st) //第一步：找最大右端点 if(range[j].secondr) r = range[j].second; //r = max(r,range[j].r); j++; if(rst) res = -1; break; res++; //放在判断前 if(r=ed) success = true; break; st =r; //第二步：更新左端点start i = j-1; if(success) coutres; else cout-1; Q :最后为什么是ij-1 而不是ij ? A :比如说： j扫描到了 2 此时while() 退出了 我们下次 i 应该从 2开始但是需要注意的是我们的for()循环 i++ ,i还会加1次 此时 我们的 i3 直接从 3 开始循环了，故需要减1。 Q ：那为什么不把i++去掉，然后i j好理解一点 A ：因为j不一定会++,这样可能会死循环 哈夫曼树（堆）合并果子在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。 达达决定把所有的果子合成一堆。 每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。 可以看出，所有的果子经过 n−1n−1 次合并之后，就只剩下一堆了。 达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。 假定每个果子重量都为 11，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。 例如有 33 种果子，数目依次为 1，2，91，2，9。 可以先将 1、21、2 堆合并，新堆数目为 33，耗费体力为 33。 接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 1212，耗费体力为 1212。 所以达达总共耗费体力3+12153+1215。 可以证明 15 为最小的体力耗费值。 输入格式 输入包括两行，第一行是一个整数 n，表示果子的种类数。 第二行包含 n 个整数，用空格分隔，第 i 个整数 ai 是第 i种果子的数目。 输出格式 输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。 输入数据保证这个值小于 231。 数据范围 1≤n≤10000,1≤ai≤20000 #includeiostream#includequeueusing namespace std ;int res;int main(void) priority_queueint,vectorint,greaterint heap; int n;cinn; while(n--) int x ; scanf(%d,x); heap.push(x); while(heap.size()1) int a = heap.top();heap.pop(); int b = heap.top();heap.pop(); res += a+b; heap.push(a+b); printf(%d,res); 排序不等式排队打水有 n 个人排队到 11 个水龙头处打水，第 ii 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？ 输入格式 第一行包含整数 n。 第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 ti。 输出格式 输出一个整数，表示最小的等待时间之和。 数据范围 1≤n≤105,1≤ti≤104 #includeiostream#includealgorithmusing namespace std;const int N = 1e5+10;long long res;int main(void) int a[N],n; cinn; for(int i = 0;in;i++) cina[i]; sort(a,a+n); for(int i=0;in;i++) res += a[i]*(n-1-i); coutres; 绝对值不等式货仓选址在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式 第一行输入整数 N。 第二行 N 个整数 A1∼AN。 输出格式 输出一个整数，表示距离之和的最小值。 数据范围 1≤N≤1000001≤N≤100000,0≤Ai≤40000 #includeiostream#includealgorithmusing namespace std ;const int N = 1e5+10;int n;int a[N];int res;int main(void) scanf(%d,n); for(int i=0;in;i++) scanf(%d,a[i]); sort(a,a+n); for(int i=0;in;i++) res += abs(a[i]-a[n/2]); coutres; 推出来的不等式耍杂技的牛农民约翰的 N 头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演： 叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。 奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。 这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。 一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。 您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。 输入格式 第一行输入整数 N，表示奶牛数量。 接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 Wi 以及它的强壮程度 Si。 输出格式 输出一个整数，表示最大风险值的最小可能值。 数据范围 1≤N≤50000,1≤Wi≤10,000,1≤Si≤1,000,000,000 既然是推出来的不等式，下面来贴下推理过程： 交换前 交换后 第i头牛 W1+W2+…W(i-1) - Si W1+…Wi-1+Wi+1 - Si 第i+1头牛 W1+W2+…Wi - S(i+1) W1+…Wi-1 - S(i+1) 去掉重复的W1+….W(i-1) , 得 交换前 交换后 第i头牛 - Si Wi+1 - Si 第i+1头牛 Wi - S(i+1) - S(i+1) 题目所求答案为危险系数最大值的最小值，所以找到最大值就OK。 对于上表，易知 Wi -S(i+1) -S(i+1) , Wi+1-Si -Si ； 故交换前取最大值 Wi -S(i+1) ,交换后去最大值 Wi+1-Si 。 假设交换后，我们得到的是最小值（这样假设得到的式子能够帮助我们求得答案），则有不等式： Wi - S(i+1) Wi+1 - Si ，即交换后变小。 移项得 Wi + Si Wi+1 + Si+1 。 此时我们发现，设 Q W+S ，只需要按照Q对输入排序(也就是完成交换的过程)，再依次比较。 取Q1 … Qi 中的最小值即可。 #include iostream#include algorithmusing namespace std;typedef pairint, int PII;const int N = 50010;int n;PII cow[N];int main() scanf(%d, n); for (int i = 0; i n; i ++ ) int s, w; scanf(%d%d, w, s); cow[i] = w + s, w; sort(cow, cow + n); int res = -2e9, sum = 0; for (int i = 0; i n; i ++ ) int s = cow[i].first - cow[i].second, w = cow[i].second; res = max(res, sum - s); sum += w; printf(%d , res); return 0; 以前的题圣诞节来临了，圣诞老人准备分发糖果，现 在有多箱不同的糖果，每箱糖果有自己的价值和重 量，每箱糖果都可以拆分成任意散装组合带走。圣 诞老人的驯鹿雪橇最多只能装下重量W的糖果，请 问圣诞老人最多能带走多大价值的糖果。 #includeiostream#includealgorithm#includememory.h#includeiomanipconst double eps = 1e-6;using namespace std;int W;double V;struct suger\tint w;\tint v;\tbool operator(const suger s) return double(v)/w-double(s.v)/s.weps;\tsugers[110];void greedy(int total,int n)\tfor(int i=0;in;i++) if(total+sugers[i].w=W) total += sugers[i].w; V += sugers[i].v; else V += sugers[i].v* double(W-total)/sugers[i].w; W = W+W-total; break; int main(void) int n,total=0; cinnW; for(int i=0;in;i++) cinsugers[i].vsugers[i].w; sort(sugers,sugers+n);//自己写 greedy(total,n); coutfixedsetprecision(1)V; 各地放了多部电影 ，给定每部电影的放映时间区间，区间重叠的电影不可能同时 看（端点可以重合），问李雷最多可以看多少部电影。 int total;struct film\tint s;\tint e;\tbool operator(const film f) return ef.e; f,films[110];int main(void) int n;cinn; for(int i=0;in;i++) cinfilms[i].sfilms[i].e; sort(films,films+n);\ttotal++;f=films[0]; for(int i=1;in;i++) if(f.e=films[i].s) total++; f=films[i]; cout endltotal; 有 n头牛（1n50,000)要挤奶。给定每头牛挤奶的时间区 间[A,B] (1AB1,000,000，A,B为整数)。 牛需要呆畜栏里才能挤奶。一个畜栏同一时间只能容纳一头牛。 问至少需要多少个畜栏，才能完成全部挤奶工作，以及每头牛都 放哪个畜栏里（Special judged) 去同一个畜栏的两头牛，它们挤奶时间区间哪怕只在端点重合也 是不可以的。 //难点：优先队列的运用 + 配合贪心和队列的排序//（奶牛和栅栏的顺序定义operator，栅栏和奶牛都需要no来记录原顺序编号） #includeiostream //（因为它们都被排序打乱了 ） #includealgorithm //ps：循环均为从1开始#includequeueusing namespace std;struct cow\tint s;//时间区间 start -end int e;\tint no; //奶牛编号：防止原奶牛顺序 由于进入时间的排序而被打乱 operator(const cow c) //排序 return sc.s;\tcows[100];int pos[100];typedef struct fence\tint e;//栅栏的结束时间不断在变 ，作为队列排序依据\tint no; //栅栏编号，方便记录奶牛进入的栅栏（同样是防止队列顺序更新而失去原顺序编号） bool operator(const fence f) const return e f.e; fence(int e,int n):e(e),no(n);// 对栅栏赋值。 fen;int total; //栅栏数 int main(void) //1.奶牛赋值+排序 int n;cinn; for(int i=1;i=n;i++) cincows[i].scows[i].e; cows[i].no=i;//排序前，在赋值no过程记录好原位置 sort(cows+1,cows+n+1); //2.栅栏赋值+排序 priority_queuefen pq; for(int i=1;i=n;i++) if(pq.empty())//情况1.最开始（无奶牛） ++total; pq.push(fen(cows[i].e,total)); pos[cows[i].no]=total; else //情况2. next奶牛与目前栅栏冲突 fen f=pq.top();//利用排序（目前结束最快） 找到待命栅栏 if(f.e=cows[i].s) ++total; pq.push(fen(cows[i].e,total)); //冲突加入新栅栏，编号即total pos[cows[i].no]=total; else //情况3. 不冲突 //不冲突：total不变，队列弹出原奶牛，压入新奶牛 pq.pop(); pos[cows[i].no]=f.no; //进入编号为top（待命）的栅栏 pq.push(fen(cows[i].e,f.no)); //不冲突使用原栅栏 //3.循环结束，事件结束,输出 cout totalendl;\tfor(int i=1;i=n;i++) coutpos[i]endl; 放置雷达： #includeiostream#includevector#includecmath#includealgorithmusing namespace std;int n,d,total;class how\tpublic: bool operator()(pairdouble,double p1,pairdouble,double p2) return p1.firstp2.first; ;bool decide(vectorpairdouble,double m,int F,int i)\tfor(int k=F;ki;k++) if(m[i].first=m[k].secondm[i].first=m[k].first) continue; else return false; return true;\tvoid dfs(const vectorpairdouble,double m)\tint FNC=0;\twhile(1) int i; for(i=FNC+1;in;i++) if(decide(m,FNC,i)) continue; else FNC=i; total++; break; if(i=n) total++; break; int flag=1;int main(void) while(cinndn!=0)\ttotal=0;\tvectorpairdouble,double m;\tfor(int i=0;in;i++) int x,y;cinxy; pairdouble,double p; p.first =x-sqrt(d*d-y*y); p.second=x+sqrt(d*d-y*y); m.push_back(p); sort(m.begin(),m.end(),how());\tdfs(m); coutcaseflag:totalendl; flag++;"},{"title":"容器杂项","path":"/wiki/algorithm/容器杂项.html","content":"map 容器的用法map 根据 value 排序：借助vector实现 #include iostream#include map#include vector#include algorithm // 自定义比较函数，按照值从小到大排序bool compareByValue(const std::pairint, int a, const std::pairint, int b) return (a.second b.second); // 这里假设值为int类型 int main() std::mapint, int myMap; // 添加元素到myMap myMap[1] = 50; myMap[2] = 30; myMap[3] = 70; myMap[4] = 90; // 将myMap转换为vector std::vectorstd::pairint, int vec(myMap.begin(), myMap.end()); // 使用自定义比较函数对vec进行排序 std::sort(vec.begin(), vec.end(), compareByValue); // 输出结果 for (auto pair : vec) std::cout Key: pair.first , Value: pair.second std::endl; return 0; 去重 if(it.second!=num) s.erase(s.find(it.first),m[it.first]); string里的四个 find 函数 find_first_of()：正向查找在原字符串中第一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回npos。 find_last_of()：逆向查找在原字符串中最后一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回npos。 find_first_not_of()：正向查找在原字符串中第一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回npos。 find_last_not_of()：正向查找在原字符串中最后一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回npos。 普通stirng.find函数查找返回第一个的位置，查不到返回npos（-1）。 class cmp1 public: bool operator()(const int a, const int b) const return (a b); // 根据第一个元素（key）进行降序排列 ;class cmp2 //这个无法匹配m2，map的第三个排序参数是针对key值的。\tpublic: bool operator()(const pairint,int a, const pairint,int b) const return (a.first b.first); // 根据第一个元素（key）进行降序排列 ;int main(void)\tmapint,int,cmp1 m2; 3039. 进行操作使字符串为空 class Solution public: static bool m_cmp(const pairchar,int p1,const pairchar,int p2) return p1.secondp2.second; string lastNonEmptyString(string s) string sp = s;\tmapchar,int m;\tfor(int i=0;is.size();i++) m[sp[i]]++; vectorpairchar,int v(m.begin(),m.end());\tsort(v.begin(),v.end(),m_cmp);\tint num = v.front().second;\tmapint,char m2; for(vectorpairchar,int ::iterator it = v.begin();it!=v.end();it++) if(it-second==num) m2.insert(make_pair(sp.find_last_of(it-first),it-first)); else break; string s2 = ; for(auto it :m2) s2=s2+it.second; return s2; ; 更简单的版本 class Solution public: string lastNonEmptyString(string s) int cnt[26],last[26];\tfor (int i=0;is.size();i++) int t = s[i]-a; cnt[t]++; last[t] = i; //最大频率数\tint mx = -1;\tvectorint v;\tfor(int i=0;i26;i++) if(mxcnt[i]) mx = cnt[i]; //最大频率数的字符，将其最后一次出现的位置传到v\tfor(int i=0;i26;i++) if(cnt[i]==mx) v.push_back(last[i]); //对位置排序\tsort(v.begin(),v.end(),less()); string t(v.size(),0);\t//依次读入字符\tfor (int i = 0; i v.size(); i++) t[i] = s[v[i]]; return t; ; 作者：灵茶山艾府链接：https://leetcode.cn/problems/apply-operations-to-make-string-empty/solutions/2643734/tong-ji-zi-mu-chu-xian-ci-shu-he-zui-hou-0r5g/ 记忆化搜索例题 AcWing 901. 滑雪 #includeiostream#includecstringusing namespace std;const int N = 310;int h[N][N];int f[N][N];//记忆化数组int dis[4][2] = 0,1,1,0,0,-1,-1,0;int m,n;int dp(int x,int y)\tint v = f[x][y];\tif(v!=-1) return v; //此处为记忆化的关键。\tv = 1; //别忘了赋初值 for(int i=0;i4;i++) int tx = x+dis[i][0]; int ty = y+dis[i][1]; if(tx=0txnty=0tymh[tx][ty]h[x][y]) v = max(v,dp(tx,ty)+1); //此处是记录的发起点 return v; int main(void)\tcinnm;\tfor(int i=0;in;i++) for(int j=0;jm;j++) scanf(%d,h[i][j]); memset(f,-1,sizeof f);\tint res = -1;\tfor(int i=0;in;i++) for(int j=0;jm;j++) res = max(res,dp(i,j));\tcoutres;\treturn 0; Problem: 100220. 相同分数的最大操作数目 II ​ 暴力dfs： #includeiostream#includevector#includeclimits#includequeueusing namespace std;int mx = -1;dequeint f1(dequeint a) //delete front2\tint sum = a[0] + a[1];\ta.pop_front();\ta.pop_front();\ta.push_front(sum);\treturn a;dequeint f2(dequeint a)//delete back2\tint n = a.size()-1;\tint sum = a[n]+a[n-1];\ta.pop_back();\ta.pop_back();\ta.push_front(sum);\treturn a;\tdequeint f3(dequeint a)//delete front1 + back1\tint sum = a.front() + a.back();\ta.pop_front();\ta.pop_back();\ta.push_front(sum);\treturn a; //返回数组，同时添加数组的第一个元素，存储本次处理后的sumvoid dfs(dequeint a,int step,int sum)\tif(a.size()=1) if(mxstep)\tmx = step; return ; dequeint b ;//保证原数组数据干净。 b = f1(a); //按第一种方式处理\tint t_sum = b[0];\tb.pop_front();//收到队头总和元素，去掉deque里多余的队头元素。 if(t_sum!=sum)//不相等，不符合条件 if(mxstep) mx = step; else dfs(b,step+1,sum); //相等，符合条件，继续 b = f2(a);//按第二种方式处理\tt_sum = b[0];\tb.pop_front();\tif(t_sum!=sum) if(mxstep) mx = step; else dfs(b,step+1,sum); b = f3(a);//按第三种方式处理\tt_sum = b[0];\tb.pop_front();\tif(t_sum!=sum) if(mxstep) mx = step; else dfs(b,step+1,sum); int main(void)\tvectorint v = 3,2,6,1,4;\tdequeintd v.begin(),v.end();\tdfs(d,0,f1(d)[0]);\tdfs(d,0,f2(d)[0]);\tdfs(d,0,f3(d)[0]);\tcoutmx; 520 549 个通过的测试用例 借助deque的暴力dfs #includeiostream#includevector#includecstringusing namespace std;const int N = 2010;//f(l,r) l与r中间的最大值int f[N][N];int dfs(const vectorint nums,int l,int r,int target)\tif(l=r) return 1;\tint t = f[l][r];\tif(t!=-1) return t;\tint res = 1; if(nums[l]+nums[l+1]==target) res = max(res,dfs(nums,l+2,r,target)+1); if(nums[r]+nums[r-1]==target) res = max(res,dfs(nums,l,r-2,target)+1); if(nums[l]+nums[r]==target) res = max(res,dfs(nums,l+1,r-1,target)+1); t = res;\treturn res;\tint main(void)\tvectorint nums = 2,2,3,2,4,2,3,3,1,3;\tmemset(f,-1,sizeof f);\tint l = 0,r = nums.size()-1; int res = max(max(dfs(nums,l+2,r,nums[l]+nums[l+1]),dfs(nums,l,r-2,nums[r]+nums[r-1])) ,dfs(nums,l+1,r-1,nums[l]+nums[r]));\tcoutres; AC 二分#includestdio.hint left_bound_k(int* nums,int numsSize,int target)\tint left = 0 ,right = numsSize;\twhile(leftright) int mid = left+(right-left)/2; if(nums[mid]==target) right = mid; else if(nums[mid]target) right = mid; else if(nums[mid]target) left = mid+1; return nums[left]==target?left:-1; int right_bound_k(int* nums,int numsSize,int target)\tint left = 0 ,right = numsSize;\twhile(leftright) int mid = left+(right-left)/2; if(nums[mid]==target) left = mid+1; else if(nums[mid]target) right = mid; else if(nums[mid]target) left = mid+1; if (left - 1 0 || left - 1 = nums.size()) return -1;\treturn nums[left - 1] == target ? (left - 1) : -1;int left_bound_b(int* nums,int numsSize,int target)\tint left = 0 ,right = numsSize-1;\twhile(left=right) int mid = left+(right-left)/2; if(nums[mid]==target) right = mid-1; else if(nums[mid]target) left = mid+1; else if(nums[mid]target) right= mid-1; if(left==numsSize) return -1;\treturn left;int right_bound_b(int* nums,int numsSize,int target)\tint left = 0 ,right = numsSize-1;\twhile(left=right) int mid = left+(right-left)/2; if(nums[mid]==target) left = mid+1; else if(nums[mid]target) right = mid-1; else if(nums[mid]target) left = mid+1; if(left-10||left-1=nums.size()) return -1;\treturn ums[left-1]!=target?left-1:-1;int common_merge(int* nums,int numsSize,int target) int left = 0; int right = numsSize - 1; // 注意 while(left = right) int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] target) left = mid + 1; // 注意 else if (nums[mid] target) right = mid - 1; // 注意 return -1; 计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。 为什么 while 循环的条件中是 ，而不是 while(lr) : 初始化r的值 r = nums.size 相当于左闭右开，[left,right) ，right 不能取到初始值 while(l=r) : 初始化r的值r = nums.size -1 相当于左闭右闭，[left,right] ,right 可以取到初始的最大值。 停止搜索的区间？ 找到了目标值的时候可以终止： if(nums[mid] == target) return mid; 但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？ 搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。 while(left = right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空。所以这时候 while 循环终止是正确的，直接返回 -1 即可。 while(left right) 的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。 当然，如果你非要用 while(left right) 也可以，我们已经知道了出错的原因，就打个补丁好了： //...while(left right) // ...return nums[left] == target ? left : -1;//判断漏掉的那个数是不是符合目标值 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？ 答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。 刚才明确了「搜索区间」这个概念： 如果搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步当然去搜索区间 [left, mid-1] 或者区间 [mid+1, right]， 因为 mid 已经搜索过，应该从搜索区间中去除。 如果搜索区间左闭右开，即[left, right]，则可以搜索区间[mid+1,right) 和 [left,mid) 。因为右边界不会被搜索到。 关注点在于 mid 作为左右边界时的变化，即是否有必要+1 -1 。 为什么求右侧边界最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。 答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的。 至于 left 是否要减1，关键在于if (nums[mid] == target) 语句， // 增大 left，锁定右侧边界if (nums[mid] == target) left = mid + 1; // 这样想: mid = left - 1 因为我们对 left 的更新必须是 left mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。 至于为什么 left 的更新必须是 left mid + 1，当然是为了把 nums[mid] 排除出搜索区间，这里就不再赘述 左闭右闭的时候：循环结束条件相比左闭右开的left == right 变成了 left == right +1 ，即left-1 == right。 求右侧边界的函数条件里，仍然是left = mid + 1 。所以结果 left - 1 求左侧边界的函数条件，是right = mid - 1 ，将 right 转换为 left ，右： left - 1 = mid -1 ，即left = mid 。 所以结果是left 由上可知，结果取left还是right，其实根据循环条件结束的判断来看，两者可以互相换算，是一样的。 取left后是否要 - 1，要看nums[mid]==target判断语句的内容，是 left 还是 right。（实际上就是看左闭右开还是左闭右闭，也就是 还是 = 。"},{"title":"链表 + 双指针刷题路线","path":"/wiki/algorithm/链表 + 双指针刷题路线.html","content":"双指针基础：C++ 指针基本语法 路线： labuladong：https://labuladong.github.io/algo/2/20/23/ 有讲解视频，图文博客，附带了 leetcode 题型 主要涉及数组相关的双指针，和面向题目的讲解 做题笔记（阿秀）：https://interviewguide.cn/notes/03-hunting_job/03-algorithm/03-leetcode/08-%EF%B8%8F%E5%8F%8C%E6%8C%87%E9%92%88/medium/986.%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86.html 没有讲解，只有题解 yxc 双指针（中间包括滑动窗口等）：https://www.bilibili.com/video/BV1t4411o7i6?spm_id_from=333.999.0.0vd_source=a5608f967616bf12d83f68f3e350efa5 代码随想录 ：https://github.com/youngyangyang04/leetcode-master 部分题解有视频，图文博客，比较详细。 踏实的教学+力扣题 链表基础：需要简单手搓一下链表，了解其数据结构。 至少写出链表数组的增删改查 路线： labuladong ：https://labuladong.github.io/algo/2/19/ 有讲解视频，图文博客，附带了 leetcode 题型 涵盖 回文链表、反转链表、配合递归、双指针的链表 leetbook：https://leetcode.cn/leetbook/detail/linked-list/ 反转链表等的文档，不太精细。 yxc 链表专题讲题：https://www.bilibili.com/video/BV1jt411J7tC?spm_id_from=333.999.0.0 大佬带刷力扣题的视频 代码随想录 ：https://github.com/youngyangyang04/leetcode-master 部分题解有视频，图文博客，比较详细。 踏实的教学+力扣题 某算法模板：https://github.com/greyireland/algorithm-pattern/blob/master/data_structure/linked_list.md 基于题解的图文，纯干货，不生动，讲解部分少。"},{"title":"Shell入门","path":"/wiki/linux/Shell入门.html","content":"shell基础Shell概述 Shell是什么 Shell是一个命令行解释器，它为用户提供 了一个向Linux内核发送请求以便运行程 序的界面系统级程序，用户可以用Shell来 启动、挂起、停止甚至是编写一些程序。 Shell还是一个功能相当强大的编程语言， 易编写，易调试，灵活性较强。Shell是解 释执行的脚本语言，在Shell中可以直接调 用Linux系统命令。 Shell的分类 Bourne Shell:从1979起Unix就开始使用 Bourne Shell，Bourne Shell的主文件名为 sh。 C Shell: C Shell主要在BSD版的Unix系 统中使用，其语法和C语言相类似而得名 Shell 的两种主要语法类型有Bourne和C， 这两种语法彼此不兼容。 Bourne家族主要包括sh、ksh、Bash、psh、zsh; C 家族主要包括:csh、tcsh Bash: Bash与sh兼容，现在使用的Linux 就是使用Bash作为用户的基本Shell。 Linux支持的Shell存放在文件里：/etc/shells默认情况下有： /bin/sh/bin/bash/sbin/nologin/bin/tcsh/bin/csh Shell脚本的执行脚本文件一般是 .sh 结尾。 执行: bash test.sh #绝对路径或相对路径皆可 有一个操作：如果从Windows里面拷贝一个脚本到Linux 虽然有的时候格式一样但是还是会报错，这便是因为两个系统中脚本的格式不同，比如Windows中的回车在脚本中用^M$表示，而Linux中为$，（可以用cat -A [文件名] 来查询）所以需要转变，此时用到一个命令：dos2unix [文件名]转换后，Linux就可以执行啦，通过没有这个命令可以使用yum安装 历史命令history [选项] [历史命令保存文件] -c: 清空历史命令 -w: 把缓存中的历史命令写入历史命令保存文件 ~.bash_history 历史命令默认会保存1000条,可以在环境 变量配置文件etcprofile中进行修改找到HISTSIZE1000进行修改，随意修改到100000条都可以，修改之后重启使配置文件生效 历史命令的调用 使用上、下箭头调用以前的历史命令 使用“!n”重复执行第n条历史命令 使用“!!”重复执行上一条命令 使用“!字串”重复执行最后一条以该字 串开头的命令 命令与文件补全在Bash中，在输入命令或文件时，按“Tab”键就会自动进行补全 命令别名 alias 别名=‘原命令’ 设定命令别名alias 查询命令别名 命令执行时顺序： 1 第一顺位执行用绝对路径或相对路径执行 的命令。 2 第二顺位执行别名。 3 第三顺位执行Bash的内部命令。 4 第四顺位执行按照$PATH环境变量定义的 目录查找顺序找到的第一个命令。 让别名永久生效： vi /root/.bashrc 删除别名 unalias 别名 Bash常用快捷键 快捷键\t作用ctrl+a\t把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移 动到命令行开头时使用。ctrl+e\t把光标移动到命令行结尾。ctrl+c\t强制终止当前的命令。ctrl+l\t清屏，相当于clear命令。ctrl+u\t删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退 格键一个一个字符的删除，使用这个快捷键会更加方便ctrl+k\t删除或剪切光标之后的内容。ctrl+y\t粘贴ctrl+U或ctrl+K剪切的内容。ctrl+r\t在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入 搜索内容，就会从历史命令中搜索。ctrl+d\t退出当前终端。ctrl+z\t暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管 理章节详细介绍。ctrl+s\t暂停屏幕输出。ctrl+q\t恢复屏幕输出。 注意：ctrl+z 快捷键一定要谨慎使用，如果使用的多了，系统会占用大量存储空间来存放暂停的数据，用多了系统会变卡！！！ 输入输出重定向 标准输入输出 设备 设备文件名 文件描述符 类型 键盘 devstdin 0 标准输入 显示器 devsdtout 1 标准输出 显示器 devsdterr 2 标准错误输出 输出重定向 类型 符号 作用 标准输出重定向 命令 文件 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。 标准输出重定向 命令 文件 以追加的方式，把命令的正确输出输出到指定的文件或设备当中。 标准错误输出重定向 错误命令 2文件 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。 标准错误输出重定向 错误命令 2文件 以追加的方式，把命令的错误输出输出到指定的文件或设备当中。 在输入报错文件中 2和必选连着写 。 标准错误输出不常用 类型 符号 作用 正确输出和错误输出同时保存 命令 文件 21 以覆盖的方式，把正确输 出和错误输出都保存到同 一个文件当中。 正确输出和错误输出同时保存 命令 文件 21 以追加的方式，把正确输 出和错误输出都保存到同 一个文件当中。 正确输出和错误输出同时保存 命令 文件 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 正确输出和错误输出同时保存 命令 文件 以追加的方式，把正确输出和错误输出都保 正确输出和错误输出同时保存 命令 文件1 2文件2 把正确的输出追加到文件1中，把错误的输出追加到文件2中。 命令 文件 21 ，命令 文件 , 两种保存都一样，只不过是格式不同。 有一个用法：命令 /dev/unll 不管命令是否正确，直接丢入这个文件夹，不保存任何数据，在写shell脚本时有用 。 输入重定 不通过键盘输入，通过文件输入，在实际中用的不多，用在给源码包打补丁。 wc [选项] [文件名] -c 统计字节数 -w 统计单词数 -l 统计行数 用法：命令 文件 : 把文件作为命令的输入。命令 标识符 : 一直输入，直到输入标识停止输入把标识符之间内容作为命令的输入。 管道符**管道符作用：**链接多个命令，把命令1的结果作为命令2的操作对象。 管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin） 命令1 | 命令2 注意：命令1的正确输出作为命令2的操作对象 grep : 主要用于过滤 grep [选项] 文件名/路径内容 -i: 忽略大小写 -n: 输出行号 -v: 反向查找 –colorauto 搜索出的关键字用颜色显示 ls / | grep “y”#针对上面这个命令说明：#以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。 为了便于理解，上述的指令变相实现可以如下： ls / xxx.txt #将ls /的结果保存到xxx.txt文件中grep “y” xxx.txt #使用grep指令搜索xxx.txt中的包含y的行 xargs命令扩展 问题：为什么需要xargs命令？ 答：之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令。 首先来看一个命令： find /etc -name *.conf | ls -l #(错误)find /etc -name *.conf | xargs ls -l #(正确 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。 cat word.txt|xargs #多行输入单行输出cat word.txt|xargs -n #多行输出 ls / | wc -l #统计“/”下的文档的个数cat /etc/passwd | wc -l #统计有多少个用户信息 多命令顺序执行 多命令执行符 格式 作用 ; 命令1 ;命令2 多个命令顺序执行，命令之间没有任何逻辑联系，就算第一条报错，第二条也会执行 命令1 命令2 逻辑与当命令1正确执行，则命令2才会执行 当命令1执行不正确，则命令2不会执行 | | 命令1 || 命令2 逻辑或当命令1 执行不正确，则命令2才会执行 当命令1正确执行，则命令2不会执行 磁盘文件复制： dd if=输入文件 / of=输出文件 / bs=字节数/ count=个数 if=输入文件 指定源文件或源设备 of=输出文件 指定目标文件或目标设备 bs=字节数 指定一次输入输出多少字节，即把这些字节看做 一个数据块 count=个数 指定输入输出多少个数据块 这条命令可以把系统文件，磁盘都复制了，非常强大。 例子： date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date 通配符与特殊符号通配符： 通配符 作用 ? 匹配任意一个字符 * 匹配0个或任意多个任意字符，也就是可以匹配任何内容 [] 匹配中括号中任意一个字符。例如:[abc]代表一定匹配 一个字符，或者是a，或者是b，或者是c。 [-] 匹配中括号中任意一个字符，-代表一个范围。例如:[a-z] 代表匹配一个小写字母。 [^] 逻辑非，表示匹配不是中括号内的一个字符。例如:[ ^0- 9 ]代表匹配一个不是数字的字符。 特殊符号 符号 作用 ‘’ 单引号。在单引号中所有的特殊符号，如“$”和“”(反引号)都 没有特殊含义。 “” 双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“” 和“\\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。 和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。 $() 和反引号作用一样，用来引用系统命令。 # 在Shell脚本中，#开头的行代表注释。 $ 用于调用变量的值，如需要调用变量name的值时，需要用$name 的方式得到变量的值。 \\ 转义符，跟在\\之后的特殊符号将失去特殊含义，变为普通字符。 如$将输出“$”符号，而不当做是变量引用。 shell编程正则表达式 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、 sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。 通配符匹配文件名，正则匹配字符串。这种区分是Linux特点，其他语言往往不区分通配符和正则。或者说通配符仅仅是正则中的一个符号而已。 基础正则表达式 元字符 作用 - 前一个字符匹配0次或任意多次。 . 匹配除了换行符外任意一个字符。 ^ 匹配行首。例如:^hello会匹配以hello开头的行。 $ 匹配行尾。例如:hello会匹配以hello结尾的行。 [] 匹配中括号中指定的任意一个字符，只匹配一个字符。 例如:[aoeiu] 匹配任意一个元音字母，[0-9] 匹配任意一位 数字， [a-z][0-9]匹配小写字和一位数字构成的两位字符。 [^] 匹配除中括号的字符以外的任意一个字符。例如:[^0-9] 匹配 任意一位非数字字符，[^a-z] 表示任意一位非小写字母。 \\ 转义符。用于取消讲特殊符号的含义取消。 {n} 表示其前面的字符恰好出现n次。例如:[0-9]{4} 匹配4位数 字，[1][3-8][0-9]{9} 匹配手机号码。 {n\\ } 表示其前面的字符出现不小于n次。例如: [0-9]{2,} 表示两 位及以上的数字。 {n,m} 表示其前面的字符至少出现n次，最多出现m次。例如: [a- z]{6,8} 匹配6到8位的小写字母。 注意：斜杠 \\ 是转移符。 使用”{“ , “}” 需要使用转义符。 grep 过滤指令示例： -i:忽略大小写 -c:只输出匹配行的数量 -l:只列出符合匹配的文件名，不列出具体的匹配行 -n:列出所有的匹配行，并显示行号 -h:查询多文件时不显示文件名 -v:显示不包含匹配文本的所有行 -w:匹配整词 -x:匹配整行 -r:递归搜索 “ * ”前一个字符匹配 0 次，或任意多次* grep “a*” test_rule.txt匹配所有内容，包括空白行 grep “aa*” test_rule.txt匹配至少包含有一个a的行* grep “aaa*” test_rule.txt匹配最少包含两个连续a的字符串 grep “aaaaa*” test_rule.txt则会匹配最少包含四个个连续a的字符串 “.” 匹配除了换行符外任意一个字符 grep “s…d” test_rule.txt“s…d”会匹配在s和d这两个字母之间一定有两个字符的单词 grep “s.*d” test_rule.txt匹配在s和d字母之间有任意字符* grep “.*” test_rule.txt匹配所有内容。 “^”匹配行首，“$”匹配行尾 grep “^M” test_rule.txt匹配以大写“M”开头的行 grep “n$” test_rule.txt匹配以小写“n”结尾的行 grep -n “^$” test_rule.txt会匹配空白行 “[]” 匹配中括号中指定的任意一个 字符，只匹配一个字符 grep “s[ao]id” test_rule.txt匹配s和i字母中，要不是a、要不是o grep “[0-9]” test_rule.txt匹配任意一个数字 grep “^[a-z]” test_rule.txt匹配用小写字母开头的行“[^]” 匹配除中括号的字符以外的 任意一个字符 grep “^[ ^a-z ]” test_rule.txt匹配不用小写字母开头的行 grep “^[ ^a-z A-Z ]” test_rule.txt匹配不用字母开头的行 “\\” 转义符 grep “\\.$” test_rule.txt匹配使用“.”结尾的行 “{n}”表示其前面的字符恰好出现n次 grep “a\\{3\\}” test_rule.txt匹配a字母连续出现三次的字符串 grep “[0-9]\\{3\\}” test_rule.txt匹配包含连续的三个数字的字符串 “{n,}”表示其前面的字符出现不小于n次 grep “^\\[0-9]\\{3,\\}[a-z]” test_rule.txt匹配最少用连续三个数字开头的行 “{n,m}”匹配其前面的字符至少出现n次， 最多出现m次 grep “sa\\{1,3\\}i” test_rule.txt匹配在字母s和字母i之间有最少一个a，最多三个a 字符截取命令cutcut [选项] 文件名 -f 列号: 提取第几列 -d 分隔符: 按照指定分隔符分割列 特点： 1.提取多列时，用“，”隔开就可以 cut -f 2 student.txtcut -f 2,3 student.txt 2.有具体分割符时，也可以没有Tab键cut -d “:” -f 1,3 /etc/passwd : 以：为分隔符取1，3列 3.一般在使用cut命令的时候和管道符“|”连着使用 局限性： cat不支持空格“ ”作为分隔符。因为机器识别的空格和输出的空格数可能不一致。（这里很玄学，你可以自己跑跑试试，确实是这样的） 应取而代之以制表符 tab 。 配合grep： #得到passwd里的非root普通用户名cat /etc/passwd | grep /bin/bash | grep -v root |cut -d : -f 1 printfprintf ‘输出类型+输出格式’ 输出内容 输出类型: %ns: 输出字符串。n是数字指代输出几个字符 %ni: 输出整数。n是数字指代输出几个数字 %m.nf: 输出浮点数。m和n是数字，指代输出的整数 位数和小数位数。如%8.2f代表共输出8位数， 其中2位是小数，6位是整数。 输出格式: \\a: 输出警告声音 \\b: 输出退格键，也就是Backspace键 \\f: 清除屏幕 : 换行 \\r: 回车，也就是Enter键 \\t: 水平输出退格键，也就是Tab键 \\v: 垂直输出退格键，也就是Tab键 每有一个%s代表每几个字符输出一次%s %s %s 代表没三个字符输出一次并且换行 他在与cat命令结合使用的时候，需要用$()把cat命令扩起来，使用这种命令赋予变量的方式，才能正确输出文件内容，但是具体格式还得用%s\\t 或者%s 控制。 printf ‘%s’ $(cat student.txt) #不调整输出格式printf ‘%s\\t %s\\t %s\\t %s\\t %s\\t %s\\t ’ $(cat student.txt) #调整格式输出 printf 不接收管道符输出，也不能指定文件名(会被当成字符串）。 因为 awk 命令不支持 echo 和 cat 命令，所以 printf主要在 awk 命令编程中使用。 在awk命令的输出中支持print和printf命令。 print : print会在每个输出之后自动加入一 个换行符(Linux默认没有print命令，只在 awk 中用)printf : printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工 awkawk命令也叫awk编程，可以识别非制表符的空格，用来解决cut命令解决不了的提取列工作，他是把需要提取的原文件一行一行扫描，扫描每一行中所需要点列，然后把它记录下来，在全部扫描完之后全部打印出来。 awk ‘条件1动作1 条件2动作2…’ 文件名 条件(Pattern):一般使用关系表达式作为条件 x 10 判断变量 x是否大于10x10 大于等于x10 小于等于 动作(Action): 格式化输出流程控制语句。 可以是函数，可以是 print/printf，可以是流程控制。 例子：vi student.txtID Name PHP Linux MySQL Average1 Liming 82 95 86 87.662 Sc 74 96 87 85.663 Gao 99 83 93 91.66 #提取第2列和第6列。awk ‘printf $2 “\\t” $6 “ ”’ student.txt#提取 df -h命令显示之后的内容中第一列和第三列df -h | awk print $1 “\\t” $3#关系运算符cat student.txt | grep -v Name | awk $6 = 87 printf $2 “ ” 其中**$2代表第2列，$6代表第6列**，他可以识别非制表符的空格，单引号里面直接大括号代表没有条件，只要是输入有内容全部符合。 一些特殊用法： BEGIN BEGIN必须是大写，他是一个条件。 awk ‘BEGINprintf “This is a transcript ” printf $2 “\\t” $6 “ ”’ student.txt 他会在打印出2，6行之前先输出一句话 This is a transcript它的作用是强制执行BEGIN后的命令，再去执行接下来的筛选操作。 你可以理解为一个初始化命令。通常BEGIN用来指定分隔符。 内置变量 FS ：FS是用来指定分隔符的 默认空格和换行符为分隔符。例子：FS“:”就是指定：为分隔符 cat /etc/passwd | grep “/bin/bash” |awk BEGIN FS=: printf $1 “\\t” $3 “ ” Q:这是打印用户信息地一和第三列，为什么需要在{FS”:”} 前加BEGIN呢？ A:因为如果你不加BEGIN你会发现除了第一行，其他都已经按格式打印出来了，但是只有第一行会照原样输出，因为awk默认是空格为分隔符，他在执行这条命令的时候，第一行数据已经被扫描了，所以来不及修改格式。 加了BEGIN，他会第一步强制先把默认分隔符修改了。 sedsed命令:sed 是一种几乎包括在所有 UNIX 平台(包括 Linux)的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。 它不仅可以修改文件内容，还可以修改命令结果，支持管道符操作，这就是与vim最大的区别 sed [选项] ‘[动作]’ 文件名 选项： -n: 一般sed命令会把所有数据都输出到屏幕 ， 如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。 -e: 允许对输入数据应用多条sed命令编辑 -i: 用sed的修改结果直接修改读取数据的文件， 而不是由屏幕输出 动作: a : 追加，在当前行后添加一行或多行。添加多行时，除最后 一行外，每行末尾需要用“\\”代表数据未完结。 c : 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\\”代表数据未完结。 i : 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\\”代表数据未完结。 d: 删除，删除指定的行。 p:打印，输出指定的行。 s:字串替换，用一个字符串替换另外一个字符串。格式为“行范 围s旧字串新字串g”(和vim中的替换格式类似)。 例子： sed ‘2p’ student.txt 查看文件的第二行会显示： ID Name PHP Linux MySQL Average 1 Liming 82 95 86 87.66 1 Liming 82 95 86 87.66 2 Sc 74 96 87 85.66 3 Gao 99 83 93 91.66 发现多了一行，因为一般sed命令会把所有数据都输出到屏幕 ，只不过会先输出你想要的，这时候就需要-n配合。 sed -n ‘2p’ student.txt输入 -n 后就没有多余的了 sed ‘2,4d’ student.txt删除第二行到第四行的数据，但不修改文件本身 sed ‘2a hello’ student.txt在第二行后追加 ‘hello’ sed ‘2i hello \\ world’ student.txt在第二行前插入两行数据 sed ‘2c No such person‘ student.txt 替换第二行数据位 ‘No such person’ 特殊用法： 数据替换。 sed ‘s/旧字串/新字串/g’ 文件名 例子：字符串替换 sed ‘3s/74/99/g’ student.txt#在第三行中，把74换成99sed -i ‘3s/74/99/g’ student.txt#sed操作的数据直接写入文件sed -e ‘s/Liming//g ; s/Gao//g’ student.txt#同时把“Liming”和“Gao”替换为空 字符处理命令排序命令sortsort [选项] 文件名 -f:忽略大小写 -n:以数值型进行排序，默认使用字符串型排序 -r:反向排序 -t:指定分隔符，默认是分隔符是制表符 -k n[,m]: 按照指定的字段范围排序。从第n字段开始， m字段结束(默认到行尾) 例子： sort /etc/passwd#排序用户信息文件sort -r /etc/passwd#反向排序sort -t “:” -k 3,3 /etc/passwd#指定分隔符是“:”，用第三字段开头，第三字段结尾排序，就是只用第三字段排序,但是他不认识数字，会把数字当成字符串，认为3比11大 ，所以我需要加-n，进行数值排序sort -n -t “:” -k 3,3 /etc/passwd 统计命令wcwc [选项] 文件名 -l: 只统计行数 -w: 只统计单词数 -m: 只统计字符数 条件判断按照文件类型进行判断 测试选项 作用 -b 文件 判断该文件是否存在，并且是否为 块设备文件(是块设备文件 为真) -c文件 判断该文件是否存在，并且是否为字符设备文件(是字符设备 文件为真) -d 文件 判断该文件是否存在，并且是否为目录文件(是目录为真) -e 文件 判断该文件是否存在(存在为真) -f 文件 判断该文件是否存在，并且是否为普通文件(是普通文件为真) -L 文件 判断该文件是否存在，并且是否为管道文件(是管道文件为真) -p 文件 判断该文件是否存在，并且是否为符号链接文件(是符号链接 文件为真) -s 文件 判断该文件是否存在，并且是否为非空(非空为真) -S 文件 判断该文件是否存在，并且是否为套接字文件(是套接字文件 为真) 上面的表结合以下命令来判断： 两种判断格式 test -e rootinstall.log [ -e rootinstall.log ]中括号两边必须有空格，只能为[ -e rootinstall.log ] ，不能是[-e rootinstall.log] 示例： 在判断之后，使用echo $?来观察输出语句是否为真 [ -d /root ] echo “yes” || echo no 第一个判断命令如果正确执行，则打印“yes”，否则打印“no” 按照文件权限进行判断 测试选项 作用 -r 文件 判断该文件是否存在，并且是否该文件拥有读权限(有读 权限为真) -w文件 判断该文件是否存在，并且是否该文件拥有写权限(有写 权限为真) -x 文件 判断该文件是否存在，并且是否该文件拥有执行权限(有 执行权限为真) -u 文件 判断该文件是否存在，并且是否该文件拥有SUID权限(有 SUID权限为真) -g 文件 判断该文件是否存在，并且是否该文件拥有SGID权限(有 SGID权限为真) -k 文件 判断该文件是否存在，并且是否该文件拥有SBit权限(有 SBit权限为真) 示例：[ -w student.txt ] echo “yes” || echo “no”判断文件是拥有写权限的 不过系统不会区分，比如-w，只要（所有者，所属组，其他人）其中有一个有写权限，他就会返回yes，所以这个时候就需要我们自己写脚本 。 两个文件之间进行比较 测试选项 作用 文件1 -nt 文件2 判断文件1的修改时间是否比文件2的新(如果新则为真) 文件1 -ot 文件2 判断文件1的修改时间是否比文件2的旧(如果旧则为真) 文件1 -ef 文件2 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 例子：ln rootstudent.txt tmpstu.txt先创建一个硬链接[ rootstudent.txt -ef tmpstu.txt ] echo “yes” || echo “no” yes然后用test测试 两个整数之间比较 测试选项 作用 整数1 -eq 整数 2 判断整数1是否和整数2相等(相等为真) 整数1 -ne 整数 2 判断整数1是否和整数2不相等(不相等位置) 整数1 -gt 整数2 判断整数1是否大于整数2(大于为真) 整数1 -lt 整数2 判断整数1是否小于整数2(小于位置) 整数1 -ge 整数2 判断整数1是否大于等于整数2(大于等于为真) 整数1 -le 整数2 判断整数1是否小于等于整数2(小于等于为真) 例子： [ 23 -ge 22 ] echo “yes” || echo “no” yes 判断23是否大于等于22 [ 23 -le 22 ] echo “yes” || echo “no” no 判断23是否小于等于22 字符串的判断 测试选项 作用 -z 字符串 判断字符串是否为空(为空返回真) -n 字符串 判断字符串是否为非空(非空返回真) 字串1 字串2 判断字符串1是否和字符串2相等(相等返回真) 字串1 ! 字串2 判断字符串1是否和字符串2不相等(不相等返回真) 例子：1.name=sc给name变量赋值2.[ -z “$name” ] echo “yes” || echo “no” no判断name变量是否为空，因为不为空，所以返回no aa=11bb=22先给变量aa和变量bb赋值[ “$aa” == “$bb ] echo “yes” || echo no然后判断两个变量的值是否相等，明显不相等 ，所以返回no 多重条件判断 测试选项 作用 判断1 -a 判断2 逻辑与，判断1和判断2都成立，最终的结果才为真 判断1 -o 判断2 逻辑或，判断1和判断2有一个成立，最终的结果就为 真 !判断 逻辑非，使原始的判断式取反 例子：aa=11[ -n “$aa” -a “$aa” -gt 23 ] echo “yes” || echo no判断变量aa是否有值，同时判断变量aa的是否大于23因为变量aa的值不大于23，所以虽然第一个判断值为真， 返回的结果也是假aa=24[ -n “$aa” -a “$aa” -gt 23 ] echo “yes” || echo “no” yes 流程控制if两种形式，区别在 ; if [ 条件判断式 ];then\t程序fi ##########if [ 条件判断式 ]\tthen 程序 fi 单分支条件语句需要注意几个点 if语句使用fi结尾，和一般语言使用大括号结尾不同 [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格 then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了 if [ 条件判断式] then 条件成立时，执行的程序 else 条件不成立时，执行的另一个程序fi ##########if [ 条件判断式1 ] then 当条件判断式1成立时，执行程序1 elif [ 条件判断式2 ] then 当条件判断式2成立时，执行程序2#...省略更多条件... else 当所有条件都不成立时，最后执行此程序 fi casecase $变量名 in 值1) 如果变量的值等于值1，则执行程序1 ;; 值2) 如果变量的值等于值2，则执行程序2 ;; #...省略其他分支... *) 如果变量的值都不是以上的值，则执行此程序;; esac 示例： #!/bin/bash #判断用户输入 #Author: yangyang (E-mail: 1771566679@qq.com) read -p Please choose yes/no: -t 30 chocase $cho in yes) echo Your choose is yes! ;; no) echo Your choose is no! ;; *) echo Your choose is error! ;; esac for两种表示方法 for 变量 in 值1 值2 值3do 程序done###############for ((初始值;循环控制调节;变量变化)) #C 风格啦 do 程序 done 例子： #打印时间#!/bin/bashfor time in morning noon afternoon evening\tdo echo “This time is $time!”\tdone #批量解压缩软件包#!/bin/bashcd /lampls *.tar.gz ls.log #ls *.tar.gz 输出结果覆盖到ls.log文件for i in $(cat ls.log) do tar -zxf $i $/dev/null donerm -rf /lamp/ls.log #批量添加新用户read -p Please input user name: -t 30 name #输入用户名，等待时间30sread -p Please input the number of users: -t 30 num #输入创建用户个数，等待时间30sread -p Please input the password of users: -t 30 pass #输入用户密码，等待时间30sif [ ! -z $name -a ! -z $num -a ! -z $pass ] #判断输入信息是否为空 then y=$(echo $num | sed s/^[0-9]*$//g) #这里是判断输入的用户个数是否为数字，sed后也可以把^[0-9]*$换为s/[0-9]//g if [ -z $y ] #如果上一条语句输出不为空，就是输入的用户个数为数字，继续执行 then for ((i=1;i=$num;i++)) #开始循环 do /usr/sbin/useradd $name$i /dev/null #建立用户 echo $pass | /usr/bin/passwd --stdin $name$i /dev/null #设置用户密码，与用户名相同 done echo Build seccees! fifi 如果输入的时候输错了需要按，ctrl+退格键 while 与 untilwhile 循环 while [ 条件判断式 ] do 程序 done #从1加到100i=1 s=0 while [ $i -le 100 ] #如果变量i的值小于等于100，则执行循环 do s=$(( $s+$i )) i=$(( $i+1 )) done echo The sum is: $s until 循环，和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。 until [ 条件判断式 ] do 程序 done #从1加到100i=1 s=0 until [ $i -gt 100 ] #循环直到变量i的值大于100，就停止循环 do s=$(( $s+$i )) i=$(( $i+1 )) done echo The sum is: $s"},{"title":"Vim插件","path":"/wiki/linux/Vim插件.html","content":"NERDTree我说几个真用过的： , + n :打开 NertTree u ：返回到父目录 U：返回到父目录，但子目录保持展开 shift + i :显示隐藏文件 let NERDTreeShowHidden1 “默认显示隐藏文件 目录树的使用主要通过在vim的command模式下键入如下命令，即可达到相应的效果。 快捷键\t描述,+n\t打开当前文件NERDTree目录树，光标停留在上次光标停留的位置,+m\t打开当前文件NERDTree目录树，光标停留在当前文件路径的根目录上，并将文件夹折叠起来,+t\t打开关闭NERDTree目录树,+f\t查找当前文件在NERDTree中的位置，并将光标停留在NERDTree中该文件上 https://blog.csdn.net/weixin_37926734/article/details/124919260 ?: 快速帮助文档 o: 打开一个目录或者打开文件，创建的是 buffer，也可以用来打开书签 go: 打开一个文件，但是光标仍然留在 NERDTree，创建的是 buffer t: 打开一个文件，创建的是Tab，对书签同样生效 T: 打开一个文件，但是光标仍然留在 NERDTree，创建的是 Tab，对书签同样生效 i: 水平分割创建文件的窗口，创建的是 buffer gi: 水平分割创建文件的窗口，但是光标仍然留在 NERDTree s: 垂直分割创建文件的窗口，创建的是 buffer gs: 和 gi，go 类似 x: 收起当前打开的目录 X: 收起所有打开的目录 e: 以文件管理的方式打开选中的目录 D: 删除书签 NerdCommenter写注释的。 \\cc 注释当前行和选中行\\cn 没有发现和\\cc有区别\\c空格 如果被选区域有部分被注释，则对被选区域执行取消注释操作，其它情况执行反转注释操作\\cm 对被选区域用一对注释符进行注释，前面的注释对每一行都会添加注释\\ci 执行反转注释操作，选中区域注释部分取消注释，非注释部分添加注释\\cs 添加性感的注释，代码开头介绍部分通常使用该注释\\cy 添加注释，并复制被添加注释的部分\\c$ 注释当前光标到改行结尾的内容\\cA 跳转到该行结尾添加注释，并进入编辑模式\\ca 转换注释的方式，比如：和\\cl \\cb 左对齐和左右对其，左右对其主要针对 \\cu 取消注释 vim-airline状态栏高亮 YouCompleteMe代码补全"},{"title":"linux软件包管理","path":"/wiki/linux/linux软件包管理.html","content":"软件包管理 RPM包概念阐述 何为rpm？ rpm软件包 RPM : RPM包管理员（简称RPM，全称为The RPM Package Manager 此名词既可能指.rpm的文件格式软件包，也可能指其本身的软件包管理器(RPM Package Manager)。 最早由Red Hat研制，现在也由开源社区开发。 目前是GNULinux下软件包资源最丰富的软件包类型之一。 软件包管理系统是在电脑中自动安装、配制、卸载和升级软件包的工具组合，在各种系统软件和应用软件的安 装管理中均有广泛应用。 在Linux发行版中，几乎每一个发行版都有自己的软件包管理系统。 常见的有： 管理deb软件包的dpkg以及它的前端apt（使用于Debian、Ubuntu）。 RPM包管理员以及它的前端dnf（使用于Fedora）、 前端yum（使用于Red Hat Enterprise Linux）、 前端 ZYpp（使用于openSUSE） 前端urpmi（使用于Mandriva Linux、Mageia）等。 使用软件包管理系统将大大简化在Linux发行版中安装软件的过程。 RPM软件包分为二进制包（Binary）、源代码包（Source）和Delta包 三种。 二进制包可以直接安装在计算机中，而源代码包将会由RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。 代表性rpm下面聊聊两个代表性的rpm。 yumyum: Yum（全称为 Yellow dog Updater, Modified）是一个在 Fedora 、RedHat 和 CentOS中的Shell前端软件包管理器。 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 常用命令： #安装软件yum install foo-x.x.x.rpm#删除软件：yum remove foo-x.x.x.rpm#yum erase foo-x.x.x.rpm#升级软件：yum update foo#yum update foo#查询信息：yum info foo aptapt: linux软件包管理工具。用于在 Ubuntu, Debian , Linux 发行版上安装、更新、删除和管理 deb 软件包。 apt是Debian及其衍生产品的主要命令行包管理器，它提供了用于搜索、管理和查询的命令行工具、有关软件包的信息以及对所有功能的低级访问 作为操作的一部分，APT使用一个文件列出可获得软件包的镜像站点地址，这个文件就是/etc/apt/sources.list。 客户端在进行安装或升级时先要查询DEB索引清单，从而可以获知所有具有依赖关系的软件包，并一同下载到客户端以便安装。 当客户端需要安装、升级或删除某个软件包时，客户端计算机取得DEB索引清单压缩文件后，会将其解压置放于varstateaptlists，而客户端使用apt-get install或apt-get upgrade命令的时候，就会将这个文件夹内的数据和客户端计算机内的DEB数据库比对，知道哪些DEB已安装、未安装或是可以升级的。 一些常用命令： #安装删除sudo apt install package_namesudo apt remove package_name#要列出所有可用的软件包，请使用以下命令：sudo apt list#该命令将输出所有包的列表，包括有关包的版本和体系结构的信息。要了解是否安装了特定的软件包，可以使用grep命令过滤输出。 [1]sudo apt list | grep package_name#要仅列出已安装的软件包，请键入： [1]sudo apt list --installed#在实际升级软件包之前，获取可升级软件包的列表可能很有用： [1]sudo apt list --upgradeable apt 与 rpm 一样是 linux 软件包管理器。 rpm操作命令命名与依赖性RPM包命名规则 例子：Httpd-2.2.15.el6.centos.1.i686.rpm 其中： Httpd：软件包包名2.2.15：软件版本15：软件发布的次数el6.centos：适合的Linux平台i686：适合的硬件平台 noarch 表示任何硬件平台都可以安装 rpm rpm包扩展名如果自己组建rpm包，都以rpm结尾，这样更加清晰，其他管理员可以明白。 注意：Httpd-2.2.15.el6.centos.1.i686.rpm为包全名，Httpd 为包名。这两者有明显区别的，Linux系统命令严格区分两者 RPM包依赖性。 树形依赖：a→b→c 环形依赖：a→b→c→a 环形依赖需要把a,b,c三个同时安装 模块依赖：模块依赖查询网站：www.rpmfind.net 如果安装时遇到问题，出现依赖性错误的话：若被依赖文件以.so.[数字]结尾，则为库依赖，需要直接安装这个软件，错误会自动解决。安装这个包时需要进入网站 www.rpmfind.net 查询被依赖文件 安装升级与卸载 包全名：操作的包是没有安装的软件包时，使用包全名。 注意路径 包名：操作已经安装好的安装的软件包时，使用包名。 包名默认在搜索varlibrpm中的数据库 rpm -ivh 包全名 #RPM安装 参数： -i 安装（install） -v 显示详细安装信息（verbose） -h 显示进度（hash） –nodeps 不检测依赖性 一般不用，安装时都得显示依赖性 注意：安装一定要用包全名 rpm -Uvh 包全名 #RPM包升级 参数： -U 升级 rpm -e 包名 -e 卸载 –nodeps 不检查依赖性 查询#-q 查询（query）rpm -q 包名 #查询是否安装#-a 所有（all）rpm -qa #查询所有安装的包rpm -qa | grep [关键字]#查询所有含义关键字的包。 | 为管道符 。作用是：对于管道符两侧，左边命令的输出能作为右边命令的输入。 注意：1、管道命令只处理前一个命令正确输出，不处理错误输出。2、管道命令右边命令，必须能够接收标准输入流命令才行。 查询安装过软件包详细信息 rpm -qi 包名 #-i 查询软件信息（information）#-p 查询未安装包信息（package）rpm -qip 包全名#查询没安装过软件包详细信息 #因为包没有安装所以得加包全名，因为包在生产好的时候他的信息就已经生成，所以可以查到没安装好的包的信息。 查询包中文件安装位置 rpm -ql 包名 #-l 列表（list）#-p 查询未安装包信息（package） 查询系统文件属于哪个RPM包 rpm -qf 系统文件名 #-f 查询系统文件属于哪个软件包（file） 查询软件包的依赖性 rpm -qR 包名 #-R 查询软件包的依赖性（requires）#-p 查询未安装包信息（package） 校验和文件提取rpm -V 已安装的包名 RPM包校验 -V 校验指定RPM包中的文件（verify） 例子：rpm -V httpd 显示： S.5……T. c etchttpdconfheepd.conf 验证内容中的8个信息的具体内容： S：文件大小是否改变 M：文件的类型或文件的权限(rwx)是否被改变 5：文件MD5校验和是否改变(可以看成文件内容是否改变) MD5是进行文件完整性验证的 D：设备的中，从代码是否改变 L：文件路径是否改变 U：文件的属主(所有者)是否改变 G：文件的属组是否改变 T：文件的修改时间是否改变 文件类型： c：配置文件（config file） d：普通文档（documentation） g：“鬼”文件（ghost file）， 很少见，意识是该文件不应该被这个RPM包 包含。 l：授权文件（license file） r：描述文件（read me） rpm2cpio 包全名 | cpio -idv.文件绝对路径 rpm2cpio 是将rpm包转换为cpio格式的命令cpio 是一个标准工具，他用于创建软件档案文件和从档案文件中提取文件 源码包源码包和rpm的区别概念不同源码包 源码包：可以看到源代码，但是安装时间较慢。像脚本安装包类似Windows安装软件。 可以看作是是写了安装界面的源码包 优点： 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更适合自己的系统，使用更加稳定也效率更高 卸载方便，直接删除安装目录 缺点： 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错新手很难解决。 二进制包 二进制包：RPM包，系统默认包，厂商已经进行了编译，看不到源代码，但是安装时间较快 优点： 包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载。 安装速度比源码包安装快得多。 缺点： 经过编译，不再可以看到源代码。 功能选择不如源码包灵活。 依赖性 依赖性指的是要想安装A包就得先安装B包，要想安装B包又得先安装C包，所以只能以CBA的顺序。安装RPM包，删除的时候得按ABC顺序删除安装包，基本上所有的RPM包全有依赖性。 安装位置不同 RPM包默认安装路径(绝大部分软件文件安装位置): /etc 安装文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man 帮助文件保存位置 RPM包默认安装路径(绝大部分软件文件安装位置): 源码包安装位置： 安装在指定位置当中，一般是/usr/local/软件名/ 。 安装位置不同带来的影响: RPM包： RPM包安装的服务可以使用系统服务管理命令(service)来管理，例如RPM包安装的Apache的启动方法是： /etc/rc.d/init.d./httpd startservice httpd start #（红帽系列专有命令，如果没有只能靠/etc/rc.d/init.d./启动） RPM包的启动文件全在/etc/rc.d/init.d./里，service 会搜索RPM包所有的安装路径，所以 service 才能启动RPM包软件。 但是service启动不了源码包软件，因为源码包在/usr/local里，和RPM包不一样。 源码包 源码包启动使用绝对路径加start。 源码包的安装这里举例（安装Apache）说明一下： 安装准备 安装C语言编译器使用命令： yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake 执行命令前要下载源码包：http://mirror.bit.edu.cn/apache/httpd/选择任何版本，比如：httpd-2.4.43.tar.bz2 版本 注意事项 源码包保存位置：usrlocalsrc 软件安装位置：usrlocal 然后看看安装过程有没有报错：安装过程停止，并出现error，warning或者no提示，即发生错误 把电脑本机下载好的源码包传输到Linux系统或者服务器上。Windows下载WinSCP软件进行本机与虚拟机或者远程传输Mac连接远程阿里云服务器，终端使用命令 scp进行传输： scp -r localfile.txt username@192.168.0.1:/home/username/ 其中，１）scp是命令，-r是参数２）localfile.txt 是文件的路径和文件名３）username是服务器账号，一般为root４）192.168.0.1是要上传的服务器ip地址５）homeusername是要拷入的文件夹路径，一般为root 家目录例子：scp -r /Users/yangyangyang/Desktop/httpd-2.4.43.tar.bz2 root@47.95.5.171:/root 解压下载到源码包使用命令 tar -jxvf httpd-2.4.43.tar.bz2如果是tar.gz压缩包可以使用 tar -zxvf 命令 进入解压缩目录输入命令： cd httpd-2.4.43 INSTALL：安装说明README：使用说明 进入安装说明： vi INSTALL$ ./configure --prefix=PREFIX 编译前准备$ make 进行编译$ make install 编译安装$ PREFIX/bin/apachectl star 启动命令 这些为详细的安装步骤，其中：.configure为软件配置与检查 我们也称编译前准备1.定义需要的功能选项。2.检测系统环境是否符合安装要求3.把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。 定义安装路径退出之后输入命令：./configure --prefix=/usr/local/apache2 如果报错显示：进以下网址寻求解决办法http://www.cnblogs.com/yuzhaokai0523/p/4382974.html 完成定义输入命令：make 进行编译 完成编译输入命令：make install 编译安装 启动输入命令 /usr/local/apache2/bin/apachectl start$ PREFIX/bin/apachectl star #$pREFIX为软件安装路径 第三种包：脚本包 脚本安装包并不是独立的软件包类型，常见安装的是源码包。 是人为把安装过程写成了自动安装的脚步，只要执行脚本，定义简单的参赛，就可以完成安装。 非常类似于Windows下软件的安装方式。 使用绝对路径直接回车安装。 linux中.sh文件即脚本文件，一般都是bash脚本。"},{"title":"关于 vim - YouCompleteMe 的安装","path":"/wiki/linux/关于 vim - YouCompleteMe 的安装.html","content":"前提： 确保 vim 版本是 7.4.143 或以上，并且支持 python 23 脚本。 先通过 Git clone 或者 plug-install 的方式安装 YCM 步骤一： 基础配件要装好，不然麻烦重重： C++家族的配件： sudo apt-get install llvm clang-3.9 libclang-3.9-dev libboost-all-dev 步骤二： 我们需要找到libclang.so的路径在哪里，一般是在**usr**目录下使用一下命令查找 find /usr/ -name libclang.so* cmake -G generator . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp 官方解释： For those who want to use the system version of boost, you would pass -DUSE_SYSTEM_BOOST=ON to cmake. This may be necessary on some systems where the bundled version of boost doesn’t compile out of the box. 在任意位置创建一个文件夹，在里面进行编译工作。 然后编译(在新建的文件夹里)。 我的运行代码： cmake -G Unix Makefiles -DUSE_SYSTEM_BOOST=ON DEXTERNAL_LIBCLANG_PATH=/usr/local/lib/libclang.so -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/plugged/YouCompleteMe/third_party/ycmd/cpp 注意：这里有两个坑。 第一，注意 libclang 版本。 -- Using external libclang: /usr/lib/x86_64-linux-gnu/libclang-14.so.14.0.0 观察编译结束末尾几行中的 libclang 版本是否满足要求。系统安装的 libclang 最低要是是 3.9。 如果低于所需版本，就要删除 ~/.ycm_build 目录下的所有文件，使用下面的cmake选项参数指定 libclang 的版本重新编译。 DEXTERNAL_LIBCLANG_PATH=xxxxxx 第二，如果选项参数里的两个横线“–” 出问题，会出现C家族语义补全失效和找不到 “ycm_core”的情况。 成功后的输出结果，应该包含在前几行： Using libclang to provide semantic completion for C/C++/ObjC 步骤三： Makefile 收尾：构建 ycm_core 官方解释： Now that configuration files have been generated, compile the libraries using this command: YCM 官方墙烈推荐使用上游编译的二进制文件代替系统自带的 libclang You can use the system libclang only if you are sure it is version 3.9 or higher, otherwise don’t. Even if it is, we recommend using the official binaries from llvm.org if at all possible. Make sure you download the correct archive file for your OS. We STRONGLY recommend AGAINST use of the system libclang instead of the upstream compiled binaries. Random things may break. Save yourself the hassle and use the upstream pre-built libclang. （需要python3-dev) cmake --build . --target ycm_support_libs --config Release 我的运行代码： cmake --build . --target ycm_core --config Release （config Release 选项适用于 windows） 这一步运行后会有 0% 到 100% 的编译提示，最终出现 [100%] Built target ycm_core 的字样。 步骤四： 添加 vim 配置 注意下面的 python 解释器的路径要和编译 ycm_core 的时候使用的 python 解释器是相同的版本 #～/.vimrclet g:ycm_server_python_interpreter=/usr/bin/python3let g:ycm_global_ycm_extra_conf=~/.vim/plugged/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py 其他语言： java 首先提前安装环境： sudo apt install openjdk-8-jre 然后编译java环节。 python3 install.py --java-completer 官方文档： Java support: install JDK 17 and add --java-completer when calling install.py. python python自动补全。编译过去就行。 下面是一些关于python设置的官方文档 Python settings The Settings function allows users to specify the Python interpreter and the sys.path used by the completer to provide completion and code comprehension. No additional arguments are passed. The return value expected by the completer is a dictionary containing the following items: interpreter_path: (optional) path to the Python interpreter. ~ and environment variables in the path are expanded. If not an absolute path, it will be searched through the PATH. sys_path: (optional) list of paths prepended to sys.path. Usage example: def Settings( **kwargs ): return interpreter_path: ~/project/virtual_env/bin/python, sys_path: [ ~/project/third_party/module ] PythonSysPath( **kwargs ) Optional for Python support. This function allows further customization of the Python path sys.path. Its parameters are the possible items returned by the Settings function for the Python completer: interpreter_path: path to the Python interpreter. sys_path: list of Python paths from sys.path. The return value should be the modified list of Python paths. See ycmd’s own .ycm_extra_conf.py for an example. 问题汇总： 1.如果YCM的使用过程出现了问题，使用如下命令查看错误日志： YcmToggleLogs stderr 2.一个很牛的YCM调试随笔（通过修改源码使YCM支持gbk格式） https://www.cnblogs.com/HGtz2222/p/5175151.html 3.之前遇到的一个坑： YCM 的 python install.py ，出现了找不到 python 的情况。这时需要到出问题的文件里修改代码，将其引用的python头文件 (pyhton.h) 加上相对路径。 如： includepython.h#改为includeusr/local/python.h"},{"title":"上手新ubuntu机器的初始化工作","path":"/wiki/linux/上手新ubuntu机器的初始化工作.html","content":"环境类Vim直接贴配置 vim-Plug let mapleader = ,let gmapleader = ,let maplocalleader = ,NerdTreennoremap leadern NERDTreeFocusCRnnoremap leaderm NERDTreeCRnnoremap leadert NERDTreeToggleCRnnoremap leaderf NERDTreeFindCR快捷键修改set tabstop=4 tab键位数set shiftwidth=4 自动缩进位数set numberimap jk ESCnmap space vim-Plug 下载call plug#begin(~.vimplugged)Plug vim-airlinevim-airlinePlug vim-airlinevim-airline-themesPlug scrooloosenerdtreePlug luochen1990rainbowPlug scrooloosenerdcommenterPlug altercationvim-colors-solarizedPlug jiangmiaoauto-pairsPlug ValloricYouCompleteMecall plug#end()配置vim-airlineset laststatus=2 永远显示状态栏let gairline_powerline_fonts = 1 支持 powerline 字体let gairline#extensions#tabline#enabled = 1 显示窗口tab和bufferlet gairline_theme=bubblegumif !exists(gairline_symbols)\tlet gairline_symbols = endiflet gairline_left_sep = ▶let gairline_left_alt_sep = ❯let gairline_right_sep = ◀let gairline_right_alt_sep = ❮let gairline_symbols.linenr = ¶let gairline_symbols.branch = ⎇airline end nerd - commenter Add spaces after comment delimiters by defaultlet gNERDSpaceDelims = 1 Use compact syntax for prettified multi-line commentslet gNERDCompactSexyComs = 1 Align line-wise comment delimiters flush left instead of following code indentationlet gNERDDefaultAlign = left Set a language to use its alternate delimiters by defaultlet gNERDAltDelims_java = 1 Add your own custom formats or override the defaultslet gNERDCustomDelimiters = c left ,right Allow commenting and inverting empty lines (useful when commenting a region)let gNERDCommentEmptyLines = 1 Enable trimming of trailing whitespace when uncommentinglet gNERDTrimTrailingWhitespace = 1 Enable NERDCommenterToggle to check all selected lines is commented or notlet gNERDToggleCheckAllLines = 1 vim-rainbowlet grainbow_active = 1 vim-color- solarizedif has(gui_runing) 如果在图形用户界面 set background=light 设置背景色为亮色else 设置背景色为深色 set background=dark 就开启256色支持，默认为8色 set t_Co=256endiflet gsolarized_bold=0let gsolarized_underline=1 vim-autopairsau Filetype FILETYPE let bAutoPairs = ( )au FileType php let bAutoPairs = AutoPairsDefine( , php )let gycm_server_python_interpreter=usrbinpython3let gycm_global_ycm_extra_conf=~.vimpluggedYouCompleteMethird_partyycmdexamples.ycm_extra_conf.py 对vim实现代码补全插件 YouCompleteMe感兴趣的朋友可以看这篇文章：YouCompleteMe zsh1.zsh sudo apt install zsh 2.oh-my-zsh Basic install Oh My Zsh is installed by running one of the following commands in your terminal. You can install this via the command-line with either curl, wget or another similar tool. Method Command curl sh -c $(curl -fsSL httpsraw.githubusercontent.comohmyzshohmyzshmastertoolsinstall.sh) wget sh -c $(wget -O- httpsraw.githubusercontent.comohmyzshohmyzshmastertoolsinstall.sh) fetch sh -c $(fetch -o - httpsraw.githubusercontent.comohmyzshohmyzshmastertoolsinstall.sh) from httpsgithub.comohmyzshohmyzsh 3.powerlevel10k一个zsh主题 plugin plugins=( git zsh-history-substring-search zsh-autosuggestions zsh-syntax-highlighting ) 以autosuggestiongs为例：找到插件对应仓库，然后git clone git clone httpsgithub.comzsh-userszsh-autosuggestions $ZSH_CUSTOMpluginszsh-autosuggestions Backupext4分区的话有ext4magic，另外还有timeshift，snapper之类很强的备份工具，btrfs分区的快照也可以自由回滚 other gcc g++ sudo apt updatesudo apt install build-essential git yum rpm AlienAlien是用来将 rpm 包转换成 deb 包的。rpm文件不能直接被安装，需要转换成 deb。ubuntu 的安装包格式是 deb。 shell有zsh或者fish， 编辑器有neovim或者emacs 文件浏览有ls和ranger版本控制有lazygit 终端复用有tmux 还可以换的玩具有cgdb valgrind rr make autotools cmake meson xmake 示例图 文件系统：ext4 vulkan 游戏： wine有winetricks之类工具可以进行特殊配置，另外steam的proton对windows游戏支持更好，建议直接在steam里玩，运行不起来的可以看protondb.com上的评论区 应用类Typora支持typora版本1.0.3 本人已测试平台：Ubuntu22.04 激活环境准备 相关依赖 安装Python3、Python3-pip 安装nodejs sudo apt-get install nodejs 克隆typoraCraker项目 git clone httpsgithub.comcnvetmantyporacracker.git python相关依赖 切换到克隆下来的项目根目录typoracracker下执行： pip3 install -r requirements.txt 下载Typora1.0.3版本 项目目录下有typora_1.0.3的deb包，执行下面命令直接安装即可。 dpkg -i typora_1.0.3_amd64.deb 解包替换文件app.asar 以下操作都是切换到typoraCracker项目根目录下执行 注意，强烈建议在解包原生文件到~Desktop中 解包原生app.asar 安装Typora后，原生app.asar文件默认路径是usrsharetyporaresourcesapp.asar； 解包原生app.asar文件： python3 typora.py usrsharetyporaresourcesapp.asar ~Desktop #解包后，在桌面会有一个`dec_app`目录 修改License.js 修改dec_app目录中的License.js；在typoraCracker项目下，提供有修改好的License.js，所以直接替换即可： cp examplepatchLicense.js ~Desktopdec_app 生成app.asar python3 typora.py -u ~Desktopdec_app ~Desktop# 在~Desktop路径下，会生成新的的app.asar文件替换app.asar 替换app.asar 将Typora原生的的app.asar文件替换： # 备份原生app.asar文件sudo cp usrsharetyporaresourcesapp.asar usrsharetyporaresourcesapp.asar.bak # 用新生成的app.asar文件替换typora自带的app.asar文件sudo cp ~Desktopapp.asar usrsharetyporaresourcesapp.asar 激活Typora在typoraCracker项目根路径下，执行keygen.js脚本： 生成激活码 node examplekeygen.js 得到激活码后，打开Typora软件 – Typora帮助 – 我的许可证 – 输入你的激活信息，随便一个邮箱加生成的激活码。 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：httpsblog.csdn.netweixin_73546177articledetails132033297 VsCodeextension C++C extension Code Runner Tabnine AI autocomplete .vscode c_cpp_properties.json 鼠标点在.c的源文件内部，按 Ctrl+Shift+p 快捷键，在弹出的界面中选择 [CC++编配置(UI)]，然后进入设置页面。 点进去之后我们要设置我们的编译器路径和IntelliSense 模式： (windwos用户可以考虑。我使用ubuntu + gcc没有操作这一步，默认设置) tasks.json 创建执行任务 task.json 要编译代码，我们接下来，在终端中配置任务，如下图： 然后选择gcc.exe： 打开之后就会出现一个新的文件夹：这个文件是专门来执行编译任务的。 原文链接：httpsblog.csdn.netYikeforearticledetails130033638 launch.json Right click , then click Add Debug Configuration. 乱码ubuntu使用 Visual Studio Code 运行C程序时终端（控制台）上显示： result [1] + Done “usrbingdb” --interpreter=mi --tty=$DbgTerm 0tmpMicrosoft-MIEngine-In-b608v45i.py3 1tmpMicrosoft-MIEngine-Out-42xjb3vz.7lk 解决方式 在 launch.json 文件中的 configurations 字段中添加一项 miDebuggerArgs -q -ex quit; wait() fg devnull; ; bingdb -q --interpreter=mi, 再次运行C程序就不会出现不需要的信息了！———————————————— 版权声明：本文为博主 九思梦鹿 原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：httpsblog.csdn.netWU2629409421perfectarticledetails113357420 下面这三个软件没什么好说的。观望下deb包，然后sudo dpkg -i 就OK了。不过让我长见识的是，Ubuntu 桌面应用的快捷方式，竟然要到usrshareapplications这个目录下，找到.desktop文件，右键选择allow launching，这个应用才能从黑色变成红色，名字也自动变成所写。还蛮神奇的…… 话说我一开始发现原来 deb 包就是安装包，dpkg -i就是安装的时候，我震惊了； 发现桌面快捷方式是.desktop文件，而且要allow launching才能浮现真容的时候，我又一次震惊了。 发现usrbin下面的都是系统预装的可执行程序(命令），我还因为多敲了一个空格,sudo rm了bin目录的所有文件的时候，我又又又震震震惊了——在被锁屏页面将我的急救备份文件拒之门外的时候，我笑了笑，感叹自己二十二岁已经历了人生一次大起大落而笑了。于是重装系统喽。(现在看来，这篇文章以及 Ubuntu 全部 Bug 的解决没有辜负自己两天心流的努力呀！😀) (ps usrlocalbin目录是给用户放置自己的可执行程序.,不会被系统升级而覆盖同名文件。) WattToolkitQQWPS输入法Fcitx6.4.2024输入法。逆天输入法，总是卡QT 和GTK文件。一开始用fcitx4 GTK全部不兼容。后来用fcitx5 ，支持火狐浏览器和终端用了。自己下载的桌面应用程序还是用不了。逆天 6.6.2024更新。可以用了，两天没开电脑，今天上网搜了搜，无意中发现我的Typora、WPS 和QQ 这类桌面应用程序都能用了。但是这个时候fcitx-diagnose还是会有报错。至少说明这些错误和“是否支持桌面程序”无关。4.fcitx-remote 无法连接到 fcitx. 5.DBus 界面使用 dbus-send 来检查 dbus。 找不到 DBus 名称 org.fcitx.Fcitx 的所有者。 找不到 DBus 名称 org.fcitx.Fcitx 的 pid 所有者。2.用于 GTK+-2.0 的配置界面：未找到 gtk2 的配置界面. 2.根窗口上的 XIM_SERVERS Xim 服务名称 fcitx5 与环境变量中设置的值 fcitx 不同.3.QT输入法模块文件无法找到 Qt4 的 fcitx 输入法模块. 4.用户界面无法找到 kimpanel dbus 接口或非 kimpanel 用户界面. 但也不排除是因为我运行了这个指令 sudo apt-get install fcitx-libs-dev 把最后欠缺的依赖给安装上了。AnyWay,属于是柳暗花明又一村了。 这次经历让我懂得了：1.用 sudo rm 时请抱好极大求生欲2.Github 要学会看 issue3.少用百度搜，都是来回的copy.\t用Bing更好。 Deepin-wine Wechat在 fcitx 的 issue 里找解决方案的时候，我无意中发现了 deepin-wine-ubuntu 这个仓库。这玩意居然能装微信！不需要借助 铜豌豆 这种庞然大物，用Docker解决微信安装问题确实是不错的实践。后续我会找机会把微信这个BOSS拿下。现阶段可以说除微信外的所有BUG 、APP 都已经拿下了。奥，除了唯一的小问题：为什么 zsh 的 plugins 失效了，不给我自动补全和高亮。可恶。vim-Plug 也还没安上呢。 OK ，一身轻松。可以歇歇了。如果这个东西是你从0到1，一个一个 BUG解决，一个一个零件亲手建设起来的。随手的使用都会有很大的成就感。 比如现在的中文输入法哈哈。 Linux运行移动端APP的策略 pwa应用 将网页打包成APP应用程序 WebCatelog一个支持mac,windows,linux 的平台，已经预置了数千个可以打包的网页服务，安装完成后就会出现在启动台（ Launchpad）里面，可以作为独立的应用使用。 naivefier 浏览器，类似Eage、Chrome、Firefox浏览器内置app。我下载 Cubox 就是这种应用 随想所有问题已解决。收心学数学去了。 zsh插件没查到是因为.zshrc里原来的 plugins 没看到，写了两个plugin。 fcitx输入法有两个版本：fcitx4 和 fcitx5。我的ubuntu22.0不支持4,支持5。 Vim-Plug 安装时总连接不上Github。换源后完美解决。（改plug.vim两处) docker和虚拟机貌似也能实现微信。但我目前没有这个心思去研究docker,再把微信移植过去。所以先用简单易用的deepin-wine吧。 微信这类官方不支持的应用可以用wine解决。wine再往上一层，就是我所用的github项目：deepin-wine。deepin-wine 有两个版本，一个wszqkzqk，一个zq1997。两个rep都有5k+的star,但是wszqkzqk的 wine 22年就不再维护，关闭了issue。zq的一直在更新。所以用他的了。(实际上w的我尝试过但没有安装成功) 关于wine： wine 运用API转换技术实做出Linux对应到Windows相对应的函数来调用DLL以运行Windows程序。Wine 允许在 Linux 和其他类 Unix 操作系统上运行 Windows 应用程序的兼容层。 Wine是自由软件，在GNU通用公共许可证（LGPL） 下发布。名称是 Wine Is Not an Emulator 的缩写(Wine不是Windows模拟器，)。 Wine 通过提供一套模拟 Windows API 的库，使得许多 Windows 程序能够在 Linux 系统上运行，而无需对源代码进行修改。 而 Deepin-Wine 是一个开源项目，它基于 Wine（Wine Is Not an Emulator）进行开发，旨在优化 Wine 在 Linux 系统上的体验，特别是针对深度科技（Deepin）团队维护的 Linux 发行版 一种未来的应用方案用Windows + WSL，在WSL中搭建开发环境，Windows Terminal做终端。 B站上收集的信息，有时间可以参考： @fvck_all我自己是开发，我还是比较喜欢Linux的！软件也挺多的！桌面开发软件常用的都有！一旦涉及到win的软件我就装了一个win虚拟机使用！自己用蛮爽的！我现在的搭配是，自己用的笔记本，然后家里面有台服务器！用蒲公英组胖路由，然后也能访问家里的服务器[脱单doge]！干重活用服务器开发调试用笔记本[滑稽] 回复：访问家里的服务器，用花生壳就行了，tcp映射22端口 @编程评论linux适合时间多的人玩 @Speedycode回复： 确实，我用了几星期时间去看博客，编程社区，也没研究明白怎么打驱动，有哪位大神能教我一下吗？[笑哭] @纳杰日金回复 @SpeedyCode Plocate一下自己make一下替换.ko @PTALTS-LK你说的对 但是《Linux》是由Linus自主研发的一款全新开放源代码操作系统内核。使用该内核的系统运行在一个被称作「ext4」的文件系统，在这里被Kernel选中的人将被授予「Terminal simulator」，引导Shell的力量。你将扮演一位名为「Root」的神秘用户，在自由的使用中邂逅不同开源协议、各有千秋独特的桌面环境和各种软件们，和它们一起服务器运维，找回丢失的软件包的同时，逐步发掘「devnull」的真相。 @现在应该没人看昵称我也折腾了很久Linux，不得不说系统只有更适合个人喜爱的才是好系统，Linux确实没有一堆领域大神吹的那样神乎其神，Windows 也没这么糟糕 — 你在Windows上不会大概率在Linux上也不会，配环境也好，写代码也好…配环境看起来Linux aptpacman 很不错，但是很多时候还是要你自己改配置配环境变量。Windows 有DLL地狱，Linux包依赖也是噩梦。Windows 会蓝屏，Linux KDEGnome 运气不好那也是三天崩两回。Windows UI 不统一，Linux GTK + QT 主题互相独立混搭就很好看？我两个系统混着用，只能说两边用习惯都差不多。Windows 更加偏向普通用户，仅此而已。 @慕容凌鸢回复 @DSOE1024 不，普通人可以用linux装一些比较简单的服务，像我这个没有任何语言基础的花50腾讯云买个2h2g,这配置装win啥都干不了，装centos挂个真寻群聊娱乐群管机器人，还能开个mc基岩服务器，甚至能再开几个面板服务[泠鸢yousa_滑稽]就是这样内存也就75左右，稳的一批（就是缺环境折腾半死） 其他文章things-to-do-after-installing-ubuntu-22-04"},{"title":"基本命令","path":"/wiki/linux/基本命令.html","content":"Linux 基本系统分区FHS（Filesystem Hierarchy Standard）—— 文件系统层次化标准。 Filesystem Hierarchy Standard（文件系统层次化标准）的缩写，多数Linux版本采用这种文件组织形式，类似于Windows操作系统中c盘的文件目录，FHS采用树形结构组织文件。FHS定义了系统中每个区域的用途、所需要的最小构成的文件和目录，同时还给出了例外处理与矛盾处理。 —— 百度百科 符号 解释 ~ 用户主目录 - 上一次所在目录 . 当前目录 .. 上级目录 Linux与Windows一样，它的主分区和拓展分区加起来不能超过四个，而且拓展分区不能放入数据文件且不能格式化，最多一个拓展分区。拓展分区里放的逻辑分区可以放数据和格式化。 Linux 硬件全为文件 这一点与Windows不一样。 下面介绍一些Linux的主要硬件文件名已经存放路径： IDE硬盘 devhd[a-d] SCSISATAUSB硬盘 devsd[a-p] 光驱 devcdrom或devsr0 软盘 devfd[0-1] 打印机（25针） devlp[0-2] 打印机（USB） devusblp[0-15] 鼠标 devmouse 分区：把大硬盘分为小的逻辑分区格式化：写入文件系统分区设备文件名：给每个分区定义设备文件名挂载：给每个分区分配挂载点 注意： 根分区 “ ” 以下的子分区可以单独使用硬盘 在虚拟机安装中 swap 的大小为内存的两倍但是超过2G没有意义，建议1000MB合适 boot路径是为了让Linux系统可以顺利运行 里面最好不要存放数据 在虚拟机安装中分配200M左右大小就可以了 系统管理 使用分号 ; 分隔和执行多条命令 使用反斜线 \\ 多行输入 执行 exit 或 ctrl d（表示EOF），退出当前 shell ls 参数： -a 所有文件 -l 详细信息 -h 文件大小可读 -F 类型指示 -d 仅查看当前目录的信息 -S 按文件大小排序 -t 按修改时间排序 -r 倒序 查看 Linux 内核版本 uname -runame -ncat /proc/version 5.8.0-44-generic 主版本号.次版本号.发布版本-修改版本 系统的运行级别： runlevel 查询系统运行级别logout 退出登陆命令 共有六个级别： init 0-60：关机1：单用户 进入选项菜单 只有root用户登陆进去 相当于Windows安全模式F8，只不过没有图形界面2：不完全多用户，不含NFS服务，没有图形界面 NFS网络文件系统，Linux之间文件传输共享方式，除了NFS服务，和3一样。3：完全多用户，没有图形界面4：未分配，没有图形界面5：图形界面6：重启 注意：在服务器中一定要在操作完成之后退出登陆，否则其他人会直接进入你的服务器，造成非常大的损失。最基本的安全意识一定要有！！！ 日期 date [-s] date 内存 free -h 进程 ps [-u] 查询 PID pidof ps 在linux系统的目录varrun下面一般我们都会看到很多的*.pid文件。而且往往新安装的程序在运行后也会在varrun目录下面产生自己的pid文件。那么这些pid文件有什么作用呢？它的内容又是什么呢？ PID全称是Process Identification。 PID是进程的代号，每个进程有唯一的PID编号。它是进程运行时系统随机分配的，不代表专门的进程。 在运行时PID是不会改变标识符的，但是你终止程序后再运行PID标识符就会被系统回收，就可能会被继续分配给新运行的程序。 范围是1~32768。 pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。 pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 发送信号 kill [-信号声明 | -信号编号] pidkill -l # 列出所有信号killall # 结束一个程序的所有进程 命令别名 alias cmd=cmd cmd：command 输入历史 history # 查看历史命令和编号!编号 # 执行编号指定的历史命令 主机名 hostname [set-hostname] nm 软硬链接 软链接：软链接的作用和Windows中的快捷方式是差不多的。他只不过是指向源文件安装路径的符号链接，所以大小也很小 。 它的文件类型是lrwxrwxrwx 看似三种用户都可以拥有所有权限。其实，真正拥有的权限是源文件所决定的权限 ，所以这中显示也是软链接的一大特征之一。 ln -s [原文件] [目标文件] 创建软链接 这里的源文件路径一定要写成绝对路径 ，否则链接不到。 硬链接：硬链接就是把源文件拷贝到目标位置，而他与cp -p 最大的一点区别就是他可以同步更新。 源文件有变化 硬链接文件也会同时发生变化，但是如果源文件丢失或者被删除，硬链接也并不会消失。 这里不同环境结果不一样。 我的Ubuntu软连接文件也不会随着源文件丢失而丢失。只是无法访问而已。 可以通过i节点来区分，源文件和硬链接文件的i节点是一样的，所以他们会同步更新，但是他不能跨分区放置硬链接比如：分区 硬链接 不能放到boot 分区 ，而且不能对目录使用。 ln [原文件] [目标文件] 创建硬链接 权限处理权限表示ls -l total 200k 文件权限 权限计数 所有者 所属组 文件大小 最后修改时间 文件名 drwxr-x— 16 fancyzzz fancyzzz 4.0k 7月11 14:26 … 一个文件10个符号位 ： -rwx rwx rwx 第一个符号位： d 目录 l 软连接 b 块设备 c 字符设备 s socket p 管道 - 普通文件 后九位： 每三位一组，分别对应 User Group Other： r：读权限 w: 写权限 x: 执行权限 修改权限1.复制权限设定： 命令 效果 chmod –referencedir1 dir2 复制dir1目录的权限到dir2上 chmod -R –referencedir1 dir2 复制dir1目录的权限到dir2及dir2中的子文件上 -R 代表递归操作 2.字符方式设定：chmod [u,g,o,a+,-,=r,w,x] [文件或者目录] u ：所有者 g ：所属组 o ：其他人 a ：所有用户 命令 效果 chmod （a;u;g;o) ( +;-;)(r;w;x) 文件名或目录名 用字符方式设定文件或目录权限 chmod -R（a;u;g;o) ( +;-;)(r;w;x) 目录名 用字符方式设定目录以及该目录中文件权限 例如：chomd g+x,o+r tmptestfile 是把testfile文件的所有组增加执行权限，其他人增加读权限 chomd arwx tmptestfile 是给 testfile文件的所有用户增加读写执行权限 3.数字方式设定权限：权限的布尔表示方式：用三位二进制数表示八种不同情况的权限，然后转化为十进制数，并用三位十进制数，表示三个不同身份的权限信息，用数字方式设定对比字符方式设定更具有便捷，准确，不容易出错的特点： chmod -R [rwx的和,rwx的和,rwx的和]] [文件或者目录] 首先需要知道 r4 w2 x1例如：rwxrw-r- - 它的权限位数字表示就是 764 具体算法：r+w+x4+2+17r+w4+2+06r4+0+04 -R： chmod -R [rwx的和,rwx的和,rwx的和]] [文件或者目录] 这条命令与mkdir -p递归创建目录一样 这个命令把一个目录下的所有子目录的操作权限全部修改为同样的 我们仍需注意在文件与目录中的不同权限，他们具体可以实施的操作是什么。这一点非常重要，有许多人到现在也不太清楚，认为对文件有写权限就可以删除文件。这一点是非常错误的。 代表字符 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件内容 可以catmoreheadtailless 可以列出目录中的内容 可以ls w 写权限 可以修改文件内容 可以vim 可以在目录中创建，删除文件；可以touchmkdirrmdirrm x 执行权限 可以执行文件 可以script(脚本) command(命令) 可以进入目录 可以cd 文件处理 cat [文件名] 显示文件内容 只适合短的文件内容cat -n [文件名] 显示行号 给文件内容的每一行标号cat -A [文件名] 显示隐藏字符tac [文件名] 逆序显示文件内容 倒着来 不支持-n more [文件名] 一页一页显示文件内容 适合长的文件内容 空格或者f 翻页 回车（Enter）一行一行翻，换行 q或者Q ，退出 less [文件名] 一页一页显示文件内容，只不过这条命令可以往回翻页，查看翻过的文件内容 page up向上翻页，↑箭头向上翻一行其他操作和more命令一样 在less命令中 可以按+需要查找文件内容的关键字查询内容，高亮内容即为含有关键字的内容，按n（表示next）可以查看下一个含有关键字的内容 head [文件名] 显示文件最前几行 具体几行加n head -n 行数 [文件名] 没有指定 默认10行 tail [文件名] 显示文件最后几行 具体几行加n tail -n 行数 [文件名] 没有指定 默认10行 tail -f 动态显示文件末尾内容 移动： mv src target 重命名： mv old new 目录处理（目录也算文件哦） 创建 mkdir 创建目录 在tmp目录下创建临时文件 只能创建tmp***** 二级目录mkdir -p 可以递归创建 在没有一级目录的情况下新创建二级目录pwd 显示当前所在路径 跳级 cd - 上一次的目录 cd ~ 返回家目录 cd . . 返回上一级目录(两个点连着）rmdir 删除空目录 只能删除没有文件的空目录 （不经常使用） 增删改查 touch [文件名] 在当前目录下创建空文件touch[绝对路径+文件名]。 指明绝对路径，在绝对路径处创建文件“Program files” 加双引号创建带空格的文件名 不推荐使用 以后的查询，操作都需要用到 除了代表根分区的 以外 其他符号都可以 复制 cp 复制文件 cp [原文件路径] [需要复制到的路径]cp -r 复制目录cp -p 保留原文件属性复制目录 比如保留创建时间 日志文件的复制需要用到cp -rp 复制目录并且保留原文件属性mv 剪切 改名（在同一个目录下为改名） 删除 rm 删除文件rm -f 强制删除 不再询问rm -r 删除目录 一般是rm -rf 连着用control+C退出选项 注意：rm -rf 使用时一定要谨慎 切记 ！！！使用时一定要谨慎 切记 ！！！使用时一定要谨慎 切记 ！！！rm -rf * 系统直接全部被删除！！！ 使用通配符时需要转义，例如*.txt应写成\\*.txt。 查找 文件搜索命令find find [搜索范围] [匹配条件] 通配符查询 find [搜索范围] -name [关键字] 在特定路径下搜索文件名作为关键字的文件或者目录 find [搜索范围] -name [关键字]* 这样为带有关键字开头的任何文件都可以被搜索出来 find [搜索范围] -name * [关键字]* 这样为带有关键字的任何文件都可以被搜索出来 find [搜索范围] -name [关键字]??? 这样搜索的是关键字后带三个字符的 几个问号为几个字符 其他属性查询 find [搜索范围] -iname [关键字] 不区分大小写搜索 注意：不能在服务区高峰时候使用查找命令。太占内存资源，搜索的范围路径越小越好，搜索条件越精准越好 所属者查询 find [搜索范围] -user [所有者名] 根据所有者查找 find [搜索范围] -group [所属组名] 根据所属组查找 根据时间查询 find [搜索范围] -amin [时间] 查找时间以内被访问过的文件和目录 a：access find [搜索范围] -cmin [时间] 查找时间以内被修改过属性的文件和目录 c：change find [搜索范围] -mmin [时间] 查找时间以内被修改过内容的文件和目录 m：modift +：超过多长时间 -：多长时间以内 根据数据大小查询 find [搜索范围] -size [数据块] 根据文件大小查找 数据块前面加+表示查找大于这个大小的文件，-表示查找小于这个大小的文件，不加表示查找等于这个大小的文件(一般不常用1个数据块512字节0.5Ksize后接的数据只能为数据块 需要换算，比如需要查找大于100MB的文件100MB102400KB204800find etc -size +204800数据块为Linux存储文件最小单位 find [搜索范围] -size [数据块] -a -size [数据块] -a：两个条件同时满足-o：两个条件满足任意一个即可find etc -size +163840 -a -size -204800在etc下查找大于80MB小于100MB的文件 查找特定类型 find [搜索范围] -name [关键字] -a -type f 在特定路径下搜索文件名作为关键字的文件-type 根据不同类型查找f：文件d：目录l：软链接 find [搜索范围] -name [关键字] -exec ls -l {} \\ ; 查找到文件之后并且对其进行查看ls操作。-exec：查找到文件之后并且对其进行各种操作 {} \\ ;不能丢-ok：用于询问确认 一般在删除操作的时候使用，比如： find -user user_name -ok rm {} \\ ; 删除user_name用户的文件 他会挨个询问你是不是确定删除 find [搜索范围] -inum [i 节点值] 根据 i 节点查询 find etc -inum 12345 -exec rm {} \\ ; 删除这个i节点文件 非常方便。也可以用来查询一个文件的硬链接 find etc inum 12345 -exec ls -l {} \\ ; 因为硬链接和文件肯定在同一个分区，并且i节点一样 文件搜索命令locate locate [文件名] 在文件资料库中查找 速度更快 locate -i 不区分大小写查找 updatedb 更新文件资料库 因为locate并不是实时的 (如果存放的文件在tmp 临时文件存放处下面 locate就找不到，文件资料库不存储临时文件内容) which 查找命令存放位置，可以看到命令可以使用的使用者是谁，也可以查看命令别名 which rm 会显示 alias rm’rm -i’ 我们所使用的rm只不过是别名 不是真正的rm命令，其实是rm -i命令，所以才会询问是否真的删除，真正的rm是不会询问的，比如：binrm tmpyangyang 文件直接删除不会询问是否删除 相当于加了 -f whereis 也可以找到命令的绝对路径，还可以找到查询命令的帮助信息文档所在位置 grep 在文件内查询字符串或者关键字列出来grep -i 不区分大小写查找grep -v 排除指定字符串 比如： grep -v ^# etcinittab查找排除#开头的注释行文件信息^代表行首 , 文件中#开头的行 为配置文件信息,脚本信息。 用户管理命令用户和用户组 创建用户时所在组称初始组主组，其后可以将其添加到其他组中，这些组称附加组，此外，还可以更换用户的主组。 root 用户 uid 0 系统用户 uid 1 - 1000 普通用户 uid 1001+ 用户和用户组的配置文件 etcpasswd etcgroup 创建用户组 useradd unmgroupadd gnm 修改用户组 修改信息 usermod [-u | -d | -g] unm # uid 主目录 主组groupmod [-n | -g | -o] gnm # 名称 gid 允许重复的gid 修改密码管理用户组 passwdgpasswd [-A | -a | -d] # 指定管理员 添加用户 删除用户 删除用户组 userdel unmgroupdel gnm 切换用户 su unm who 查看登陆用户信息 第一列 登陆用户名 第二列 登陆终端 tty表示本地终端 pts表示远程登陆终端 第三列 登陆时间 第四列 登陆主机的IP地址 如果没有写表示本机登陆 w 查看登陆用户详细信息 第一行显示17:04:55 up 22 days, 21:32, | 2 users,| load average: 0.02, 0.02, 0.05 17:04:55 表示当前时间 up 22 days, 21:32 表示服务区系统连续运行时间没有重启或者关机，衡量服务区稳定性 2 users 表示当前总共有多少个用户登陆 load average: 0.02, 0.02, 0.05 表示负载均衡指数，分别记录了过去一分钟，五分钟，十五分钟系统的负载情况，加起来除以三就是平均负载指数，系统的负载情况主要是指 CPU和内存的负载情况，数字大表示负载严重。 uptime 命令也可以显示此项数据 第二行显示USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT IDLE 表示用户登陆过来后空闲多久 PCPU 表示用户登陆后执行的操作占用的CPU的时间 CPU时间 JCPU 表示累计占用的CPU时间 WHAT 表示执行的操作 who 命令 # rootwho am i username pts/0 2020-04-21 14:41 (:1.0)# rootwho mom likes username pts/0 2020-04-21 14:41 (:1.0)# pre userwhoami username# rootwho -m username pts/0 2020-04-21 14:41 (:1.0) pts/{num}中的pts表示伪终端，{num}表示用户打开的伪终端序号。 相对来说，dev/tty是真终端，pts是在某个真终端下的伪终端，可以存在多个。 param description -a 打印能打印的全部 -d 打印死掉的进程 -m 同am i，mom likes 文件打包打包和压缩的区别 打包 : 将多个文件和目录集中存储在一个文件中。 压缩 : 利用算法对文件进行处理，从而达到缩减占用磁盘空间的目的。 Linux下，常用打包命令有2个，分别是tar和dd; 常用的压缩命令有很多，比如gzip、zip、bzip2等。 打包 打包，也称为归档(archive)，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。 归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。通常，归档总是会和系统备份联系在一起。 压缩 压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。 其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。 打包工具tar打包tar -cf pack dir 必选参数： -f :使用档案名字，该参数作为最后一个参数，后面只能接档案名。 -f 是执行tar过程中需要携带的 可选参数： -p，保留文件属性（权限等）。 -h，追踪链接并归档。 -P保留绝对路径符，即路径前的/。若保留，则解压时会按照绝对路径进行解压。 解压时也可通过-P参数指定是否通过绝对路径解压。不过，对于根本就不是绝对路径的文件，不会按照绝对路径解压。 -c: 建立压缩档案 -x：解压（会根据压缩格式自动进行识别） -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这些选项作为 tar 使用过程中根据执行的操作进行选择，必须要有其一。 注意：默认尽可能地按照相对路径解压，防止意外覆盖文件。 tar解包： tar -xf pack -C dir -x表示解包-C {dir}指定解包目录。 可选参数-P保留绝对路径符，对于不是绝对路径的文件，不会按照绝对路径解压。 tar使用压缩工具： 压缩时只需要加上对应参数即可，例如gzip对应-z： tar -zcf pack dir 解包时统样： tar -zxf pack 压缩文件格式 参数 *.tar.gz -z *.tar.xz -J *tar.bz2 -j 压缩工具下面为压缩或解压档案时的可选参数。 -z：有 gzip 属性的压缩及解压 -j：有 bz2 属性的压缩及解压 -Z：有compress属性的压缩及解压 -v：显示所有打包及压缩解压过程 -O：将文件解开到标准输出 zip 压缩 zip打包： zip -r -q -9 -o pack dir -r表示递归打包子目录，-q是静默打包，不输出信息，-9是压缩质量，最高 9 最低 1，-o后紧跟输出的文件。 另外还可以加一个参数-e进行加密打包。 对于跨平台的换行问题，可以通过-l参数在打包的同时进行转换，将LF转换为CRLF。 unzip解包： unzip -q pack 可以使用-d {dir}指定解压目录：unzip -q {pack} -d {dir}。 -O可以指定编码，例如-O GBK。 unzip可以用来查看压缩包信息，通过-l参数：unzip -l {pack}。 gzip压缩 gzip打包 gzip [文件名] 压缩文件 只能压缩文件不能压缩目录，而且不保留原文件 压缩后格式为：.gz gzip解包 gunzip [压缩包名] 解压缩.gz文件 gzip -d [压缩包名] 也是一样的作用，解压缩.gz文件 bzip压缩bzip 打包: bzip2 [选项] [文件名] 压缩文件 大型文件一般用这个压缩 例子：bzip2 -k Japan -k：保留原文件。如果不需保留可去掉。 可以与tar结合使用 tar -cjfv Japan.tar.bz2 Japan Bunzip 解包: bunzip2 [选项] [压缩文件名] 解压文件 -k：保留压缩包 与tar结合使用 : tar -xjfv Japan.tar.bz2 Japan 关机命令关机重启 shutdown [-r | -h] time #shutdown [选项] 时间shutdown -r now # 重启rebootshutdown -h now # 关机poweroff#时间选项里可以填具体时间比如：#now 现在关机#20:30 八点半关机shutdown -r +5 # 5minshutdown -h +5 # 5minshutdown -r 5:00 # 5:00shutdown -h 5:00 # 5:00 -c：取消前一个关机命令 -h：关机 -r：重启 在服务器上重启需要谨慎，需要先停掉服务，否则物理内存会坏而且远程服务器只能重启，关机后需要管理员手动开机 其他关机命令： halt poweroff 相当于直接断电 init 0 推荐使用shutdown关机，会保存正在运行的服务 其他重启命令：reboot 挂载命令如果想要访问Linux中的根目录以外的文件，需要将它“关联”到根目录下的某一个目录来实现，这种关联操作就叫做“挂载”，这个目录就是“挂载点”，解除次关联关系的过程就是“卸载”。 “挂载点”的目录有3个要求： （1）可以用mkdir命令新建目录（目录事先存在）。 （2）挂载点目录不可被其他进程使用到。 （3）挂载点下原有文件被隐藏。 知乎：挂载可以理解为插乐高积木（我闺女最近很爱玩这个；），首先系统一定要先有一个根文件系统并挂载在”“上，你可以理解为你用乐高做了一个机器人，在系统启动后这就是根文件系统了。之后你想再挂载新文件系统，就好像你又用乐高插出一把剑（一个新的独立文件系统），你可以把剑插在机器人任何能插的地方，比如右手上。剑是独立的，你改变剑的形状并不影响机器人本身，将来你不想用这把剑了可以直接拆下来（卸载）收好，也可以再插（挂载）一把枪（另一个文件系统）上去。 文件系统挂载时有覆盖（遮盖）关系，如果你所要挂载的挂载点（目录）下面有文件或已挂载的文件系统，那么新挂载的文件系统会遮盖其下面的内容。这点和乐高不同，比如你又做了一个新的机器人右手臂，你得自己把原右手臂连同手上的东西拆下来，再插上新作的。而实际的文件系统挂载不需要先卸载，新文件系统（右手臂）会直接从挂载点（右臂接口）开始覆盖（隐藏）挂载点（接口）以下所有的原内容。而卸载后原内容又会显现出来。 来自用户：醉卧沙场 mount [-t 文件系统] 设备文件名 挂载点 mount 设备文件名挂载点 卸载光盘，设备文件名和挂载点两者任选其一 放入光盘 : 虚拟机中放入，或者服务器下载ios文件 创建一个空目录，设为挂载点 mkdir /media/cdrom /media 输入命令 mount -t iso9660 /dev/sr0 /media/cdrom 设备文件名默认就是devsr0，文件系统为iso9660 它是国际标准的cd文件格式，它告诉mount命令，我要挂载的是一个标准的cd。需要死记！！！ devcdrom也可以写 devsr0devcdrom是sr0的软链接。 进入挂载后的盘符 cd /media/cdrom 卸载光盘 cd #先退出/media/cdromumount /dev/sr0 #再输入命令：umount /dev/sr0 注意：如果之前挂载过其他盘，需要卸载之后才能挂载，输入命令： umount /dev/sr0 网络命令给在线用户发信息 write 用户名 按Ctrl+D保存结束 只能给在线用户发 可以用w查询用户在线情况 不在线发不出去。 wall [信息] 发广播信息 群发所有在线用户 ping [IP地址] 测试网络连通性 ping -c 指定发送次数 ifconfig 查看网卡信息 主要功能是查询当前本机IP地址 mail 用户名给不在线的用户发送邮件 mail friend_nameSubject headline #输入标题content#正文#Ctrl D 保存结束发送 h 键查看邮箱列表 d [n] 删除第n封邮件 q 退出 last 列出目前与过去登陆系统的用户信息 lastlog 检查某特定用户上次登陆的时间 lastlog -u [uID] 检查uID用户上次登陆的时间 traceroute 显示数据包到主机间的路径这里CentOS7用户也会出现traceroute命令不能使用的问题，直接下载traceroute就好了yum install -y traceroute 安装 traceroute [网站网址] 可以检查网络哪个节点出现问题 netstat [选项] 显示网络相关信息 -t TCP协议：传输控制协议 -u UDP协议：用户数据报 -l 监听 -r 路由：网关 -n 显示IP地址和端口号 netstat -tlun ：查询本机监听的端口 netstat -an ：查看本机所有的网络连接 netstat -rn ：查看本机路由（网关） setup 配置网络 （redhat专有命令 ,在其他版本不存在） 永久生效 , 和刚开始介绍的ifconfig命令不一样。CentOS7使用 nmtui命令代替setup，不过是在虚拟机中调试"},{"title":"哈希表","path":"/wiki/algorithm/哈希表.html","content":"哈希表定义哈希表(Hash table)： 根据关键码值(Key value)而直接进行访问的数据结构。 也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，你也可以叫哈希函数。存放记录的数组叫做散列表。 特点： 哈希表是一种数据结构 哈希表表示了关键码值和记录的映射关系 哈希表可以加快查找速度 任意哈希表，都满足有哈希函数h(key)，代入任意key值都可以获取包含该key值的记录在表中的地址 通俗讲，哈希表是一种表结构，我们可以直接根据给定的key值计算出目标位置。 在工程中这一表结构实现通常采用数组。 与普通的列表不同的地方在于，普通列表仅能通过下标来获取目标位置的值，而哈希表可以根据给定的key计算得到目标位置的值。 复杂度： 在列表查找中，使用最广泛的二分查找算法，复杂度为O(log2n)，但其始终只能用于有序列表。普通无序列表只能采用遍历查找，复杂度为O(n)。 而拥有较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为常数级，即O(1)。 两个知识点： 哈希函数： 将哈希表中元素的关键键值映射为元素存储位置的函数。 以用 y ∈ (0~10^5) 的定义域 通过哈希表 表示值域为 x ∈ (-10^9 ~ 10^9) 的集合为例： 设 x 为值域中的某个数， 有 h(x) y 。 y即定义域中的一个数。 值域内的 x 通过哈希函数h(x) 表示了定义域的 y 。 哈希冲突：不同的两个 x1，x2 通过哈希函数产生了相同的结果 y。 这会导致结果冲突，即该哈希表中的 y ，到底是表示 x1 还是 x2 ？ 存储结构： 1.拉链法 :开辟一个数组，元素作为链表存放冲突的哈希值。 2.开放寻址法：开辟一个数组，不需要链表，但长度往往是数据的2~3倍。 长度不一定这样长，但更长的长度冲突概率会比较低。 两道题模拟散列表 拉链法 1.N 100000? 根据tips，我们要对一个质数取模，1N10^5，通过试除法能求出来大于N的最小质数是10003。 2.取余值也是N？ x 取余 N，意味着用(0,N-1)的范围表示 x ，也就是(1,10^5) 。这符合我们的数组长度，防止越界。 (哈希函数相当于把10^-9～10^9中的一个个数x压缩存放在N(质数)个链表中) #includeiostream#includestring.husing namespace std ;//哈希表：实现无非是插入和查找两个功能const int N = 100003;int h[N],e[N],ne[N],idx; //静态链表//h头结点 e 当前结点的值 ne 当前结点的下一个结点下标 ，idx 多余空间的下标 ，k 映射后呈现的数组值void insert(int x) int k = (x%N+N)%N; //先取模再+N 使负余数转正（CPP特性） ne[idx] = h[k]; h[k] = idx; e[idx] = x; idx++;bool find(int x) int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) //-1配合memset if (e[i] == x) return true; return false;int main(void) int n;cinn; memset(h,-1,sizeof(h)); while(n--) char c[2];int x; cinc;cinx; if(*c==I) insert(x); else if(find(x)) puts(Yes); else puts(No); 开放寻址法 特点：一旦find() 查找不到这个数据 ，就返回最近多余空间的下标。 所以添加函数利用find就ok了。 #include cstring#include iostreamusing namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x) int t = (x % N + N) % N; while (h[t] != null h[t] != x) //一直往后找闲置空间，null:数组边界 t ++ ; if (t == N) t = 0; //循环查找 return t;int main() memset(h, 0x3f, sizeof h); int n; scanf(%d, n); while (n -- ) char op[2]; int x; scanf(%s%d, op, x); if (*op == I) h[find(x)] = x; else if (h[find(x)] == null) puts(No); else puts(Yes); return 0; 0x3f : memset是按字节赋值的，因此char类型的数组可以赋任意值。因此memset的正规用法是用来初始化char类型的数组的，也就是说它只会接受0x00-0xFF的值。 因为0的二进制是32个0，-1的二进制是三十二个1，所以使用memset可以直接初始化0和-1。如果要初始最大化，第一位是符号位为0，剩下为1，01111111化十六进制正好为0x7f，所以memset(arr, 0x7f, sizeof())就是初始最大化了。 但是这个数不能满足“无穷大加无穷大依然是无穷大”的性质，相加后它是一个很小的负数。所以一般无穷大常量取值是0x3f3f3f3f。 memse是按字节来初始化的，int中有四个字节，初始化成0x3f就是将每个字节都初始化成0x3f，所以每个int就是 0x3f3f3f3f。 0x3f3f3f3f十进制是1061109567，是10^9级别。0x3f3f3f3f + 0x3f3f3f3f 2122219134，没有超过32位int的范围，所以相加也满足“无穷大加无穷大以旧是无穷大”的性质 void memset(void *str, int ch, size_t n)将str中当前位置后面的n个字节用ch替换并返回s，也就是说这个函数的作用是将数字以单个字节逐个拷贝的方式放到指定的内存中memset(a, 127, sizeof(a))127的二进制表示是01111111，在数组里存放的就是四个01111111，十进制数里是2139062143（小于int类型的范围）memset(a, 127, sizeof(a))128二进制是10000000，四个10000000就是-2139062144，就是初始化为一个很小的数 字符串哈希Tips: 取模所用的数，一般都是质数。 数学证明，取模质数时，哈希冲突的情况最少。 哈希表 scanf读入字符，尽量以字符串形式读入。 因为读入字符串 scanf 自动忽略回车空格换行符 哈希表的常用操作是 添加 和 查找。 删除操作比较少。即使支持删除操作功能，也不一定删除源数据。 （例如设置一个布尔变量或者什么标记，来判断该数据是否已被删除） 删除操作可以看做查找操作的特殊处理。 取余 % 不要和除法 混淆。 n X%Y ，意味着 n ∈ (0,Y-1)"},{"title":"杂项","path":"/wiki/linux/杂项.html","content":"碎碎念 2023.7.11 目录问题原来根目录是 ,我一直以为根目录是家目录 （homeuser_name） 密码问题电脑待机，但密码忘记了，想知道怎么修改密码。 待机导致 xshell 失联。怎么查看虚拟机ip呢？ifconfig bug好多安装curl出现了好多问题。网上搜到很多解决命令，我就无脑粘贴运行，结果频频报错，一头雾水。 看到了一个回答说的很好： 在使用 dpkg -i 安装.deb软件包的过程中，会出现安装失败的可能。之后无论用 sudo apt install -f or sud apt autoremove 等常见的修复命令都是无效的。网络上很多解决方案都直接给出需要运行的命令，不分析原因也不说明理由。我从来不尝试这样的解决方案，除非我自己知道或是只能死马当活马医。 那种傻瓜式解决好像学不到什么东西，也很无趣。 两个命令source 命令：更新配置文件 重定向符 ： echo source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ~/.zshrc #把 echo 后的这一串东西写到用户主目录的 zshrc 文件里。 那为什么要写到 zshrc 文件里面呢？显然因为它是配置文件。 拓展： zsh会读取的配置文件 一般的shell都有两种配置文件，一者是全局的，放在etc里，文件名前面没有’.’（非隐藏），另一种是放在用户家目录，只对当前用户生效，是隐藏的。以下对这两种不作区分 1，zshenv：一般放环境变量 2，zprofile：用于用户login时读入（执行）的配置 3，zshrc：用户开启交互是命令行时读入的配置 用户环境变量搭网站需要docsify，docsify 又需要 npm -js ，安装完发现 docsify 命令无法识别，查了查发现是环境变量的问题。 npm install -g forever安装了之后在其他目录无法执行，找不到命令，在windows下可以直接使用，在linux下需要配置下环境变量 npm prefix -g 该命令可以看到node全局环境的目录在哪里 环境变量配置(LINUX) Linux环境变量配置有三种： 当前用户当前shell有效。（临时环境变量,关闭即失效）当前用户有效所有用户均有效 （1） 临时环境变量 在 shell 中运行下列命令，$PATH:后跟想要加入环境变量的目录 export PATH=$PATH:/usr/nodejssoft/node-v10.9.0-linux-x64/bin （2） 对当前用户有效 修改用户目录下的.bashrc文件vi ~/.bashrc在文件最后添加该语句 PATH=$PATH:/usr/nodejssoft/node-v10.9.0-linux-x64/bin 重新登录即生效 （3） 所有账户均有效 修改/etc/profile文件 在末尾添加以下内容 #sudo vi /etc/profileexport PATH=$PATH:/usr/nodejssoft/node-v10.9.0-linux-x64/bin 退出当前shell再重新登录即可生效或执行source etcprofile该命令 版权声明：本文为qq_33788609原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 echo -e export PATH=$(npm prefix -g)/bin:$PATH ~/.bashrc source ~/.bashrc 权限问题成功配好环境变量，运行 docsify 后，又遇到了权限问题。 Error: EACCES: permission denied, mkdir XXX/XXX 网上查了查，发现是npm没有权限。于是赋予了它权限，用到了chmod: sudo chown -R $USER /usr/local/lib/node_modules 成功了。 所以权限问题有两种解决思路： sudo chown .node_moduleshexonode_moduleshexo-clibin 所有命令失效PATH=/bin:/usr/bin:/usr/local/bin:$PATHexport PATH .configure – prefix关于configure： Linux下源码的安装一般由3个步骤组成：配置（configure）、编译（make）、安装（make install），具体的安装方法一般作者都会给出文档，这里主要讨论配置（configure）。Configure是一个可执行脚本，它有很多选项， 关于prefix： linux configure --prefix 的作用是：编译的时候用来指定程序存放路径 。 如下面示例： cd keepalived-1.2.18/ ./configure --prefix=/usr/local/keepalived 如果不指定 --prefix 则 安装程序的 可执行文件默认放在 /usr/local/bin ；库文件默认放在 /usr/local/lib ；配置文件默认放在 /usr/local/etc ；其它的资源文件放在 /usr /local/share 。非常地乱！ 如果指定 --prefix 比如： --prefix=/usr/local/keepalived ，则此软件的所有文件都放到 /usr/local/keepalived 目录下，很整齐。 其他优点： 卸载软件时，只须简单的删除该安装目录，就可以把软件卸载得干干净净； 移植软件时，只需拷贝整个目录到另外一个机器即可； pip3的镜像源用pip3安装东西，提示一堆WARNING还有一个ERROR： Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by ReadTimeoutError(HTTPSConnectionPool(host=pypi.org, port=443): 于是尝试更新pip3本身，依然报错： Could not fetch URL https://pypi.python.org/simple/requests/: There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify faile 搜了搜，好像是默认源识别下载不了。需要改镜像源。 下面是解决方法： 问题原因 国内使用默认的pip的源就会这样修改一下就行，由于我是临时使用这台电脑，所以换了一种配置的方法。 1.解决方法【临时】 pip install requests -i http://pypi.douban.com/simple –trusted-host pypi.douban.com【 -i http://pypi.douban.com/simple –trusted-host pypi.douban.com，这一段全部复制就行了，install后面根你需要下载的内容】\\ 2.解决方法【永久】 Windows： python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple some-packagepip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple Linux： cd ~ # 进入家目录 mkdir .pip # 新建.pip隐藏文件夹 cd .pip # 进入.pip隐藏文件夹 touch pip.conf # 新建pip.conf文件 vim pip.conf # 用vim编辑pip.conf文件，内容与Windows下pip.ini文件的内容一样 pip.ini 内容： [global] index-url=http://pypi.douban.com/simple/[install]trusted-host=pypi.douban.com :wq # 保存退出 vim-plugvim-plug 是一个Vim插件管理器，利用异步并行可以快速地安装、更新和卸载插件。它的安装和配置都非常简单，而且在操作过程中会给出很多易读的反馈信息，是一个相当友好精简的插件。 安装配置下载 plug.vim 文件，根据操作系统不同，放置在以下autoload目录中：Linux: ~.vimautoloadWindows: ~vimfilesautoloadplug.vim2. 目录结构如下，之后安装的插件将存放在plugged目录中： 在vimrc配置文件中增加plug-vim部分，示例如下： call plug#begin(‘.vimplugged’)“ Shorthand notation for pluginPlug ‘foobar’call plug#end()配置实例“ plug-vim“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ Specify a directory for pluginscall plug#begin(‘.vimplugged’) “ Make sure you use single quotes“ Shorthand notation; fetches junegunnvim-easy-alignPlug ‘vim-airlinevim-airline’Plug ‘lilydjwgcolorizer’Plug ‘kshenoyvim-signature’“Plug ‘mattngist-vim’“ Any valid git URL is allowed“Plug ‘junegunnvim-github-dashboard’“ Multiple Plug commands can be written in a single line using | separators“Plug ‘SirVerultisnips’ | Plug ‘honzavim-snippets’“ On-demand loading“Plug ‘scrooloosenerdtree’, { ‘on’: ‘NERDTreeToggle’ } 安装插件vim-plug支持源码托管在GitHub的插件，你可以在github.comvim-scripts上找到vim官网里所有插件的镜像。 如果希望安装新插件，首先找到其在http://github.com的网址，然后将其追加至vimrc配置文件中的call plug#begin()和call plug#end()之间，最后执行以下命令安装所有引用的插件： :PlugInstall 你也可以使用以下命令，指定安装特定的插件： :PlugInstall gist-vim卸载插件如果希望卸载插件，请先在vimrc配置文件中注释或者删除对应插件的配置信息，然后再执行以下命令： :PlugClean 更新插件使用以下命令，可以更新vim-plug插件自身： :PlugUpgrade使用以下命令，可以批量更新所有已安装的插件： :PlugUpdate 插件状态使用以下命令，可以查看当前已安装插件的状态信息： :PlugStatus 设置github代理 报错： Failed to connect to github.com port 443: Connection timed out输入以下两行代码解决： 首先，设置默认代理，也可以理解为清除代理git config –global –unset http.proxygit config –global –unset https.proxy 设置代理git config –global http.proxy “你需要的代理”git config –global https.proxy “你需要的代理” 报错：GnuTLS recv error (-110): The TLS connection was non-properly terminated.在使用 git clone 时，出现了以下报错： GnuTLS recv error (-110): The TLS connection was non-properly terminated. 依次输入以下代码： # apt-get install gnutls-bingit config --global http.sslVerify falsegit config --global http.postBuffer 1048576000 修复DPKG问题apt 安装时出现一大堆dpkg: WARNING 用删除info啥的不管用。运行一个脚本意外解决了。 #!/bin/bashset -e# Clean out /var/cache/apt/archivessudo apt-get clean# Fill it with all the .debs we needsudo apt-get --reinstall -dy install $(dpkg --get-selections | grep [[:space:]]install | cut -f1)DIR=$(mktemp -d -t info-XXXXXX)for deb in /var/cache/apt/archives/*.debdo # Move to working directory cd $DIR # Create DEBIAN directory mkdir -p DEBIAN # Extract control files dpkg-deb -e $deb # Extract file list, fixing up the leading ./ and turning / into /. dpkg-deb -c $deb | awk print $NF | cut -c2- | sed -e s/^\\/$/\\/./ DEBIAN/list # Figure out binary package name DEB=$(basename $deb | cut -d_ -f1) # Copy each control file into place cd DEBIAN for file in * do cp -a $file /var/lib/dpkg/info/$DEB.$file done # Clean up cd .. rm -rf DEBIANdonermdir $DIR 另外一个解法没有尝试 dpkg: warning: files list file for package ***** missing; assuming package has no files currently installed#1、列出所有 warning的包apt reinstall sl　#　结果发送至一个文件中apt reinstall sl warning.sh#2、写一个脚本，挑选出错误的软件包进行重新安装#!/bin/bash#/*参考代码*/for package in $(cat warning.txt | grep dpkg: warning: files list file for package | grep -Po [^]* | sed s///g)；do apt-get reinstall $package;done #此步骤需要20分钟左右。 文本编辑器ubuntu 自带 nano 和 vim 。驯化了一天半时间的vim，刚刚小有熟悉，发现居然还有个更“人性化”的 nano。罢也，还好我是个爱捣鼓的人。 Sub-process error : dpkgcd /var/lib/dpkg/sudo mv info/ info_bak # 现将info文件夹更名sudo mkdir info # 再新建一个新的info文件夹sudo apt-get update # 更新sudo apt-get -f install # 修复sudo mv info/* info_bak/ # 执行完上一步操作后会在新的info文件夹下生成一些文件，现将这些文件全部移到info_bak文件夹下sudo rm -rf info # 把自己新建的info文件夹删掉sudo mv info_bak info # 把以前的info文件夹重新改回名 卸载python1、卸载python3.5（指定相应的版本就可以） sudo apt-get remove --purge python3.5 2、完全卸载python3.5及其依赖软件（这个我试了管事） sudo apt-get remove --auto-remove python3.5sudo apt-get purge --auto-remove python3.5 3、清除python3.5及其依赖软件的安装包 sudo apt-get autoclean python3.5 软连接位置发现软连接好像默认安置在 \\usr\\bin目录下啊。 删掉软连接直接 rm 掉就行。 journalctl -xe"},{"title":"环境变量","path":"/wiki/linux/环境变量.html","content":"三种变量在 Linux 中，变量依照作用域分为三种，分别是环境变量、普通变量、导出变量。 环境变量可以理解为 Windows 中的环境变量，在任一终端总可以直接访问到。 公共变量被存放在/etc/profile文件中，用户变量被存放在~/.profile中。 cat /etc/profile 普通变量仅在当前进程可用，在子进程中无法访问。 可以通过declare {var}声明变量或使用{var}={value}直接定义。通过echo ${var}查看变量。通过unset {var}释放变量。 declare temptemp=333echo $tempunset temp 导出变量是临时环境变量，即临时导出到环境变量的普通变量。可以通过export {var}对普通变量进行导出，此时其子进程也可以访问该变量。 当前进程结束时，该导出变量一并销毁。 export temp 有三个命令可以查看变量： set # 显示所有变量env # 显示用户相关的环境变量export # 显示导出变量export 变量名=变量值 #申明变量env# 查询变量echo $变量名# 变量调用unset 变量名 #删除变量pstree 树形显示进程数#没有这条命令可以执行以下命令下载：#yum -y install psmisc#yum provides /命令 查看没有的命令的安装包 配合yum -y install使用 环境变量定义阐述：环境变量配置文件中，主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME等 默认环境变量。 以下几个环境变量的配置文件是最主要的： etcprofile etcprofile.d*.sh (指etcprofile.d下所有的.sh结尾的文件) ~.bash_profile ~.bashrc etcbashrc 环境变量配置文件调用图： 这些是在登陆的时候挨个调用，所以在这里面设置环境变量，登陆之后就会自动设置好 登陆输入密码之后，第一步是读取etcprofile文件etcprofile的作用：USER变量LOGNAME变量MAIL变量PATH变量HOSTNAME变量HISTSIZE变量umask里面有以上环境变量的配置 接下来便调用etcprofile.d .sh文件*然后就是下面的文件，语言包文件，识别系统自带的语言 *~.bash_profile的作用调用了.bashrc文件。在PATH变量后面加入了“:$HOMEbin” 这个目录.bashrc的作用定义默认别名调用etcbashrc etcbashrc的作用PS1变量umaskPATH变量 调用etcprofile.d*.sh文件这一块就是进入界面以内，切换shell登陆方式，这种不需要密码，所以和前面的etcprofile的作用不冲突 变量操作变量添加： 以PATH为例，将某路径添加到PATH环境变量中。 由于PATH变量以:作为分隔符，所以我们应该将:{dir}追加到PATH的末尾。 PATH=$PATH:/home/user/dir 字符串拼接不需要使用+，直接顺着写即可。 注意！！这种方式添加的环境变量是临时的，当关闭终端时失效。 想要让环境变量一直生效，可以让上述命令在终端初始化时执行，终端在初始化时会调用一个脚本，这里使用的是zsh，所以这个脚本位于用户主目录下~/.zshrc。 我们可以编辑他，将这条命令添加进去。 echo PATH=$PATH:/home/user/dir .zshrc 不过对于不同终端，这个初始化脚本也不同，例如bash的初始化脚本是.bashrc。 可以通过cat /etc/shells查看已安装的Shell cat /etc/shells 介绍一个命令echo： echo string echo可以将字符串输出到终端，如果要输出变量，那么变量名前应添加一个$。 echo还可以将输出定向至文件： echo string filenameecho string filename 是直接覆盖文件，是追加到文件。 变量修改 变量修改方式 说明 ${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据 ${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据 ${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据 ${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据 ${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串 ${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 例如，我想将PATH变量中的:/home/user/dir删除： PATH=PATH%%:/home/user/dir 执行初始化脚本 更改配置文件后，如果想要立即生效，就要重新执行一遍该脚本。 我们可以使用source命令： source ./.zshrc 或者直接简写为： . ./zshrc 变量设置规则变量设置规则： 变量名称可以由字母、数字和下划线组成 ，但是不能以数字开头。如果变量名是 “2name”则是错误的。 在Bash中，变量的默认类型都是字符串型 ，如果要进行数值运算，则必需指定变量类型为数值型。 默认变量类型全都是字符串型，和其他语言不太一样。 变量用等号连接值，等号左右两侧不能有空格。 变量的值如果有空格，需要使用单引号或双引号包括。 在变量的值中，可以使用“\\”转义符。 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名”或用${变量名}包含。 如果是把命令的结果作为变量值赋予变量 ，则需要使用反引号或$()包含命令。 环境变量名建议大写，便于区分。 变量的分类： 用户自定义变量 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。 位置参数变量:这种变量主要是用来向脚本当 中传递参数或数据的，变量名不能自定义，变量作用是固定的。 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。 变量划分系统常见环境变量系统常见环境变量 PATH:系统查找命令的路径这便是输入命令之前不用输入绝对路径的根本原因，系统会提前在PATH环境变量里的所有路径中查询一遍有没有你输入的命令，找到之后直接执行。 如果你想直接执行shell脚本，不加绝对路径，直接写入PATH环境变量，使用叠加。 例子： echo $PATHPATH=$PATH:/root/sh #PATH变量叠加 此后，rootsh路径里面的执行文件都可以在任意目录下直接执行，不过是临时生效 PS1：定义系统提示符的变量 用来改[root@localhost ~]# 这个显示 下面是系统提示符的变量： \\d:显示日期，格式为“星期 月 日” \\h:显示简写主机名。如默认主机名“localhost” \\t:显示24小时制时间，格式为“HH:MM:SS” \\T:显示12小时制时间，格式为“HH:MM:SS” \\A:显示24小时制时间，格式为“HH:MM” \\u:显示当前用户名 \\w:显示当前所在目录的完整名称 \\W:显示当前所在目录的最后一个目录 #:执行的第几个命令 $:提示符。如果是root用户会显示提示符为“#”，如果是普通用户 会显示提示符为“$” 位置参数变量在脚本中主要针对参数的一些变量操作。 位置参数 变量 作用 $n n为数字，$0代表命令本身，$1-9 代 表 第 一 到 第 九 个 参 数 ， 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9代表第一 到第九个参数，十以上的参数需要用大括号 包含，如9代表第一到第九个参数，十以上的参数需要用大括号包含，如{10}. $* 这个变量代表命令行中所有的参数，$*把所 有的参数看成一个整体 $@ 这个变量也代表命令行中所有的参数，不过 $@把每个参数区分对待 $# 这个变量代表命令行中所有参数的个数 举例： #$n的例子:一个加法器num1=$1num2=$2sum=$(( $num1 + $num2)) #变量sum的和是num1加num2 echo $sum #打印变量sum的值echo $sum 预定义变量 预定义变量 作用 $? 最后一次执行的命令的返回状态。如果这个变 量的值为0，证明上一个命令正确执行;如果 这个变量的值为非0(具体是哪个数，由命令 自己来决定)，则证明上一个命令执行不正确 了。 $$ 当前进程的进程号(PID) $! 后台运行的最后一个进程的进程号(PID) echo “The current process is $$”#输出当前进程的PID。#这个PID就是variable.sh这个脚本执行时，生成的进程的PIDfind /root -name hello.sh #使用find命令在root目录下查找hello.sh文件 #符号的意思是把命令放入后台执行，工作管理在系统管理章节会详细介绍echo The last one Daemon process is $! 接受键盘输入 read [选项] [变量名] -p “提示信息”:在等待read输入时，输出提示信息 -t 秒数: read命令会一直等待用户输入，使用 此选项可以指定等待时间 -n 字符数:read命令只接受指定的字符数，就会执行 -s: 隐藏输入的数据，适用于机密信息的输入 其他配置文件和登录信息注销时生效的环境变量配置文件 ~.bash_logout注销登陆时写入 其他配置文件 ~bash_history 历史命令文件 Shell登录信息 本地终端欢迎信息: etcissue 转义符 作用 \\d 显示当前系统日期 \\s 显示操作系统名称 \\l 显示登录的终端号，这个比较常用。 \\m 显示硬件体系结构，如i386、i686等 显示主机名 \\o 显示域名 \\r 显示内核版本 \\t 显示当前系统时间 \\u 显示当前登录用户的序列号 远程终端欢迎信息:/etc/issue.net 转义符在etcissue.net文件中不能使用。 是否显示此欢迎信息，由ssh的配置文件 /etc/ssh/sshd_config决定，加入“Banner etcissue.net”行才能显示(记得重启SSH服务)。 登陆后欢迎信息:/etc/motd不管是本地登录，还是远程登录，都可以显示此欢迎信息。 变量运算declare 声明变量类型 declare [+/-][选项] 变量名 -: 给变量设定类型属性 +: 取消变量的类型属性 -i: 将变量声明为整数型(integer) set-x: 将变量声明为环境变量 -p: 显示指定变量的被声明的类型 数值运算 数值运算 aa=11bb=22 #给变量aa和bb赋值declare -i cc=$aa+$bb expr或let数值运算工具 aa=11bb=22 #给变量aa和bb赋值dd=$(expr $aa + $bb)# dd的值是aa和bb的和。注意“+”号左右两 侧必须有空格 let与expr一样。 “$((运算式))”或“$[运算式]” aa=11bb=22 给变量aa和bb赋值ff=$(( $aa+$bb ))gg=$[ $aa+$bb ] 优先级表： 优先级\t运算符\t说明13\t-, +\t单目负、单目正12\t!, ~\t逻辑非、按位取反或补码11\t,, %\t乘、除、取模10\t+, -\t加、减9 , 按位左移、按位右移8 , , , 小于或等于、大于或等于、小于、大于7 , !\t等于、不等于6 按位与5\t^\t按位异或4\t|\t按位或3 逻辑与2\t||\t逻辑或1\t,+,-,,,%,, ^,赋值、运算且赋值 |, , 变量测试与替换用来测试一个变量到底有没有设置，测试表： 变变量置换方式\t变量y没有设置\t变量y为空值\t变量y设置值x${y-新值}\tx新值\tx为空\tx$yx${y:-新值}\tx新值\tx新值 x$y\tx${y+新值}\tx为空\tx新值\tx新值x${y:+新值}\tx为空\tx为空\tx新值x${y新值}\tx新值 y新值\tx为空 y值不变\tx$y y值不变x${y:新值}\tx新值 y新值\tx新值 y新值\tx$y y值不变x${y?新值}\t新值输出到标准错误输出(就是屏幕)\tx为空\tx$yx${y:?新值}\t新值输出到标准错误输出\t新值输出到标准错误输\tx$y 例子：测试x${y-新值} 测试y变量存不存在 unset y 删除变量yx=$y-new 进行测试echo $x 显示new，y变量不存在因为变量y不存在，所以xnew y= 给变量y赋值为空x=$y-new 进行测试echo $x 显示空，y为空值 y=old 给变量y赋值x=$y-new 进行测试echo $x 显示old ，y变量存在且有值 在用到的时候查询就好，不需要死记硬背。这个表是在写脚本的时候给电脑程序看的，人不参与其中"},{"title":"必知必会","path":"/wiki/mysql/必知必会.html","content":"10.2 尚硅谷mysql基础篇看完就忘了。基础的语法内容需要一定的代码量，最近我会多敲敲mysql。 SQL背景： 最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的 形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂， 但可读性更强。SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。 表连接区分内连接、外连接 inner join 内连接：满足交集。 outer join : 左右外连接。 内外连接即交并集的关系。 自连接 、 非自连接 自连接：对某个表来说，自己和自己的数据进行匹配。 非自连接：非自连接要借助外表。 联结连接区分联结、高级联结 等值联结（内部联结）： SELECT *FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id 多表联结： SELECT *FROM orderitems,prodacts,vendors WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 2005 自联结（自己和自己的两个表进行联结），即自连接 自然联结：如下 NATRUAL JOIN 外部联结 LEFT RIGHT JOIN (内连接，外连接) 组合查询：UNION 子查询 表查询区分等值查询、非等值查询 等值查询：过滤条件里是否为数值上的相等关系 非等值：BETWEEN ON，模糊查询 相关（关联）查询、非相关（非关联）查询 关于关联子查询： 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联。因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。 题目示例：不相关子查询：查询员工中工资大于本公司平均工资的员工的last_name,salary和其department_id 相关子查询：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id PS：公司平均工资和该员工的个人信息没有关系，即不相关。部门和该员工的个人部门有关，相关。 另：多表查询是个很大的范围，用到两个表以上的查询就是多表查询。 函数区分单行函数、多行（分组、聚合）函数 单行函数 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以嵌套 参数可以是一列或一个值、 多行函数 聚合函数作用于一组数据，并对一组数据返回一个值 表连接的新语法自然连接： 类似 SQL92 中的等值连接：自动查询两张连接表中所有相同的字段来进行等值连接 在SQL92标准中： SELECT employee_id,last_name,department_name FROM employees e JOIN departments d ON e.`department_id` = d.`department_id` AND e.`manager_id` = d.`manager_id`; 在 SQL99 中你可以写成： SELECT employee_id,last_name,department_name FROM employees e NATURAL JOIN departments d; #所有相同的字段自动等值查询 USING连接 SQL99支持使用 USING 指定数据表里的同名字 进行等值连接。USING只能配合JOIN一起使用。 区别于自然连接 ，USING 指明了相同的字段名称，同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。 SELECT employee_id,last_name,department_name FROM employees e JOIN departments d USING (department_id); SELECT employee_id,last_name,department_name FROM employees e ,departments d WHERE e.department_id = d.department_id; 上面两者效果相同。 这里 using 取代了 WHERE 的作用，并且形式上更简洁。 表连接的约束条件可以有三种方式：WHERE, ON, USING WHERE：适用于所有关联查询 ON ：只能和JOIN一起使用，只能写关联条件。 虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。 USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致 只能表示关联字段值相等 N张表关联时的效率问题： #n张表关联，需要n-1个关联条件 #查询员工姓名，基本工资，部门名称 SELECT last_name,job_title,department_name FROM employees,departments,jobs WHERE employees.department_id = departments.department_id AND employees.job_id = jobs.job_id; SELECT last_name,job_title,department_name FROM employees INNER JOIN departments INNER JOIN jobs ON employees.department_id = departments.department_id AND employees.job_id = jobs.job_id 我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重。 在许多 DBMS 中，也都会有最大连接表的限制。 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。 来源：阿里巴巴《Java开发手册》 优化sql查询语句的思路：一次查询返回多个需要的column 注意 DISTINCT ， IS NOT NULL 的情况。 FROM 后的表和别名更容易维护扩展。 实际上，很多 WHERE 处的过滤条件，都可以通过在 FROM 处改动来替换 例子： 无别名 SELECT *FROM employees WHERE employee_id = ANY( SELECT manager_id FROM employees WHERE department_id = (SELECT department_id FROM employees GROUP BY department_id ORDER BY salary DESC LIMIT 0,1 ) ) 有别名 SELECT last_name, department_id, email, salaryFROM employees WHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees e,( SELECT department_id,AVG(salary) avg_sal FROM employees GROUP BY department_id ORDER BY avg_sal DESC LIMIT 0,1) dept_avg_sal WHERE e.department_id = dept_avg_sal.department_id )"},{"title":"存储过程函数","path":"/wiki/mysql/存储过程函数.html","content":"[Stored Procedure Stored Function] [TOC] 存储过程定义一组预先经过编译的SQL语句： 执行过程：存储过程预先存储在 MySQL 服务器上。执行时，客户端向服务器端发出调用命令，服务器端会将这一系列 Stored SQL 语句全部执行。 语法分析：创建： CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) [characteristics ...] BEGIN存储过程体END 分类： 没有参数（无参数无返回） 仅仅带 IN 类型（有参数无返回） 仅仅带 OUT 类型（无参数有返回） 既带 IN 又带 OUT（有参数有返回） 带 INOUT（有参数有返回） 注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。 参数意义 IN ：当前参数为输入参数，也就是表示入参； 读取参数值。 默认为 IN ，表示输入参数。 OUT ：当前参数为输出参数，也就是表示出参； 执行完成后，调用客户端可以读取参数返回值。 INOUT ：当前参数既可以为输入参数，也可以为输出参数。 形参类型：可以是 MySQL数据库中的任意类型。 约束条件：characteristics 创建存储过程时指定的约束条件 LANGUAGE SQL | [NOT] DETERMINISTIC | CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA | SQL SECURITY DEFINER | INVOKER | COMMENT string LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。 [NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。 1.DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同输入得到相同输出。 2.NOT DETERMINISTIC表示结果是不确定 的，相同输入可能得到不同输出。 (如果没有指定任意一个值，默认为NOT DETERMINISTIC) { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使用SQL语句的限制。 1.CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句； 2.NO SQL表示当前存储过程的子程序中不包含任何SQL语句； 3.READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； 4.MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 (默认情况下，系统会指定为CONTAINS SQL) SQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。 1.DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程； 2.INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 (如果没有设置相关的值，则MySQL默认指定值为DEFINER) COMMENT string ：注释信息，用来描述存储过程 省略：如果函数体里仅仅一条SQL 语句，则可以省略 BEGIN 和 END 结束标记：DELIMITER DELIMITER $ # look at this!CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...] BEGINsql语句1; #为了避免和函数体里的分号混淆sql语句2; END $ # Wowwwww! 避免使用反斜杠（\\）字符 ：因为反斜线是MySQL的转义字符。 调用 存储过程必须使用CALL语句调用，并且存储过程和数据库相关， 执行其他数据库中的存储过程，需要指定数据库名称，例如 CALL dbname.procname。 CALL 存储过程名(实参列表) IN 场景 CALL sp1(值); OUT 场景 SET @name;CALL sp1(@name);SELECT @name; 注意：OUT 输出参数，还要配合 SELECT [求得的字段] INTO @变量 FROM…… 来给参数变量赋值， 同时在调用时给 OUT 参数 赋值。 INOUT 场景 SET @name=值;CALL sp1(@name);SELECT @name; 示例： 创建调用过程 DELIMITER // CREATE PROCEDURE `add_num`(IN n INT) BEGIN #定义+赋值DECLARE i INT; DECLARE sum INT;SET i = 1; SET sum = 0; #进入循环WHILE i = n DO SET sum = sum + i; SET i = i +1; END WHILE; #产出结果SELECT sum;END //DELIMITER ;#第2个存储过程CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)... CALL调用过程 CALL CountProc (101, @num);CALL add_num(50); 查看发挥结果 SELECT @num; 如果使用了DBMS： Navicat ，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号， 不需要再进行 DELIMITER 的操作。 调试SQL没有IDE，你只能通过SELECT一个一个实验排查。 效果比较好处： 简化操作，提高了sql语句的重用性，减少了开发程序员的压力 减少操作过程中的失误，提高效率 减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性 和视图、函数的对比： 它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。 和视图的不同 视图是虚拟表 ，通常不对底层数据表直接操作， 存储过程是程序化的 SQL，可以直接操作底层数据表,相比于面向集合的操作方式，能够实现一些更复杂的数据处理。 和函数的不同 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于 函数，存储过程是 没有返回值 的。 存储函数应用语法分析：创建： CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回值类型 [characteristics ...] BEGIN函数体 #函数体中肯定有 RETURN 语句 END 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数RETURNS type 语句表示函数返回数据的类型； RETURNS子句只能对FUNCTION做指定,对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。 characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。 函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。 调用 在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。 换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。 区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。 SELECT 函数名(实参列表) 示例 创建 CREATE FUNCTION email_by_name()RETURNS VARCHAR(25) DETERMINISTIC CONTAINS SQL BEGINRETURN (SELECT email FROM employees WHERE last_name = Abel);END // DELIMITER ; DELIMITER // CREATE FUNCTION count_by_id(dept_id INT) RETURNS INT LANGUAGE SQL NOT DETERMINISTIC READS SQL DATA SQL SECURITY DEFINER COMMENT 查询部门平均工资 BEGINRETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id); END // DELIMITER ; 调用 SELECT email_by_name()SET @dept_id = 50; SELECT count_by_id(@dept_id); 注意：若在创建存储函数中报错 you might want to use the less safe log_bin_trust_function_creators variable 有两种处理方法： 方式1：加上必要的函数特性 [NOT] DETERMINISTIC”和“CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA 方式2： mysql SET GLOBAL log_bin_trust_function_creators = 1; 两者对比 关键字 调用语法 返回值 应用场景 存储过程 PROCEDURE CALL 存储过程() 0或多个 更新 存储函数 FUNCTION SELECT 函数() 只能是一个 返回一个查询结果 存储函数可以放在查询语句中使用，存储过程不行。 存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，存储函数不行。 存储过程和函数的查看、修改、删除查看MySQL存储了存储过程和函数的状态信息，用户可以通过3种方法查看： SHOW CREATE语句 SHOW CREATE PROCEDURE | FUNCTION 存储过程名或函数名#举例SHOW CREATE FUNCTION test_db.CountProc \\G SHOW STATUS语句 SHOW PROCEDURE | FUNCTION STATUS [LIKE pattern] 这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。 在information_schema.Routines 表中查看 SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=存储过程或函数的名 [AND ROUTINE_TYPE = PROCEDURE|FUNCTION];#数据库中存在（函数和过程）名称相同的情况，指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。 修改 这里的修改指：不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。 ALTER PROCEDURE | FUNCTION 存储过程或函数的名 [characteristic ...] characteristic 指定存储过程或函数的特性，其取值信息与[创建存储过程、函数时的取值信息] 不同。 CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA | SQL SECURITY DEFINER | INVOKER | COMMENT string CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。 NO SQL ，表示子程序中不包含SQL语句。 READS SQL DATA ，表示子程序中包含读数据的语句。 MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。 DEFINER ，表示只有定义者自己才能够执行。 INVOKER ，表示调用者可以执行。 COMMENT ‘string’ ，表示注释信息 修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。 两个语句的结构一样，语句中的所有参数也一样。 示例： ALTER PROCEDURE CountProcMODIFIES SQL DATASQL SECURITY INVOKER ; 修改后查询 SELECT specific_name,sql_data_access,securtiy_typeFROM information_schema.ROUTINESWHERE routine_name = CountProc AND routine_type = PROCEDURE; 查询结果：访问数据权限和安全类型改变。 删除DROP PROCEDURE | FUNCTION [IF EXISTS] 存储过程或函数的名#IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告 拓展对于存储过程的使用争议： 优点 **存储过程可以一次编译多次使用。**存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。 **可以减少开发工作量。**将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰。 **存储过程的安全性强。**我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。 可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。 良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。 缺点基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？ 阿里开发规范【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。存储过程虽然有诸如上面的好处，但缺点也是很明显的。 可移植性差：存储过程不能跨数据库移植 比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。 调试困难：只有少数 DBMS 支持存储过程的调试。 对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。 存储过程的版本管理很困难：比如数据表索引发生变化了，可能会导致存储过程失效。 我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。 它不适合高并发的场景：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方 式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就 不适用了。"},{"title":"杂项","path":"/wiki/mysql/杂项.html","content":"管理用户mysql用户的账号和信息都存在名为mysql的MYSQL数据库中。 mysql数据库有一个 USER 表，存放着账户和密码。 USE mysql;SELECT user FROM user; CREATE USER ben IDENTIFIED BY your_password; IDENTIFIED BY 为纯文本。MYSQL会自动在保存到user表前对密码进行加密，作为散列表指定口令。 GRANT和INSERT也可以添加用户。 重命名： RENAME USER ben TO bforta; #bforta是个用户 删除： DROP USER bforta; 更改密码 SET PASSWORD FOR bforta = PASSWORD(new_passw); 设置访问权限: #查看用户账号权限SHOW GRANTS FOR user_name;#赋予权限GRANT SELECT ON crashcourse.* TO bforta;# crashcourse是个表，*即全部，表中全部内容都有了只读的访问权限#撤销权限REVOKE SELECT ON crashcourse.* FROM bforta; 适用范围 整个服务器：GTANT ALL 和 REVOKE ALL 整个数据库： 例如 ON database.* 特定表：例如 ON database.table 特定列 特定存储过程 权限类型：“太鸡儿多了，自己去看文档或者google好了” 提前授权: GRANT 和 REVOKE 的账户必须已经存在，但对象没有这种要求。 所以可以在创建数据库之前授权。更加安全。 坏处是删掉数据库后权限仍然存在，需要手动清理，否则可能影响下次创建。 一些维护的东西数据库维护 ANALYZE TABLE :检查表键 CHECK TABLE ：检查很多表属性。 日志文件 错误日志:hostname.err 查询日志:hostname.log 二进制日志:hostname-bin 缓慢查询日志:hostname-slow.log 1.都在data目录里了 2.- - log命令符能更改这些文件的名字。 陌生关键字ACTION ASENSITIVE CONVERT ENUM FORCE GOTO KILL LINES MOD NUMERIC OPTIMIZE OPTION OUTFILE PURGE RELEASE RESTRICT STARTING START_JOIN TERMINATED SPATIAL SONAME SCHEMA VARYING USAGE SQLEXCEPTION STATE WARNING"},{"title":"游标和触发器","path":"/wiki/mysql/游标和触发器.html","content":"游标**（或光标）**定义游标是一种 能够对结果集中的每一条记录进行定位（像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一条记录 ），并对指向的记录中的数据进行操作的数据结构。 游标让 SQL这种面向集合的语言有了面向过程开发的能力。 特点： 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。 这里游标充当指针的作用,通过操作游标来对数据行进行操作. 游标必须在声明处理程序之前被声明 相对的，变量和条件则必须在声明游标和处理程序之前被声明。 使用过程使用游标一般分4步，不同DBMS细节不同。 声明游标 mysql(还有SQL Server，DB2 和 MariaDB) DECLARE cursor_name CURSOR FOR select_statement; Oracle 或者 PostgreSQL DECLARE cursor_name CURSOR IS select_statement; select_statement:要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据， 所以这里要通过SELECT 语句，返回一个用于创建游标的结果集。 打开游标 定义好游标之后，使用游标前必须先打开游标。 打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。 OPEN cursor_name 使用游标 使用即通过它来获取数据 FETCH cursor_name INTO var_name [, var_name] ...#这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，#游标指针指到下一行。 注意： 如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。 var_name必须在声明游标之前就定义好。 游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 关闭游标 CLOSE cursor_name 使用完游标后需要关闭掉该游标 。下次还要使用就要重新打开游标。 游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。 示例创建存储过程“get_count_by_limit_total_salary()”， 声明IN参数 limit_total_salary，DOUBLE类型； 声明 OUT参数total_count，INT类型。 函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。 DELIMITER // CREATE PROCEDURE get_count_by_limit_total_salary( IN limit_total_salary DOUBLE,OUT total_count INT)BEGINDECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资 DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值 DECLARE emp_count INT DEFAULT 0; #记录循环个数 #定义游标 DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;#打开游标 OPEN emp_cursor; REPEAT #使用游标（从游标中获取数据） FETCH emp_cursor INTO cursor_salary; SET sum_salary = sum_salary + cursor_salary; SET emp_count = emp_count + 1; UNTIL sum_salary = limit_total_salary END REPEAT; SET total_count = emp_count; #关闭游标 CLOSE emp_cursor; END // DELIMITER ; 总结 优点：为逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 缺点：比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理。 建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率 触发器应用场景有 2 个或者多个相互关联的表，如商品信息和库存信息 分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。 这样一来，我们就必须把这两个关联的操作步骤同步写到程序里面。可对数据进行手动维护时，很容易忘记其中的一步 ，导致数据缺失。 这时可以使用触发器：创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。 定义 MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。 所谓事件就是指 用户的动作或者触发某项行为。 如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。 当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。 使用 触发器不能更新或覆盖；为了修改一个触发器，必须先删再建。 使用触发器 insert 触发器 在insert触发器代码内，可引用一个名为new的虚拟表，访问被插入的行； 在before insert触发器内，new中的值也可以被更新(允许更改被插入的值)； delete 触发器 在delete触发器代码内，可以引用一个名为old的虚拟表，访问被删除的行； old中的值全都是只读的，不能更新； update 触发器 在update触发器代码内，可以引用一个名为old的虚拟表访问以前(update语句前)的值，引用一个名为new的虚拟表访问新更新的值； 在before update触发器中，new中的值可能也被更新(允许更改将要用于update语句中的值)； old中的值全都是只读的，不能更新； 另外的 tips ： 创建触发器可能需要特殊的安全访问权限，但触发器的执行是自动的。如果insert、update或delete语句可以执行，则相应触发器也能执行； 应该用触发器来保证数据的一致性(大小写、格式等)；优点在于它总是进行这种处理，而且是透明的进行，与客户机应用无关； 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改记录到另一个表非常容易； MySQL触发器不支持call语句，即不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 创建CREATE TRIGGER 触发器名称BEFORE|AFTERINSERT|UPDATE|DELETE ON 表名 FOR EACH ROW 触发器执行的语句块; 表名 ：表示触发器监控的对象。 BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。 INSERT|UPDATE|DELETE ：表示触发的前提事件。 查看查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。 查看当前数据库的所有触发器的定义 SHOW TRIGGERS\\G 查看当前数据库中某个触发器的定义 SHOW CREATE TRIGGER 触发器名 从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。 SELECT * FROM information_schema.TRIGGERS; 删除DROP TRIGGER IF EXISTS 触发器名称; 触发器作为数据库对象之一，也适用于DROP删除。 示例DELIMITER // CREATE TRIGGER salary_check_trigger BEFORE INSERT ON employees FOR EACH ROW BEGIN DECLARE mgrsalary DOUBLE; SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id; IF NEW.salary mgrsalary THEN SIGNAL SQLSTATE HY000 SET MESSAGE_TEXT = 薪资高于领导薪资错误; END IF; END // DELIMITER ; 一个注意点：如果在子表中定义了外键约束，并且外键指定了ON UPDATEDELETE CASCADESET NULL子句，此 时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE和DELETE语句定义的触发器并不会被激活。 优缺点 优点： 触发器可以确保数据的完整性。 触发器可以帮助我们记录操作日志 触发器还可以用在操作数据前，对数据进行合法性检查。 缺点： 触发器最大的一个问题就是可读性差 因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统维护是非常有挑战的。 #创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败update demo.membermaster set memberdeposit=20 where memberid = 2; ERROR 1054 (42S22): Unknown column aa in field list 这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力 相关数据的变更，可能会导致触发器出错。 特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。 拓展：MySQL 8.0的新特性**—**全局变量的持久化在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。 例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现： SET GLOBAL MAX_EXECUTION_TIME=2000; 但使用SET GLOBAL语句设置的变量值只会临时生效 : 即数据库重启 后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。 例如：设置服务器的最大连接数为1000： SET PERSIST global max_connections = 1000; MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。"},{"title":"用户的创建、修改和删除","path":"/wiki/mysql/用户的创建、修改和删除.html","content":"用户管理用户信息在哪里默认数据库有四个： information_schema mysql performance_schema sys 其中 “mysql” 数据库有一个表名为user，存储着用户信息。 通常默认有四个用户： root ,mysql.infoschema,mysql.session,mysql.sys 。 ubuntu 或 debian 用户还会有个maint用户。 debian-sys-maint中Debian系统对MySQL维护用的，可以理解为通过系统的某个“非常规”程序对Mysql进行备份恢复等行为时，改程序所使用的用来登录Mysql的账户。 具体作用是重启及运行mysql服务，不过有一个安全问题：该用户的权限和ROOT是一样的，并且密码可以在etc某个文件中找到，这需要对账户进行一些限制。 root 的权限最高，顾名思义为“根”，拥有最高权限，创建其他用户，它不能没有。 user 的联合主键用户信息里两个列很关键：host 和 user。 host : 主机，用来区分用户的连接段。 user : 用户名，区分用户 user 表的主键有两个：host和user，即联合主键。 所以不同连接段允许有重名用户出现，就像不同作用域能够有重名变量一样。 创建、修改、删除创建用户指令： CREATE USER 用户名 [@主机名称] [IDENTIFIED BY 密码] #[]为可选 tips： 该语句可以同时创建多个用户。 用户名参数由用户和主机名构成。 需要有CREATE权限，新账户什么权限都没有。 修改 UPDATE mysql.user set user = wang5 where user = li4 [and host = xxx]flush privileges;# 刷新权限，否则登陆时仍然是原本的用户信息 修改用户就是直接操作 user 表。 修改完需要fs; 删除 两个方法：DROP 和 DELETE (user 表里删)。 DROP DROP USER user,[user].... #user即用户名参数，可包含 hostDROP USER li4; # 默认删除host为%的用户DROP USER li4@localhost; DELETE DELETE FROM mysql.user WHERE Host=hostname AND User = username;#必须有 host ，联合主键的两个字段，才能唯一确定一条记录。FLUSH PRIVILEGES; #立即生效。 DELETE 删除会有系统信息残留。DROP 指令能同时删去 mysql.user 表和 mysql.db 表内容。 设置当前用户密码1. 使用ALTER USER命令来修改当前用户密码 ALTER USER USER() IDENTIFIED BY new_password; 2. 使用SET语句来修改当前用户密码 SET PASSWORD=new_password; 修改其他用户密码1. 使用ALTER语句来修改普通用户的密码 ALTER USER user [IDENTIFIED BY 新密码] [,user[IDENTIFIED BY 新密码]]…; 2. 使用SET命令来修改普通用户的密码 SET PASSWORD FOR username@hostname=new_password; 密码过期关键词 EXPIRE 你可以通过ALTER和CREATE 时 手动设置用户密码过期，这样用户可以登入数据库，但无法查询。除非重新设置密码。 你也可以修改系统全局变量 Default password lifetime 。改变量默认为0，即不过期。设置为N代表密码生存期，N天后密码必须修改，否则将自动过期。 密码重用关键词 INTERVAL 、REUSE 分两类：时间和更改数量 时间（周期）：修改后密码不能用最近N天时间使用过的密码相同。 更改数量 ：修改后密码与最近N个密码不能相同。 系统变量：password_history , password_reuse_interval 权限管理show privileges; #查看权限 CREATE和DROP权限，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 SELECT、INSERT、UPDATE和DELETE权限允许在一个数据库现有的表上实施操作。 SELECT权限只有在它们真正从一个表中检索行时才被用到。 INDEX权限允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。 CREATE ROUTINE权限用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用来执行保存的程序。 GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。 FILE权限使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。 授予权限GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’]; 该权限如果发现没有该用户，则会直接新建一个用户。 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost; 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限 GRANT ALL PRIVILEGES ON *.* TO joe@% IDENTIFIED BY 123; 授予权限的原则 权限控制主要是出于安全因素，因此需要遵循以下几个经验原则： 1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 2、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。 3、为每个用户设置满足密码复杂度的密码。 4、定期清理不需要的用户，回收权限或者删除用户。 查看权限 查看当前用户权限 SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER(); 查看某用户的全局权限 SHOW GRANTS FOR user@主机地址; 收回权限注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。 收回权限命令 REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址; 举例 #收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@%; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost; 注意：须用户重新登录后才能生效 权限表user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。 这些字段可分为四类： 范围列： host : 表示连接类型 % 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 机器名 通过制定网络中的机器名进行的TCP方式的连接 ::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1 localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。 user : 表示用户名，同一用户通过不同方式链接的权限是不一样的。 password ：mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字 段。 权限列：是否拥有一些特定权限 安全列 ：加密，表示用户，验证用户身份。 资源控制列：限制用户使用的资源。共4个字段。 ①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。 查看字段： DESC mysql.user; 查看用户, 以列的方式显示数据： SELECT * FROM mysql.user \\G; 查询特定字段： SELECT host,user,authentication_string,select_priv,insert_priv,drop_priv FROM mysql.user; db表 用户列 db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。 权限列 Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。 结构查看： DESCRIBE mysql.db; tables_priv 和 column_priv 表 tables_priv 表：对表设置操作权限 columns_priv 表 ：对表的某一列设置权限 。 procs_priv 表procs_priv 表可以对存储过程和存储函数设置操作权限 上面几个表都在 database → mysql 里，想看自己 DESC 去。 角色角色的创建、删除和权限操作创建角色 CREATE ROLE role_name[@host_name] [,role_name[@host_name]]... 角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。 给角色赋予权限 GRANT privileges ON table_name TO role_name[@host_name]; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称 SHOW PRIVILEGES\\G 查看角色的权限 SHOW GRANTS FOR role_name; 只要你创建了一个角色，系统就会自动给你一个“USAGE”权限，意思是连接登录数据库的权限。 回收角色的权限 REVOKE privileges ON tablename FROM rolename; 删除角色 DROP ROLE role [,role2]... 注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。 角色和用户给用户赋予角色 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。 GRANT role [,role2,...] TO user [,user2,...]; 查询当前已激活的角色 SELECT CURRENT_ROLE(); 激活角色 方式1：使用set default role 命令激活角色 SET DEFAULT ROLE ALL TO kangshifu@localhost; 方式2：将activate_all_roles_on_login设置为ON SET GLOBAL activate_all_roles_on_login=ON; 这条 SQL 语句的意思是，对所有角色永久激活。 撤销用户的角色 REVOKE role FROM user; 设置强制角色(mandatory role) 方式1：服务启动前设置 [mysqld] mandatory_roles=role1,role2@localhost,r3@%.atguigu.com 方式2：运行时设置 SET PERSIST mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后仍然有效SET GLOBAL mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后失效 配置文件**文件里会定义许多组(用 [ ] 括起来)，组下边可以定义启动选项。**通常称组为标签。 [server]#具体启动选项option1 #不需要选项值：True / False 类型option2 = value2 #需要选项值 ： 键值对 类型[mysqld]...[mysqld_safe]...[client]... 配置文件中不同选项组是给不同的启动命令使用的。 有两个选项组比较特别： [server]组的启动选项作用于所有服务器程序 [client]组的启动选项作用于所有客户端程序。 像mysql这个启动命令，就会调用 [mysql] 和 [client] 两个组 tips： [mysql-‘版本号’]：只适用于特定版本的专用选项组 两个组里出现重复配置项，以最后一个为准。 一个选项既出现在命令行，又出现在配置文件里，以命令行为准。 如 defaults-extra-file 和 defaults-file 本身就是为了指定配置文件路径的。"},{"title":"约束","path":"/wiki/mysql/约束.html","content":"约束定义为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制 实体完整性（Entity Integrity） ： 同一个表中，不能存在两条完全相同无法区分的记录 域完整性（Domain Integrity） ： 年龄范围0-120，性别范围“男女” 引用完整性（Referential Integrity） 例如：员工所在部门，在部门表中要能找到这个部门 用户自定义完整性（User-defined Integrity） 例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。 定义建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束是表级的强制规定。 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束。 分类 根据约束数据列的限制，约束可分为： 单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据 根据约束的作用范围，约束可分为： 分类 位置 支持的约束类型 是否可以起约束名 作用范围 列级约束 列的后面 语法都支持，但外键没有效果 不可以 只能作用在一个列上 表级约束 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果） 可以作用在多个列上， 不同约束属性： NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束* FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果。 #information_schema数据库名（系统库） #table_constraints表名称（专门存储各个表的约束） SELECT * FROM information_schema.table_constraints WHERE table_name = 表名称; 不同约束NOT NULL非空约束，规定某个字段不能为空 默认所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 非空约束只能针对列，不能组合非空 空字符串’’不等于NULL，0也不等于NULL 添加 CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL ); 修改 alter table 表名称 modify 字段名 数据类型 not null; 删除 #去掉not null，相当于修改某个非注解字段，该字段允许为空 #1.alter table 表名称 modify 字段名 数据类型 NULL;#2.alter table 表名称 modify 字段名 数据类型; UNIQUE唯一约束，规定某个字段在整个表中是唯一的 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 mysql 会给唯一约束的列上默认创建一个唯一索引。** 添加 唯一约束 create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名) ); 组合约束 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, unique key(字段列表) )#字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的 ); 修改 #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的#方式1：alter table 表名称 add unique key(字段列表);#方式2： alter table 表名称 modify 字段名 字段类型 unique; 删除 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。 ALTER TABLE table_name DROP INDEX index_column; 注意：可以通过 show index from 表名称 来查看表的索引。 PRIMARY KEY主键(非空且唯一)约束 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 主键约束对应着表中的一列或者多列（复合主键） 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 MySQL的主键名总是PRIMARY**，就算自己命名了主键约束名也没用。 ** 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引 能够根据主键查询的，就根据主键查询，效率更高。 如果删除主键约束了，主键约束对应的索引就自动删除了。 不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性 添加 唯一约束 #列级模式 create table 表名称( 字段名 数据类型 primary key, #不要忘了，一个表最多一主键 字段名 数据类型, 字段名 数据类型 );#表级模式 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段名) ); 组合约束 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段); 修改 ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表);#字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段 ); 删除 ALTER TABLE 表名称 drop primary key; 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。 AUTO_INCREMENT 自增列 一个表最多只能有一个自增长列 当需要产生唯一标识符或顺序值时，可设置自增长 自增长列约束的列必须是键列（主键列，唯一键列） 自增约束的列的数据类型必须是整数类型 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 ​ 赋值为具体值。 添加 create table 表名称( 字段名 数据类型 primary key auto_increment, #必须是键列 字段名 数据类型 unique key not null, #一表最多一自增列 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, );create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值, primary key(字段名) ); 修改 alter table 表名称 modify 字段名 数据类型 auto_increment; 删除 alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 扩展： MySQL 8.0新特性：自增变量的持久化 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENTmax(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 test: (创建的数据表中包含自增主键的id字段) MySQL 5.7版本中， 语句如下： INSERT INTO test1 VALUES(0),(0),(0),(0); mysql SELECT * FROM test1;+----+| id |+----+| 1 | | 2 | | 3 | | 4 |+----+4 rows in set (0.00 sec) 再删再插 DELETE FROM test1 WHERE id = 4; INSERT INTO test1 VALUES(0); 结果： mysql SELECT * FROM test1;+----+| id | +----+| 1 | | 2 | | 3 | | 5 | +----+ 从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。 删除id为5的记录，结果如下： DELETE FROM test1 where id=5; 重启数据库，重新插入一个空值,在插入，结果则会变成： | id | +----+| 1 | | 2 | | 3 | | 4 | #应该是6！+----+4 rows in set (0.00 sec)#自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。 当数据库重启时，该计数器会被初始化 但在8.0版本中的结果： mysql SELECT * FROM test1;+----+| id |+----+| 1 | | 2 | | 3 | | 6 | +----+4 rows in set (0.00 sec) 此之谓“自增主键持久化” FOREIGN KEY 外键约束限定某个表的某个字段的引用完整性 定义 主表和从表父表和子表 主表（父表）：被引用的表，被参考的表 从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。 特点 从表的外键列，必须引用参考主表的主键或唯一约束的列 因为被依赖被参考的值必须是唯一的 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名 例如 student_ibfk_1;），也可以指定外键约束名。 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表 删表时，先删从表（或先删除外键约束），再删除主表 当主表的记录被从表参照时，主表的记录将不允许删除 如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 在“从表”中指定外键约束，并且一个表可以建立多个外键约束 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误。 例如：都是表示部门编号，都是int类型。 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。 但是索引名是外键的约束名。（根据外键查询效率很高） 删除外键约束后，必须手动删除对应的索引 添加 create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型 );create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT 外键约束名称] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) ); #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列 修改 一般情况下，表与表的关联都是提前设计好了的，因此会在创建表的时候就把外键约束定义好。 如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，这时就要用修改表的方式来补充定义。 ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx]; 总结： 约束关系是针对双方的 添加了外键约束后，主表的修改和删除数据受约束 添加了外键约束后，从表的添加和修改数据受约束 在从表上建立外键，要求主表必须存在 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除 约束等级 Cascade方式 ：在父表上updatedelete记录时，同步updatedelete掉子表的匹配记录 Set null方式 ：在父表上updatedelete记录时，将子表上匹配记录的列设为null 注意子表的外键列不能为not null No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行updatedelete操作 Restrict方式 ：同no action， 都是立即检查外键约束 Set default方式 （在可视化工具SQLyog中可能显示空白）： 父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别。如果没有指定等级，就相当于Restrict方式。 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式 删除 第一步先查看约束名和删除外键约束 SELECT * FROM information_schema.table_constraints WHERE table_name = 表名称;#查看某个表的约束名 ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; 第二步查看索引名和删除索引。（注意，只能手动删除） SHOW INDEX FROM 表名称; #查看某个表的索引名 ALTER TABLE 从表名 DROP INDEX 索引名; 扩展 建外键约束，操作会受到限制，从语法层面受到限制。 例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。 不建外键约束，操作不受限制，要保证数据的引用完整性 ，只能依靠程序员的自觉 。 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。 所以， MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。 所以即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。 6.10 阿里开发规范 [ 强制 ]不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。 外键与级联更新适用于 单机低并发 ，不适合分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。 CHECK 检查约束作用 检查某个字段的值是否符号xx要求，一般指的是值的范围 注意：mysql5.7不支持 MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告 但是MySQL 8.0中可以使用check约束了。 举例说明： create table employee( eid int primary key, ename varchar(5), gender char check (男 or 女) ); insert into employee values(1,张三,妖);mysql select * from employee; +-----+-------+--------+| eid | ename | gender | +-----+-------+--------+| 1 | 张三 | 妖 | +-----+-------+--------+1 row in set (0.00 sec) CREATE TABLE temp( id INT AUTO_INCREMENT, NAME VARCHAR(20), age INT CHECK(age 20), #哇啊哦 PRIMARY KEY(id) ); age tinyint check(age 20) sex char(2) check(sex in(‘男’,’女’)) DEFAULT 默认值约束添加 create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, # Ohhhhhhhh);create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 not null default 默认值,#1 字段名 数据类型 not null default 默认值,#2 primary key(字段名), unique key(字段名) ); 修改 alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 删除了 #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了 alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 删除 alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束 几个面试问题 面试1、为什么建表时，加** not null default ‘’ 或 default 0 ​ 答：不想让表中出现null值。 面试2、为什么不想要** null 的值 答: 不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通 常返回null。 效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0 面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？ 答：在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。 面试4、并不是每个表都可以任意选择存储引擎？ 外键约束（FOREIGN KEY）不能跨引擎使用。 MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来 保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不 能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。"},{"title":"视图","path":"/wiki/mysql/视图.html","content":"对象 描述 表(TABLE) 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 数据字典 就是系统表，存放数据库相关信息的表 系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看 约束 (CONSTRAINT) 执行数据校验的规则，用于保证数据完整性的规则 视图(VIEW) 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据 索引(INDEX） 用于提高查询性能，相当于书的目录 存储过程 (PROCEDURE) 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调 存储函数 (FUNCTION) 用于完成一次特定的计算，具有一个返回值 触发器 (TRIGGER) 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的 视图是一种 虚拟表 ，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。 视图，是向用户提供基表数据的另一种表现形式。小型项目的数据库可以不使用视图，但是在大型项目中，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。 当我们创建好一张视图之后，还可以在它的基础上继续创建视图。 创建视图CREATE [OR REPLACE] [ALGORITHM = UNDEFINED | MERGE | TEMPTABLE] VIEW 视图名称 [(字段列表)] AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION] CREATE VIEW 视图名称 AS 查询语句 查看视图#语法1：查看数据库的表对象、视图对象SHOW TABLES;#语法2：查看视图的结构DESC / DESCRIBE 视图名称;#语法3：查看视图的属性信息SHOW TABLE STATUS LIKE 视图名称\\G#执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。#语法4：查看视图的详细定义信息SHOW CREATE VIEW 视图名称; 更新视图MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。 SELECT ename,tel FROM emp_tel WHERE ename = 孙洪亮; UPDATE emp_tel SET tel = 13789091234 WHERE ename = 孙洪亮;DELETE FROM emp_tel WHERE ename = 孙洪亮 修改方式1：使用CREATE OR REPLACE VIEW 子句修改视图 CREATE OR REPLACE VIEW empvu80 (id_number, name, sal, department_id) ASSELECT employee_id, first_name || || last_name, salary,department_id FROM employees WHERE department_id = 80; 说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。方式2：ALTER VIEW ALTER VIEW 视图名称 AS 查询语句 删除DROP VIEW IF EXISTS 视图名称; 删除视图只是删除视图的定义，并不会删除基表的数据。 基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。 不可更新的视图要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如 下情况时，视图不支持更新操作： 在定义视图的时候指定了“ALGORITHM TEMPTABLE”，视图将不支持INSERT和DELETE操作； 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 ​ UNION 等，视图将不支持INSERT、UPDATE、DELETE； 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE； 视图定义基于一个 不可更新视图 或 常量视图。 虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的 数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。 优缺点： 优点： 操作简单 减少数据冗余 数据安全 适应灵活多变的需求 能够分解复杂的查询逻辑 缺点： 如果实际数据表的结构变更了，我们就需要及时对 相关的视图进行相应的维护。 对于嵌套的视图，维护会变得比较复杂，可读性不好 ，容易变成系统的潜在隐患。 因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。 实际项目中，如果视图过多，会导致数据库维护成本的问题。"},{"title":"权限、用户、角色、配置文件","path":"/wiki/mysql/权限、用户、角色、配置文件.html","content":"用户管理用户信息在哪里默认数据库有四个： information_schema mysql performance_schema sys 其中 “mysql” 数据库有一个表名为user，存储着用户信息。 通常默认有四个用户： root ,mysql.infoschema,mysql.session,mysql.sys 。 ubuntu 或 debian 用户还会有个maint用户。 debian-sys-maint中Debian系统对MySQL维护用的，可以理解为通过系统的某个“非常规”程序对Mysql进行备份恢复等行为时，改程序所使用的用来登录Mysql的账户。 具体作用是重启及运行mysql服务，不过有一个安全问题：该用户的权限和ROOT是一样的，并且密码可以在etc某个文件中找到，这需要对账户进行一些限制。 root 的权限最高，顾名思义为“根”，拥有最高权限，创建其他用户，它不能没有。 user 的联合主键用户信息里两个列很关键：host 和 user。 host : 主机，用来区分用户的连接段。 user : 用户名，区分用户 user 表的主键有两个：host和user，即联合主键。 所以不同连接段允许有重名用户出现，就像不同作用域能够有重名变量一样。 创建、修改、删除创建用户指令： CREATE USER 用户名 [@主机名称] [IDENTIFIED BY 密码] #[]为可选 tips： 该语句可以同时创建多个用户。 用户名参数由用户和主机名构成。 需要有CREATE权限，新账户什么权限都没有。 修改 UPDATE mysql.user set user = wang5 where user = li4 [and host = xxx]flush privileges;# 刷新权限，否则登陆时仍然是原本的用户信息 修改用户就是直接操作 user 表。 修改完需要fs; 删除 两个方法：DROP 和 DELETE (user 表里删)。 DROP DROP USER user,[user].... #user即用户名参数，可包含 hostDROP USER li4; # 默认删除host为%的用户DROP USER li4@localhost; DELETE DELETE FROM mysql.user WHERE Host=hostname AND User = username;#必须有 host ，联合主键的两个字段，才能唯一确定一条记录。FLUSH PRIVILEGES; #立即生效。 DELETE 删除会有系统信息残留。DROP 指令能同时删去 mysql.user 表和 mysql.db 表内容。 设置当前用户密码1. 使用ALTER USER命令来修改当前用户密码 ALTER USER USER() IDENTIFIED BY new_password; 2. 使用SET语句来修改当前用户密码 SET PASSWORD=new_password; 修改其他用户密码1. 使用ALTER语句来修改普通用户的密码 ALTER USER user [IDENTIFIED BY 新密码] [,user[IDENTIFIED BY 新密码]]…; 2. 使用SET命令来修改普通用户的密码 SET PASSWORD FOR username@hostname=new_password; 密码过期关键词 EXPIRE 你可以通过ALTER和CREATE 时 手动设置用户密码过期，这样用户可以登入数据库，但无法查询。除非重新设置密码。 你也可以修改系统全局变量 Default password lifetime 。改变量默认为0，即不过期。设置为N代表密码生存期，N天后密码必须修改，否则将自动过期。 密码重用关键词 INTERVAL 、REUSE 分两类：时间和更改数量 时间（周期）：修改后密码不能用最近N天时间使用过的密码相同。 更改数量 ：修改后密码与最近N个密码不能相同。 系统变量：password_history , password_reuse_interval 权限管理show privileges; #查看权限 CREATE和DROP权限，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 SELECT、INSERT、UPDATE和DELETE权限允许在一个数据库现有的表上实施操作。 SELECT权限只有在它们真正从一个表中检索行时才被用到。 INDEX权限允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。 CREATE ROUTINE权限用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用来执行保存的程序。 GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。 FILE权限使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。 授予权限GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’]; 该权限如果发现没有该用户，则会直接新建一个用户。 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost; 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限 GRANT ALL PRIVILEGES ON *.* TO joe@% IDENTIFIED BY 123; 授予权限的原则 权限控制主要是出于安全因素，因此需要遵循以下几个经验原则： 1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 2、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。 3、为每个用户设置满足密码复杂度的密码。 4、定期清理不需要的用户，回收权限或者删除用户。 查看权限 查看当前用户权限 SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER(); 查看某用户的全局权限 SHOW GRANTS FOR user@主机地址; 收回权限注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。 收回权限命令 REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址; 举例 #收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@%; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost; 注意：须用户重新登录后才能生效 权限表user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。 这些字段可分为四类： 范围列： host : 表示连接类型 % 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 机器名 通过制定网络中的机器名进行的TCP方式的连接 ::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1 localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。 user : 表示用户名，同一用户通过不同方式链接的权限是不一样的。 password ：mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字 段。 权限列：是否拥有一些特定权限 安全列 ：加密，表示用户，验证用户身份。 资源控制列：限制用户使用的资源。共4个字段。 ①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。 查看字段： DESC mysql.user; 查看用户, 以列的方式显示数据： SELECT * FROM mysql.user \\G; 查询特定字段： SELECT host,user,authentication_string,select_priv,insert_priv,drop_priv FROM mysql.user; db表 用户列 db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。 权限列 Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。 结构查看： DESCRIBE mysql.db; tables_priv 和 column_priv 表 tables_priv 表：对表设置操作权限 columns_priv 表 ：对表的某一列设置权限 。 procs_priv 表procs_priv 表可以对存储过程和存储函数设置操作权限 上面几个表都在 database → mysql 里，想看自己 DESC 去。 角色角色的创建、删除和权限操作创建角色 CREATE ROLE role_name[@host_name] [,role_name[@host_name]]... 角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。 给角色赋予权限 GRANT privileges ON table_name TO role_name[@host_name]; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称 SHOW PRIVILEGES\\G 查看角色的权限 SHOW GRANTS FOR role_name; 只要你创建了一个角色，系统就会自动给你一个“USAGE”权限，意思是连接登录数据库的权限。 回收角色的权限 REVOKE privileges ON tablename FROM rolename; 删除角色 DROP ROLE role [,role2]... 注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。 角色和用户给用户赋予角色 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。 GRANT role [,role2,...] TO user [,user2,...]; 查询当前已激活的角色 SELECT CURRENT_ROLE(); 激活角色 方式1：使用set default role 命令激活角色 SET DEFAULT ROLE ALL TO kangshifu@localhost; 方式2：将activate_all_roles_on_login设置为ON SET GLOBAL activate_all_roles_on_login=ON; 这条 SQL 语句的意思是，对所有角色永久激活。 撤销用户的角色 REVOKE role FROM user; 设置强制角色(mandatory role) 方式1：服务启动前设置 [mysqld] mandatory_roles=role1,role2@localhost,r3@%.atguigu.com 方式2：运行时设置 SET PERSIST mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后仍然有效SET GLOBAL mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后失效 配置文件**文件里会定义许多组(用 [ ] 括起来)，组下边可以定义启动选项。**通常称组为标签。 [server]#具体启动选项option1 #不需要选项值：True / False 类型option2 = value2 #需要选项值 ： 键值对 类型[mysqld]...[mysqld_safe]...[client]... 配置文件中不同选项组是给不同的启动命令使用的。 有两个选项组比较特别： [server]组的启动选项作用于所有服务器程序 [client]组的启动选项作用于所有客户端程序。 像mysql这个启动命令，就会调用 [mysql] 和 [client] 两个组 tips： [mysql-‘版本号’]：只适用于特定版本的专用选项组 两个组里出现重复配置项，以最后一个为准。 一个选项既出现在命令行，又出现在配置文件里，以命令行为准。 如 defaults-extra-file 和 defaults-file 本身就是为了指定配置文件路径的。"},{"title":"TCPIP1","path":"/wiki/network/TCPIP1.html","content":"1"},{"title":"湖科大(4)网络层","path":"/wiki/network/湖科大(4)网络层.html","content":"网络层 由于TCPIP体系结构的因特网的网际层提供的是简单灵活、无连接的、尽最大努力交付的数据报服务，因此本章主要围绕网际层如何传送IP数据报这个主题进行讨论。 网络层提供的两种服务 面向连接的虚电路服务 可靠的通信由网络来保证 必须建立网络层的连接—-虚电路VC(Virtual Circuit) 注意：虚电路表示这是一条逻辑上的连接，数据分组都沿着这条逻辑链接按照存储转发方式传送。所以这不是真正建立一条物理连接。 采用电路交换的电话通信，则是先建立一条真正的连接。 因此分组交换的虚连接与电路交换的连接只是类似，但并不完全一样。 通信双方沿着已建立的虚电路发送分组 目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号(构成虚电路的每一段链路都有一个虚电路编号)。 这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方(无差错按序到达、不丢失、不重复)。 通信结束后，需要释放之前所建立的虚电路 很多广域分组交换网都使用面向连接的虚电路服务，例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。 无连接的数据报服务 可靠通信应当由用户主机来保证 不需要建立网络层连接 每个分组可走不同路径 每个分组的首部必须携带目的主机的完整地址 这种通信方式所传送的分组可能误码、丢失、重复和失序 由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉 因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘(用户主机和其内部的运输层)，而将相对简单的尽最大努力的分组交付功能置于因特网核心。665 IPv4定义： IPv4地址就是给因特网(Internet)上的 每一台主机(或路由器)的每一个接口 ** 分配一个 在全世界范围内是唯一的32比特的标识符**。 IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。 我国用户可向亚太网络信息中心APNIC(Asia Pacifc Network Information Center)申请IP地址，需要缴费。 2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPv4地址已经分配完毕 我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6. 表示方法： 每八个比特一组，采用点分十进制表示方法。 IPv4的地址编制方法经历三个历史阶段： 分类编址 区分： 注意 A、B、C类地址的二进制前缀，以及对应的网络号和主机号位数。 A类地址网络号第1位固定为0，网络号后面部分不能全0，也不能全1，所以网络号范围是1~126 可指派网络数量：2^(8-1)^-2 126 (减 2：除去最小网络号0和最大网络号127) 每个网络中可分配IP地址数量：2^24^-2（(减2：除去主机号为全0的网络地址和全1的广播地址) B类地址网络号前2位固定为10，网络号后面部分可以全取0或1，所以网络号范围是128.0~191.255 可指派网络数量：2^(16-2)^ 126 (幂减 2：除去前缀的前两位） 每个网络中可分配IP地址数量：2^16^-2 65534（减2：除去主机号为全0的网络地址和全1的广播地址) （根据2002年9月发表的RFC3330文档，B类地址不需要保留网络号，也就是 128.0 已经可以分配了。） C类地址网络号前3位固定为110，网络后后面部分可以全取0或1，所以网络号范围是192.0.0~223.255.255 1指派网络数量：2^(24-3)^ 126 (幂减 2：除去前缀的前两位） 每个网络中可分配IP地址数量：2^8^-2 65534（减2：除去主机号为全0的网络地址和全1的广播地址) （根据2002年9月发表的RFC3330文档，B类地址不需要保留网络号，也就是 192.0 已经可以分配了。） D类地址为多播地址，IP地址为224.0.0.0~239.255.255.255 注意： [每类地址]都有一个最小网络号 0，即网络位全为 0 的地址保留不指派。都有一个最大网络号 255，作为广播地址不指派。 第一个可指派网络号为1，最后一个网络号为254。 [A 类地址]的最大网络号127 保留，作为本地环回测试地址，不指派。 最小的本地环回测试地址为 127.0.0.1 最大的本地环回测试地址为 127.255.255.254 划分子网应用场景： 比如一个单位有300台主机，此时需要申请一个B类网络地址，也就是有65534个IP地址。很容易得知，分配出去300个IP地址后，申请得到的B类网络还剩下很多IP地址。这些剩余IP地址只能由该单位的同一个网络使用。 当单位扩大规模，需要再添加两个子网的时，又要为这两个子网分别申请B类地址，这会花费一些不必要的支出，实际上子网1申请到的B类地址还有很多没用到，我们希望能够将这些剩余地址应用到其他子网中(节约地址)。 为新增网络申请新的网络号会带来以下弊端: 需要等待时间和花费更多的费用 会增加其他路由器中路由表记录的数量 浪费原有网络中剩余的大量IP地址 划分子网： 灵魂是子网掩码。 通过一个32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号 子网掩码使用连续的**比特1对应网络号+子网号(**子网号来自原先的一部分主机号) 子网掩码使用连续的比特0对应主机号 将划分子网的IPv4地址与其相应的子网掩码进行**(逻辑与运算)【即掩码是1的部分】**就可得到IPv4地址所在子网的网络地址 无分类编址应用场景： 划分子网在一定程度上缓解了因特网发展中遇到的困难，但是数量巨大的C类网因为其地址空间太小并没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。 1993年，IETF发布了无分类域间路由选择CIDR CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念 CIDR可以更加有效地分配IPv4地址空间 CIDR使用**“斜线记法”**，或称CIDR记法。即在IPv4地址后面加上斜线”“，在斜线后面写上网络前缀所占比特数量 CIDR实际上是将网络前缀都相同的连续IP地址组成一个”CIDR地址块” 我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节: 地址块的最小地址 地址块的最大地址 地址块中的地址数量 地址块聚合某类网络(A类、B类或C类)的数量 地址掩码(也可继续称为子网掩码) IPv4划分地址块的不同应用 给定一个IPv4地址块，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中的不同网络，进而可以给个网络中的主机和路由器接口分配IPv4地址。 如何划分，有两种方法： 定长的子网掩码FLSM（Fixed Length Subnet Mask） 使用同一个子网掩码来划分子网，每个子网所分配的IP地址数量相同，造成IP地址的浪费。 变长的子网掩码VLSM（Variable Length Subnet Mask） 使用不同的子网掩码来划分子网，每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费。 下面举例说明： 定长思路 变长思路 ”假设申请到的地址块为218.75.230.024，请使用变长的子网掩码给下图所示的小型互联网中的各设备分配IP地址“ 分析主机号位数和网络前缀位数。 分析后可知，划分需求是：从地址块218.75.230.024中取出5个地址块： (1个“27”地址块，3个“28”地址块，1个“30”地址块)，按需分配给下图所示的5个网络。 按照先给大子块分配（网络地址块少，主机地址数量多，）的原则，先给网络N2划分。 所以以网络N2为例： 218.75.230.0 是网络N2的网络地址，218.75.230.31是网络N2的广播地址。 中间即是网络N2的可分配地址。 以此类推……. IP数据报发送转发过程同一个网络之间的主机可以直接通信，不同网络之间的主机通信需要路由器中转。 直接交付与间接交付 同一网络中的主机之间可以直接通信，属于直接交付。 不同网络之间的主机通信，需要路由器中转，属于间接交付。 源主机如何判断目的主机是否和自己在同一个网络中？ 将自身IP地址与子网掩码相与得到自身的网络号1，再将目的IP地址与自身子网掩码相与得到网络号2。若两个网络号相等，则说明处在同一个网络，不能则不再同一网络，属于间接交付。 主机如何知道应该把IP数据报交给哪个路由器进行转发呢？ 用户为了能让本网络主机与其他网络主机进行通信，就必须给其指定本网络中的一个路由器，由该路由器进行帮忙转发。 所指定的路由器，称为默认网关。 所谓默认网关，即当路由表中查不到数据时会将数据发往的路由器端口IP地址。 路由器收到IP数据包后如何转发？ 路由器首先会检查IP数据报的首部是否出错: 若出错，丢弃该IP数据包并通告源主机； 未出错，则进行转发。 根据IP数据包的目的地址，在路由表中查找匹配的条目： 若找到匹配条目，则转发给条目中指示的吓一跳； 若找不到，则丢弃该IP数据包并通告源主机。 冲突域和广播域 中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域。 集线器、网桥和交换机(多端口网桥)工作在数据链路层，可以隔离冲突域，不能隔离广播域。 路由器工作在网络层，既隔离冲突域，也隔离广播域。 路由器隔离广播域。否则会有广播风暴。 路由聚合如路由器A上连接同一网络的多台主机，路由器B与A相连。若A将所有主机的具体IP地址都报给B，则路由器B中会增加多项路由条目。 可实际上B向A中任意一个主机转发数据的时都是走同一个端口，因此我们可以将这些网络的共同前缀提取出来成为新的网络号，同时将剩余主机号置0放入路由器B中 如：A连接了172.1.4.0/25和172.1.7.0/24，则提取公共前缀聚合后变为172.1.4.0/22 IPv4数据报首部格式 版本 占4比特，表示IP协议版本。通信双方使用的IP协议版本必须一致。目前广泛使用的IP协议版本为号为4(IPv4) 首部长度 占4比特，表示IP数据报首部长度。该字段取值以4字节为单位 最小十进制取值为5，表示IP数据报首部只有20字节【4字节单位，所以取值5对应20字节】固定部分 最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分 可选字段 长度从1到40个字节不等。用来支持排错、测量及安全等措施 可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用 填充字段 确保首部长度为4字节长度的整数倍，使用全0进行填充 区分服务 占8比特，利用该字段的不同数值可提供不同等级的服务质量，只有在使用区分服务时，该字段才起作用。一般情况下不使用该字段 总长度 占16比特，表示IP数据报的总长度【首部+数据载荷】，最大取值为十进制65535，以字节为单位 标识 占16比特，属于同一个数据报的各分片数据报应该具有相同的标识【可理解为ID】 IP软件维持一个计数器，每产生一个数据报，计数器值+1，并将此值赋给标识字段 标志 占3比特，各比特含义如下 DF位：1表示不允许分片，0表示允许 MF位：1表示”后面还有分片”，0表示”这是最后一个分片” 保留位：必须为0 片偏移(必须是整数) 占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少单位 片偏移以8个字节为单位 举例子： 生存时间 占8比特，最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段值减去IP数据报在本路由器上耗费的时间，若不为0【说明路由器消耗时间后还活着】就转发，否则丢弃 现在以”跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段值减1，若不为0就转发，否则丢弃【防止兜圈】 协议 占8比特，指明IPv4数据报的数据部分是何种协议数据单元 首部检验和 占16比特，用来检测首部在传输过程中是否出现差错，比CRC检验码简单，称为因特网检验和 IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段【生存时间、标志、片偏移等】的取值可能发生变化 由于IP层本身不提供可靠传输服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报 源IP地址和目的IP地址 各占32比特，用来填写发送该IP数据报的源主机IP地址和接收该IP数据报的目的主机 路由选择协议概述路由选择分为静态路由选择与动态路由选择。 静态路由选择： 1.由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由。2.这种人工配置方式简单、开销小。但不能及时适应网络状态(流量、拓扑等)的变化。3.一般只在小规模网络中采用。 动态路由选择： 1.路由器通过路由选择协议自动获取路由信息。2.比较复杂、开销比较大。能较好地适应网络状态的变化。3.适用于大规模网络。 静态路由配置 **概念：**是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表 可能由于：①配置错误 ②聚合了不存在的网络 ③网络故障 而出现路由环路错误 默认路由为：0.0.0.00。 作用是当路由表不知道往哪里转发时，就会往默认路由指定的下一跳位置转发。 根据网络号最长匹配原理，默认路由网络号长度为0，因此一定是最后一个被匹配的条目。 特定主机路由：具体主机IP32。网络号前缀长度32保证了这是第一个被匹配的静态条目。 如何防止错误路由导致IP数据报永久兜圈？ 在IP数据报首部设置生存时间TTL字段IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃对于聚合后或由于网络故障而不存在的路由条目设置黑洞路由所谓黑洞路由，即路由器应该丢弃的路由。 路由器基本结构 路由选择部分的核心部件：路由选择处理机 任务：根据所使用的路由选择协议周期性地与其他路由器进行路由信息交互，来更新路由表。 分组转发部分： 分三部分 1.交换结构 2.一组输入端口 2.一组输出端口。 一些属性： 路由器处理不同信息时： 当信号从某个端口进入路由器时，路由器会将信号从输入端口查表转发到对应输出端口。 而如果是路由器之间交换路由信息的路由报文，则将这类分组送交路由选择处理机。 路由选择处理机根据分组的内容来更新自己的路由表。 路由表一般仅包含从目的网络到下一跳的映射 路由表需要对网络拓扑变化的计算最优化 转发表是从路由表得出的 转发表的结构应当使查找过程最优化 本课不严格区分路由表与转发表。 路由选择处理机除了处理收到的路由报文外，还会周期性给其他路由器发送自己所知道的路由信息。 路由器各端口还应具有输入缓冲区和输出缓冲区。 输入缓冲区用来暂存新进入路由器但还来不及处理的分组。 输出缓冲区用来暂存已经处理完毕但还来不及发送的分组。 路由器的端口一般都具有输入和输出的功能。 路由选择协议因特网所采用的的路由选择协议主要特点 自适应：动态路由选择，能较好地适应网络状态的变化 分布式：路由器之间交换路由信息，共同完成路由信息获取和更新。 分层次：将整个因特网划分为许多较小的网络群自治系统AS 域间路由选择使用外部网关协议 EGP 早期用网关代替路由器，现在可以用ERP代替EGP。 域内路由选择使用内部网关协议 IGP 现在可以用IRP代替EGP。 EGP 和 IGP 只是路由选择协议的分类名称，不是具体协议。 IGP 使用的协议具有独立性，和其他 IGP不相关。 路由信息协议RIP特点： 路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC 1058。 RIP 要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V(Distance-Vector)” RIP使用跳数作为度量来衡量到达目的网络的距离 路由器到直连网络的距离定义为1 路由器到非直连网络的距离定义为所经过的路由器数+1 允许一条路径最多只能包含15个路由器。“距离”等于16时相当于不可达。因此，RIP只适用于小型互联网 RIP认为好的路由就是”距离短”的路由，也就是所通过路由器数量最少的路由。 当到达同一目的网络有多条”距离相等”的路由时，可以进行等价负载均衡。 RIP包含以下三个要点 和谁交换信息 仅和相邻路由器交换信息 交换什么信息 交换的是自己路由表的信息 何时交换信息 周期性交换信息（例如每30秒） RIP存在的问题 存在”坏消息传播很慢”的问题，又称为路由环路(两个路由器相互学习错误路由，造成循环)或距离无穷计数问题。 这是距离向量算法的一个固有问题，可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。 减少问题的措施： 限制最大路径距离为15(16表示不可达)。 当路由表发生变化时就立即发送更新报文(即”触发更新”)，而不是周期性发送。 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口反方向传送(即**“水平分割”“毒性反转”**)。 开放最短路径优先OSPF属性 开放最短路径优先OSPF(0pen Shortest Path First)，是为克服RIP的缺点在1989年开发出来的。 “开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。“**最短路径优先”**是因为使用了Dijkstra提出的最短路径算法SPF。 简单来说就是得到一个带权有向图，以当前路由器为起点，通过迪杰斯特拉算法得到到达某个点的最短路径 OSPF基于链路状态，而不像RIP那样是基于距离向量。 采用SPF算法计算路由，从算法上保证了不会产生路由环路。 OSPF不限制网络规模，更新效率高，收敛速度快 链路状态是指本路由器都和哪些路由器相邻，以及相应链路的”代价” “代价”的意思是费用、距离、时延、带宽等，这些由网络管理人员确定。 OSPF五种分组 问候(Hello)分组 用来发现和维护邻居路由器的可达性 数据库描述(Database Description)分组 向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息 链路状态请求信息(Link State Request)分组 向邻居路由器请求发送特定链路状态项目的详细信息 链路状态更新LSU(Link State Update)分组 路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态 链路状态确认(Link State Acknowledgement)分组 这是对链路状态更新分组的确认分组 基本工作原理 OSPF相邻路由器之间通过交互问候(Hello)分组，建立和维护邻居关系。 Hello分组封装在IP数据报中，发往组播地址224.0.0.5； 发送周期为10秒； 40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达 使用OSPF的每个路由器都会产生链路状态通告LSA(link state advertisement)，包含以下内容 直连网络的链路状态信息 邻居路由器的链路状态信息 LSA被封装在链路状态更新分组LSU（update group）中，采用洪泛法发送 洪泛法意味着其他路由器收到该 LSU ，也会从自己其他所有接口转发该分组。 使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA 通过各路由器洪泛法发送封装有自己LSA的LSU分组，各路由器的LSDB最终达到一致 使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各种到达其他各路由器的最短路径，即构建各自的路由表 OSPF基本工作过程 相邻路由器之间周期性交互发送问候分组(Hello)，以便建立和维护邻居关系。 建立邻居关系后，给邻居路由器发送数据库描述分组(DD)，也就是将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器。 R1 收到 R2 的数据库描述分组后，若发现自己缺少其中某些链路状态项目，R1 则会发送链路状态请求分组(LSR)。 R2 收到链路状态请求分组后，则会将其所缺少的链路状态项目的详细信息封装在**链路状态更新分组(LSU)**中发送给 R1 回去。 R1 收到链路状态更新分组后，将这些信息添加到自己的链路状态数据库中。 R1 给 R2 发送链路状态确认分组。 R2也可以给 R1 请求自己所缺少的链路状态项目的相信信息。 最终，R1 和 R2 的链路状态数据库将达到一致（同步）。 每30分钟或链路状态发生变化时，路由器都会发送链路状态更新分组，收到该分组的其他路由器也会洪泛转发并返回LS确认分组。 这又称为新情况下的链路状态数据库同步。 邻居关系的建立 一条总线上有多台主机，则它们互为邻居，因此每个路由器都要向其他路由器发送问候分组和链路状态更新分组。为了减少所发送分组的数量，则需要用相应方法对邻居关系进行删减。 OSPF采用选举指定路由器DR(Designated Router)和**备用的指定路由器BDR(**Backup Designated Router)的方法减少邻居数目 所有的非DRBDR只与DRBDR建立邻居关系 非DRBDR之间通过DRBDR交换信息 当DR失效时由BDR顶上 这与交换机生成树协议选举根交换机类似。 区域 为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域(Area)。 格式： 每个区域都有一个32比特的区域标识符 主干区域用于连通其他区域。其他区域的标识符不能为0且互不相同 每个区域的规模不能太大，一般所包含的路由器不能超过200个。 好处：把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统。这样减少了整个网络上的通信量。 命名： 如果路由器的所有接口都在同一个区域内,则该路由器称为区域内路由器IR(internal router)。 为了本区域可以和自治系统内的其他区域连通，每个区域都会有一个区域边界路由器ABR(area border router)。 区域边界路由器的一个接口连接自身所在区域，另一个接口连接主干区域。 **主干区域内路由器称为主干路由器。**区域边界路由器一定是主干路由器。 主干区域内还要有一个路由器专门和本自治区外的其他自治系统交换路由信息。这个路由器称为自治系统边界路由器ASBR(AS border router)。 工作过程： 边界区域向主干区域发送自己所在区域的链路状态通告，向自己所在区域发送区域0，1，2的链路状态通告。 分层次划分区域，增加了交换信息种类，让OSPF协议更复杂了。但这也使每个区域内部交换路由信息的通信量大大减小。因此OSPF能够使用在规模很大的自治系统中。 边界网关协议BGP应用场景: 1.内部网关协议IGP(如路由信息协议RIP或最短路径优先OSPF): 设法使分组在一个自治系统内尽可能有效地从源网络传输到目的网络 无需考虑自治系统外部其他方面的策略 2.外部网关协议EGP(如边界网关协议BGP): 在不同自治系统内，度量路由的”代价”(距离，宽带，费用等)可能不同。因此，对于自治系统之间的路由选择，使用”代价”作为度量来寻找最佳路由是不行的 比如A系统路由选择度量是距离，B系统是带宽……那么A到系统E的路由怎样走最好呢？由于没有统一度量，所以不能直接得到最佳路由 自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等) 如中国的数据报尽量要绕开美国的自治系统 BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)而并非要寻找一条最佳路由 基本工作原理 在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人 不同自治系统的BGP发言人要交换路由信息： 首先必须建立TCP连接，端口号为179 在此TCP连接上交换BGP报文以建立BGP会话 利用BGP会话交换路由信息(例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等) 使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站(neighbor)或对等站(peer) BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP BGP发言人交换网络可达性的信息(要到达某个网络所要经过的一系列自治系统) 当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。也就是构造出树形结构(防环路)的自治系统连通图 BGP-4中的报文 OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化 UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由 KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性 NOTIFICATION(通知)报文：用来发送检测到的差错 BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表，以后只在发生变化时更新变化部分。 网际控制报文ICMP 为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP（Internet Control Message Protocol） 主机或路由器使用ICMP来发送差错报告报文和询问报文 ICMP报文被封装在IP数据报中发送 回答报文类型 终点不可达 当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络位置、目的主机未知等13种错误 源点抑制 当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报发送速率放慢 时间超过 当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文 参数问题 当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文 改变路由(重定向) 路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由) 如主机1的默认路由是R1，信息经过R1时，R1发现最佳路由不是自己，而是R2，所以通过ICMP告知主机1 不发送ICMP的情况 对ICMP差错报告报文不再发送ICMP差错报告报文 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文 对具有多播地址的数据报都不发送ICMP差错报告报文 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文 询问报文类型 回送请求和回答 ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问 收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文 这种询问报文用来测试目的站是否可达及了解其有关状态 时间戳请求和回答 ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间 在ICMP时间戳回答报文中有一个32比特的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒 这种询问报文用来进行时钟同步和测量时间 ICMP应用举例 分组网间探测PING 用来测试主机或路由器间的连通性【eNSP的ping命令】 应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP) 使用ICMP回送请求和回答报文 跟踪路由tracerouce 用来测试IP数据报从源主机到达目的主机要经过哪些路由器 Windows版本 tracert命令 应用层直接使用网际层ICMP 使用了ICMP回送请求和回答报文以及差错报告报文 Unix版本 traceroute 命令 在运输层使用UDP协议 仅使用 ICMP差错报告报文 实现方法 由主机发送出去的数据包中的生存时间字段TTL由1开始逐渐增加，每个路由器都会返回一个时间超过报文，由此达到跟踪路由器的目的 虚拟专用网VPN和网络地址转换NAT虚拟专用网VPN利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。 由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。 因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。 专用(私有)地址: 10.0.0.0~10.255.255.255(108地址块) 172.16.0.0~172.31.255.255(172.1612地址块) 192.168.0.0~192.168.255.255(192.16816地址块) 注意：私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。 即私有地址只能用作本地地址而不能用作全球地址。 所以所有路由器对目的地址是私有地址的IP数据报一律不进行转发。 所有每个机构至少需要一个路由器具有合法的全球IP地址。这样各自的专用网才能利用公用的因特网进行通信。 两个专用网内的主机间发送的数据报，是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样。 数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。 如下图所示，同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。 有时一个机构的VPN需要有某些外部机构(通常就是合作伙伴)参加进来。这样的VPN就称为外联网VPN。 在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。 网络地址转换NAT应用场景： 虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。1994年提出了一种网络地址转换NAT的方法再次缓解了IPv4地址空间即将耗尽的问题。 NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源【为了节省IPv4地址】 问题：该转换方法存在一个问题:如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。 解决：由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。 这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT 杂项路由器隔离广播域 路由器属于网络层设备，默认情况下不对广播数据包进行转发，因此自然达到隔离的效果。 路由器是连接不同网络的，广播只是在一个网络里面，所以路由器隔离开了不同网络之间的广播信号。 广播是数据链路层的广播，网络层只有点对点。 整理 SMTP邮件发送是TGP，视频通话是UDP 服务访问点：邻层实体之间的逻辑接口。 各层服务访问点 SAP 应用层 ：用户界面 运输层：端口号 网络层：IP地址 数据链路层：Mac地址 物理层：网卡 各层协议数据单元 应用层：报文(message) 传输层：报文段(segment)：（TCP报文段，UDP数据报） 网络层：分组packet（如果无连接方式：数据报 datagram） 数据链路层：帧(frame) 数据链路层又可分为两层 Mac层和llc层LLC层是主要向上层提供服务的,Mac地址是网卡地址。 物理层：位(bit)"},{"title":"湖科大(3)数据链路层","path":"/wiki/network/湖科大(3)数据链路层.html","content":"数据链路层概述链路(link)：从一个结点到相邻节点的一段物理线路，而中间没有任何其他的交换结点。 数据链路(Data Link) ：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层以帧为单位传输和处理数据 意义：在物理层提供服务的基础上向网络层提供服务。 **数据链路层的功能：**加强物理层传输原始比特流的功能，将可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 数据链路层的三个信道： 1.点对点信道（我们在介绍时一般使用） 2.交换式局域网 3.共享式局域网（使用广播信道的数据链路层） 交换式局域网在有线领域已经完全取代了共享式。 由于无线信道的广播天性，无线局域网使用的仍然是共享信道技术。 使用点对点信道的数据链路层 三个重要问题： 封装成帧：在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。一个作用是帧定界。 差错检测：判断传输过程中是否出现误码（1变0，0变1） 可靠传输：实现发送方发送什么，接收方就能收到什么 使用点对点信道的数据链路层 两个重要问题： 共享式以太网的媒体接入控制协议CSMACD 802.11局域网的媒体接入控制协议CSMACA 数据链路层的互连设备 网桥和交换机的工作原理 集线器(物理层互连设备) 与交换机的区别 封装成帧封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。 帧头和帧尾中含有重要的控制信息 帧头帧尾的作用之一就是帧定界 (变成比特传输后据此区分每个帧的起始和结束) 为了提高帧的传输效率，应当使帧的数据部分长度尽可能大 考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU（Maximum Transfer Unit） 前导码 但比不是每一种数据链路层协议的帧都包含有帧定界标志，也可以使用前导码: 前导码 前同步码：作用是使接收方的时钟同步 帧开始定界符：表明其后面紧跟着的就是MAC帧 另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符 透明传输 透明：指某一个实际存在的事物看起来却好像不存在一样。 透明传输是指数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样。 帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收。 所以必须要确保帧的唯一性。 解决方法： 面向字节的物理链路使用字节填充 (byte stuffing) （又称字符填充 character stuffing）。 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 面向比特的物理链路使用比特填充的方法实现透明传输。 例如，假设帧是0111110 ，发送前对数据单元进行扫描，每5个连续的1后面提前插入一个0。接收方在接受时，将那个增补的0剔除即可。 差错检测 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能变成0，0可能变成1。这叫比特差错 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Big Error Rate) 错误比特总比特 的比率即误码率 使用差错检测码(如Mac帧尾的FCS)来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一、 奇偶校验码在待发送的数据后面添加1位奇偶校验位，使整个数据(包括所添加的校验位在内)中”1”的个数为奇数(奇校验)或为偶数(偶校验) 比如发送数据001 若是奇校验，则在数据后添加0，使其成为0001,1的个数为奇数。 如果传输过程中发生了1位误码，则1的个数会变成偶数，据此判断是否发生误码；但是若发生了2个误码，1的个数依然为奇数，因此检查不出来 若为偶校验，则在数据后添加1，使其成为1001,1的个数为偶数，其他情况与奇校验类似 但不管是奇校验还是偶校验，如果有奇数个位发生误码，则可以检查出误码，因为奇偶性发生变化；如果有偶数个位发生误码，则不能检查出误码(漏检),因为奇偶性不发生变化。 循环冗余码CRC 收发双方约定好一个生成多项式G(x) 发送方基于待发送的数据和生成多项式计算出差错检测码**(冗余码)**，将其添加到待传输数据的后面一起传输 接收方通过生成多项式来计算收到的数据是否产生了误码 CRC有很好的检错能力(漏检率非常低)，虽然计算比较复杂，但易于用硬件实现，因此被广泛应用于数据链路层 检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。 在计算机网络中通常采用检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务 可靠传输不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做可靠传输：想办法实现发送端发送什么，接收端就收到什么 一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。 无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务 比特差错只是传输差错中的一种，从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。 可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输 可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求 停止等待协议SW（stop-wait）发送方发送数据DATA，接收方接收时进行差错检测①如果没有出现误码，则接收信息并返回ACK确认分组给发送方，发送方收到ACK后，一次通信结束②如果出现误码，则丢弃信息并返回NAK拒绝分组给发送方，发送方收到NAK后，重传DATA，直至出现步骤①的情况 发送方没有收到ACK确认分组，就不会进行下一次通信。故名“停止等待“。 机制补充： 如果DATA传送过程中丢失了，即接收端一直等DATA，发送端一直等ACK，造成死锁，如何解决呢？ 可以引入超时重传机制。可以在发送端设置一计时器(大约发送接收的平均时间)，当发送端在这个时间内没有收到ACK或NAK时，就会判断DATA丢失，从而再次发送DATA，打破死锁 如果ACK发送中丢失了，即接收方收不到ACK就将数据重新发送，而数据实际上接收方已经有了，因此重复接收，并返回ACK，造成错误，怎么办？ 可以对每次发的DATA都加上序号，这样接收端就可以判断当前的数据是否有接收过，从而决定其去留 如果发送端发送DATA 0，如果ACK由于某些原因使其到达接收端的时间变长了，那么根据超时重传，DATA 0会再次发送，而此时ACK到达，则发送方会认为这是后一次DATA 0的确认分组，于是马上发送DATA 1。而第二次发送的DATA 0此时返回ACK，发送方误以为是DATA 1的ACK，因此又会发送DATA2，而实际上DATA 1的是否误码等情况还不知道，因此出现了错误，这种情况怎么办？ 可以为ACK加上编号。则每个ACK的相互作用就不会互串了。【对于数据链路层点对点信道，往返时间比较固定，不会出现确认迟到的情况，因此可以不给确认分组编号】 回退N帧协议GBN(Go-Back-N)背景 停止-等待协议的信道利用率太低了，如果加上超时重传，利用率更低了！ 之所以低还是因为”停止等待“。 所以GBN采用流水线传输，一次分组传输多个信息。 回退N帧：成批发送数据分组。但当一批数据分组到达接收方后，其中一个分组出现误码，其他的正确分组也会受到牵连。 所以通信线路质量不好时，GBN的信道利用率不比SW好多少 三个关键信息 比特数目：比特数目决定允许一次发送的序号数量。 如，3个比特可以表示序号 0~7 。 发送窗口尺寸WT取值：lW= （2^n）-1 n 即比特数 接收窗口尺寸WR取值：Wr = 1 如果是2及以上，就变成选择重传了。 注意：Wt、Wr 是独立于发送序号的，且受发送需要的限制（必须小于序号个数-1）. 累计确认 接收方对收到的数据分组不一定要逐个发送确认，而是可以在收到几个数据分组后 (由具体实现决定)对按序到达的最后一个数据分组发送确认。 即：ACKn表示序号为n及以前的所有数据分组都已正确接收。 优点： 节省资源 即使确认分组丢失，发送方也可能不必重传。 注意是确认分组，不是数据。不要混淆。 缺点：不能向发送方及时反映出接收方已经接受的正确分组信息。 机制补充： 发送的数据出现问题？ 接收方通过检错码，发现有数据出错，则丢弃该数据分组。继而向发送方发送之前接受的正确分组序号x 。 错误分组之后的数据，有多少个，就向发送方发送多少个确认 x 的ACK。 于是发送方收到重复确认就知道出现了差错，即可越过超时计时器，立即重传。 （收到几个重复确认就立即重传由具体实现决定） 若Wt超过取值范围，例如Wr8，会出现什么情况? 接收方无法分辨新旧数据分组！ 假设第一次发送数据，接收方成功接收。但接受确认ARK丢失了。这时发送方超时重传，接收方接受到数据分组后，因为Wr超过范围，使窗口内数据序号前后重合了，则接收方难以判断本次数据是第一次发送的还是第二次发送的。 选择重传协议SR（Selective Repeat）背景： 回退N帧协议的接收窗口尺寸Wr只能等于1，因此接收方只能按序接收正确到达的数据分组。 一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃 (尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，这是对通信资源的极大浪费。 选择重传协议： 为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸WR不应再等于1 (而应大于1)，以便接收方先收下失序到达但无误码并且席号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。 这就是选择重传协议。 注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不再采用累积确认，而需对正确接收到的数掘分组进行逐一确认。 三个关键信息 比特数目：比特数目决定允许一次发送的序号数量。 如，3个比特可以表示序号 0~7 。 发送窗口尺寸WT取值：lW= 2^（n-1） 若 Wt 1 ：与停止等待协议相同 若 Wt 2^(n-1) ：造成接收方无法分辨新、旧数据分组的问题 接收窗口尺寸WR取值：Wr = Wt 一般情况与发送窗口尺寸相同。 若 Wr 1 ：与回退N帧协议相同 若 Wr 2^(n-1) ：没意义，没用处。和不超出一样。 发送方收到一个确认分组就往后滑动一位。除非该滑动分组前有未确认分组。 如果收到确认分组却未滑动，则标记该分组为已成功发送，等待发送该分组前未确认发送的分组。 接收方收到一个正确分组就往后滑动一位。除非该滑动分组前有错误(未接收)分组。 如果收到正确分组却未滑动，则标记该分组为已成功接收，等待发送该分组前未成功接收的分组。 机制补充： 为什么Wt的最大值是2^(n-1) 而不是和GBN中的 (2^n)-1 一样? 因为无论是GBN还是SR，都要求接收方接受数据分组时能分辨新旧数据分组。 而GBN中的接收窗口固定为1，SR中的接收窗口不定。 这里的2^(n-1) 可以拆分成 发送窗口+接受窗口 2^n 默认发送窗口和接收窗口大小一样的情况下，Wt Wr 2^(n-1) 此时 Wt + Wr 2^(n-1) + 2^(n-1) 2^n。 即使不一样的情况下，也要求Wt + Wr 2^n。 那为什么满足这个条件就能保证新旧数组的区分呢？ 分辨新旧数据分组的关键在于，新分组和旧分组的序号不一致（不相同）。 接收方对旧分组的接受确认ARK丢失，再次接受发送方超时重传的数据时，只有发现序号不一致，才能发现ARK丢失，从而重新发回接受确认ARK，方便下一步传输。 而 Wt + Wr 2^n 的情况下，由于窗口内序号个数 总的序号表示个数，势必会发生序号相同的情况，也就难以分辨了。 PPP协议 （Point to Point Protocol本身是一种数据链路层协议，用于规定帧格式。 应用场景： 一般用户接入因特网，需要通过连接某个因特网服务提供者 ISP(Internet Service Provider)来进入因特网。 中国 ISP （运营商）: 中国联通，中国电信，中国移动。 因为这些 ISP 已经从因特网管理机构申请到了一批 IP 地址。用户的计算机只有获取到 ISP 所分配的合法 IP 地址后，才能成为 internet 上的主机。 用户计算机与 ISP 进行通信时，所使用的数据链路层协议就是 PPP 协议。 1999年公布的再以太网上运行的PPP协议，即 PPP over Ethernet ，简称 PPPoE 。它使得 ISP 可以通过 DSL、电路调制解调器、以太网等宽带接入技术，以以太网接口的形式为用户提供接入服务。 点对点服务PPP 也广泛应用于广域网路由器之间的专用线路。 PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成: 封装成帧：对各种协议数据报的封装方法。 链路控制协议LCP：用于建立、配置以及测试数据链路的连接。 一套网络控制协议NCPs ： 其中的每一个协议支持不同的网络层协议。 支持不同类型网络层协议：TCPIP 中的IP、Novell NetWare 网络OS中的 IPX、苹果公司的Apple Talk。 支持在多种类型的点对点链路（物理层）上运行：面向字节的异步链路、面向比特的同步链路。 帧格式： 透明传输 字节填充法 面向字节的异步链路采用插入转义字符的字节填充法。 如PPP帧的标志字段取值为7E(16进制)，如果数据中出现7E则需要在数据前插入转义字符7D(16进制)，并将原来的7E减20(16进制)，所以7E在数据中最终会变成7D5E。 如果数据中有转义字符7D怎么办呢？可以在转义字符7D前再加一个转义字符7D，并将数据的7D减20(16进制)，于是转义字符7D在数据中最终会变成7D5D。 数据中出现的每一个ASCII码控制字符【数值小于20(16进制)的字符】，则在该字符前插入一个7D，同时将该字符的编码加上20(16进制)。 接收方只需要反变换即可恢复出原来的帧的数据部分。 比特填充法 面向比特的同步链路采用插入比特0的比特填充法 发送方：对帧的数据部分进行扫描(一般由硬件实现)。只要发现5个连续的比特1，则立即填充1个比特0。 接收方：对帧的数据部分进行扫描(一般由硬件实现)。只要发现5个连续的比特1，就把其后的1个比特0删除。 差错检测 接收方每收到一个PPP帧，就进行CRC检验(多项式)。若CRC检验正确，就收下这个帧；反之就丢弃这个帧(不可靠传输服务)。检验由尾部的FCS实现 用于检验的多项式为X^16^ + X^12^+X^5^+1 RFC1662 的附录部分，给了FCS的C语言实现（查表法） 最后，以拨号接入为例，介绍PPP协议的工作状态。 这里看书或者看原视频。 媒体接入控制 场景：以总线型局域网为例，一根同轴电缆上的多台主机同时发送数据，肯定会发生碰撞。 共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(Medium Access Control) 集中控制有多点轮询协议，分散控制有令牌传递协议。 静态划分信道复用(Multiplexing)：通过一条物理线路同时传输多路用户的信号。当网络中传输媒体的传输容量大于多条单一信道的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。 分为四类：频分、时分、码分、波分。 频分：一条路同一时间走两种车；车与车之间间隔区分。 时分：一条路一种车只能在属于他的时间间隙经过；也就是依次按序串行。 波分、码分：给两种车分别编号（编码），到了终点再根据编号区分； TDMA，FDMA，CDMA是常见的物理层信道复用技术，属于静态划分信道，用于多用户共享信道，不会发生冲突。 频分复用FDM将传输线路的频带资源划分成多个子频带，形成多个子信道。各子信道之间留出隔离频带，以免造成子信道间干扰。 当多个信号输入一个多路复用器时，这个复用器将每一个信号调制到不同频率的载波上，接收端由相应的分用器通过滤波将各路信号分隔开，将合成的复用信号恢复成原始的多路信号。 时分复用TDM将时间划分为一个个时隙，将带宽资源按照时隙轮流分配给不同的用户，每对用户只在所分配时隙里使用线路传输数据。 时分复用技术将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。每个用户所占的时隙是周期性出现的，其周期就是时分复用帧的长度 波分复用WDM波分复用其实就是光的频分复用。经过光复用器(合波器)的光调制，分别将光载波变换到不同波长。这些光波经过光复用器就可以在一根光纤中传输。到达终点后用光分用器将不同波长的光进行还原得到信息 光信号传输一段距离后会衰减，对衰减的光信号必须进行放大才能继续传输。放大的工具是掺镇光纤放大器EDFA。 码分复用CDM CDM的每一个用户可以在同样的时间使用同样的频带进行通信，这是因为各用户使用了经过**特殊挑选的不同码型，**因此各用户之间不会造成干扰。 频谱类似白噪声，抗干扰能力强。最初用于军事通信。后来技术发展成本低了，也用于民用通信。 码片(chip)： 在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片。通常m的值是64或128； 使用CDMA的每一个站被指派一个唯一的m bit码片序列。 一个站如果要发送比特1，则发送它自己的m bit码片序列； 一个站如果要发送比特0，则发送它自己的m bit码片序列二进制反码。a 这种通信方式又称”直接序列扩频DSSS“ 复用和分址： 由于码分复用主要用于多址接入，人们更常用的名词是码分多址CDMA。 频分复用FDM和时分复用TDM同样可用于多址接入， 相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。 复用：将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。 多址(多点接入)：处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的 (对于无线广播或电视广播站就是这样)。 多址可以理解为并发，复用即并行。 CSMACD协议（随机接入）总线局域网使用。 载波监听多址接入碰撞检测 CSMACD (Carrier Sense Multiple AccessCollision Detection) CSMACD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMACD协议。 多址接入MA：多个站连接在一条总线上，竞争使用总线。 载波监听CS：每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧(“先听后说”) : 若检测到总线空闲96比特时间则发送这个帧;若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧。 96比特时间是指发送96比特所耗费的时间，也称帧间最小间隔。 作用是使接收方可以检测出一个帧的结束，同时也使得所有其他站点都能有机会平等竞争信道并发送帧。 **碰撞检测：**每一个正在发送帧的站边发送边检测碰撞 (“边说边听”) 。 一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送 (“一旦冲突，立即停说等待时机，重新再说”) 因为主机B先发送一段时间，所以主机C比主机B更早检测到碰撞。 争用期 最小帧长为什么需要规定最小帧长？ 假设A向D发送帧，如果帧很短的话，在2 τ (tau)内就会将帧发送完毕，帧发送完毕后不会进行碰撞检测，而此时依然有发生碰撞的可能。所以必须保证在2 τ 时间内帧不会被发送完，在这段时间里能够保持碰撞检测。 以太网规定最小帧长为64字节，即512比特(512比特即争用期) 如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节 以太网的最小帧长保证了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞 这保证了两点： 如果在争用期没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞。 如果在争用期检测到碰撞就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞检测而异常中止的无效帧。 根据网络跨距（端到端传播时延tau）和数据传输速率限定最小帧长。 争用期 * 数据传输速率 最小帧长 最大帧长 为什么需要规定最大帧长？ 当帧过长时，其他线路会迟迟得不到资源，同时也可能导致接收方缓冲区溢出，因此帧的最大长度也有规定。 退避算法 当帧发送碰撞后会停止发送，隔一段时间后再次发送，而具体隔多少时间再发送需要根据退避算法得出 信道利用率 每帧的发送时延为T0 ，传播时延为τ ，占用信道的时间为T0+τ 。 帧接收流程 不能用于无线网络 原因： 无线信道上冲突检测代价大 存在信号衰减问题 存在隐藏站点问题 存在暴露站点问题 CSMACA协议（随机接入）无线局域网使用。 载波监听多址接入碰撞避免 CSMACA(Carrier Sense Multiple AccessCollision Avoidance) 背景： 既然CSMACD协议已经成功地应用于使用广播信道的有线局域网，那么同样使用广播信道的无线局域网能不能也使用CSMACD协议呢? 对于CSMA： 在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以避免碰撞 对于CD： 在无线局域网中，不能使用碰撞检测CD，原因如下： 由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度(可能差百万倍)。如果要在无线网卡上实现碰撞检测CD，对硬件的要求特别高。 即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性(存在隐蔽站的问题)，进行碰撞检测的意义也不大(如下)。 而有线网络中信号会随着总线到达各个地方，不会出现隐蔽站。 引入： CSMACA是指载波监听多址接入碰撞避免，是802.11局域网采用的无线信道访问控制协议。 802.11局域网在使用CSMACA的同时，还使用停止-等待协议。这是因为无线信道的通信质量远不如有线信道，因此无线站点每发送完一个数据帧后，要等到收到对方的确认帧后才能继续发送下一帧; 所以由于不可能避免所有的碰撞并且无线信道误码率较高,802.11标准使用了数据链路层确认机制 (停止-等待协议) 来保证数据被正确接收。 802.11无线局域网使用CSMACA协议，在CSMA的基础上增加了一个碰撞避免CA功能而不再实现碰撞检测功能。 802.11的MAC层 标准定义了两种不同的媒体接入控制方式： 分布式协调功能DCF(Distributed Coordination Function)。 在DCF方式下，没有中心控制站点，每个站点使用CSMACA协议通过争用信道来获取发送权，这是802.11定义的默认方式 点协调功能PCF(Point Coordination Function)。 PCF方式使用集中控制的接入算法(一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用 帧间间隔IFS： 802.11标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS。 帧间间隔的长短取决于该站点要发送的帧的类型 高优先级帧需要等待的时间较短，因此可优先获得发送权 低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发送碰撞的机会。 常用的两种帧间间隔如下 短帧间间隔SIFS(28μm)。这是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型由ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧 DCF帧间间隔DIFS(128μs)。它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧 工作原理 DIFS时间 : 为什么源站检测到信道空闲后，还需要等待DIFS时间才将帧发送呢？ 因为其他站此时可能有优先级更高的帧需要发送，因此有DIFS时间进行缓冲，若这个时间内没有高优先级的帧要发送，则说明信道是真正的空闲 SIFS时间 : 为什么目的站接收到帧后还需要等到SIFS时间才返回ACK确认帧呢？ SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。这段时间内一个站点应当能够从发送方式切换到接收方式 随机时间 : 当其他站要发送数据，但是发现此时信道正忙时就会退避一段时间，等信道不忙后再进行操作，接着等待DIFS时间(与①同理)，但为什么等待了DIFS时间后还要退避一段随机时间呢？ 因为可能有多个站点在信道忙时都想发送帧，因此它们都会被搁置直至信道不忙，在DIFS时间后他们会同时发送，而实际上多个站点同时发送数据会碰撞。因此需要一个随机时间将他们进行错峰发送。 退避算法 多个站点发送冲突时，各个站点需要退避一段随机时间再进行操作 以下情况必须使用退避算法 在发送数据帧之前检测到信道处于忙状态时； 在每一次重传一个数据帧时； 在每一次**成功发送后要连续发送下一个帧时(**这是为了避免一个站点长时间占用通道) 过程 在执行退避算法时，站点为退避计时器设置一个随机的退避时间 当退避计时器的时间减小到0，就开始发送数据 当退避计时器的时间还未减小到0时信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过DIFS后，继续启动退避计时器 在进行第i次退避时，退避时间在时隙编号{0,1,2,4, … , 2^i+1^-1}中随机选择一个，然后乘以基本退避时间(也就是一个时隙的长度)就可以得到随机的退避时间。这样做时为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时(对应第6次退避)就不再增加了。 信道预约 为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约 下面我们分五步讨论信道预约的过程： 源站在发送数据帧之前先发送一个短的控制帧，称为请求发生RTS，它包括源地址、目的地址以及这次通信(包括相应的确认帧)所需的持续时间 若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS,它也包括这次通信所需的持续时间从RTS帧中将此持续时间复制到CTS帧中。 源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧 如果RTS帧发送碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。 **由于RTS帧和CTS帧很短，发生碰撞的概率、碰撞产生的开销及本身的开销都很小。**而对于一般的数据帧，其发送时延往往大于传播时延(因为是局域网)，碰撞的概率很大，且一旦发生碰撞而导致数据帧重发就会浪费很多时间，因此用很小的代价对信道进行预约往往是值得的。 802.11标准规定了3种情况供用户选择: 使用RTS帧和CTS帧 不使用RTS帧和CTS帧 只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧 若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK 除源站和目的站以外的其他各站，在收到CTS帧(或数据帧)后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会收到其他站的干扰。 虚拟载波监听 除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制 由于利用虚拟载波监听机制，**站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，**而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题 如下图，A与C虽然互相覆盖不到，但是C可收到B发出的关于A的CTS帧，从而得知A需要占用信道的时间。在这段时间里，C不发送数据，从而解决隐蔽站带来的碰撞问题 MAC地址、IP地址和ARP协议 MAC地址是以大网的MAC子层所使用的地址； IP地址是TCPIP体系结构网际层所使用的地址； ARP协议属于TCPIP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址。 MAC地址属于数据链路层 IP地址和ARP协议属于网际层 尽管IP地址和ARP协议属于TCPIP体系结构的网际层(而不属于数据链路层)，但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议因此，我们将这三者放在一起讨论。 MAC地址应用场景： 只有一条路径的信道不需要地址，因为没得选。 当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。 在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC(Media Access Control)，因此这类地址被称为MAC地址 MAC地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址。 MAC地址有时也被称为物理地址。但是MAC地址不属于物理层而是属于数据链路层 一般情况下，用户主机会包含两个网络适配器： 有线局域网适配器(有线网卡) 无线局域网适配器(无线网卡) **每个网络适配器都有一个全球唯一的MAC地址。**而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。 综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。 单播地址、广播地址与多播地址 单播MAC地址：明确的目的MAC地址。将此地址填入帧的目的地址栏中，接收到该帧的主机将此地址与自身MAC地址进行匹配，若相同则接收，不同则丢弃。 广播MAC地址：FF-FF-FF-FF-FF-FF，将此地址填入帧的目的地址栏中，接收到该帧的主机检索该地址发现是广播地址，因此接收该帧。 多播地址： MAC地址的第一字节第一位：取0为单播，取1为多播（组播）。 第一字节第二位：取0为全球管理（全球唯一），取1为本地管理。 所以MAC地址中第一字节后4比特为(1,3,5,7,9,B,D,F)时，MAC地址是多播地址。(第一位十六进制数不能除二时) 将此地址填入帧的目的地址栏中，接收到该帧的主机将此多播地址与自己多播组列表中的地址进行逐一配对，如果有匹配的项，则接收，否则丢弃。 每个用户都会给自己的主机配置多播组列表。 注意：给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址。 所以一共有四种类型的多播地址： 全球管理-单播地址：厂商生产网络设备时给设备的各网络接口固化的MAC地址。 全球管理-多播地址：是标准网络设备所应支持的多播地址，用于特定功能。 例如交换机生成树协议所需要的多播地址。 本地管理-单播地址：有网络管理员分配，会覆盖网络接口的全球管理单播地址（优先级高）。 本地管理-多播地址：用户对主机进行软件配置，以表明其属于哪些多播组。 注意：剩余46位全为1时，就是广播地址FF-FF-FF-FF-FF-F F MAC地址由48个比特构成，所以总地址数量：2^48^，这四类MAC地址各占四分之一。 随机MAC地址 IP地址 应用场景： MAC地址只能区分同一网络中的不同主机，不具备区分不同网络的功能，而IP地址可以通过网络号做到。 如果只是一个单独网络，不接入因特网，则使用MAC地址就足够了(这不是一般用户的应用方式)如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用 IP地址是TCPIP体系结构的网际层所使用的的地址。 IP地址是Internet上的主机和路由器所使用的的地址，由两部分信息构成 网络编号：标识因特网上数以百万计的网络 主机编号：标识同一网络上不同主机(或路由器各接口) 数据报转发过程中源IP地址和目的IP地址保持不变。 数据包转发过程中源MAC地址和目的MAC地址**(由ARP协议获得)**逐个链路改变。 路由器上有路由表，记录了要到目的IP地址，先要走哪些路(即下一跳位置)。所以H1起初只带有目的IP地址，查询路由表后路由器指路，从而知道下一步该往哪里走，从而不断转发直至到达目的地。 ARP协议 地址解析协议ARP属于TCPIP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址 数据的发送需要经过链路，仅仅知道IP地址是无法在数据链路层实现传输的，因此我们需要得到IP地址与MAC地址的对应关系，即地址解析。 每台主机都会有一个ARP高速缓存表，记录有IP地址与MAC地址的对应关系 初始ARP高速缓存表为空，假设此时B知道C的IP地址，准备发送信息，但是由于不知道C的MAC地址，因此无法封装数据帧，所以此时会广播一个ARP请求报文(封装在MAC帧中，目的地址为广播地址FF-FF-FF-FF-FF-FF)，内容如下： 我的IP地址是：xxx ；我的MAC地址是：XXX；我想知道C主机的MAC地址是多少？ 这个广播帧会被该广播域的所有主机收到 A主机收到后交由上层处理，发现B问的不是他，所以不予理会 C收到后交由上层处理，发现这个IP地址正是自己，因此: 首先将B的MAC地址和IP地址的对应关系记录到自己的高速缓存表中， 接着给 B返回ARP响应报文(封装在MAC帧中，目的地址为B的MAC地址)，其中包含自己的MAC地址。 ARP高速缓存条目有静态与动态两种类型: 动态代表是通过广播自动获取的条目，生命周期默认为两分钟 IP 与 MAC 的对应关系不是永久的。该主机可能更换网卡。 静态是手工设置的条目，不同操作系统下的生命周期不同。 ARP协议只能在一段链路或一个网络上使用。 集线器与交换机的区别 场景： 早期的总线型以太网使用细同轴电缆，普遍使用无源电缆线。 但电缆线和大量机械接口的总线型以太网并不可靠。 使用双绞线和集线器HUB的星型以太网，可靠性更高，双绞线也更便宜。 双绞线电缆中的 RJ-45 接头是我们熟知的水晶型接头 集线器 集线器HUB的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。 使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议 集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测(由各站网卡检测) **集线器一般都有少量的容错能力和网络管理功能。**例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作 集线器是半双工模式，收发不能同时进行，收到帧后会广播到除本身接口外的各个接口。 集线器可以在物理层扩展以太网，也就是扩大碰撞域。 交换机 交换机是一种负责转发信号的网络设备，可以为接入交换机的任意两个网络节点提供独享的电信号通路 以太网交换机通常有多个接口，每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在全双工方式 以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞(不使用CSMACD协议) 以太网交换机一般都具有多种速率的接口。 以太网交换机工作在数据链路层(也包括物理层)，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。 以太网交换机是一种即插即用的设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的 帧的两种转发方式 存储转发：先缓存再处理。 直通交换：采用基于硬件的交叉矩阵(交换时延非常小，但不检查是否有差错而直接发出去)。 交换机每个接口是一个独立的碰撞域。 综上：集线器扩大广播域的同时，扩大了碰撞域。 交换机扩大广播域的同时，隔离碰撞域。 工作在数据链路层的交换机，性能远超过工作在物理层的集线器。 以太网交换机自学习和转发帧的过程： MAC地址表中的每条记录都有自己的有效时间，到期自动删除。这是因为MAC地址与交换机接口的对应关系并不是永久性的。 如果刚刚学习到的MAC地址G来自接口1，同时交换机发现接口1也是来源，就会丢弃该帧。 STP生成树协议 STP可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题 应用场景： 当交换机之间链路较少时，某一条链路发送故障，会导致其中有些主机无法通信，即链路不可靠。如下图，A与B之间的链路发送故障后，H1便无法与H2和H3进行通信 解决方法是添加冗余链路，如在B与C之间多拉一条链路，这样即使A与B之间的链路发送故障，H1、H2、H3之间还是能够相互通信。但如下图所示，出现了新的问题： 帧会在交换机中不停转发，究其原因是因为网络形成了环路，网络环路会带来以下问题 广播风暴 大量消耗网络资源，使得网络无法正常转发其他数据帧 主机收到重复的广播帧 大量消耗主机资源 交换机的帧交换表震荡(内容不断更新) 解决方法：以太网交换机使用生成树协议STP(Spanning Tree Protocol)。 可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。 生成树原理： 不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的(无逻辑环路) 最终生成树的逻辑拓扑要确保连通整个网络 当首次连接交换机或网络物理拓扑发生变化时(有可能是人为改变或故障)，交换机都将进行生成树重新计算 VLAN虚拟局域网 一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求，每个VLAN就是一个独立的广播域 应用场景： 随着交换式以太网规模的扩大，广播域相应扩大，而巨大的广播域会带来很多弊端 广播风暴 如数台交换机连接了数台主机，当主机A要向主机B发送数据帧，此时各交换机的MAC表均为空，因此帧每到一个交换机就会进行泛洪，由于网络巨大，因此泛洪的范围也巨大 难以管理和维护 潜在的安全风险 但即便如此，网络中还是会频繁出现广播信息： TCPIP协议栈中的很多协议都会使用广播: 地址解析协议ARP(已知IP地址，找出其相应的MAC地址) 路由信息协议RIP(一种小型的内部路由协议) 动态主机配置协议DHCP(用于自动配置IP地址) NetBEUl:Widnows下使用的广播型协议 IPXSPX:Novell网络的协议栈 Apple Talk:Apple公司的网络协议栈 解决方法：分割广播域 两种方法： 路由器隔离广播域 由于路由器属于网络层设备，默认情况下不对广播数据包进行转发，因此自然达到隔离的效果。但是成本较高，局域网内部全靠路由器分割广播域是不现实的。 虚拟局域网 VLAN（Virtual Local Area Network） 技术:将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。 实现机制： 1.帧格式 2.交换机端口类型 帧格式 VLAN标记的最后12比特称为VLAN标识符VID，它唯一地标志了以太网帧属于哪一个VLAN VID的取值范围是0~4095 0和4095都不用来表示VLAN，因此用于表示VLAN的VID的有效范围是1~4094 802.1Q帧时由交换机来处理的，而不是用户主机来处理的 当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q，简称**“打标签”** 当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称**“去标签”** 端口类型 Access Trunk Hybrid（思科交换机没有这个端口） 交换机个端口的缺省 VLAN ID： 在思科交换机上称为Native VLAN，即本征VLAN。 在华为交换机上称为Port VLAN ID，即端口VLANID，简记为PVID。 交换机每个端口有且仅有一个PVID。 Access 接口 Access端口一般用于终端设备与交换机之间 注意：交换机与路由器连接的接口也需要使用access接口。这是因为路由器中的消息也不带VLAN标签，就像终端一样，保证路由器的数据能够进入交换机领域，数据由路由器进入交换机是会被打上默认标签，接着猜按照交换机间VLAN的规则行走。简单理解就是把路由器当作终端。 交换机初始端口类型是Access Access端口只能属于一个VLAN Access端口的PVID值与端口所属VLAN的ID相同(默认为1) Access端口接收方法 一般只接收”未打标签”的普通以太网MAC帧。根据接收帧的端口PVID值给帧”打标签”，即插入4字节的VLAN标记字段，字段中的VID取值与端口PVID取值相等。 Access端口发送处理方法 若帧中的VID与端口的PVID相等，则”去标签”并转发该帧；否则不转发。 Trunk 接口 Trunk端口一般用于交换机之间或交换机与路由器之间的互连 Trunk端口可以属于多个VLAN 用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口PVID值为1 Trunk端口发送处理方法： 对VID等于PVID的帧，“去标签，再转发” 对VID不等于PVID的帧，直接转发 Trunk端口接收处理方法： 针对”未打标签”的帧。根据接收帧的端口的PVID给帧”打标签”，即插入4字节的VLAN标记字段，字段中的VID取值与端口的PVID取值相等 针对”已打标签的帧”直接接受。 Hybrid 接口 Hybrid端口既可以用于交换机之间或交换机与路由器之间的互连(同Trunk端口)，也可用于交换机与用户计算机之间的互连(同Access端口) Hybrid端口可以属于多个VLAN(同Trunk端口) 用户可以设置Hybrid端口的PVID值。默认情况下，Hybrid端口的PVID值为1 Hybrid端口发送处理方法： 查看帧的VID是否在端口的”去标签”列表中 若存在，则”去标签”后转发 若不存在，则直接转发 Hybrid端口接收处理方法(同Trunk)： 接收”未打标签”的帧，根据接收帧的端口的PVID给帧”打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等 接收”已打标签的帧” 杂项传播时延和传输时延 传输时延又称发送时延。 传播时延距离信号转播速率(ms) 发送时延（传输时延）数据块长度（比特）发送速率（又称带宽或数据传输速率）(bits) 传输时延是指一个站点从开始发送数据帧到数据帧发送完毕所需要的全部时间，传播时延是指发送端开始发送数据到接收端收到数据所需要的全部时间。传输时延和发送数据帧大小有关，而传播时延和传输距离相关。"},{"title":"湖科大(2)","path":"/wiki/network/湖科大(2).html","content":"第二章：物理层物理层的基本概念物理层基本概念 物理层考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流。 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么 。 物理层协议主要任务 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置 电气特性：指明在接口电缆的各条线上出现的电压范围 功能特性：指明某条线上出现的某一电平的电压表示何种意义 过程特性：指明对于不同功能的各种可能事件的出现顺序 物理层下的传输媒体传输媒体分两类： 导引型：电磁波被导引到固体媒体传播 同轴电缆： 电缆各层都是同轴心的，因此称同轴电缆 。 基带同轴电缆(50Ω \\OmegaΩ)：数字传输，过去用于局域网宽带同轴电缆(75Ω \\OmegaΩ)：模拟传输，目前主要用于有线电视的入户线。 同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。 双绞线： 把两根互相绝缘的铜导线并排放在一起，按照一定规则绞合起来就构成了双绞线。 这是种古老且常用的媒体。 绞合作用：抵御外界电磁波干扰，减少相邻导线的电磁干扰。 有无屏蔽双控线UTP电缆和屏蔽双控线STP电缆，差了一个金属丝屏蔽层而已。 光纤： 光纤很细，因此必须将其做成结实的光缆。一根光缆少则一根光纤，多则可包括数百根 。 原理 如果全反射一直进行，则光就会沿着光纤一直传输下去。 实际上只要入射角大于某个临界角度就可以发生全反射，因此多条不同角度的光可以在光线里一起传输，这种光纤称作多模光纤。 由于色散(模式、材料、波导色散)，光在多模光纤中传输一定距离后必然产生失真(脉冲展宽) 因此多模光纤只适合近距离传输(建筑物内) 发送光源可使用发光二极管(便宜)；接收检测可用光电二极管 若光纤直径减小到只有一个光的波长，则光纤就像一根波导一样，可使光线一直向前传播，而不会产生多次反射，这样的光纤称作单模光纤 没有模式色散，在1.31微米波长附近，材料色散和波导色散大小相等符号相反，两者正好抵消 单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高 发送光源需要使用激光发生器(贵)；接收检测用激光检波器 纤芯直径多模光纤：50微米，62.5微米单模光纤：9微米纤芯外包层：125微米 工作波长0.85微米(衰减较大)1.30微米(衰减较小)1.55微米(衰减较小) 优点通信容量大(25000~30000GHz的带宽)传输损耗小，远距离传输时更加经济抗雷电和抗电磁干扰性能好。这在大电流脉冲干扰环境下尤为重要无串音干扰，保密性好，不易被窃听体积小，重量轻 缺点割接需要专用设备光电接口价格较贵 电力线 电力线电话 非导引型：自由空间传播 无线电波 低频和中频频段用地面波传播；高频和甚高频靠电离层(地球上方100~500千米高空的带电离子层)反射 微波 微波会穿透电离层进入宇宙，因此其不能通过电离层反射到很远的地方 地面微波接力通信 微波是直线传播的，而地球表面是个曲面，因此传播距离受到限制，一般只有50KM左右；如果采用100米高的天线塔，则传播距离可增大到100公里。为实现远距离通信，必须在一个微波通信信道的两个终端之间建立若干个中继站，中继站把前一阵送来的信号经过放大后再发送到下一站。 卫星通信 在地球站之间，利用位于约36000KM高空的人造同步地球卫星作为中继器的一种微波接力，其最大特点是通信距离远，传播时延大(约250~300ms)。低轨道卫星通信系统也已经正在部署。 红外线 点对点无线传输 直线传播，中间不能有障碍物，传输距离短 传输速率低(4Mb/s~16Mb/s) 可见光（LiFi） 即光源作为信号源，前景好，暂时未被大范围应用 传送方式 串行并行传输 串行传输是指数据是1个比特1个比特依次发送的，发送端与接收端之间只用1条数据传输线即可。 并行传输是指一次发送n个比特而不是一个比特，在发送端和接收端之间要有n条传输线路。 在计算机网络中，数据在传输线路上的传输时串行传输；而计算机内部(如CPU和内存)多使用并行传输。 同步异步传输 同步传输 数据块以稳定的比特流形式传输，字节之间没有间隔。接收端在每个比特信号的中间时刻(有区分0,1的标志)进行检测，以判别接收到的是比特0还是1。 由于不同设备的时钟频率存在一定差异，不可能完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号的判别错位。因此需要采取方法使双方的时钟保持同步。 收发双方时钟同步方法 外同步：在收发双方之间加一条单独的时钟信号线 内同步：发送端将时钟同步信号编码到发送数据中一起传输(如曼彻斯特编码) 异步传输 以字节为独立的传输单位，字节间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步，为此传送前要在每个字节前后加上起始位和结束位。 异步是指字节之间异步(字节之间的时间间隔不固定)字节中的每个比特仍然要同步(各比特的持续时间是相同的) 单工半双工全双工（单向通信..) 单工通信：通信双方只有一个数据传输方向。 (无线电广播) 半双工通信：通信双方可以相互传输数据，但不能同时进行。 (对讲机) 全双工通信：通信双方可以同时发送和接收消息。 (电话) 单工需要一条信道；其他的需要两条(一个方向一条) 编码与调制逻辑前提： 消息(message)包括文字、图片、音频和视频。 数据是运送消息的实体；计算机中的网卡将比特1和0变换成相应电信号发送到网线，即信号。 信号是数据的电磁表现，由信源(网卡)发出的原始电信号称为基带信号。 基带信号又分为数字基带信号(CPU和内存传输的信号)和模拟基带信号(麦克风收到声音后转变的电信号) 信号需要在信道中进行传输，信道可分为数字信道和模拟信道。 如果使用信道复用技术，传输媒体里可以有多个信道。 例如，全双工就需要两个信道，一个发送信道，一个接收信道。 编码：在不改变信号性质的前提下，仅对基带信号的波形进行变换，称为编码。编码后产生的信号还是数字信号，可以在数字信道中传输。 调制：把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生的信号还是模拟信号，可以在模拟信道中传输。 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 常用编码 不归零编码正电平代表比特1，负电平代表比特0。在整个码元时间内，电平不会出现零电平 这种编码方式如何区分连续几个相同电平呢？ 这要求发送方发送和接收方接收严格同步，也就需要额外一根传输线来传输时钟信号。接收方按照时钟节拍逐个接收码元。 但是对于计算机网络，多的线不如拿来传输数据，因此由于存在同步问题，计算机中的数据传输不使用不归零编码。 归零编码每个码元传输结束后信号都要”归零”，所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。 实际上，归零编码相当于把时钟信号用”归零”方式编码在了数据之内，这称为”自同步”信号 归零编码中的大部分数据带宽都用来传输”归零”而浪费掉了(编码效率低) 曼彻斯特编码码元的中间时刻既表示时钟，又表示数据。根据正负跳变来区分比特. 具体如何根据跳变实现同步？ 第一次数据跳变的时间记录下来【即半个码元的时间】，此后每过一个码元的时间就进行检测，根据跳变方向决定数据为0还是1。这个不一定哦 差分曼彻斯特编码①跳变仅表示时钟 ②码元开始处电平是否发生变化表示数据。 比曼彻斯特变化少，更适合较高的传输速率。 基本调制方法 数字基带信号：原始的1，0。 调幅：有无载波输出。 调频：频率的大小。 调相：初相度不同。 如上一个码元对应一个比特，如何能让1个码元包含多个比特呢？ 可以使用混合调制。正弦信号A sin ⁡ ω ( x + φ / ω ) 相位和频率是相关的，因此二者不可同时做修改。 通常情况下,相位和振幅可以结合起来其一调制，称为正交振幅调制QAM。 基本调制成为二元制。 混合调制可以实现多元制。 QAM-16 12种相位 每种相位有1或2种振幅可选 可以调制出16种码元(波形)，即16个形状可以用4个二进制位排列组合表示，所以一个码元可以对应4比特 码元与4个比特的对应关系要采用格雷码【任意两个相邻码元只有一位不同】 关于QAM-16： qam16为什么有12种相位? 12种相位2个振幅为什么有16种波形? 尚未解决。。。 信道的极限容量 通信质量较差的信道在传输信号的过程中会发生严重失真(无法识别原信号)【码间串扰】 失真因素 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 那怎么避免这种失真呢？ 主要理论有两个：奈氏准则和香农定理。 上面的调频、调幅、调相的三种基本调制方法，是二元调制，只能调出两种波形两种码元。因此每种码元只能有1bit的信息流。 QAM-16可以调制出16种码元，所以每个码元可以携带4bit的信息量。 每个码元信息量的计算：log(2)2 1 ； log(2) 16 4 。 上限数值：奈氏准则的推导是在理想条件下得出的，没有考虑噪声干扰、传输媒体质量等，所以实际信道传输的最高码元速率要低于上限数值。 **信噪比：**信道中的噪声也会影响接收端对码元的识别。 信道功率越大，噪声功率相对影响越大。 在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制【更好的调制方法】和努力提高信道中的信噪比。 自从香农公式发布后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限。 例题："},{"title":"湖科大(1)","path":"/wiki/network/湖科大(1).html","content":"第一章因特网概述网络、互联网和因特网 网络（Network）由若干结点（Node) 和连接这些结点的链路(link)组成。 互联网 ( Network of Networks ):多个网络通过路由器互连构成的覆盖范围更大的网络（网络的网络）。 因特网(Internet)：世界上最大的互连网络 区分 internet(互联网)：通用名词，泛指多个计算机网络互连的网络，通信协议随意。 Internet (因特网)：专有名词，指一个前身为ARPANET的特定计算机网络，采用TCPIP协议族作为通信规则。 因特网发展的三个阶段单个网络ARPANET → 三级结构因特网 → 多层次ISP结构因特网 因特网服务提供者ISP：Internet Service Provider （联通、移动、电信） ISP 拥有通信线路和路由器（大型）等网络设备，因此普通用户往往通过 ISP 接入因特网，这时 ISP 会从因特网管理机构为用户申请IP地址。 另：用户也能作为ISP。你只需要购买些调制解调器之类的东西，让其他人连接你。 因特网的标准化工作相关部门： ISOC —— IAB —— IETF 和 IRTF 因特网制定标准面向公众。 正式标准制定阶段： 因特网草案 建议标准 （RFC文档） 草案标准 因特网标准 因特网的组成 边缘部分：所有因特网上的主机。部分是用户直接使用，来通信和共享资源。 核心部分：大量网络和连接网络的路由器。它们为边缘部分提供服务。 交换方式电路交换(Circuit Switching) 电话交换机接通电话线的方式称为电路交换。 交换即按照某种方式动态分配传输线路的资源。 电路交换三个步骤： 建立连接（分配通信资源） 通话（一直占用通信资源） 释放连接（归还通信资源） 这个连接是一条专用的物理通路。 建立连接的传输：比特流直达。 分组交换(Packet Switching)传输信息在发送时，将信息分段，每一段根据一定规则添加首部信息(包头)，构成分组，称为包。分组交换机会根据包头信息进行合理传输。到达目的地后去掉包头，还原信息。 合理传输意味着包的传输可以走不同路径。 分组传输意味着传输有乱序性：分组到达目的地后顺序可能不同。 (这会造成潜在的分组丢失、误码、重复问题) 三个主体：发送方，路由器，接收方。 主体 任务 发送方 构造分组，发送分组 路由器 缓存分组，转发分组 接收方 接收分组，还原报文 分组存储转发：减少了转发时延，避免长报文长时间占用链路，方便差错控制。 报文交换(Message Switching) 主要用于早期电报通信网络。现已被分组交换取代。 随时发送报文，不需要建立连接。先传送到相邻结点交换机，存下来后存储转发到下一相邻结点交换机。 **报文存储转发：**不限制报文大小，需要结点交换机有较大缓存空间。 对比 交换方式 优点 缺点 电路交换 1) 通信时延小2) 有序传输3) 没有冲突4) 适用范围广5) 实时性强6) 控制简单 1)建立连接时间长2)线路独占，使用效率低3)灵活性差4)难以规格化 报文交换 1)无需建立连接2)动态分配线路3)提局线路可靠性4)提高线路利用率5)提供多目标服务 1)起了转发时延2)需要较大存储缓存空间3)需要传输额外的信息量 分组交换 1)无需建立连接 2)线路利用率高 3)简化了存储管理 4)加速传输 5)减少出错概率和重发数据量 1)引起了转发时延2)需要传输额外的信息量3)对于数据报服务，存在失序、丢失或重复分组的问题：对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程 计算机网络定义 计算机网络精确定义未统一。 简单定义：一些互相连接的、自治的计算机的集合。 互连：计算机间可以通过有线或无线的方式进行数据通信； 自治：指有自己硬件软件的，单独运行使用的独立计算机 集合：至少两台计算机。 精准定义：计算机网络主要由一些通用的，可编程的硬件互连而成的。这些可编程的硬件能够用来传送多种不同类型的数据，并能够支持广泛和日益增长的应用。 这些硬件并非专门用来实现某一特定目的 （例如，传送数据或视频信号），而是能传送不同类型数据，包括应用。 硬件包括智能手表等。 分类按交换技术分类： 电路交换网络 报文交换网络 分组交换网络 按使用者分类： 公用网：大型网络，一般由电信公司出资构建。普通用户缴费参与。 专用网：针对特定单位、特定系统的专用网。 按传输介质分类： 有线网络：双绞线网络、光纤网络。 无线网络：wifi 按覆盖范围分类： 广域网WAN（Wide Area Network） 作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。 任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。 广域网是互联网的核心部分。 城域网MAN 作用范围一般是一个城市，可跨越几个街区甚至整个城市 局域网LAN 一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbits 以上），但地理上范围较小（1 km 左右） 个域网PAN 就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。 (无线耳机，蓝牙设备) 按拓扑结构分类： 总线型网络 优点：建网容易，增减结点方便。节省线路。 缺点：1.重负载通信效率不高。2.一处故障，全线瘫痪。 星型网络 中央设备：早期计算机，中期集线器，后期路由器交换机。 优点：便于网络集中控制和管理。 缺点：成本高，中央设备对故障敏感。 环形网络 网状型网络 优点：可靠性高 缺点：控制复杂、线路成本高 性能指标速率 商家声称的的250G硬盘买来在电脑上显示的居然是236G。不是商家作假，而是因为两个数据单位不同。 现实中的测量单位，1k 1000b，计算机中资源单位，1K 1024 Bit ，这是视角问题。 速率单位和比特单位的视角同理。 (注意区分M、K等单位后 B和b 的大小写) 比特：计算机的数据量单位，信息学的信息量单位。 Byte，bit ， 1KB 2^10B 速率：计网主机在数字信道上，传送比特的速率单位，也称比特率、数据率。 bits, bps , bs , 1kbs 1000 bs 示例题： 带宽 在模拟信号系统：不同频率成分占据的频率范围 单位：Hz (kHz , MHz , GHz) 在计网中：网络带宽，表示单位时间内从网络一点到另一点所能通过的“最高数据率” 单位：bs (kbs , Mbs , Gbs , Tbs) 表示网络通信线路传送数据的能力 两者有密切联系。一条通信线路的频带宽度越宽，传输效率的最高数据率越高。 朋友问：你家出口网速有多大，回答是200M(兆) ，这里省略了比特每秒。 正确描述：完整速率为200Mbs 吞吐量吞吐量：在单位时间内通过某个网络（信道、接口）的数据量。 经常用于描述测量网络的情况，也就是有多少数据量能通过网络。 吞吐量受网络带宽和额定速率限制。 带宽1 Gbs的以太网，代表其额定速率是1 Gbs，这个数值也是该以太网的吞吐量的绝对上限值。因此，对于带宽1 Gbs的以太网，可能实际吞吐量只有 700 Mbs，甚至更低。 注意：吞吐量还可以用每秒传送的字节数或帧数表示 时延时延 : 数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。 网络时延由几部分组成： 发送时延 主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 计算：分组长度(b)发送速率(bs) 传播时延 电磁波在信道中传播一定的距离需要花费的时间。 计算：信道长度(m)电磁波传播速率(ms) 处理时延 主机或路由器在收到分组时要花费一定时间进行处理 排队时延 分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。 有时会把排队时延看成处理时延 一部分 总时延 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延） 注意点 构建设备时，不同设备和传输介质的传送速率的速度应该近似。否则速度快的会制约于速度慢的部分。 主机发送速率受网卡发送速率和信道带宽、接口速率影响，其中速率最慢的部分会决定整个发送速率。 电磁波在自由空间和网络传输介质中的传播速度是不一样的。 介质 速度 自由空间 3.0 * 10^8 铜线 2.3 * 10^8 |光纤 | 2.0 * 10^8| 当处理时延忽略不计时，发送时延 和 传播时延 谁占主导，要具体情况具体分析。 例如同样传播距离和带宽，数据块长度不同会导致决定因素的不同。 时延带宽积时延带宽积 传播时延 * 带宽 发送端连续发送数据，第一个比特到达终点，发送端视作已发送了时延带宽积的比特 链路又称为 以比特为单位的链路长度 类似圆柱体体积，物理意义上的单位比特数量 往返时间互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。 RTT: Round Trip Time 利用率利用率有信道利用率和网络利用率两种。 信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过) 网络利用率：全网络的信道利用率的加权平均。 1.利用率并非越高越好 根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加，因此利用率并非越高越好 2.利用率不能太低 这会浪费通信资源 因此要使用一些机制动态调整网络通信量。 丢包率 丢包率：分组的丢失率， 指在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率 。 具体分为：接口丢包率，节点丢包率，链路丢包率，路径丢包率，网络丢包率等。 丢包的两种情况： 分组在传输过程中出现误码，被节点丢弃； 分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥堵。 丢包率反应网络拥堵情况 : 无拥塞时丢包率为0 轻度拥塞，1%~4% 严重拥塞，5%~15% 计算机网络体系结构常见的计算机网络体系结构 OSI体系结构：七层，国际标准化组织设计，是法律上的国际标准 结构从下往上是物理层，数据链路层，网络层，运输层，会话层，表示层，应用层 TCPIP体系结构：因特网结构，事实上的国际标准(市场决定)。 从下往上依次是网络接口层，网际层，运输层，应用层 对于TCPIP： 网际层：IP是TCPIP体系结构是网际层的核心协议。 这个协议可以将不同的网络接口进行互连，并向其上的TCP协议和UDP协议提供网络互连服务 。 IP中文意思叫网际，所以网络层又称网际层。 运输层：TCP和UDP是TCPIP体系结构是运输层 的两个重要协议。 TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议提供可靠传输的服务；UDP协议在……可向应用层的相关协议提供不可靠传输服务。 应用层：TCPIP体系结构的应用层包含了大量的应用层协议HTTP-SMTP DNS-RTP 路由器和主机都带有TCPIP协议族，路由器一般只包括网络接口层和网际层 网络接口层没什么具体内容，目的是为了连接世界上各种不同接口。 这也意味着该体系结构本质上只有上面三层， TCPIP两协议的承上启下重要作用说明了为什么该结构叫TCPIP协议。 五层协议原理体系结构，适用于教学，从下到上依次是物理层，数据链路层，网络层，运输层，应用层 TCPIP协议的网络接口层为了灵活性没有什么具体内容，不方便学习。结合OSI和TCPIP诞生了原理体系结构，将网络接口层换成了数据链路层和物理层。 体系结构分层的必要性物理层 ：使用何种信号来传输比特的问题 采用什么传输媒体(介质) 采用什么物理接口 使用什么信号 第一，严格来说，传输媒体并不属于物理层 计算机传输的信号，并不是图示的方波信号 数据链路层 ：分组在一个网络上传输的问题 如何标识网络中的各个主机-例如IP地址（前三段标识网络，最后一个数标识主机） 这样也能知道目的地址和发送地址 如何从信号所表示的一连串比特流中区分出地址和数据 如何协调各主机征用总线（两个异向信号碰撞） 总线型现已淘汰，代替的是交换式以太网：以太网交换机将多台主机互联。 网络层：分组在多个网络上传输的问题 如何标识各网络以及网络中的各主机（网络和主机共同编址，如IP地址） 192.168.1 这前三个数据就是一个共同网络编址 路由器如何转发分组，如何进行路由选择（多个路径走哪个） 运输层：进程之间基于网络的通信问题 如何解决进程之间基于网络的通信问题 出现传输错误，如何处理 应用层：通过应用进程的交互来实现特定网络应用的问题 制定应用层协议，按之编写app，通过应用进程间的交互完成特定网络应用。 计算机网络体系结构分层思想举例• 例子：通过计算机访问一个网站• 1：应用层按HTTP协议的规定构建一个HTTP请求报文，然后交付给运输层处理• 2：运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段，然后 将TCP报文段 交付给网络层处理 TCP报文段的首部格式作用是区分应用进程以及实现可靠传输 • 3：网络层给TCP报文段添加一个IP首部，使之成为IP数据报，然后交付给数据链路层 IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发 • 4：数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧，然后交付给物理层 该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收 该尾部的作用是让目的主机检查所接收到的帧是否有误码 • 5：物理层先将帧看做是比特流，会在该比特流前面添加前导码,然后物理层将比特流变换成相应的信号发送给传输媒体， 这里的网络N1假设是以太网 前导码的作用是为了让目的主机做好接收帧的准备 • 6:信号通过传输媒体到达路由器 • 7：路由器会把这些反向操作一遍再转换成比特流给Web服务器，Web服务器接收到后经过层层筛选接收HTTP请求报文 路由器中： 物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层 数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际交付的是IP数据报 网络层解析IP数据报的首部，从中提取目的网络地址 提取目的网络地址后查找自身路由表。确定转发端口， 以便进行转发 网络层将IP数据报交付给数据链路层 数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧 数据链路层将帧交付给物理层 物理层先将帧看成比特流，这里的网络N2假设是以太网，所以物理层还会给该比特流前面添加前导码 物理层将装有前导码的比特流变换成相应的信号发送给传输媒体，信号通过传输媒体到达Web服务器 •8： 然后Web服务器给主机发送HTTP响应报文啊吧啊吧，方法和请求一样 注意：报文和帧都是通过底层内存的固定排布，来让计算机理解数据哪一部分对应的东西。 注意报文上的位 计算机网络体系结构中的专业术语实体 实体：任何可发送或接收信息的硬件或软件进程 对等实体：收发双方相等层次中的实体，比如收发的两个应用层 协议定义：控制两个对等实体进行逻辑通信的规则的集合 协议三要素：语法，语义，同步 语法：定义所交换信息的格式 语义：定义收发双方所要操作完成的操作 同步：定义收发双方的时序关系 应用层使用应用层协议（例如HTTP, SMTP）进行通信，运输层应用运输层协议（例如TCP, UDP）进行通信，依次类推 服务 在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务、 要实现本层协议，还需要使用下面一层所提供的服务 协议是水平的，服务是垂直的 实体看的见相邻下层所提供的服务，但并不知道实现该服务的具体协议，也就是说，下面的协议对上面的实体是透明的【就好比我们可以享受 手机提供的服务，但不需要弄懂手机运行的原理】 服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令 服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型， 如数据链路层的服务访问点为帧的“类型”字段； 网络层的服务访问点为IP数据包首部中的“协议字段”； 运输层的服务访问点为“端口号”。 协议数据单元-PDU:对等层次之间传送的数据包称为该层的协议数据单元， 例如物理层的数据包就是比特流，以此类推有帧，分组IP数据报 服务数据单元-SDU:同一系统内，层与层之间交换到数据包称为服务数据单元。 多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。"},{"title":"湖科大(5)运输层","path":"/wiki/network/湖科大(5)运输层.html","content":"运输层概念：端口号、复用、分用 物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的的问题，实现了主机到主机的通信 但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程 如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称端到端协议 网络层范围：主机到主机 运输层范围：端到端 这里的端口并不是物理上看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符。 运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道等) 根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP，这两种协议就是本章要讨论的主要内容。 端口 运行在计算机上的进程使用进程标识符PID来标志。 为了使运行不同操作系统的计算机的应用进程之间能进行网络通信，必须使用统一的方法对TCPIP体系的应用进程进行标识，即端口号。 为什么不能使用进程标识符PID来区分各进程？ 因为因特网上的计算机并不是使用统一的操作系统，不同的操作系统使用不同格式的进程标识符 端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同的端口号是没有联系的 端口号使用16比特表示，取值范围0~65535。 熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议 登记端口号：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。如Microsoft RDP微软远程桌面使用的端口是3389 短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用 复用、分用 发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，这是UDP复用；若用TCP封装则称TCP复用 运输层使用端口号区分不同进程，不管使用何种协议封装的报文，在网络层都需要使用IP协议封装成IP数据报，这是IP复用 数据报中协议字段的值用来表名封装的是何种协议数据单元。 取值为6，表示封装的TCP用户数据报； 取值为17，表示封装的UDP用户数据报。 根据协议字段的值，将IP数据报封装的协议数据单元上交运输层的过程叫IP分用 同理，UDP根据端口号将数据交给应用进程叫做UDP分用；TCP根据端口号将数据交给应用进程叫做TCP分用 常用端口号 UDP 还有 OSPF 。 **举例：**在用户PC中使用网页浏览器来访问 Web 服务器的内容 ①用户通过DNS找到域名对应IP地址 用户在网页浏览器的地址栏中输入Web服务器的域名，请求访问 用户PC中的DNS客户端进程会发送一个DNS查询请求报文 其内容为“域名 www.porttest.com 所对应的IP地址是什么? DNS查询请求报文需要使用运输层的UDP协议,封装成UDP用户数据报， 填写UDP首部中的两个端口的数值。 源端口字：在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程，例如49152。 目的端口字段的值设置为53，这是DNS服务器端进程所使用的熟知端口号。 之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器。 DNS服务器收到该数据报，从中解封出UDP用户数据报，交付给本服务器中的DNS服务器端进程。 UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文。 DNS服务器端进程解析DNS查询请求报文的内容，然后接其要求查找对应的IP地址。 找到对应IP地址后，使用UDP协议封装成UDP数据报，设置UDP首部的两个端口值。 源端口值和目的端口值。这个值和用户源进程的端口值是相反的。 将UDP数据报封装在IP数据报中，通过以太网给用户PC发送DNS响应报文， 内容为“域名www.porttest.com所对应的IP地址是192.168.0.3”。 用户把DNS响应报文交付给DNS客户端进程，解析完响应报文，就可知道域名对应的IP地址了。 ②用户通过HTTP获得网页内容。 用户PC中的HTTP客户端进程向Web服务器发送HTTP请求报文 内容为“首页内容是什么？” HTTP请求报文需要使用运输层的TCP协议封装成TCP报文段。 填写TCP首部中的两个端口值：源端口和目的端口。 HTTP进程的端口号一般是80，即目的端口。 Web服务器收到后根据目的端口号，把数据载荷部分（HTTP请求报文）交付给本服务器中的HTTP服务器端进程。 HTTP服务器端进程解析HTTP请求报文的内容，按其要求查找首页内容，给用户PC发送HTTP响应报文。 请求报文内容是获取对应的网页内容。 此处同①中UDP的端口号设置、报文段包装、客户端解析。 UDP和TCP的对比这两个运输层协议的使用频率仅次于网络层的IP协议。 UDP：User Datagram Protocol TCP：Transmission Control Protocol UDP和TCP都支持全双工通信。 通信前，UDP不需要连接。TCP**面向连接(**三握手四挥手) UDP 支持单播、多播、广播。TCP 只能通过三次握手单独建立连接，仅支持单播。 UDP 面向应用报文，TCP 面向字节流。 UDP 对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界。 TCP 将字节流编号存储在发送缓存中，根据发送策略，将缓存分段发送。 对于TCP： 对于收到的数据，接收方一方面取出数据载荷部分存储在接收缓存中，一方面直接将接收缓存中的一些字节交付给应用进程。 接收方收到的数据块数可能与发送方发出的数据块数不一致，但是收发双方收发的字节流数目一致 比如发送方要发送10个字节，分五个字节一块，一共两块，但接收方接收字节是3.3.4，一共三块 所以是TCP不保证一次性传完，这就要求应用进程有处理这种乱序、多次传输后还能拼接完整的能力. 面向字节流是TCP提供可靠传输、流量控制、拥塞控制的基础。 UDP向上层提供无连接不可靠传输服务(适用于IP电话、视频会议等实时应用) TCP向上层提供面向连接的可靠传输服务(适用于要求可靠传输的应用，例如文件传输) IP数据包向上层提供的是无连接不可靠传输服务。 UDP 用户数据报首部仅仅 8 字节，而TCP 由于要实现可靠传输等，报文段首部最小20字节，最大60字节。 流量控制 一般来说，我们希望数据传输能快一些，但如果发送方把数据发送得过快，接收方就可能来不及接收，这会造成数据的丢失 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收 利用滑动窗口实现流量控制 滑动窗口：发送窗口和接收窗口。 发送方和接收方窗口保持一致，发送方窗口随着接收方窗口变化而变化(通过确认报文告知发送方) 发送方发送完窗口内数据后需要等到确认报文才会滑动窗口并继续发送，若窗口内的某个值很久没有收到回答报文，则超时重传报文 ACK：标志位，取值1表示这是TCP确认保温段。 ack：确认号字段，取值201表示序号201之前的数据已全部确接收。 rwnd：窗口字段，取值300表示自己的接收窗口大小为300。 seq：序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号是1。 一些问题： 若接收方窗口调为0后，一段时间之后又调为200，此时向发送方传递确认报文，可此时报文丢失，则会造成发送方窗口始终为0，接收方以为发送方收到了确认报文而开始等待数据，造成死锁，如何解决？ TCP为每个连接设置一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。持续计时器超时，发送方就会发送一个1字节大小的零窗口探测报文（仅携带一字节数据）。 对方确认这个探测报文段时，通过确认报文给出自己的接受窗口值。 如果发送方窗口大小为0时，发送方重新启动持续计时器。超时后重新发送零窗口探测报文。 如果不是0，也就是接收方主机此时的接收缓存又有了一些存储空间，调整了窗口，那么死锁局面就可以被打破了。 如果主机B此时的接收窗口仍然为0，那么主机B根本就无法接受该报文段？ TCP规定，即使接收方主机接受窗口为0，也必须接受零窗口探测报文段，确认报文段以及携带紧急数据的报文段。 若发送的零窗口探测报文也丢失了，会造成新死锁吗？ 不会。因为零窗口探测报文也有重传计数器，具备超时重传机制。 拥塞控制在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况叫做拥塞(congestion) 在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的资源。 若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降 理想拥塞控制的网络：在吞吐量达到饱和之前，网络吞吐量应等于所输入的负载。故吞吐量曲线是45度的斜线。但当输入负载超过某一限度时，由于网络资源受限，吞吐量就不再增长而保持水平线。也就是吞吐量达到饱和。这就表明输入的负载中有一部分损失到了。例如输入到网络中的某些分组被某个结点丢弃了。 即便如此，网络的吞吐量仍然维持在其所能达到的最大值。 无拥塞控制的网络，输入到达一定程度会轻度拥塞，吞吐量增长变慢。严重拥塞，吞吐量甚至会不增反降，直到0。 实际的拥塞控制应该尽量接远理想的拥塞控制曲线。 下面介绍拥塞控制的四种算法： 慢开始(slow-start) 拥塞避免congestion avoidance 快重传(fast retransmit 快恢复(fast recovery) 为方便分析，下面对四种算法的描述进行了条件假设： 数据是单方向传送，而另一个方向只传送确认。 接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定 以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。 发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。 拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些(确认报文段窗口大小)，但只要网络出现拥塞，拥塞窗口就减少一些 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文(发送超时重传) 发送方将拥塞窗口作为发送窗口swnd，即swnd=cwnd 维护一个慢开始门限ssthresh状态变量 当cwnd ssthresh时，使用慢开始算法 当cwnd ssthresh时，停止使用慢开始算法而改用拥塞避免算法 当cwnd = ssthresh时，既可使用慢开始算法，也可以使用拥塞避免算法 1. 慢开始和拥塞避免 慢开始cwnd ssthresh时，拥塞窗口从1开始，根据应答报文大小来扩大拥塞窗口，也就是cwnd cwnd * 2。 如发送方窗口2，应答大小2，则下次发送大小为4 拥塞避免cwnd = ssthresh 时，拥塞窗口每次只扩大1，而不是向慢开始那样根据发送方的返回窗口进行增加。 超时重传：当窗口增加到一定大小，发送方发送的报文出现了超时重传，则判断网络可能出现了拥塞，此时：①将拥塞窗口初始化为1，②慢开始门限ssthresh设置为发生拥塞时窗口大小的一半 “拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞 2. 快重传和快恢复 慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCP Tahoe版本) 1990年又增加了两个新的拥塞控制算法(改进TCP的性能)，这就是快重传和快恢复(TCP Reno版本) 有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。 这将导致发送方超时重传，并误认为网络发生了拥塞。 发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。 快重传快重传是使发送方尽快进行重传，而不是等待超时重传计时器超时再重传 要求接收方不用等待自己发送数据时才进行捎带确认，而是要立即发送确认 即使收到了失序的报文段(说明有一段丢失了)也要立即发出对已收到的报文段的重复确认 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞。使用快重传可以使整个网络的吞吐量提高约20% 快恢复发送方一旦收到3个重复确认，就知道现在只是丢失了个别报文段。也是不启动慢开始算法，而执行快恢复算法 发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法 发送窗口不用一下子回到 1 了。 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3 既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络 这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中 可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些 超时重传、往返时间超时重传时间的选择超时重传时间 RTO的值： 短于往返，发送方会有不必要的重传，增大网络负荷。 远长于往返，使重传推迟时间太长，使网络空闲时间增大，降低了传输效率。 所以正常情况下，超时重传时间应该设为略大于往返时间。 但是，TCP下层是复杂的互联网环境，由于各区域的速率可能不一致，每个IP数据报的转发路由也可能不同。 因此将超时重传时间设置为一个固定值是行不通的 所以只能利用每次测量得到的RTT样本，计算加权平均往返时间 RTTs(又称平滑的往返时间) 显然，超时重传时间RTO应略大于加权平均往返时间RTTs 在上图式子中，0≤ α I ： 若 α 很接近于0，则新RTT样本对RTT的影响不大; 若 α 很接近于1，则新RTT样本对RTT的影响较大。 已成为建议标准的RFC6298推荐的α 值为18，即0.125 。 用这种方法得出的加权平均往返时间RTTS就比测量出的RTT值更加平滑。 往返时间测量问题 针对出现超时重传时无法测准往返时间RTT的问题，有以下解决方法 在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。 也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。 此方法的漏洞如下：如果报文段时延突然增大很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段，于是重传。根据上述算法，每次重传后，发送方都不会收到确认，但重传时间永远不会更新，发送方永远要重传，无外力作用，此过程永远不会结束，这就造成了死锁。 修正方法：报文段每重传一次，就把超时重传时间RTO增大一些，典型的做法是将RTO的值取为旧RTO的2倍 可靠传输传输时滑动窗口移动的不同情况： 向后收缩、前沿移动的情况，TCP强烈不建议出现。 因为很可能发送方在收到这个通知之前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，就会产生错误。 如何描述发送窗口的状态？使用三个指针P1，P2，P3分别指向相应的字节序号 小于P1的是已发送并已收到确认的部分; 大于等于P3的是不允许发送的部分; P3-P1发送窗口的尺寸; P2-P1已发送但尚未收到确认的字节数; P3-P2允许发送但当前尚未发送的字节数(又称为可用窗口或有效窗口) 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。 网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。 发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。 对于**不按序到达的数据应如何处理，**TCP并无明确规定。 如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做不利于对网络资源的利用。因为发送方会重复传送较多的数据。 TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。 当缺少字节还未收到时，只能对已到达的数据进行确认，而不滑动窗口。这意味着接收方发送的确认序号仍然是缺少字节的最小序号。 TCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。 接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。 TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]。 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向向TCP服务器进程发送TCP连接请求报文段上发送数据。 TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。 运输连接管理TCP连接建立：三握手TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。 TCP的连接建立要解决以下三个问题: 使TCP双方能够确知对方的存在; 使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等); 使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配。 建立过程： 最初，两端的TCP进程都处于关团状态。 一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。 例如，TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号。 此时，TCP服务器进程就进入监听状态，等待TCP客户进程的连接请求。 对于TCP服务器，TCP服务器进程是被动等待来自TCP客户进程的连接请求，而不是主动发起。因此称为被动打开连接。 对于TCP客户，由于TCP连接建立是由TCP客户主动发起的，因此称为主动打开连接。 TCP客户进程也是首先创建传输控制块。然后，在打算建立TCP连接时，并进入同步已发送状态。 进入“三报文握手” SYN为1：同步位，表明这是一个TCP连接请求报文段。 该报文段不能携带数据，但会消耗一个序列号seq ACK=1：确认位，代表这是普通确认报文段，ackx+1表示这是对报文段序列号seqx的确认 ack=x+1：这是对TCP客户进程所选择的初始序号的确认。 该报文段同样不能携带数据。同样会消耗一个序列号seq seq ：序号字段 ，被设置了一个初始值x，作为TCP客户服务器进程所选择的初始序号。 TCP连接释放：四挥手通信结束后，TCP通信双方都可以释放连接。现在TCP客户进程和TCP服务器进程都处于连接已建立状态。 假设使用TCP客户进程的应用进程通知其主动关团TCP连接，TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态。 FIN：终止位 ACK：确认位 上面两个位都为1，表明这是一个TCP连接释放报文段。 TCP规定终止位 FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。 seq:序号字段。 ack:它等于TCP客户选程之前已收到的、数据的最后一个字节的序号加1. TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。 TCP客户进程在发送完最后一个确认报文段后，必须进入时间等待状态，2MSL后才进入关闭状态。因为要防止发给服务器的确认报文丢失。 客户端发起关闭请求，一去一回后进入半关闭状态【客户端不再发送数据，服务端可能还会发】 服务器将自己剩余的数据发送完后也发送一个关闭请求，接着客户端给予回应后服务器关闭，客户机则要等到一段时间后完全关闭。 问题：TCP客户进程在发送完最后一个确认报文段后，为什么不直接进入关闭状态，而是要进入时间等待状态，2MSL后才进入关闭状态？ 回答： 因为这必然会造成TCP服务器进程反复重传TCP连接释放报文段，并一直处于最后确认状态而无法进入关闭状态。 时间等待状态以及处于该状态2MSL时长，可确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。 另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间肉所产生的所有报文段都网络中消失。这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。 TCP中保活计时器的作用： TCP 首部格式 源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程 目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程 序号：占32比特，取值范围[ 0 , 2^32^ − 1 ] ，序号增加到最后一个后，下一个序号就又回到0。 作用是指出本TCP报文段数据载荷的第一个字节的序号 确认标志位ACK：取值为1时确认号字段才有效，为0时确认号字段无效 确认号：占32比特，取值范围[ 0 , 2 ^32^ −1 ] ，序号增加到最后一个后，下一个序号就又回到0。 可理解为若确认号n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据 数据偏移：占4比特，并以4字节为单位 用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处。这个字段实际上是指出TCP报文段的首部长度 首部固定长度为20字节，因此数据偏移字段的最小值(0101)2；首部最大长度为60字节，因此数据偏移字段最大值为(1111)2 保留字段：占6比特，保留为今后使用，但是目前应置为0 窗口：占16比特，以字节为单位。指出发送本报文段一方的接收窗口 窗口值作为接收方让发送方设置其发送窗口的依据，这是以接收方的接收能力来控制发送方的发送能力，称为流量控制 检验和：占16比特，检测范围包括TCP报文段的首部和数据载荷两部分 在计算校验和时，要在TCP报文段的前面加上12字节的伪首部 同步标志位SYN：在TCP连接建立时用来同步序号 终止标志位FIN：用来释放TCP连接 复位标志位RST：用来复位TCP连接 当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接；RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接 推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付 紧急标志位URG：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。 紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度 当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据 选项：增加选项可以增加TCP的功能 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度 窗口扩大选项：为了扩大窗口(提高吞吐率) 时间戳选项： 用来计算往返时间RTT 用于处理序号超范围的情况，又称为防止序号绕回PAWS 选择确认选项：实现选择确认功能 填充：由于选项长度可变，因此使用填充来保证报文段首部能被4整除"},{"title":"淘宝网抓取月销量的课设","path":"/wiki/python/淘宝网抓取月销量的课设.html","content":"Github仓库： https://github.com/Back2Zer0/md-CS_Note/tree/master/python/python%E8%AF%BE%E8%AE%BE Your browser does not support the video tag."},{"title":"爬虫入门1","path":"/wiki/python/爬虫入门1.html","content":"杂项简单的爬虫爬虫概念：编写程序获取互联网资源 from urllib.request import urlopenurl = http://www.baidu.comresp = urloepn(url)with open(mybaidu.html, mode=w) as f: f.write(resp.read().decode(utf8)) 得到模拟百度首页的内容。 两种Request Method:POST 、 GET 两种渲染方式： 服务器渲染：由服务器把html和数据结合在一起统一发给客户端 客户端渲染：两次请求。第一次请求服务器发送html骨架，第二次请求拿到数据 区别方式：在页面源代码中是否能看到数据 HTTP协议协议：两个计算机之间为了能流畅沟通设置的一个君子协定。常见协议：TCPIP，HTTP HTTP：Hyper text Transfer Protocol（超文本传输协议） 请求和相应分三块：请求： 请求行：请求方式，请求url地址，协议 请求头：服务器需要的附加信息 请求体：参数 响应： 状态行：协议，状态码 响应头：客户端使用的附加信息 服务器返回给客户端的内容（HTML，json） 两种openwith open(baidutest.html, mode=w,encoding = utf8) as f1: f1.write(resp.read().decode(utf-8)) f2 = open(baidutest.html, mode=w,encoding = utf8)f2.close() 三种输出方式i = 1print(asdas:ddasd.format(i))print(fasdasidasd)print(asdas%ddasd%(i)) 数据提取问题有三种解析方案：re解析，bs4解析，xpath解析 re模块的应用豆瓣想读爬虫 import re, requests , csvhead = User-agent:OperaWin7:Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50obj = re.compile(rli class=subject-item.*?title=(?Pname.*?).*?div class=pub(?Pinformation.*?)/div, re.S)f = open(pics.csv, mode= w, encoding= utf8, newline= )csvwrite = csv.writer(f)i = 0while i 1141: url = https://book.douban.com/people/211783344/wish?start= + str(i) resp = requests.get(url=url, headers=head) res = obj.finditer(resp.text) for it in res: dic = it.groupdict() dic[name] = 《 + dic[name].strip() + 》 ---- dic[information] = dic[information].strip() csvwrite.writerow(dic.values()) i = i + 15f.close()resp.close() 电影天堂超链接爬虫 import requests, redomain = http://www.dytt89.com/resp1 = requests.get(url= domain,verify=False)resp1.encoding = gb2312obj1 = re.compile(2022必看热片.*?ul(?Pul.*?)ul,re.S)obj2 = re.compile(lia href=(?Phref.*?).*?(?Pfilm.*?)/a,re.S)obj3 = re.compile(◎片 名(?Pname.*?).*?td style=WORD-WRAP:.*?href=(?Pdownload.*?)magnet:,re.S)res1 = obj1.search(resp1.text)ul = res1.group(ul)res2 = obj2.finditer(ul)for it2 in res2: url = domain.rstrip(/) + it2.group(href) resp2 = requests.get(url,verify=False) resp2.encoding = gb2312 res3 = obj3.finditer(resp2.text) for it3 in res3: print(it3.group(name).strip(),end=:) print(it3.group(download)) bs4库： from bs4 import BeautifulSoup 常见方法： #BeautifulSoupmain_name = BeautifulSoup(resp.text, html.parser)#find_all 和 find:find_all搜寻所有满足条件代码并插入到列表，find就近找，bs4形式taotus = main_page.find_all(div, class_= taotu-main) 属性和关键字重复时： # table = page.find(table, class_=hq_table) # class是python的关键字table = page.find(table, attrs=class: hq_table) #和上一行是一个意思. 此时可以避免class 示例：爬取唯美图片 #1.拿到主页面源代码，提取子页面链接地址，href#2.href找到子页面内容，子页面内提取图片连接#3.根据图片链接下载import requestsfrom bs4 import BeautifulSoupurl = https://www.umei.cc/bizhitupian/resp = requests.get(url)resp.encoding = utf8#源码交给bs4，指定html解释器main_page = BeautifulSoup(resp.text, html.parser)# 范围第一次缩小# 参数名后加“_”,区分参数名和关键字taotus = main_page.find_all(div, class_= taotu-main)for taotu in taotus: pictures = taotu.find_all(p) for picture in pictures: # get 拿子网页链接 href = picture.find(a).get(href) #拿子网页源码 child_page_resp = requests.get(fhttps://www.umei.cc/href) child_page_resp.encoding = utf8 cptext = child_page_resp.text child_page = BeautifulSoup(cptext, html.parser) page = child_page.find(div,class_=big-pic) #注意_ a = page.find(a) img = a.find(img) src = img.get(src) #下载图片 img_resp = requests.get(src) img_name = src.split(/)[-1] with open(img+img_name, mode=wb) as f: f.write(img_resp.content) xpathxpath是xml文档中搜索内容的一门语言。html 又是 xml 的一门语言。 from lxml import etreename = etree.HTML()name = etree.XML()xpath(/book) #/name 指 name层级 ， 第一个/指根节点#1. //指所有该层级之后的内容（后代）#2. /*指通配符，所有当前层级的目录（而非内容） 语法入门： !DOCTYPE htmlhtml lang=en head meta charset=UTF-8 / titleTitle/title /head body ul lia href=http://www.baidu.com百度/a/li lia href=http://www.google.com谷歌/a/li lia href=http://www.sogou.com搜狗/a/li /ul ol lia href=feiji飞机/a/li lia href=dapao大炮/a/li lia href=huoche火车/a/li /ol div class=job李嘉诚/div div class=common胡辣汤/div /body/html from lxml import etreetree = etree.parse(b.html)result1 = tree.xpath(/html/body/ol/li/a[@href=feiji]/text()) #参数（此概念可能不明确）result2 = tree.xpath(/html//li/a/text()) result3 = tree.xpath(/html/body/ul/li)for it in result3: temp1 = it.xpath(./a/text()) # ./表当前路径 print(temp1) temp2 = it.xpath(./a/@href) # 输出当前路径的参数值 print(temp2) temp3 = it.xpath(./a[postion()1]) # 索引大于1的属性 示例（爬取猪八戒网） from lxml import etreeimport requestsresp = requests.get(https://cangzhou.zbj.com/search/service/?kw=saasl=0r=2)tree = etree.HTML(resp.text)divs = tree.xpath(/html/body//div[@class=search-result-list-service search-result-list-service-width]/div)for div in divs: name = div.xpath(.//div[@class = name-pic-box]/a/text()) price = div.xpath(./div//div[@class = price]/span/text()) print(price,end= ) print(name) for div in divs: price = div.xpath(./ div / div[3] / div[1]/span/text()) name = div.xpath(./div/div[2]/div[2]/a/text()) print(price,end= ) print(name)#绝对路径不靠谱，网页的布局可能不遵循规律，而且更新后要重新定位。#所以直接找变量是更好的方法（像上面那样[@]） 要熟悉抓包工具，找到网页内容，方便解析（精准抓取） cookiecookie:网站用于识别用户的一连串代码 步骤： 登陆 -得到 cookie 带着 cookie 请求到书架的 url -得到书架上的内容 这两个步骤需要合并在一起，即第二步的进行需要立即使用第一步的信息 方法一： import requests#1 利用post的data参数url = https://passport.17k.com/ck/user/logindata = loginName: 15532608912, password: asd123sess = requests.session()sess.post(url, data= data, )resp = sess.get(https://user.17k.com/ck/author/shelf?page=1appKey=2406394919)print(resp.json()) 方法二： #2 利用cookie（跳过post）,也就不需要sessionurl = https://passport.17k.com/ck/user/loginhead = cookie:GUID=31f82c40-9141-4860-a059-8eb54cb91250; sajssdk_2015_cross_new_user=1; Hm_lvt_9793f42b498361373512340937deb2a0=1668070477; c_channel=0; c_csc=web; accessToken=avatarUrl%3Dhttps%253A%252F%252Fcdn.static.17k.com%252Fuser%252Favatar%252F00%252F00%252F03%252F99430300.jpg-88x88%253Fv%253D1668071104000%26id%3D99430300%26nickname%3D%25E4%25B9%25A6%25E5%258F%258B777e827gw%26e%3D1683623230%26s%3Db904c643179ed595; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2299430300%22%2C%22%24device_id%22%3A%2218460bf8d334a4-012d512c1dffe8-3e604809-1049088-18460bf8d3414f%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E5%BC%95%E8%8D%90%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fgraph.qq.com%2Foauth2.0%2Fshow%3Fwhich%3DLogin%26display%3Dpc%26response_type%3Dcode%26client_id%3D215314%26scope%3Dget_user_info%26redirect_uri%3Dhttps%253A%252F%252Fpassport.17k.com%252Fsns%252FqqCallback.action%253FfromUrl%253Dhttp%22%2C%22%24latest_referrer_host%22%3A%22graph.qq.com%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC%22%7D%2C%22first_id%22%3A%2231f82c40-9141-4860-a059-8eb54cb91250%22%7D; Hm_lpvt_9793f42b498361373512340937deb2a0=1668071834resp = sess.get(https://user.17k.com/ck/author/shelf?page=1appKey=2406394919,headers= head)print(resp.json()) 反反爬：防盗链防盗链示例网站：梨视频 分析 首先梨视频官网采用二次传输（客户端渲染？），第二次才传送视频信息。这意味着网站源代码里看不到视频信息。 首先可以在页面检查里找到视频播放地址，因为它是实时更新的。 视频代码： video webkit-playsinline= playsinline= x-webkit-airplay= autoplay=autoplay src=https://video.pearvideo.com/mp4/short/20170818/cont-1135255-10772797-hd.mp4 style=width: 100%; height: 100%;/video src后面即使视频播放地址。 既然是二次刷新，应该在网页打开的过程中传送文件。 检查项里 Network 中找到了唯一一个XHR文件，标题就是 videoStatus... 在文件的preview里，能找到,里面有个srcUrl： https://video.pearvideo.com/mp4/short/20170818/1668059979658-10772797-hd.mp4 这个地址和上面视频的真正的地址，差别在于cont-数字那部分。这个cont-数字是在爬取中需要替换的关键位置。 被替换数据：在同一个XHR文件里， systemTime 参数即srcUrl中我们要替换的那串数字 替换数据：每个视频都有相同的cont-,后面的数字和梨视频展现该视频的网页网址有关。 示例视频官网网页为：https://www.pearvideo.com/video_1135255 cont-1135255即替换数据。 经过上述分析，确认以下步骤。 找到视频对应网页 找到抓包到的XHR文件中的srcUrl内容 防盗链 这一步需要连接文件header中的Request URL，在连接时，会遇到“文章已下线”的问题（即使网页并未关闭），这就是防盗链的作用。 如果正常网页的连接过程为1-2-3 ，防盗链会在连接2或3时进行回溯，即查看前面的步骤是否完整。如果是NULL-2 , 这个2就会引起怀疑，拒绝连接要求。 解决办法 : 如同补充User-Agent一样，在连接时的header参数中补充 Referer 数据。 替换srcUrl内容 下载新地址对应的目标视频 再抽象到代码层面： 拿到cont-id 拿到videoStatus里的srcUrl（json格式） 以cont-id替换srcUrl内容 下载视频 代码实现 import requests# 1. 拿到cont-idurl = https://www.pearvideo.com/video_1135255cont_id = url.split(_)[-1]# 2. 拿到videoStatus里的srcUrl（json格式） #注意防盗链head= User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36, Referer:url,videoStatus = fhttps://www.pearvideo.com/videoStatus.jsp?contId=cont_idmrd=0.768106800161237resp = requests.get(videoStatus, headers= head, )dic = resp.json()srcUrl = dic[videoInfo][videos][srcUrl]systemTime = dic[systemTime]# 3. 以cont-id替换srcUrl内容srcUrl = srcUrl.replace(systemTime,fcont-cont_id)# 4. 下载视频with open(asd.mp4,mode=wb) as f: f.write(requests.get(srcUrl).content)resp.close() 代理import requestsproxies = https:http://114.86.181.92resp = requests.get(https://www.baidu.com)resp.encoding = utf8print(resp.text) 代理：类似找黄牛买票，更换自己的IP地址来进行目标服务器访问。"},{"title":"爬虫入门2","path":"/wiki/python/爬虫入门2.html","content":"线程库：threading 概念： 区分线程和进程 线程：执行单位。 它被包含在进程之中，是进程中的实际运作单位。 线程是操作系统能够进行运算调度的最小单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程：资源单位。进程是程序的实体，每个进程都要占用一定内存。 计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 进程里必定有至少一个线程。进程如同项目，线程如同员工，项目的运作至少需要一个员工。 多进程应用： 方法 from threading import Threaddef func(): for i in range(1,1000): print(fChild :i)t = Thread(target= func) # t 为线程对象，Thread里的target参数设置工作内容t.start() #设置线程状态为 开始 （只是状态，实际执行时间由CPU决定）if __name__ = __main__: for i in range(1,1000): print(fBase :i) 类 from threading import Threadclass Mythread(Thread): #继承 Thread 类 def run(self): #固定格式，线程状态开启，自动运行 for i in range(1, 1000): print(fChild :i)if __name__ == __main__: t = Mythread() #t.run #直接调用，为当前线程的单线程执行 t.start() #开启线程 for i in range(1,1000): print(fBase :i) 遇到参数： 方法 from threading import Threaddef func(dj): for i in range(1,1000): print(dj,i)#args 参数必须以元组形式发出t1 = Thread(target= func,args=(Jay_Z, )) t1.start()t2 = Thread(target= func,args=(kan_ye, ))t2.start() 类 from threading import Threaddef func(dj): for i in range(1,1000): print(dj,i)#args 参数必须以元组形式发出t1 = Thread(target= func,args=(Jay_Z, )) t1.start()t2 = Thread(target= func,args=(kan_ye, ))t2.start() 多进程 多线程应用的API和多进程一样，只是使用库为 multiprocessing . Process from multiprocessing import Process (这只是因为Python方便用户设置的，实际两者底层原理完全不同) 线程池线程池：一次性开辟一些线程，用户直接给线程池子提交任务，线程任务的调度交给线程池来完成 from concurrent.futures import ThreadPoolExecutor ,#打个比喻，这里50个线程可以理解成50个人，for...range(100)相当于有100个任务，#每个任务是从1数到1000，只要一个人（线程）数完了（执行完1-1000），就可以继续数下一个任务def fn(name): for i in range(1000): print(name, i)if __name__ ==__main__: #创建线程池 (该例中有50个线程) with ThreadPoolExecutor(50) as t: for i in range(100): t.submit(fn, name=f线程i) #线程池任务全部执行完毕后，才继续执行(守护) print(over) 进程池： 可以提供指定数量的进程给用户使用, 即当有新的请求提交到进程池中时，如果池未满，则会创建一个新的进程用来执行该请求; 反之，如果池中进程数为最大值，则请求等待；池中有进程空闲，则请求得到执行。 线程池示例：新发地菜市场价格爬取 # 1. 如何提取单个页面的数据# 2. 上线程池,多个页面同时抓取import requestsfrom lxml import etreeimport csvfrom concurrent.futures import ThreadPoolExecutorf = open(data.csv, mode=w, encoding=utf-8)csvwriter = csv.writer(f)def download_one_page(url): # 拿到页面源代码 resp = requests.get(url) html = etree.HTML(resp.text) table = html.xpath(/html/body/div[2]/div[4]/div[1]/table)[0] trs = table.xpath(./tr[position()1]) # 拿到每个tr for tr in trs: txt = tr.xpath(./td/text()) # 对数据做简单的处理: “\\\\”， “/”去掉 txt = (item.replace(\\\\, ).replace(/, ) for item in txt) # 把数据存放在文件中 csvwriter.writerow(txt) print(url, 提取完毕!)if __name__ == __main__: # 创建线程池 with ThreadPoolExecutor(50) as t: for i in range(1, 200): # 199 * 20 = 3980 # 把下载任务提交给线程池 t.submit(download_one_page, fhttp://www.xinfadi.com.cn/marketanalysis/0/list/i.shtml) print(全部下载完毕!) 协程概念：当程序遇见了IO操作的时候，可以选择性切换到其他任务上。 这种切换： 微观上是一个任务切换到另一个任务 宏观上则是多任务异步操作：多个任务同时执行（因为切换速度太快） 切换的操作：input，request.get()网络请求返回数据，sleep等。 代码示例： import time,asyncioasync def func1(): print(任务一 1) #time.sleep(3) # time.sleep为同步操作，此时异步操作会中断 await asyncio.sleep(3) print(任务一 2)async def func2(): print(任务二 1) await asyncio.sleep(4) print(任务二 2)async def func3(): print(任务三 1) await asyncio.sleep(5) print(任务三 2)if __name__ == __main__: # tasks = [func1(),func2(),func3()] #这种写法3.8以后会有警告 tasks = [ asyncio.create_task(func1) asyncio.create_task(func2) asyncio.create_task(func2) ] t1 = time.time() asyncio.run(asyncio.wait(tasks)) t2 = time.time() print(t2-t1) # 单进程同步操作：12.028307676315308 # 多进程异步操作：5.009987115859985 create_task问题：这个问题对应警告（DeprecationWarning: The explicit passing of coroutine objects to asyncio.wait() is deprecated since Python 3.8, and scheduled for removal in Python 3.11） 把协程对象创建成一个任务，即task对象，将多个task对象包装在一起就没问题了。 (原来是包装好准备协程对象后同时执行，现在写法是逐个执行) 2.await 挂起操作 ：必须在 async 函数里，且要放在协程对象前面 异步初涉：异步http请求aiohttp模块讲解请求连接操作上，request 是同步代码 ，异步代码你得用 aiohttp 模块中的 aiohttp.ClientSession() (也许你会想到 cookie 中的会话) 示例（爬取唯美图片） import aiohttpimport asynciourls = [ http://kr.shanghai-jiuxin.com/file/2022/0607/0d0208537886e225a5902e1001b2c702.jpg, http://kr.shanghai-jiuxin.com/file/2022/0607/b690bb5677be51cf12fe5b7638faf6b9.jpg, http://kr.shanghai-jiuxin.com/file/2022/0607/b3238e128301a37d24f65157d25fe3a9.jpg]async def download(url): name = url.rsplit(/,1)[1] #懒得起名字 async with aiohttp.ClientSession() as S: #1. 发送请求 async with S.get(url) as resp: #2. 得到内容 with open(name, mode=wb) as f: #3. 下载图片 f.write(await resp.content.read()) #读取内容操作是异步的，要挂起 await print(name,文件已下载) #S.get() / S.post() == request.get() / .post() #S.text()/json() == resp.text() /.post()async def main(): tasks = [] for url in urls: tasks.append(asyncio.create_task(download(url)))\t#包装链接（任务网址）为一个列表 await asyncio.wait(tasks)if __name__ == __main__: asyncio.run(main()) 简单的异步爬虫爬取百度小说内容 1.同步操作：连接目录网址，拿到cid和book_id #def getId2.异步操作： 根据cid和book_id 连接内容网址，拿到小说内容 3.下载 #def getContendimport jsonimport aiofiles import aiohttpimport requestsimport asynciourl1 = http://dushu.baidu.com/api/pc/getCatalog?data=book_id:4306063500url2 = http://dushu.baidu.com/api/pc/getChapterContent?data=book_id:4306063500,cid:4306063500|1569782244,need_bookinfo:1async def getContend(book_id,cid,title): data = book_id:book_id , cid:fbook_id|cid , need_bookinfo:1 data = json.dumps(data) url = fhttp://dushu.baidu.com/api/pc/getChapterContent?data=data async with aiohttp.ClientSession() as s: async with s.get(url) as resp: dic = await resp.json() # 协程对象 async with aiofiles.open(title+.txt, mode=w,newline= ,encoding=utf8) as f: await f.write(dic[data][novel][content])async def getId(): tasks = [] resp = requests.get(url1) dic = resp.json() book_id = dic[data][novel][book_id] print(book_id) for it in dic[data][novel][items][0:5]: #切个片 title = it[title] cid = it[cid] tasks.append(asyncio.create_task(getContend(book_id,cid,title))) await asyncio.wait(tasks)if __name__ == __main__: asyncio.run(getId()) 一般视频爬虫思路网站服务器把整个源视频发送给客户端是很少见的： 传输整个视频文件太大，传输速度很慢 ，花费流量高 用户会拉进度条，存在资源浪费 一般视频网站存储思路： 用户上传 —— 转码（不同清晰度） —— 切片（将大文件视频切成连续的一小段） 切片意味着需要一个文件来保证片段的有序性，也就是记录 视频播放顺序和视频存放路径。当然这个文件还可以附加视频码率等其他信息。 通常该文件格式为 M3U8 。 示例： #EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:4 #每个视频切片最大时长#EXT-X-PLAYLIST-TYPE:VOD#EXT-X-MEDIA-SEQUENCE:0#EXT-X-KEY:METHOD=AES-128,URI=*/key.key#切片文件加密方式和秘钥地址（如果有加密，则要先解密才能播放）#EXTINF:2, #持续时间https://hey07.cjkypo.com/20220505/9BS0wTIh/1100kb/hls/dsZ27s7p.ts #ts文件的地址#EXTINF:2,https://hey07.cjkypo.com/20220505/9BS0wTIh/1100kb/hls/Gw8DtNn5.ts#EXTINF:2,https://hey07.cjkypo.com/20220505/9BS0wTIh/1100kb/hls/EZ0UlXoC.ts#EXTINF:2,https://hey07.cjkypo.com/20220505/9BS0wTIh/1100kb/hls/MNb9yXCB.ts#EXTINF:2,https://hey07.cjkypo.com/20220505/9BS0wTIh/1100kb/hls/JisT83Nx.ts 反爬（示例网站：91视频）： m3u8文件的响应头 url 和视频网址源代码中的url有所差别： response header: https://m3api.awenhao.com/index.php?note=kkRphqrd5sykfam43wzx1raw=1n.m3u8source code: https://m3api.awenhao.com/index.php?note=kkRtxaw975rd6qcbnz3jfraw=1n.m3u8 note 中间部分会有部分字符串不同的情况（动态）。这是反爬的一种机制（仅就示例而言）。 播放视频有两步： 客户端访问html请求到服务器 —— 服务器返回html页面源代码 客户端请求得到m3u8文件播放视频 —— 服务器返回m3u8文件 在第一步进行时，服务器会生成一个动态字符串，这个字符串会赋值到接下来的m3u8文件，两者互相对应。 这样能保证先进行html页面请求，再请求m3u8的正常流程。直接请求m3u8的爬虫机制会因为动态字符串不匹配被驳回。 （动态字符串有时效性，如同5分钟验证码这种。页面长时间没有请求m3u8文件操作，也会造成m3u8响应失效，需要刷新网址重新请求） 抓取视频思路： 找到 m3u8 （各种手段） 通过 m3u8 下载 ts 文件 通过各种手段把 ts 文件合并到一起 示例代码(91看剧爬取ts)： #resp 的 text / content ，字节流和字符串的格式变换太难受了，这段代码仅供参考，实操未成功import requestsimport reurl = http://91kanju2.com/vod-play/47487-1-1.htmlresp = requests.get(url)obj = re.compile(rurl: (?Purl.*?),,re.S)m3u8_url = obj.search(resp.text).group(url)resp.close()resp2 = requests.get(m3u8_url)#这里相当坎坷，不具备普适性。但探究精神值得借鉴。resp3 = requests.get(https://v4.cdtlas.com/+ resp2.text.split(/,1)[1].rstrip()) s = resp3.content.decode(utf-8)n = 0for line in s line = line.strip() if line.startswith(#): continue print(line) resp4 = requests.get(line) with open(fn.ts,mode=wb) as f: f.write(resp4.text) resp4.close() n += 1resp3.close()resp2.close() 两个大作业普通爬虫爬取网易云音乐评论91视频selenium"},{"title":"湖科大(6)应用层","path":"/wiki/network/湖科大(6)应用层.html","content":"应用层应用层概述 应用层：解决通过应用进程的交互来实现特定网络应用的问题 运输层：解决进程之间基于网络的通信问题 网络层：解决分组在多个网络上传输(路由)的问题解决 数据链路层：分组在一个网络(或一段链路)上传输的问题 物理层：解决使用何种信号来传输比特的问题 应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。 早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组) 20世纪90年代将因特网带入干家万户的万维网WWW 当今流行的即时通信、P2P文件共享及各种音视频应用计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台。 在本章中，我们以一些经典的网络应用为例来学习有关网络应用的原理、协议和实现方面的知识。 CS 客户-服务器方式 和 P2P 对等方式 网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。 开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系目前流行的主要有以下两种: 客户服务器(ClientServer，CS) 方式 对等(Peer-to-Peer，P2P) 方式 客户服务器方式(CS) 客户服务器 客户和服务器是指通信中所涉及的两个应用进程 客户服务器方式所描述的是进程之间服务和被服务的关系 客户是服务请求方，服务器是服务提供方 服务请求方是客户程序，称为客户进程，运行客户进程的主机称为客户计算机。 服务提供方是服务器程序，称为服务器进程，运行服务器进程的主机称为服务器计算机。 服务器总是处于运行等待状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址 CS方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是CS方式包括万维网WWW、电子邮件、文件传输FTP等。 基于C/S方式的应用服务通常是服务集中型的，即应用服务集在网络中比客户计算机少得多的服务器计算机上 由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况 为此，在C/S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器 对等方式（P2P方式） 对等(Peer-to-Peer，P2P)方式 在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。 目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。 基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。 P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。 P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大。 P2P 网络特点： ▪非中心化 ▪可扩展性 ▪健壮性 ▪高性价比 ▪隐私保护 ▪负载均衡 优势与客户端服务器网络相比，其： 优势： 可在网络的中央及边缘区域共享内容和资源。在客户端服务器网络中，通常只能在网络的中央区域共享内容和资源。 由对等方组成的网络易于扩展，而且比单台服务器更加可靠。单台服务器会受制于单点故障，或者会在网络使用率偏高时，形为瓶颈。 由对等方组成的网络可共享处理器，整合计算资源以执行分布式计算任务，而不只是单纯依赖一台计算机，如一台超级计算机。 用户可直接访问对等计算机上的共享资源。网络中的对等方可直接在本地存储器上共享文件，而不必在中央服务器上进行共享。 不足 影响用户计算机的性能对等网络中的计算机需要同时承担服务器与工作站两方面的任务，这就使原先的单用户计算被当作多用户计算机来使用。在进行大批量的数据交换时，网络的性能会受到较大的影响。 网络安全性较差在对等网络中，资源不是被集中存放在某些计算机中，而是分散地位于整个网络之中，被若干用户所管理着，无法保证所有的用户都可以保护好各自的资源。另外对等网络中用户账号与密码的管理也是个重要问题，一个用户要记忆多套账号与密码才可以访问不同计算机中的资源。 备份、恢复资源困难对等网络中的资源较为分散，对所有计算机中的资源进行备份与恢复都是较为复杂的。由于上述特点，对等网络适用于用户少、规模小及安全性能要求较低的场合。 动态主机配置协议DHCP应用场景 如何配置用户主机的网络信息，才能使用户主机正常访问Web服务器? 手工配置的工作量大，且容易出错! 通过DHCP服务器为指定网段主机配置网络信息，像分配IP地址、子网掩码、默认网关、DNS服务器等自动完成。 DHCP使用 CS 方式！ 使用运输层UDP提供的服务。 DHCP服务器使用的UDP端口是67，DHCP客户使用的UDP端口是68。 工作过程 DHCP客户机首先进行广播寻找DHCP服务器(“DHCP发现“消息)，源地址为本机0.0.0.0，目的地址为广播地址255.255.255.255 之所以源地址IP为0.0.0.0，这是因为主机目前还未分配到IP地址，使用网络地址代替。 之所以广播，是因为主机并不知道网络中有哪几个DHCP服务器，以及它们的IP地址各是什么。 DHCP服务器收到发现报文后，根据其中封装的DCHP客户端MAC地址来查找自己的数据库，看是否有针对该MAC地址的配置信息。如果有直接发送，没有使用默认配置信息构建。 注意：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会通过ARP协议确认此地址未被网络中其他主机使用。 返回”DHCP提供报文“消息，其中包含提供给DHCP客户机的IP地址和相关配置信息。源地址为DHCP服务器地址，目的地址为广播地址(因为此时目的客户机还没有IP地址) 网络层所有主机都会收到该IP数据报(DHCP发现报文)，并对其层层解封继而发现UDP用户数据报。 对于DHCP客户，其应用层没有监听该UDP用数据报目的端口67的进程，因此无法交付DHCP发现报文，只能丢弃。 对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并作出响应。 DHCP报文格式比较复杂，只需知道发现报文内部封装有事物ID和DHCP客户端的MAC地址即可。 DHCP服务器和客户收到DHCP提供报文同理，应用层应当监听端口68。 DHCP客户收到提供报文后，根据提供报文中的事物ID来判断该报文是否是自己所请求的报文。事务ID是否相符，相符表明是自己请求的报文，接受。若不符则丢弃。 提供报文中还封装了配置信息如IP地址、子网掩码、地址租期、默认网关、DNS服务器等。 客户机可能会收到多个DHCP提供消息，一般选择收到的第一个。 然后向服务器发送DHCP请求报文，来征得刚刚选择的DHCP服务器的同意。同意后才能正式使用向该DHCP服务器租用的IP地址。 报文的源地址为0.0.0.0，目的地址为255.255.255.255 。 请求报文中封装了事务ID、DHCP客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器端的IP地址。 广播地址意味着DHCP客户不用向网络中的每一个DHCP服务器单播发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器。 DHCP服务器同意后，给DHCP客户发送DHCP确认报文。 封装该报文的IP数据报的源IP地址为DHCP服务器1的IP地址; 目的地址仍为广播地址。 客户机收到DHCP确认信息后，查看其中事务ID是否相符，不符则丢弃；符合则再次使用ARP确认IP地址没有被使用，确认成功后将此IP地址应用(有一定租约)。 客户使用租用到的IP地址之前，主机还会使用ARP检测该IP地址是否已被网络中其他主机占用。 若被占用:给DHCP服务器发送:”DHCP DECLINE” 谢绝报文撤销IP地址租约，并重新发送“DHCP DISCOVER”发现报文; 若未被占用:可以使用租约中的IP地址与网络中其他主机通信了。 当IP地址租用期达到0.5倍时间时，客户机会再次向 DHCP 服务器发送请求报文，请求更新租用期。 源IP地址为之前租用到的地址。目的IP地址为服务器地址。 此时 DHCP 服务器会出现以下三种情况： 收到请求后，若DCHP服务器同意，则返回一个确认报文，其中有新的IP地址租期 收到请求后，返回否认报文，则客户机收到后立刻停止使用IP地址并重新发送”DHCP发现”报文 不响应。则在租期达到0.875倍时，DHCP客户必须重新发送”DHCP请求“报文，继续等待DHCP服务器可能做出的反应。若依然无反应，则租用期到后，客户机必须立刻停止使用当前IP地址，并重新申请新的IP地址。 客户端可随时终止DHCP服务器提供的租用期，这时只需要向DHCP服务器发送DHCP释放报文即可。源地址0.0.0.0，目的地址255.255.255.255 概括： 客户：寻找DHCP服务器 —— 发现报文 服务器：向客户提供IP地址租用 —— 提供报文 给客户挑选IP地址时，使用ARP确保IP未被占用。 客户：接受IP地址租约 —— 请求报文 服务器：确认IP地址租约 —— 确认报文 客户：使用 IP 地址 使用IP地址之前，使用ARP检测IP是否被占用。 若被占用: 给DHCP服务器发送:”DHCP DECLINE” 谢绝报文撤销IP地址租约， 并重新发送“DHCP DISCOVER”发现报文。 客户：后续的 IP地址续约 随时解除IP地址续约 DHCP中继代理 应用场景： 右边两台主机获取不到IP地址。 因为广播的 DHCP发现报文不会被路由器转发，而是丢弃。 解决方法： 给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理。 这样，路由器收到广播的DHCP发现报文，会将其单播转发给DHCP服务器。 有了中继代理，网络中各主机就可以通过DHCP自动获取网络配置信息了。 原因： 我们并不愿意在每一个网络上都设置一个DHCP服务器,因为这样会使DHCP服务器的数量太多。 域名系统DNS 我们通过输入域名网址来访问网页，可实际上计算机间的通信是通过IP地址，所以域名网址的本质上是IP地址，将域名网址与IP地址映射起来就是DNS的作用 因特网是否可以只适用一台DNS服务器？ 这种做法不可取。因为因特网的规模很大，如果只有一个服务器，肯定会因为超负荷而无法正常工作。那么一旦其出现故障，整个因特网就会瘫痪 因此现实中采用层次结构的命名树作为主机的名字(即域名)，并使用分布式的域名系统DNS DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高。由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行 域名结构 因特网采用层次树状结构的域名结构。 域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名。 … .三级域名.二级域名.顶级域名 一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。 级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。 完整的域名不超过255个字符。 域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思 各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理 【举例】湖南科技大学网络信息中心的域名 nic.hnust.edu.cn cn : 顶级域名，表示中国 edu ：在 cn 其下注册的二级域名，表示教育机构 hnust : edu 下注册的三级域名，表示湖南科技大学 nic : 该校自行管理的四级域名，表示网络信息中心 域名命名分类 顶级域名TLD(Top Level Domain)分为以下三类: 国家顶级域名nTLD：采用IS0 3166的规定。如cn表示中国，us表示美国，uk表示英国、等等。 通用顶级域名gTLD：最常见的通用顶级域名有七个，即:com(公司企业)、net(网络服务机edu(美国教育结构)、构)、org(非营利性组织)、int(国际组织)、gov(美国政府部门)、mil(美国军事部门) 反向域arpa ：用于反向域名解析，即IP地址反向解析为域名 在国家顶级域名下注册的二级域名均由该国家自行确定。 例如，顶级域名为jp的日本，将其教育和企业机构的二级域名定为ac和co，而不用 edu 和 com。 我国则将二级域名划分为以下两类: 类别域名：共7个 ac(科研机构) com(工、商、金融等企业) 注意区分：与通用顶级域名给TLD区分。 edu(教育机构) gov(政府部门) net(提供网络服务的机构) mil(军事机构) org(非营利性组织)。 行政区域名共34个，适用于我国的各省、自治区、直辖市。 例如:bj为北京市、sh为上海市js为江苏省，等等。 域名服务器区别 域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。 显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。域名服务器可以划分为以下四种不同的类型: 根域名服务器 根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。 顶级域名服务器这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。 权限域名服务器这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。 本地域名服务器 本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。**本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP，一个大学，甚至个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。**本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。 域名解析过程 递归查询：大环路，从主机上询问时，由询问服务器继续向上询问，直到顶级服务器逐级向下回复。 迭代查询：向上级询问后，被询问服务器返回IP地址到本级，由本级服务器进行查询。 负担大：因为根域名服务器要服务很多机器，用递归查询的过程中，信息会滞留在服务器中等待结果，所以负担大，本地域名服务器只服务少量设备。 使用递归查询，根域名没收到顶级域名恢复，得一直listen顶级域名服务器，迭代查询返回一个ip根服务器就没啥事了。 注意： 为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。 由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项(例如，每个项目只存放两天)。 不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。 许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。 文件传送协议FTP 将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即文件传送 文件传送协议FTP(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。 FTP提供交互式的访问，运行客户指明文件的类型与格式(如指明是否使用ASCII码)，并允许文件具有存取权限(如访问文件的用户必须经过授权，并输入有效的口令) FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件 在因特网发展的早期阶段，用FTP传送文件约占整个因特网的通信量的三分之一，而由电子邮件和域名系统所产生的通信量还要小于FTP所产生的通信量。只是到了1995年，万维网WWW的通信量才首次超过了FTP。 使用TCP传输，基于客户———服务器（CS）模型而设计的，只能是CS网络通信方式。 FTP的常见用途： 在计算机之间传输文件，尤其是用于批量传输文件。 让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器 工作原理 主动模式： 连接时，FTP客户使用随机选择的临时端口号率先发起TCP连接，目的端口是FTP服务器的21端口号。 通过三次握手后，服务器同意连接。双方构建起用于传送控制命令的TCP连接。 即这条TCP连接是FTP客户与服务器之间的命令通道。 有数据要传输时，FTP客户通过命令通道告知FTP服务器来与自己的另一个临时端口号建立TCP连接，建立数据通道。 服务器的20端口号，与使用另一个随机端口号的FTP客户，发起TCP连接建立数据通道。 这条TCP连接是FTP客户与服务器之间的数据通道，用于传送文件。 由于建立数据通道时，FTP服务器主动连接FTP客户，所以称为主动模式。 注意： 用于传送控制命令的TCP连接在整个会话过程都保持开启状态 用于传送数据的TCP连接只会在有数据传送时开启，数据结束传送后就关闭 被动模式： FTP服务器与FTP客户之间命令通道的建立，与主动模式没什么不同。 不同之处在于：有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个协商好的临时端口，被动等待TCP连接，建立数据通道。 由于建立数据通道时，FTP服务器被动等待FTP客户的连接，因此称为被动模式。 电子邮件背景： 电子邮件(E-mail)是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一。 传统的电话通信属于实时通信，存在以下两个缺点: 电话通信的主叫和被叫双方必须同时在场; 一些不是十分紧迫的电话也常常不必要地打断人们的工作或休息。 而电子邮件与邮政系统的寄信相似。①)发件人将邮件发送到自己使用的邮件服务器②)发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱③)收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件。 电子邮件使用方便、传递迅速而且费用低廉。它不仅可以传送文字信息，而且还可附上声音和图像。 由于电子邮件的广泛使用，现在许多国家已经正式取消了电报业务。在我国，电信局的电报业务也因电子邮件的普及而濒临消失。 电子邮件系统采用客户服务器方式 构成 电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议 用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件 邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱 协议包括邮件发送协议(如SMTP)和邮件读取协议(如POP3，IMAP) 工作过程 SMTP协议 简单邮件发送协议（Simple Mail Transfer Protocol） 工作原理 信息格式 电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。 一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。 首部和主体的信息都需要由用户来填写。 首部中包含一些关键字，后面加上冒号。 例如： 关键字FROM ，后面填入发件人的电子邮件地址，一般由邮件系统自动填入。 关键字TO，后面填入一个或多个收件人的电子邮件地址。 关键字Cc，后面填入一个或多个收件人以外的抄送人的电子邮件地址， 抄送人收到邮件后可看可不看邮件，可回可不回 关键字 Subject，后面填入邮件主题，反映了邮件主要内容。 To和Subject最重要，往往是必填内容。 邮件系统将自动地将信封所需的信息提取出来并写在信封上，所以用户不需要填写电子邮件信封上的信息。 用户还需撰写邮件的主体部分。这是正文核心信息。 特点： SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。 注意：ASCII码一共只有七比特。 ASCII码使用7个比特位(bit)表示一个字符,因此它的编码范围是0-127,共128个字符。 SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。 为解决SMTP传送非ASCI码文本的问题，提出了多用途因特网邮件扩展MIME(Multipurpose Intemet Mail Extensions) SMTP的转发过程需要MIME的转换与逆转换。 增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。 实际上，MIME不仅仅用于SMTP，也用于后来的同样面向ASCII字符的HTTP。 **邮件读取协议(POP)**IMAP常用的邮件读取协议有以下两个: 邮局协议POP(Post Office Protocol)，POP3是其第三个版本，是因特网正式标准。 非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。(例如创建文件夹，对邮件进行分类管理等)。 因特网邮件访问协议IMAP(InteretMessage AccessProtocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。 IMAP4是功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。 POP3和IMAP4都采用基于TCP连接的客户服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143。 基于万维网的电子邮件 通过浏览器登录(提供用户名和口令)邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。 邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。 万维网WWW 万维网并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用 万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网 浏览器最重要的部分是渲染引擎，也就是浏览器内核。负责对网页内容进行解析和显示 不同的浏览器内核对网页内容的解析也有不同，因此同一网页在不同内核的浏览器里显示的效果可能不同 网页编写者需要在不同内核的浏览器中测试网页显示效果 为了方便地访问在世界范围的文档，万维网使用**统一资源定位符URL**来指明因特网上任何种类”资源”的位置 URL的一般形式由以下四个部分组成 协议://主机:端口/路径 举例：http://www.hnust.cn:80/index.htm 在同一网站下切换不同网页时，协议、主机和端口与网站首页相同,不同的是路径和网页文件。 HTML : 超文本标记语言HTML(HyperText Markup Language) 作用：使用多种“标签”来描述网页的结构和内容 CSS : 层叠样式表CSS(Cascading Style Sheets) 作用：从审美的角度来描述网页的样式。 JavaScript ：一种脚本语言(和Java没有任何关系) 作用：控制网页的行为 由HTML、CSS、JavaScript编写的万维网文档 , 由浏览器内核负责解标和渲染。 超文本传输协议HTTP HTTP(HyperText Markup Language)定义了浏览器(即万维网进程)怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。 HTTP1.0采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接当收到响应后就立即关闭连接。 每请求一个文档就要有两倍的RTT的开销。若一个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。 为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。 HTTP1.1采用持续连接方式。 在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。 这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。 为了进一步提高效率，HTTP1.1的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。 HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。 HTTP请求报文 HTTP报文支持以下方法： HTTP响应报文 支持的状态码： 一般来说，浏览器并不会直接显示出服务器发送来的这些状态行信息，而是有更友好的界面。 例如浏览器连接超市或找不到页面显示的一些状态信息。 其背后的本质是浏览器收到了包含这条状态行的响应报文 Cookie使用Cookie在服务器上记录用户信息 早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为-种无状态的协议。这样可以简化服务器的设计。 现在，用户可以通过万维网实现各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户。 Cookie提供了一种机制使得万维网服务器能够”记住”用户，而无需用户主动提供用户标识信息。也就是说，Cookie是一种对无状态的HTTP进行状态化的技术 工作原理 用户主机中的浏览器进程，首先与万维网服务器中的服务器进程建立TCP连接。 当用户的浏览器进程初次向服务器进程发送HTTP请求报文时，服务器进程就会为其产生一个唯一的Cookie识别码。并以此为索引在服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息。 接着服务器发回HTTP响应报文。 当浏览器进程收到该响应报文后，就在一个特定的Cookie文件中添加一行，记录该服务器的域名和Cookie识别码。 当用户再次使用该浏览器访问这个网站时，每发送一个HTTP请求报文，浏览器都会从Cookie文件中读取该网站的Cookie识别码，并放到HTTP请求报文的Cookie首部行中。服务器根据Cookie识别码就可以识别出该用户，并返回该用户的个性化网页。 在响应报文中，包含有一个首部字段为Set-Cookie的首部行,该字段的取值就是Cookie识别码. 万维网缓冲与代理服务器 在万维网中还可以使用缓存机制以提高万维网的效率。 万维网缓存又称为Web缓存(WebCache)，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器(ProxyServer)。 Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源。 工作过程： 校园网中某台主机访问因特网上原始服务器，先向校园网里的代理服务器发送请求。 若代理服务器的缓存里有请求对象， 则发回包含该请求对象的响应。 没有的话，则代理服务器会向因特网上的原始服务器发送请求。 原始服务器将包含有所请求对象的响应发回给代理服务器，代理服务器将该响应存入Web缓存，然后给主机发回该响应。 若Web缓存的命中率比较高,大大减少了该链路上的通信量因而减少了访问因特网的时延。 问题： 如果本地磁盘或中间系统上的的Web缓存副本，和因特网服务器（原始服务器）中的版本不一致，该如何更新？ 回答： 原始服务器通常会为每个响应的对象设定一个修改时间字段和一个有效日期字段。 在请求报文中包含有一个首部字段为lf-modified-since的首部行，该字段的取值就是该文档的修改日期。 当校园网中的某台主机要请求原始服务器中的该文档时，它首先向校园网中的代理服务器发送请求； 若代理服务器中的该文档未过期，则代理服务器将其封装在响应报文中发回给主机。 若代理服务器中的该文档已过期，则代理服务器会向因特网上的原始服务器发送请求。 原始服务器根据该文档的修改日期，就可判断出代理服务器中存储的该文档是否与自己存储的该文档一致。 如果一致，则给代理服务器发送不包含实体主体的响应，状态码为304，短语为Not Modified; 代理服务器重新更新该文档的有效日期，然后将该文档封装在响应报文中发回给主机。 如果不一致，则给代理服务器发送封装有该文档的响应报文，这样代理服务器就更新了该文档，然后将更新后的该文档封装在响应报文中发回给主机。 问题： 按这个说，主机请求网址，代理服务器需要判断缓存文档是否过期。判断方式就是和原始服务器确认。 这意味着每次请求都得有一次代理服务器和原始服务器的通信来回。可是不用缓存，主机直接和原始服务器通信，也是一次来回啊。那缓存这个机制就没啥用处了啊? 回答 因为原始服务器有修改时间和有效时间，代理服务器在超过了有效时间后才和原始服务器里面的内容比较是否过期。 例题 防火墙防火墙 防火墙主要用于保护一个网络区域免受来自另一个网络区域的网络攻击和网络入侵行为，主要部署在网络边界，对进出网络的访问行为进行控制，安全防护是其核心特性，比如在企业网中，在与Internet接口处布置防火墙，可以起到过滤病毒、阻止黑客攻击等好处。 默认安全领域 华为防火墙的默认安全区域：Trust、DMZ和Untrust 区域名 受信任程度 安全级别 何时使用 Trust 高 85 定义内部用户所在网络 DMZ 中等 50 定义内部服务器所在网络 Untrust 低 5 定义Internet等不安全的网络 Local 代表防火墙本身 100 凡是防火墙主动发出的报文均可认为是Local区域发出的，凡是需要防火墙响应并处理的报文均可认为是Local区域接收。Local不能添加接口， 因为防火墙的所有接口都隐含属于Local区域 在网络数量较少网络中，使用默认的安全区域就可以满足划分网络的需求，反之，则需要创建新的安全区域。 安全区间 安全域间是两个安全区域的唯一道路，也可以用来描述流量的传输通道，任意两个安全区域都可构成一个安全域间。如果希望对经过这条通道的流量进行控制，就必须配置安全策略。 报文在两个安全区域之间流动时，报文从低级别的安全区域向高级别的安全区域流动时为入方向Inbound，报文从高级别的安全区域向低级别的安全区域流动时为出方向Outbound。 通信双方一定会交互报文，即安全区域的两个方向上都有报文的传输，通过设置安全区域，防火墙的安全区域之间有等级明确的域间关系，不同的安全区域代表不同网络，防火墙成为连接各个网络的节点，以此为基础，防火墙可以对各网络之间流动的报文实施管控。 三种工作模式 路由模式：采用路由模式时，可以完成ACL包过滤、NAT转换等功能，Trust与Untrust区域间有一台防护墙，防火墙左右接口IP不同，需要使用路由表指导报文的转发，此种模式就是路由。 透明模式：透明模式的防火墙支持ACL规则检查，防攻击检查、流量监控等功能，报文在防火墙当中不仅仅像是交换机的二层处理，还会对报文进行高层分析处理，两个区域IP属于同一网段，防火墙接口没有配置IP，工作成交换机模式。 混合模式：Trust与Untrust区域都使用同一网段，两台防火墙，组成主备关系，防火墙工作为路由模式，左右流量是二层转发，上下流量是三层转发。"},{"title":"inside object model3","path":"/wiki/cpp/inside object model3.html","content":"构造、析构、拷贝语意学 不要在纯虚基类里声明成员变量！ 这是《effective c++》里的一条忠告，现在我们回顾一下。 下面是个漏洞百出的例子，并且围绕漏洞会有所讨论： class Abstract_basepublic:\tvirtual ~Abstract_base() = 0;\tvirtual void interface() const = 0;\tvirtual const char* mumble() const return _mumble;protected:\tchar* _mumble; // damn bug...; //这个类需要一个显式的构造函数初始化mumble，否则后续使用很容易出问题 可能你想的是后续子类能完成初始化工作。这样想的话，纯虚基类还是要提供一个接口：带有参数的构造函数（最好还是 protected 权限）。 Abstract_base:: Abstract_base(char* mumble_value = 0) //like this\t:_mumble(mumble_value) 真是有够麻烦的……不要再提后面的使用者或修改者忘记赋值之类的问题了。。 最实用的观点还是：不要在纯虚基类里声明成员变量。 但在某些情况下，把子类共享的数据放到基类里也算是一种自然的想法和设计。 纯虚函数的存在 虽然和设计初衷相违背，但纯虚函数确实可以在虚基类里定义甚至调用。 inline voidAbstract_base:: interface() const\tfunction\t//... inline voidConcrete_derived::interface() const\t//静态调用\t//调用一个pure virtual function\tAbstract_base::interface(); //调用的方式是静态调用而非虚拟机制特有的执行期动态调用。 Pure Virtual destruction 例外是纯虚析构。你必须定义它。 因为析构“树”的存在，子类对象的析构连带着其父类的所有析构，到纯虚基类这里不能缺席啊。 准确来说：静态子类析构会被编译器扩张，静态调用其基类（包括虚基类）的析构函数。析构函数的缺失会导致链接失败。 纯虚函数定义的可能性，使编译器不会在面对纯虚析构函数时停止执行。 另外，编译器不能像默认构造函数那样自动合成纯虚析构函数。 因为编译器对可执行文件采取“分离编译模型”。编译器是看不到那些必要的信息的。 这里的结论秉承上文：不要把虚析构声明成纯虚函数。 虚拟准则（virtual specification） 所谓“虚构准则”：不要把所有成员函数都一刀切的声明为虚函数，并妄想编译器的优化操作能去除非必要的virtual-invocation。 像上例中只是返回成员变量的 Abstract_base::mumble： 因为函数定义内容和继承类型无关，完全没必要 virtual 。 它的non-virtual函数实例是个inline函数，常常调用会拉低效率。 理论上，编译器如果发现整个继承体系中只有这一个virtual函数，是否能将其调用操作转换为静态调用，并允许其调用操作的 inline expansion 呢？ 这么做以后，新的 class 加入又包含了这个单一virtual函数的虚构函数，就会破坏这个优化：函数会被重新编译，产生第二个 virtual 函数实例来配合多态。 (实例能够以二进制形式存放在 library 中) 啊，别把这些麻烦事推给编译器了，记住这句话： 不要为了图省事把所有函数声明为 virtual 。 虚拟准则中 对 const 的态度 注意：语境为虚拟继承体系中 态度：别用const 决定虚函数是否用const 使用const：预期子类对象中的 subclass object 会被使用无数次。 不适用const：该函数将不能获得一个 const 引用和指针。 真正的难题：声明为const，但发现子类对象又要修改相关成员变量。 别用const。 重新考虑 class 的声明 上例的最终版本如下： class Abstract_basepublic:\tvirtual ~Abstract_base(); //不再是pure\tvirtual void interface() const = 0; //不再是const const char* mumble() const return _mumble; //不再是virtualprotected:\tAbstract_base(char* pc = 0); //新增一个带唯一参数的constructor\tchar* _mumble;; 5.1 “无继承”情况下的对象构造下面展示产生不同对象的方式 Point global; //global 内存配置Point foobar()\tPoint local; //local内存配置\tPoint *heap = new point; //heap内存配置\t*heap = local; //把一个类对象指定给另一个（拷贝赋值） //...stuff... delete heap; //显式 delete 删除 heap object\treturn local; 注意:这里出现的 Point 数据类型尚未定义，因为接下来会根据不同情况进行分析。 情况1：质朴的C structtypedef struct\tfloat x, y, z;Point; 普及一个概念：POD —— Plain OI’ Data ，可以理解为与C兼容的 c++ 数据类型。 这里的 Point 便是 POD 。 用C++编译器编译这个POD时： 观念上Point的trival constructor和destructor都会被产生出来并被调用，constructor在程序起始处被调用而destructor在程序的exit()处被调用（exit()是由系统产生的，放在main()结束之前）。**然而，事实上那些trival members要不是没被定义，就是没被调用。**表现和C编译器没什么区别。 local变量 作为POD没有被构造也没有必要析构，但这里没有初始化 heap object Point *heap = new Point;//会被转换为Point *head = __new(sizeof(Point)); //空间而已 没有默认构造函数调用在 new 出来的 Point 对象上。 拷贝赋值 local 如果被初始化了就当然没问题，但没初始化的话问题也不大：local 对象是个POD，所以赋值操作只是简单的C风格的二进制码位搬移。 delete 操作 delete heap;//转换为__delete(heap); 这个操作理应触发编译器产生的 trival destructor，但析构函数要么没被产生要么没被调用。 函数最后通过传值方式把local传回，这也理应触发 trival constructor，但这里 return 仅仅是个位拷贝操作，因为对象是个POD。 注意例外：global 变量 —— 在C中被视为临时定义：因为它没有显式初始化操作，所以可在程序中定义多次。 定义多次的实例会被链接器折叠起来，只留下单独一个实例，存储在程序 data segment 中一个空间中。 这个空间“特别保留给未初始化的全局对象使用”，称作BBS（Block Started by Symbol）。 在C++中被视为完全定义（它会阻止第二个或更多个定义）。C++根本不支持临时定义，因为class构造行为的应用。 C和C++的一个差异就在于：C++的所有全局对象都被以“初始化过的数据”来对待。 BBS对c++来说没那么重要。 即使C++有能力判断这个类是 class object 还是 POD。 情况2：抽象数据类型class Point pubblic:\tPoint(float x = 0.0, float y = 0.0, float z = 0.0) : _x(x), _y(y), _z(z) private:\tfloat _x, _y, _z;; 情况3：为继承做准备class Point public:\tPoint(float x = 0.0, float y = 0.0) : _x(x), _y(y)\tvirtual float z();protected:\tfloat _x, _y;; 5.2 继承体系下的对象构造当我们定义了一个object，如： T object 除了会调用其构造函数外，还可能伴随大量的隐藏码：这些隐藏代码由编译器扩充。扩充程度要看 class T的继承体系。 扩充操作如下： 初始化列表：在成员初始化列表中的成员变量初始化操作会被放进构造函数本体，并以成员的声明顺序为顺序。 我个人对“以成员的声明顺序为顺序“ 存疑 成员构造函数：成员如果没有被初始化，而它本身有个默认构造函数，这个默认构造函数会被强制调用。 虚表指针（vptr):如果类对象里有虚表指针，编译器会为其设定初值来指向适当的虚表。 基类构造函数：父辈的基类构造函数会按声明顺序(和成员初始化列表无关)被调用。 如果基类在成员初始化列表中，就应把需要显式指定的参数都传递过去 基类没有在成员初始化列表中，但它有默认构造函数(默认 memberwise 拷贝构造也行)，就调用。 如果基类是多重继承下，第二或后继的基类，this 指针就要有所调整。 调用所有虚基类构造函数（从左到右，从深到浅）： 如果类在成员初始化列表中，就把需要显式指定的参数都传递过去，没有就调用默认构造函数。 类中的虚基类子对象的偏移量，要能在执行期存取。 如果类处于继承体系中最底层，其构造函数会可能被调用，所以其调用机制也要由编译器放进来。 下面结合实际例子，来看看这些扩充机制的必要性。 以Point为例（增加了拷贝函数和虚析构）: class Point Point(float x = 0.0, float y = 0.0);\tPoint(const Point);\tPoint operator=(const Point);\tvirtual ~Point();\tvirtual float z() return 0.0; protected:\tfloat _x, _y;;class Line Point _begin, _end; //它由两个点构成~public:\tLine(float = 0.0, float = 0.0, float = 0.0, float = 0.0);\tLine(const Point, const Point);\tvoid draw();； 先看看 line class 的扩充结果： 每一个显式构造函数都会扩充和调用其两个成员类对象(Point)的构造函数。 Line::Line(const Point begin, const Point end)\t:_end(end), _begin(begin) 会被编译器扩充为 Line* Line::Line(Line *this, const Point bebgin, const Point end)\tthis-_begin.Point::Point(begin);\tthis-_end.Point::Point(end);\treturn this; 于Point声明了一个copy constructor、一个copy operator，以及一个destructor，所以Line class的implicit copy constructor、copy operator和destructor都将是有具体效用的，即non-trivial。 (trivial是没意义的杂项) 再看一个例子： Line a; implicit Line copy destructor会被合成出来，同时会调用其成员类对象的析构函数(以构造的相反顺序)。 // C++伪代码:合成出来的Line destructorinline void Line::~Line(Line *this) this-_end.Point::~Point(); //虽然Point::~Point()是virtual\tthis-_begin.Point::~Point();//其调用操作仍然会静态决议，在containing class destructor中//如果Point的析构是inline函数，则会在调用地点扩展。 同理 line b = a;//mplicit line copy constructor会被合成出来，成为一个inline public member。a = b;//mplicit copy assignment operator会被合成出来，成为一个inline public member。 最后，多数编译器会缺少对自我指派情况的处理。 if(this == rhs) return *this; //like this 然而很多时候都要考虑这种情况，像拷贝操作时忘记： // 使用者供应的copy assignment operator// 忘记提供一个自我拷贝时的筛选String String::operator=(const String rhs) // 这里需要筛选(在释放资源之前) //if(this == rhs) return *this;\tdelete []str;\tstr = new char[strlen(rhs.str) + 1]; 虚拟继承虚拟继承，啊，还是继承我们的Point class 吧。 class Point3d : public virtual Point public:\tPoint3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point(x, y), _z(z) Point3d(const Point3d rhs) : Point(rhs), _z(rhs._z) ~Point3d();\tPoint3d operator=(const Point3d );\tvirtual float z() return _z; protected:\tfloat _z;; 传统的”constructor扩充现象”并没有用,这是因为 virtual base class 的”共享性”的缘故: // C++伪代码:不合法的constructor扩充内容Point3d *Point3d::Point3d(Point3d *this, float x, float y, float z) this-Point::Point(x, y);\tthis-__vptr_Point3d = __vtbl_Point3d;\tthis-__vptr_Point3d__Point = __vtbl_Point3d_Point;\tthis-_z = rhs._z;\treturn this; Point3d constructor 扩充内容有错误，这里卖个关子。 现在对不同继承层次对象的初始化策略 //看看这三种派生情况class Vertex : virtual public Point ... ;//Vertex的constructor必须也调用Point的constructor。class Vertex3d : public Point3d, public Vertex ... ; //holly shit double inherit//当Point3d和Vertex同为Vertex3d的subobjects时,它们对Point constructor的调用操作一定不可以发生,取而代之的是,作为一个最底层的class,Vertex3d有责任将Point初始化。class PVertex : public Vertex3d ... ;//更往下的继承,则由PVertex(不再是Vertex3d)来负责完成被共享的Point subobject的构造。 传统的初始化策略 传统的初始化策略如果要支持初始化虚基类,会导致constructor中有更多的扩充内容,用以指示 virtual base class constructors应不应该被调用。 constructor的函数本身因而必须尝试测试传进来的参数,然后决定调用或不调用相关的 virtual base class constructors。 下面是Point3d的扩充内容（伪码） // C++伪代码:在virtual base class情况下的constructor扩充内容Point3d *Point3d::Point3d(Point3d *this, bool __most_derived, float x, float y, float z) if (__most_derived != false) this-Point::Point(x, y);\tthis-__vptr_Point3d = __vtbl_Point3d;\tthis-__vptr_Point3d_Point = __vtbl_Point3d__Point;\tthis-_z = rhs._z;\treturn this; 在更深层的继承情况下,例如Vertex3d, 当调用Point3d和Vertex的constructor时,总是会把__most_derived参数设为 false,于是就压制了两个constructors中对Point constructor的调用操作。 // C++伪代码:在virtual base class情况下的constructor扩充内容Vertex3d *Vertex3d::Vertex3d(Vertex3d *this, bool __most_derived, float x, float y, float z) if (__most_derived != false) this-Point::Point(x, y);\t// 调用上一层base classes\t// 设定__most_derived为false\tthis-Point3d:::Point3d(false, x, y, z);\tthis-Vertex::Vertex(false, x, y);\t// 设定vptrs\t// 插入user mode\treturn this; 这样的策略得以保持语意的正确无误.例如, 当定义: Point3d origin 时， Point3d constructor可以正确地调用其Point virtual base class subobject 当定义：Vertex3d cv时， Vertex3d constructor正确地调用Point constructor.Point3d和Vertex的constructor会做每一件该做的事情——对Point的调用操作除外。 结论：只有当一个完整的类对象被定义出来（origin)，虚基类构造函数才会被调用。 如果object 只是个子对象，就不会调用。 某些新的编译器，为了产生更有效率的构造函数，将每个构造函数一分为二： 一个针对完整的object：“完整object”版无条件地调用virtual base constructor，设定所有的vptrs等。 **一个针对 subobject **：“subobject”版则不调用virtual base constructors，也可能不设定vptrs等。 vptr初始化语意学 继承体系下，构造函数的调用顺序 以 PVertex 对象为例，它的构造函数调用顺序： Point();Point3d();Vertex();Vertex3d();PVertex(); 假设每个class都定义了一个virtual function size();返回该class的大小。 我们来看看定义的PVertex constructor： PVertex::Pvertex(float x, float y, float z) : _next(0), Vertex3d(x, y, z), Point(x, y) if(spyOn)//每个构造函数内含一个调用操作 cerr Within Pvertex::PVertex() size: size() endl; 在一个类的构造函数或析构函数中，通过构造对象来调用一个虚函数，其函数实例应该是在此类中真正有作用的那个。（本例中“该类”为Point3d） 在Point3d 构造函数中调用的 size() 函数，必须被决议为 Point3d::size() 而非PVertex::size()。 基类构造函数执行时，子类还没有构造起来： Pvertex构造函数没完成前，Pvertex还不是完整对象； Point3d构造函数执行完毕后，紧紧意味着Point3d的子对象构造完毕了 构造函数顺序：由父到子，由内而外。 如何保证适当的重名函数被调用 上面的实现很妥帖，因为每个Pvertex 基类构造函数被调用时，编译器保证了适当的size函数被调用。 如何实现呢？ 静态决议每个调用操作 既然静态决议了，就不要用虚拟机制。 在Point3d 的构造函数里，就调用Point3d 的size()。 如果size()里又调用虚函数，这个调用必须决议为Point3d的函数实例。 其他情况下，这个调用会视作virtual，要通过正常虚拟机制决定执行。也就是说虚拟机制本身要知道这个调用源来不来自一个构造函数中。 在构造函数析构函数中设立一个标志 标志的作用是判断是否要以静态方式决议。 但更好的设计是执行构造函数后，让可能要调用的虚函数数量少些。 决定虚函数数量的关键是虚表。决定虚表如何处理的关键是vptr。 vptr ：决定虚函数调用的关键 vptr的决定效果来自初始化和设定操作。这些操作是编译器的责任，程序员不用瞎操心。 但还是要看看编译器怎么做到的: vptr 什么时候初始化？无非三个情况：1.在其他任何操作前 2.在基类构造函数调用后，但还没进行成员初始化。3.所有操作后 情况2 更好。 令每一个base class constructor设定其对象的vptr，使它指向相关的virtual table之后，构造中的对象就可以严格而正确地变成“构造过程所幻化出来的每一个class”的对象。 一个PVertex对象会先形成一个Point对象、一个Point3d对象、一个Vertex对象、一个Vertex3d对象，然后才成为一个PVeretex对象。 在每一个base class constructors中，对象可以与constructors’s class 的完整对象作比较。对于对象而言，“个体发生学”概况了“系统发生学”。 我的理解是“一个接一个”进化到了“整体”。 constructor的执行步骤： 在derived class constructor中，“所有virtual base classes”及“上一层base class”的constructors会被调用 上述完成之后，对象的vptrs被初始化，指向相关的virtual tables 如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。 最后，执行程序员所提供的代码 PVertex::PVertex(float x, float y, float z)_next(0), Vertex3d(x, y, z), Point(x, y)if(spyOn)cerr “Within PVertex::PVertex()” size: size() endl;//它可能被扩展为：PVertex* PVertex::PVertex(PVertex *this, bool _most_derived,float x, float y, float z)//条件式调用virtual base constructorif(_most_derived != false)this-Point::Point(x, y);//无条件地调用上一层basethis-Vertex3d::Vertex3d(x, y, z);//将相关的vptr初始化this-_vptr_PVertex = _vtbl_PVertex;this-_vptr_Point_PVertex = _vtbl_Point_PVertex;//程序员缩写代码if(spyOn) cerr Within PVertex::PVertex() Point3d::Point3d(), size: (*this-_vptr_PVertex[3].faddr)(this) endl;//传回被构造的对象return this; vptr 的初始化 下面是vptr必须被设定的两种情况： 当一个完整的对象被构造起来时，如果我们声明一个Point对象，Point constructor必须设定其vptr。 当一个subobject constructor调用了一个virtual function(不管是直接调用还是间接调用时)。 如果我们声明一个PVertex对象，然后由于我们对其base class constructors的最新定义，其vptr将不再需要在每一个base class constructors中被设定。 解决之道是把constructor分裂为一个完整的object实体和一个subobject实体。在subobject实体中，vptr的设定可以省略(如果可以的话)。 这样能回答两个问题： 1.类的构造函数的成员初始化列表调用类的虚拟函数，安全吗？ 编译器使 vptr 能保证在成员列表初始化前设定好，挺安全； 函数本身可能会依赖没有设定初值的成员，语意上不太安全。 2.什么时候给基类构造函数一个参数？这种情况，问题1情况还安全吗？ 不安全。vptr 还没设定好或者指向错误的类。该函数存取的任何类成员数据一定还未初始化。 5.3对象复制 对象复制，即研究 copy assignment operator 的语意，看看它们怎么被塑造出来。 bitwise copy 所谓bitwise copy 和 memberwise copy 即深拷贝和浅拷贝。 深拷贝（memberwise copy）和浅拷贝（bitwise copy）的区别在于： 深拷贝(对象拷贝)是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 浅拷贝（按位拷贝）在拷贝指针、引用时，按位拷贝会导致拷贝的指针和原指针指向了同一地址。 利用Point class 来讨论。 class Point public: Point(float x= 0.0, float y = 0.0); // ... 没有virtual functionprotected: float _x, _y;; 关于拷贝赋值操作，先看看默认生成的拷贝行为是否够用。 如果够用，那么默认拷贝操作将更有效率，不需要再画蛇添足，重写为新的拷贝操作 默认行为不够用，甚至可能导致一些不安全、不正确的操作，需要自己设计一个 copy assginment operator 。拿上面的Point class来说，默认的 memberwise copy，编译器不会产生示例（类似拷贝构造的情况），因为该类已经有了 bitwise copy 语意(这个 class 人畜无害，没有指针也没有多态)，所以隐式拷贝赋值操作没什么意义。 一个 class 对于默认的copy assignment operator,在下面情况不会表现出bitwise copy语意: 当 class 内带一个member object,而其 class 有一个copy assignment operator时. 当一个 class 的base class 有一个copy assignment operator时. 当一个 class 声明了任何 virtual functions (一定不可以拷贝右端 class object的vptr地址,由于它可能是一个derived class object). 当 class 继承自一个 virtual base class(不论此base class 有没有copy operator)时。 C++ Standard上说copy assignment operators并不表示 bitwise copy semantics 是 nontrivial 。 实际上,只有存在nontrivial instances时才会被合成出来。 Point a, b;a = b;//其间并没有copy assignment operator被调用. 进行按位拷贝,把Point b拷贝给Point a。 注意: 我们还是可能提供一个copy constructor,来配合 name return value (NRV) 的优化。 copy constructor的出现不应该暗示出也一定要提供一个copy assignment operator 。 继承下的拷贝构造行为 现在导入一个拷贝赋值操作，来说明该操作在继承下的行为 inline Point Point::operator=(const Point p) _x = p._x; _y = p._y; return *this//虚继承class Point3d : virtual public Point public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0);protected: float _z;; 如果没有声明拷贝赋值函数，编译器就会合成类似下面的代码： // C++伪代码:被合成的copy assignment operatorinline Point3d Point3d::operator=(Point3d *const this, const Point3d p) //调用base class的函数实体 this-Point::operator=(p); // memberwise copy the derived class members _z = p._z; return *this; 这时，拷贝赋值操作有一个不太理想的情况：缺乏成员初始化列表。 这导致下面的情况将不存在： // C++伪代码,下面性质并不支持inline Point3d Point3d::operator=(const Point3d p3d) : Point(p3d), z(p3d._z)//取而代之的是Point::operator=(p3d);//或(*(Point *)this) = p3d; 缺乏初始化列表，在继承体系中该如何阻止基类的拷贝操作 为什么要阻止呢？ a 看下面的例子： // class Vertex : virtual public Pointinline Vertex Vertex::operator=(const Vertex v) this-Point::operator(v); _next = v._next; return *this;inline Vertex3d Vertex3d::operator=(const Vertex3d v) this-Point::operator=(v); this-Point3d::operator(v); this-Vertex::operator=(v); 传统的 constructor 解决方案：附加额外参数 附加额外参数没用，因为：取拷贝赋值函数地址是合法的，下面的使用将推翻拷贝赋值函数的设计。 typedef Point3d (Point3d::*pmfPoint3d) (const Point3d );pmfPoint3d pmf = Point3d::operator=;(x.*pmf)(x); 仍然需要根据其独特的继承体系,插入任何可能数目的参数给copy assignment operator 为copy assignment operator 产生分化函数（split function) 产生后，希望函数能支持这个类成为中间基类或最底层子类。 最好让编译器借助分化函数产生拷贝赋值操作。class-defined user 亲自操刀，可能面临某些函数很难分化的困境： inline Vertex3d Vertex3d::operator=(const Vertex3d v) init_bases(v);//甚至让它成为虚函数 copy assignment operator在虚拟继承情况下很复杂,需要特别小心地设计和说明. 如果使用一个以语言为基础的解决方法,那么应该为copy assignment operator提供一个附加的**”member copy list”**。 简单地说,任何解决方案如果是以程序操作为基础,将导致较高的复杂度和较大的错误倾向. 一般公认,这是语言的一个弱点,也是应该小心检验程序代码的地方(当使用 virtual base classes时). 语言为基础的方法：在子类拷贝函数示例最后调用那个 operator 在derived class 的copy assignment operator函数实体的最后,明确地调用那个operator inline Vertex3d Vertex3d::operator=(const Vertex3d v) this-Point3d::operator=(v); this-Vertex:;operator=(v); // must place this last if your compiler dose not suppress intermediate class invocations this-Point::operator=(v); 这并不能省略subobjects的多重拷贝,但却可以保证语意正确.另一个解决方案要求把 virtual subobjects拷贝到一个分离的函数中,并根据call path条件化调用它。 最好的办法是 尽可能不要允许一个 virtual base class 的拷贝操作。 甚至有一个奇怪的方法是: 不要在任何 virtual base class 中声明数据 5.4对象的效能（略）略 5.5析构语意学析构函数不是所有情况都是必要的 如果class没有定义destructor，那么只有在class内含的member object(或者是class自己的base class)拥有destructor的情况下，编译器才会合成出一个来。 否则，destructor被视为不需要，也就不需要被合成（当然更不需要被调用）。 下面举出一个没有合成析构函数的 class （它甚至还有个虚函数） class Point public:\tPoint(float x = 0.0, float y = 0.0);\tPoint(const Point);\tvirtual float z();private:\tfloat _x, _y;; 类似的道理，如果把两个Point对象组合成一个Line class: class Line public:Line(const Point, const Point); virtual draw();protected:\tPoint _begin, _end;; Line也不会拥有一个被合成出来的destructor，因为Point并没有destructor。 当我们从Point派生出Point3d(即使是一种虚拟派生关系)时，如果我们没有声明一个destructor，编译器也就没必要合成一个destructor。 你应该拒绝某种强迫症：你已经定义了一个constructor，所以你觉得提供一个destructor是天经地义的事情。事实上，程序员应该根据需要而非感觉来选择是否提供destructor。 怎么判断 class 是否需要一个程序层面的析构函数构造函数考虑标准： 保证对象完整性 类对象生命周期的起点和终点 析构函数顺序： 一个程序员定义的析构函数的扩展方式与构造函数方式相同，但顺序相反: destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设（reset）。 如果class拥有member class objects，而后者拥有destructors，那么它们会以声明顺序的相反顺序被调用。 如果object内含一个vptr，那么首先重设（reset）vptr来指向相关的virtual table。 如果有任何直接的（上一层）nonvirtual base classes拥有destructor，它们会以其声明顺序的相反顺序被调用。 如果有任何virtual base classes拥有destructor，到目前讨论的这个class的最尾端（most-derived）的class，那么它们会以其原来的构造顺序的相反顺序被调用。 析构函数的最佳实现策略和5.2章节最后，构造函数采取的“一分为二”法一样： 就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实例：1、一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructors。2、一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr。 一个object的生命结束于其destructor开始执行之时。由于每一个base class destructor都轮番被调用，所以derived object实际上变成了一个完整的object。 例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象，一个Point3d对象，最后成为一个Point对象。 当我们在destructor中调用member functions时，对象的蜕变会因为vptr的重新设定（在每一个destructor中，在程序员所供应的代码执行之前）而受到影响。 举个例子： Point pt;\tPoint *p = new Point3d;\tfoo(pt, p); ...\tdelete p; pt 、 p 作为参数之前，要初始化为坐标值，通过构造函数或显式提供坐标值。 类使用者没法检验local或heap变量是否需要初始化。 所以构造函数很有必要。 那么显式delete掉 p 是否需要提前处理呢？ p-x(0);p-y(0); //like this 没必要。没有任何理由说在delete一个对象之前先得将其内容清除干净。 如果确保在结束pt和p的生命之前，没有任何和该 class 有关的程序操作是必要的，往往不一定会需要一个destructor。 例外情况 ：delete 存在“结束前和该 class 有关的程序操作” 考虑Vertex class，它维护了一个由紧邻的顶点所形成的链表，并且当一个顶点的生命结束时，在链表上来回移动以完成删除操作。如果这正是程序员所需要的，那么这就是Vertex destructor的工作。 这个delete 存在“结束前和该 class 有关的程序操作” 当我们从Point3d和Vertex派生出Vertex3d时，如果我们不供应一个explicit Vertex3d destructor，那么我们还是希望Vertex destructor被调用，以结束一个Vertex3d object。 因此编译器必须合成一个Vertex3d destructor，其唯一任务就是调用Vertex destructor。 如果我们提供一个Vertex3d destructor，编译器会扩展它，使它调用Vertex destructor(在我们所供应的程序代码之后)。"},{"title":"inside object model2","path":"/wiki/cpp/inside object model2.html","content":"第四章 Function 语意学 (The Semantics of Function)前言： float Point3d::magnitude()const return sqrt(_x*_x + _y*_y + _z*_z);Point3d Point3d::normalize()const /*\t用register说明的局部变量称为寄存器变量，该变量将可能以寄存器作为存储空间。\tregister说明仅能建议（而非强制）系统使用寄存器，这是因为寄存器虽然存取速\t度快，但个数有限，当寄存器不够用时，该变量仍按auto变量处理。\t*/\tregister float mag = magnitude();\tPoint3d normal;\tnormal._x = _x / mag;\tnormal._y = _y / mag;\tnormal._z = _z / mag;\treturn normal; 下面我们进行操作： Point3d obj;Point3d *ptr=obj;//What Will Happen?obj.normalize();ptr-normalize(); 这里还无法确定实际的操作。 C++支持三种函数调用：static func , nontatic func , virtual func 。 每种方式都不同，也是我们接下来要区分的。 这里可以确定 normalize() 和 magnitude() 两函数绝不是 staic。 原因： 可以直接存取 nonstatic 数据 它被声明为了const 注释：static 数据没有隐式 this 指针，同理 static 成员不是任何对象的成分（元素），没有 const 对应的“不修改所属对象的成员属性”一说。 4.1Member 的三种调用方式Nonstatic Member Function1.nonstatic 成员函数至少和 nonmember function 有相同效率 达成这个效果，是因为编译器内部已将 成员函数 转换成了对等的 non-member 函数 举个例子吧： float magnitude3d(const Point3d *_this) return sqrt(_this-_x*_this-_x + _this-_y*_this-_y + _this-_z*_this-_z); 反差：利用 this 指针 不断间接取用坐标成员好像降低了效率，不同于非成员函数的直接取用。 转化步骤： 改写函数原型（signature)，安插一个 this指针 作为额外参数到成员函数中，从而使类对象被直接调用。 const 成员函数，其额外参数 this 指针同样是 const *this pointer。 将后续操作中涉及存取 nonstatic data member 的，改为通过 this 指针存取。 return sqrt(_this-_x*_this-_x + _this-_y*_this-_y + _this-_z*_this-_z); 将成员函数重新写成一个外部函数 为了防止重名，函数名会经过 mangling 处理，成为绝不会重名的词。 extern magnitude__7Point3dFv( register Point3d *const this); 成员函数转换为外部函数，意味着调用操作也完成了转换： obj.magnitude();变成了magnitude__7Point3dFv(obj); ptr-magnitude();变成了magnitude__7Point3dFv(ptr); 这时回到原题：normalize函数的调用问题。 //伪码void normalize__7Point3dFv(register const Point3d *const this,\tPoint3d __result) register float mag = this-magnitude();\t__result.Point3d::Point3d();//default constructor\t__result._x = this- _x / mag;\t__result._x = this- _x / mag;\t__result._x = this- _x / mag;\treturn; 这是转变情况之一。 另外一种情况是利用Point3d的构造函数构造匿名对象简化操作： Point3d::Point3d::normalize()const register float mag = magnitude();\treturn Point3d(_x / mag, _y / mag, _z / mag); 转化(假设拷贝构造相关操作已完成，NRV优化^1也已实现)： void normalize__7Point3dFv(register const Point3d *const this, Point3d __result) //调用拷贝构造函数\t__result.Point3d::Point3d(this-_x / mag, this-_y / mag, this-_z / mag);\treturn; 节省了默认构造初始化的额外负担。 2.名称的特殊处理（Name Mangling) 编译器的处理下，通常成员名称前会被加上类名称。 class Barpublic: int ival;//成员 ival 经过Name Mangling 后的可能结果：ival_3Bar Name Mangling的原因：便于区分重名变量。 1.子类继承时重名 class Foo:public Barpublic:int ival; 子类Foo和父类发生成员变量重名的情况；编译器为了区分会处理名称： class Foo public: int ival_3Bar; int ival_3Foo; 2.成员函数重载时重名 class Point public:\tvoid x(float newX);\tfloat x();; 简单转换为 class Point public:\tvoid x__5Point(float newX); float x__5Point(); ;//会导致被重载的函数实例拥有相同名称。//为了区分，还需要加上它们的参数链表，同时把参数类型也编码进去，就能够防止重复。class Point public:\tvoid x__5PointFf(float newX);\tfloat x__5PointFv();; 这就是cfront的编码方法。目前还没有Name Mangling 的工业标准统一这一行为。 Name Mangling 能实现有限的类型检验： 声明和定义两部分参数类型不一致的函数，会产生不同的编码名称，这就会导致链接时期无法 resolved 而失败。 有限之处在于它只能涉足函数签名（signature），不能检测返回值。 拓展： 现在的编译系统中，有一种 demangling 工具，能把编码后的名称转换回去。这个系统内会存储两种名称：”mangled 之前“和”mangled 之后”。 **这会导致一种误导行为：**编译器错误信息提示时，使用源码名称；链接器却使用编码后的内部名称。 把内部名称（mangled 编码后）给 user 看会让 user 一头雾水。 Virtual Member Function第三章讲过，如果normalize()是个虚拟成员函数: ptr-normalize()//converse to (*ptr-vptr[1])(ptr);register float mag = (*this-vptr[2])(this);//converse to register float mag = (*this-vptr[2])(this); vptr : 指向 virtual table 的指针，由编译器产生安插在 virtual function -involved class 中。 vptr也会被 name mangling 处理。 1 是 virtual table slot 索引值，关联到 normalize 第二个 ptr 表示 this 指针。 这里还不是最终版本，因为这段代码还有值得优化的地方： 在上面的 code segmeng 中，magnitude() 是在 normalize() 中被调用的，后者由虚拟机制 resolved 后，可以直接显式调用 Point3d 实例中的 magnitude 函数。 大家都在一个类中，我又处在你的作用域里。 register float mag=Point3d::magnitude();//直接调用算了，这能回避不必要的虚拟机织重复调用操作 还可以继续优化：将 magnitude() 声明为 inline 函数。这样一来代码会变成： reginster float mag = magnitude__7Point3dFv(this); //mangled name！ 通过 this 指针指出对象所在位置的同时调用虚函数，resolve 的状态会和非静态成员函数一样！ 另外，对于函数 obj.normalize()转换成(* obj.vptr[1])(obj)的意义不大。 因为这个情况中的类对象并不支持多态，所以通过 obj 实例调用的函数只能是 Point3d::normalize()。 通过类对象调用虚函数，会被编译器如同对待非静态成员函数一样，迅速完成 resolved ，成为带对象参数的普通函数调用。 此时，这个虚函数还成为了 inlined function 实例，能够在后续应用中广泛扩展，提高效率。 obj.normalize(); //not to (* obj.vptr[1])(obj) //converse to normalize__7Point3dFv(obj); Static Member Function//如果Point3d::normalize()是一个static member function，以下两个调用操作：obj.normalize();ptr-normalize();//将被转换为一般的nonmember函数调用，//obj.normalize()↓normalize__7Point3dSFv();//ptr-normalize()↓normalize__7Point3dSFv(); 对静态成员函数的处理，要分为“引入静态成员函数前”（cfront2.0引入）和引入后。 1.引入前的处理： 抛开上面的例子，看一个很有特点的函数形式： ((Point3d*) 0 )-object_count();//嗯，这个 object_count 只是简单传回 _object_count 这个简单静态成员变量。 这种函数形式出现的原因： 引入…前，CPP要求所有的成员函数都必须通过对应类的实例对象来调用。 这也是 this 指针的重要作用之一 this 指针把 在成员函数中存取的非静态成员 绑定在了 类对象内的相应成员上。 但事实上： 只有当成员函数中，存在非静态成员变量的存取时，才需要类对象。 其他情况根本用不到 class object 。 成员函数如果没有成员被存取，那么它压根就不需要 this 指针。也没有必要强行要求通过一个类对象的实例来调用这个成员函数。 这种情况下，如果设计者把静态成员变量声明为 非public ，他就必须提供很多成员函数来存取这个成员变量。 这时，即使静态成员变量不需要类对象去存取，可对应的存取函数还是需要类对象，这就是一种无奈的绑定关系。 所以脱离类对象的一些存取操作还是很重要的。上面的奇葩函数形式就是这种脱离需求下的产物： ((Point3d*) 0 )-object_count();//将 0 强转为一个类指针，来提供一个略显生硬的 this指针实例。//（生硬之处：还是在费尽心机去贴合成员和对象间的绑定关系。） 这时，为了让独立于类对象的一些存取函数操作更自然：静态成员函数引入了。 2.引入后的处理 我们来看看引入的静态成员函数特性： 没有 this 指针。 不能直接存取所属类中的非静态成员。 不能被声明为 const、volatile、virtual。 不需要通过类成员去调用。 首先关于静态成员函数的“.”语法（打官腔叫“member selection”），编译器是这样处理的： //类成员实例的直接调用：Point3d p3;if(p3.object_count() 1) ...//converse to if(Point3d::object_count() 1) ... //通过表达式获得类成员的调用if(foo().object_count() 1) ...//converse to(void) foo();//foo()函数还是被调用了，只是没有蹩脚的返回值而已。if(Point3d::object_count() 1)... name mangled 效果： unsigned int Point3d::object_count() return _object_count;//converse to unsigned int object_count__5Point3dSFv() //额，这里的SFv表示它是一个static member function,拥有一个void(空白)的参数\treturn _object_count__5Point3d; 取地址 如果此时你想取一个 静态成员函数 的地址，将获得其在内存中的地址。 这和其类成员实例无关，且类型不是指向类成员函数的指针(它和this指针已经没有关系)，而是一个实实在在的非成员函数指针。 Point3d::object_count();//会得到一个数值，类型是unsigned int(*)(); // right!//而不是unsigned int(Point3d::*)(); //wrong. 静态成员函数没有了this指针束缚，效果几乎等同于非成员函数了。 扩展： 一个意想不到的好处：static member function 成为了一个回调函数（callback func）。 这有利于CPP和 C-based X Window 系统的兼容，也可以自然的应用在线程(thread)函数上。 4.2 虚拟成员函数这一章我们会从头到尾过一遍设计虚函数模型的过程。 老生常谈的模型：一个类，里面有虚表，虚表里存储着虚函数的地址。该类的每个实例对象都会自带一个虚指针，指向这个虚表，来完成多态调用。 执行期多态的实现 既然是虚函数，那么看到这个操作： ptr-z(); 你面对的第一个问题便是执行期类型判断（runtime type resolution）。 先从编译期多态的尝试走起： 尝试把信息绑定在函数指针上 判断方式里，最自然的想法是将帮助判断对象的信息绑定在ptr身上。 这种策略下，通常一个指针需要的信息有： 它所指向的对象地址 对象类型的编码或者结构信息的地址。 Ps：结构信息是用来分辨对象函数实例的，即help resolved to z()。 这种策略的问题： 空间负担 和C程序的链接不再兼容。 如果这些额外信息不和指针放在一起，那就只能放在对象(classstruct)的身上了。 类似这种形式：struct data{ int m,d,y; } （这种形式没有摆脱把信息与指针绑定的弊端） 如果为了C兼容性，而要求这种策略只针对class，也不能解决问题。 因为 struct 可能会发生多态，而 class 可能并不需要这些冗余信息。 执行期 尝试半天，这个责任还是落到了执行期。所以执行期多态到底怎么实现呢？ 多态的定义： 在C++中，多态表示以一个public base class的指针（或引用），寻址出一个derived class object的意思。 Point *ptr;ptr = new Point2d;ptr = new Point3d; 消极多态： 让ptr扮演输送机制的角色，仅仅让基类指针指向子类对象，而没有其他操作。 积极多态： 指出的对象通过指针被使用。 //1.ptr-z(); //ptr指向了子类//2.Point3d *p3d=dynamic_castPoint3d *(ptr)p3d-z();//这就说明是Point3d的_z函数 仅仅是这种操作还不够。因为我们无从知晓ptr指向的是基类还是子类或者它有没有实现多态。 结论： 识别一个class是否支持多态，只能看它是否有虚函数。只要要虚函数，它就需要额外的执行期信息。 存储的额外信息什么？ 现在我们知晓了一个类要实现多态，需要执行期信息来完成正确多态操作。 需要的信息： ptr所指对象的真实类型，方便找到正确的实例（如z() 对象实例的位置，方便ptr调用 实现： 一个字符串或数字来表示类的类型 一个指向表格的指针，该表格存储虚函数执行期地址 这时，vptr和 virtual table 很自然的出现了。 剩下的问题是，虚表怎么找到并构建这些地址？ 找到地址：虚函数地址在编译期就能通过类对象找到。而且这些地址固定不变，不需要执行期介入。 存储建构： 由编译器在每个类对象中安插一个指针指向该表格。 每个虚函数生成一个表格索引值，帮助表格寻找地址。 PS：表类似一个数组，索引值即下标，元素是虚函数地址。 (编译器立大功。) 这些都是编译期工作。执行期只是通过 virtual table slot (那些索引)找到地址，然后触发虚函数。 关于虚表的详细探讨： 一个class 只有一个虚表，每个表里有积极虚函数实例地址。 积极虚函数(active virtual func): 这一class所定义的函数实例。它会改写一个可能存在的base class virtual function函数实例 继承自base class的函数实例。这是在derived class决定不改写virtual function时才会出现的情况（也就是单纯的继承） 一个pure_virtual_called()函数实例（纯虚函数，没有内容），可以用来保存纯虚函数的空间，或当作执行期的异常处理函数等。 举个例子： class Point public:\tvirtual ~Point();\tvirtual Point mult(float) = 0;\tfloat x()const return _x; virtual float y() const return 0; virtual float z() const return 0; protected:\tPoint(float x = 0.0);\tfloat _x;; 解释：虚析构函数生成 slot 1，mult() 生成 2，y() 和 z() 分别为 slot3 slot4。 x()不是虚函数，没有slot。 PS：mult()作为纯虚函数，没有定义。如果意外调用，直接结束掉。 继续深入一下，找个 class 继承 Point 会是什么结构呢？ class Point2d :public Point public:\tPoint2d(float x = 0.0, float y = 0.0) :Point(x), _y(x) ~Point2d();\t//改写base class virtual functions\tPoint2d mult(float);\tfloat y()const return _y; protected:\tfloat _y;; 一共又三种可能性： 1.它可以继承base class所声明的virtual functions的函数实例。正确地说是，该函数实例的地址会被拷贝到derived table的相对应slot之中。比如上图中的#4位置 2.它可以使用自己的函数实例，也就是在base class中的virtual function上做改变了。这表示它自己的函数实例地址必须放在对应的slot之中。比如上图中的#2、#3位置 3.它可以加入一个新的virtual function。这时候virtual table的尺寸会增大slot，而新的函数实例地址则会被放入该slot之中 ( Point2d的virtual table在slot1中指出析构函数，而在slot2中指出mult()(取代纯虚函数)。它自己的y()函数实例放在slot 3中，继承自Point的z()函数实例地址则被放在slot 4中。 ) 继续继承： class Point3d :public Point2d public:\tPoint3d(float x = 0.0, float y = 0.0, float z = 0.0) :Point2d(x, y), _z(z) ~Point3d();\t//改写babse class virtual functions\tPoint3d mult(float);\tfloat z()const return _z; protected:\tfloat _z;; 其virtual table中的slot 1位置放置Point3d的destructor，slot 2放置Point3d::mult()函数地址，slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z()函数地址。 现在，让我们再次面对ptr-z(); 如何在编译期设定虚函数的调用？ 可以解答如下了： 1.一般而言，在每次调用z()时，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table。 2虽然我不知道哪一个z()函数实例会被调用，但我知道每一个z()函数地址都被放在slot4中，从上面的图可以看出来。 由这两条信息使得编译器可以将该调用转化为： （*ptr-vptr[4]）(ptr);//编译期工作：vptr指向vitrual table，生成编号 slot4//执行期工作：知道 slot 4 指向的那个z()示例 这是单一继承下，虚函数的实现过程。 多重继承下的虚函数 编译期实现多态的困境 多重继承中虚函数的复杂度，主要来源于第二个或后续基类和执行期 this 指针的调整。 示例： class Base1 public:\tBase1();\tvirtual ~Base1();\tvirtual void speakClearly();\tvirtual Base1 *clone() const;protected:\tfloat data_Base1;;class Base2 public:\tBase2();\tvirtual ~Base2();\tvirtual void mumble();\tvirtual Base2 *chone() const;protected:\tfloat data_Base2;;class Derived :public Base1, public Base2 public:\tDerived();\tvirtual ~Derived();\tvirtual Derived *clone() const;protected:\tfloat data_Derived;; 让 Derived 支持虚函数困难度落在了 Base2 子对象上。 这里我的理解是，Base1和Derived的指针位置是一样的，都为0；而Base2指针的指向地址则是0 + sizeof(base1)。这时我们面前有三个问题：1.虚析构2.继承而来的Base2::mumble()3.一组clone()函数实例。 这时，我们尝试多态操作： 指针赋值 Base2 *pbase2 = new Derived;//编译期的代码会变成这样：Derived* temp = new Derived;Base2 *pbase2 = temp?temp + sizeof(Base1) : 0;//这里的思想第三章有阐释（例如不这样做，相关 base2 调用会失败） 删除 delete pbase2; 这里出现了问题：指针必须再次调整，因为要指向Derived对象的起始处。但这个指向涉及的偏移量操作已经不能在编译期设定，因为 pbase2 指向的真正对象根本确定不了（该死的多态），除非在执行期。 1、这里是开头所说的问题之一：虚析构。 delete pbase2的时候Derived,Base1,Base2的析构函数都要被调用。 因为一个Derived对象中含有Base1和Base2的subobject，所以也需要调用它们的析构函数销毁它们的对象并释放内存空间(当然只有析构函数是这样）。 父类子对象可能有很多种多态情况，因此我们无法确定其指向的真正对象，（不同对象的偏移量不同），所以不能在编译期准确调用其析构函数。 //本例中的多态就有两种情况//两个new返回的都是首地址：子类子对象在地址0处，父类子对象在0+sizeof(Base2)处Base2 *pbase2 = new Derived; //该情况不需要偏移（甚至不需要this）Base2 *pbase2 = new Base2; //该情况需要偏移//于是编译器处理的两种结果不同(*pbase2-vptr[1])(pbase2 + offset???) 而且有无偏移量是一种情况，偏移量是多少又是一种情况（比如后续基类的Base3，Base4 …） 另外，调用虚析构函数时 this 指针发生了偏移(指向pbase2 到 指向 derived ，因为你需要调用人家的函数)。我既需要调整后的derived对象的起始地址，我又需要调整前的pbase2::vptr，来指向子类析构函数实际地址。 这里出现矛盾：我同时需要调整前后的信息。编译器如何实现的情况，我的理解是： 1.调整前先通过pbase2找到vptr中Derived的析构函数地址， 2.隐式地传this指针时才会调整指回整个Derived对象的起始地址，像这样： (*pbase2-vptr[1])(pbase2+offset);\t//pbase2-sizeof(Base1)//左括号调整前，右括号调整后 执行期解决方案：替代加大虚表的方法：thunk设计 执行期解决的一般的思路是，通过第二或后续的基类指针调用子类虚函数。 该操作必需的“this指针调整”操作，必须在执行期完成。 这意味着，操作的信息：offset的大小，以及把offset加上this指针的那一小段代码必须由编译器安插在某个地方。 问题是，在那个地方？ 最自然（最笨）的方法是，都塞到虚表里，把虚表加大，来容纳这些偏移信息和地址。 虚表的 slot 也从整型之类的数字类型变成了结构体。 (pbase2-vptr[1])(pbase2);//改变为：(*pbase2-vptr[1].faddr) (pabse2 + pbase2-vptr[1].offset) 毫无疑问，太大了。不需要这些信息的空间也被塞满了。 thunk：主角登场 thunk是一小段汇编代码，实现：1.调整this指针偏移量 2.跳到目标虚函数中 pbase2_dtor_thunk: this += sizeof(base1); Derived::~Derived(this); 所以可以暂时将thunk理解成一个函数，它是对上述两点操作的封装（调整this指针和调用对应的函数），只不过它是用汇编语言写才有效率可言。 thunk 让 虚表 slot 内含一个简单指针，要么指向虚函数，要么指向一个thunk（也就是要调整this指针时）。 但一个问题是，就如我们分析编译期局限性时一样，可能有多个不同继承层级的对象来调用同一个析构函数，这时的偏移量是不同的，对应slot也不同。 最高层级且处于最左侧的类对象，甚至不需要偏移量——它和子类对象的起始地址一样。这时slot直接放真正的调用函数地址就好了。 多重继承下，一个派生类内含n-1个额外的虚函数表，n表示上一层基类的数目(因此单一继承不会有额外的虚函数表)。如果子类有额外的虚函数，会存放在第一个基类的虚函数表里。 对本例Derived而言，编译器会产生有两个虚函数表。 分别对应 Base1 和 Base2 。针对每个虚表，子类对象都会有专门的 vptr ，且这些 vptr 会在构造函数中被赋初值（编译器的工作喽） 于是子类对象地址赋给子类指针或父类指针，就会产生多态效果——根据不同的类型，用不同表格来处理。 执行期链接器处理符号链接这种东西可能有点慢。一个思路是将多个虚表连接成一个：次要表格（次要仅从继承顺序上说）的获取只需要主要表格地址加上偏移量。 后续基类影响虚函数运行的三种情况 这三种情况在上面的图里有所反映 通过指向同层、次级父类的指针，调用子类虚函数 Base2 *ptr = new Derived;//调用Derived::~Derived//ptr要减去sizeof(Base1)个bytesdelete ptr; 之前已经讨论过，为了正确执行，ptr必须调整指向子类对象的起始处 （整个对象地址的 0） 通过指向子类对象的指针，调用同层、次级父类继承而来的父类自己的虚函数 Derived *pder = new Derived;//调用Base2::mumble()//pder要加上sizeof(Base1)个bytespder-mumble(); 第一种情况的逆向。到父类子对象那里调用父类的虚函数 允许一个virtual function的返回值类型有所变化，可能成为base type，也可能是publicly derived type。 Base2 *pb1=new Derived;//调用Derived* Derived::clone()//返回值必须被调整，以指向Base2 subobjectBase2 *pb2=pb1-clone(); Derived::clone()传回一个Derived类指针，改写了它的两个基类的函数体。当我们通过指向第二个基类的指针来调用clone()时，this指针的offset问题就会产生： 当进行pb1-clone()时，pb1会被调整指向Derived对象的起始地址，所以调用的是Derived::clone()。它会传回一个指针，指向一个新的Derived对象，该对象的地址在被指定给pb2前，必须先经过调整，以指向Base2 subobject。 书中还提供了两种提高效率的方法，一种是sun编译器的”split function”，一种是微软的“address points” 虚继承下的虚函数class Point2d public:\tPoint2d(float = 0.0, float = 0.0);\tvirtual ~Point2d();\tvirtual void mumble();\tvirtual float z();protected:\tfloat _x, _y; //纯纯毒瘤;class Point3d : public virtual Point2d public:\tPoint3d(float = 0.0, float = 0.0, float = 0.0);\t~Point3d();\tfloat z();protected:\tfloat _z;; 图右下角的两个vtbls内容有错。至少mumble()应该是Point2d::mumble 而不是 Point3d::mumble。 此例反映出的唯一有用的信息便是虚继承下的内存空间排布和正常继承不一样，并且一旦虚基类中虚继承了另一个虚基类，整个内存空间会非常混乱。this 指针的调整就会复杂难辨。 所以我们的启示只有一个：不要再虚基类里声明 nonstatic data members 。 指向成员函数的指针 nonstatic 成员函数 和 nonstatic 成员变量与类对象的绑定 取非静态成员变量的地址，是它在类中的相对byte位置（可能+1），这个offset需要类对象的地址，也就是绑定关系。 取非静态成员函数的地址，如果函数为non-virtual，它就和成员变量一样，是个绑定在类对象上的offset 地址。 对象地址来自 this指针 。 指向成员函数的指针 //double是返回值类型//Point::*说明是Point类成员，pmf是成员指针名//最后的()是参数列表double (Point::*pmf)();\t//两种方法定义并初始化该指针的两种方法：double (Point::*coord)() = Point::x;coord=Point::y;//调用的两种方法：(origin.*coord)();(ptr-*coord)();//分别会被转换成（C++伪码）(coord)(origin);(coord)(ptr); 指向成员函数的指针的声明语法，以及指向“member selection”运算符（-或 .）的指针，这两部分的作用是为this指针保留空间。 所以静态成员函数的类型是函数指针，因为他们不需要 member selection ，更不需要 this指针。 在没有虚函数，多重继承，虚拟继承的情况下，编译器可以让 使用成员函数的指针与使用非成员函数的指针 的效率相同。 支持“指向虚拟成员函数”的指针 需求场景 //z()是个虚函数(Point::*pmf)()=Point::z;Point *ptr=new Point3d;ptr-z();\t//调用Point3d::z()(ptr-*pmf)(); //调用Point3d::z() ptr 调用 z()，被调用的是 Point 3d::z()； ptr 通过 pmf 调用z（）,被调用的还能是 Point3d 中的 z 吗？ 答案是肯定的。 实现方法 首先，虚函数真正地址在编译期未知，只能知道它的 virtual table slot。 class Point\tpublic: virtual ~Point(); float x(); float y(); virtual float z();;Point::~Point; //得到虚函数表里的索引1Point::x();\t//得到内存地址Point::y(); //得到内存地址Point::z();\t//得到虚函数表里的索引2//通过 pmf 调用 z()，会被内部转化为编译期的式子：(*ptr-vptr[(int)pmf])(ptr); //大概是这个样子了 于是函数指针就有了两个意义：普通成员函数的内存地址和虚函数的slot专属版。 //pmf内部定义float(Point::*pmf)(); 这个函数要具备能寻址两种类型的成员函数的能力： float Point::x() return _x; //一长串吧float Point::z() return 0; //小串//都可以指定给 pmf 于是pmf有两个功能： 能持有两种数值（注意不是同时) 能区分这个数值是内存地址还是虚表索引值 cfront2.0的解决办法： (((int)pmf)~127) ?(*pmf)(ptr):(*ptr-vptr[(int)pmf](ptr)); 这个实现只能应用在继承体系中最多只有128个虚函数的情况。 多重继承下，指向成员函数的指针如题，怎样让指向成员函数的指针在多重继承下可行？ Stroustrup的方法： struct __mptr int delta;\tint index; //表现 虚表索引 （用不到就设为-1）\tunion ptrtofunc faddr; //表现 成员函数 int v_offset;\t;;(ptr-*pmf)();//转换为(pmf.index 0) ? //non-virtual\t(*pmf.faddr)(ptr) :\t//virtual\t(*ptr-vptr[pmf.index](ptr)); 缺点： 检查成本高 Microsoft把这项检查拿掉，导入一个它所谓的vcall thunk。 在此策略下，faddr被指定的要不就是真正的member function(如果函数是nonvirtual的话)，要不就是vcall thunk的地址。 于是virtual或nonvirtual函数的调用操作透明化，vcall thunk会选出并调用相关virtual table中适当的slot。 传递一个不变值指针给成员函数时，它需要产生一个临时对象 举例子： extern Point3d foo(const Point3d , Point3d (Point3d::*)());void bar(const Point3d p ) Point3d pt = foo(p,Point3d::normal );//Point3d::normal 的值类似这样：0 , -1 , 10727417//需要产生临时对象，有明确初值_mptr temp = 0 , -1 , 10727417 //伪码foo(p,temp); 回到开始的那个结构体： delta字段表示this指针的offset指针，而v_offset字段放的是一个virtual base class（或多重继承中的第二个、第三个等等）的vptr位置。 如果vptr被编译器放在class对象的起头处，这个字段就没什么必要了：这些字段在多重继承或虚拟继承的情况下才有必要性。 有许多编译器在自身内部根据不同的classes特性提供多种指向member functions的指针形式，例如Microsoft就供应了三种针对： 一个单一继承实例(其中带有vcall thunk地址或是函数地址) 一个多重继承实例(其中带有faddr和delta两个members) 一个虚拟继承实例(其中带有四个members) 内联函数 加了inline关键字，函数不一定就是内联函数。 编译器真的相信它可以扩展成inline函数时，其执行成本比一般函数调用和返回机制带来的负荷要低。 编译器处理inline函数，有两个阶段： 分析函数定义和复杂度，编译器会判断能否成为inline函数。 如果函数成不了inline ，就会转成一个static函数，并在被编译模块内产生对应函数定义。 真正的inline函数扩展操作是在调用的那一点上，这会带来参数的求值操作以及临时性对象的管理。 Formal argumentsinline 函数扩展期间，形参会被实参替代。 但无脑替代实参决定是有副作用的，比如一些表达式的重复求值之类的。 inline int min(int i,int j)\treturn ij?i:j;inline int bar()\tint minval;\tint val1=1024;\tint val2=2048;\tminval=min(val1,val2);\t//参数直接替换，会扩展成 minval=val1val2?val1:val2;\tminval=min(1024,2048);\t//计算常量表达式10242048?1024:2048得出结果1024，直接使用常量minval=1024\tminval=min(foo(),bar()+1)\t//有副作用，导入临时对象,避免重复求值\t//int t1,t2;\t//minval=(t1=foo()),(t2=bar()+1),t1t2?t1:t2;\treturn minval; Local variables加入一个局部变量，类似int minval inline int min(int i,intt j)\tint minval=ij?i:j;\treturn minval;//如果这样调用\tint local_val;\tint minval;\t//...\tminval=min(val1,val2);// inline函数扩展后的局部变量可能变成下面的样子\tint local_val;\tint minval;\t//将inline函数的局部变量mangling\tint __min_lv_minval;\tminval=(__min_lv_minval=val1val2?val1:val2),__min_lv_minval; 如果 inline 函数以单一表达式扩展多次，则每次扩展都需要自己的一组局部变量。 inline 函数以分离的多个式子被扩展多次，那么只需要一组局部变量求值就能重复使用。 inline 函数扩展后的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生，特别是它以单一表达式被扩展多次的话，例如： //例如：minval=min(val1,val2)+min(foo(),foo()+1);//可能扩展成：//为局部变量产生临时变量int __min_lv_minval_00;int __min_lv_minval_01;//为放置副作用值而产生临时变量 （副作用值即要重复计算的值）int t1;int t2;minval= ((__min_lv_minval_00 = val1 val2 ? val1:val2), __min_lv_minval_00) + ((__min_lv_minval_01= (t1=foo()), (t2=foo()+1), t1 t2 ? t1:t2), __min_lv_minval_01 ); 两个特性 inline 函数可以有效存取封装于class中的nonpublic数据，同时也是#define的一个安全代替品。 但其弊端是，一个inline函数如果被调用太多次，会产生大量的扩展码，使程序的大小暴涨。 inline里再有inline可能因为连锁复杂度扩展不出来。 所以你需要小心处理 inline 函数 返回一个即将销毁的局部对象，像这样： X bar() X xx; ... return xx;//bar 的返回值怎么从局部对象 xx 中拷贝回来。 cfront做法： 加上一个类型为类对象引用的额外参数，用来放置拷贝构造出的返回值。 return 前穿插一个拷贝构造的操作：利用传回值(例子中的xx )初始化上面增加的额外参数。 于是我们希望得到的局部对象值，在真正的返回值返回通过额外参数返回了；而真正的返回值呢？ void bar(X __result) //额外参数 X xx xx.X::X(); //默认构造 __result.X::XX(xx); //拷贝构造 return ; //真正的返回值什么都不返回（注意函数类型) 接下来转换每个bar()调用操作： X xx = bar(); //转化为X xx; bar(xx); //不必实行默认构造bar().memfunc();//可能转化为X __temp0(bar(__temp0),__temp0).memfunc();X (*pf)();pf = bar;//转化为void (*pf)(X);pf = bar; 概括来说：用一个载体来 copy 对象（已经有载体了就作为参数）。"},{"title":"inside object model","path":"/wiki/cpp/inside object model.html","content":"第3章 Data语意学（The Semantics of Data）一个 libraryclass X ;class Y : public virtual X ;class Z : public virtual X ;class A : public Y, public Z ; 在这个继承体系下，X 、Y 、Z 、A 各自的大小不是0，而分别是：1、8 、 8 、12（byte）。 原因： 对于X：X大小为1，是因为编译器不允许独立 class 占用内存为0。它在 class X 中偷偷插入了一个 char 指针。 对于Y、Z： 语言本身的 overhead ：为了支持 virtual base class , 类内会插入一个 vptr 指针来指向相关 virtual table。 table 里存放 virtual base class subobject 的偏移地址或实际地址。 X 的 char 指针被偷偷继承了，此时子类大小为 1+4 5 byte 。 这里许多编译器会对这个char指针进行优化，但该例中没有。 Alignment 齐位要求导致 5-8 byte。 32位计算机的内存齐位大小：4byte 许多编译器对继承来的 空白基类char指针会进行优化。 （优化后，Y和Z 只剩一个指针的大小为 4 byte） 优化方式：EBO ，让空白虚基类作为子类对象开头的一部分（不花费任何空间） 对于 A：virtual base class 不会让A的内存变成简单的 8+816。 至于为何变成12： 虚基类的subobject（子内容）占 1 byte。 Base class Y 和 Z 减去了vptr 的大小为4 byte，4+48byte class A 自己的大小为 0 齐位要求：9-12 byte 。 如果编译器有EBO，大小则为 8 byte。 （如果虚基类里本身有数据（一个以上），EBO就会失效，两种编译器的对象布局会完全相同） 另外 C++Standard 不强制规定 base class subobject 的排列顺序或 不同存取层级的 data member 顺序。 它也不规定 virtual function 或 virtual base class 的实现细节。它认为这些应该交给厂商决定 这一章中有两个关键点：class中的 data members 和 class hierarchy 。 class.data members能够表现 class 的状态： Nonstatic data member 放置的是针对个别 object 的数据。数据和对象的内存在一起。 static data member 放置的是针对整个类（共享）的数据。数据被放置在 global data segment 中。它永远只有一份实例。 即使 class 没有任何 object ，static data 也存在。这一点在template class 中稍有不同。 Nonstatic data 的设计考虑到了与 C-struct 的兼容。 编译器为实现 virtual 等会加上许多额外 data member ，加上边界需要，内存往往比想象中更大。 3.1 The Binding of a Data Member 从编译器角度探索代码实现的一些过程 //某个foo.h头文件extern float x;\t//x在别处被定义，此处被引用。这里x是声明不是定义，定义是要分配存储空间的。//Point3d.h文件class Point3d\tpublic: Point3d(float,float,float); //问题：被回传和设定的x是哪一个x呢？ float X()const return x; void X(float new_x)const x=new_x; //...\tprivate: float x,y,z;; 在今天的编译器下，point::X()传回 class 内部的x。早期编译器为了防止指向 global x object ，有两种设计思路。 所有data member 放在开头，来确保正确绑定。 class Point3d float x,y,z; //看到它们了public: float X() const return x; //不怕被外部引入调用了！ 把所有 inline function 放到类的声明之外。 classs Point3dpublic: Point3d(); float X() const; void X(float) const; //编译器只看到了声明，看到下面的内部变量后再去实现 ...inline float Point3d::X() const return x;放到实现外... 这两个古老思路被称为 member rewriting rule ,不允许 inline 函数实体在 class 声明被完全看见之前去进行 evaluate。 C++ Standard 以 member scope resolution rules 来更好完成 rewriting rule 。 效果：inline function 在class声明后被立刻定义，仍然对其评估求值。 extern float x;\tclass Point3d\tpublic: ...\tvoid X(float new_x)const x=new_x; //对于函数本体的分析将延迟到编译器发现 class 的 “” 时\tprivate: float x,y,z;; 对member function 的本体分析，直到整个 class 声明都出现才开始。这时不需要把所有类内部函数实现转移到类外部了。 特殊情况：member function 的 argument list typedef int length; //重命名类型了class Point3d\tpublic: ...\tvoid X(length val)const _val=val; // argument 1 length mumble() return _val; // argument 2\t//对于函数本体的分析将延迟到编译器发现 class 的 “” 时\tprivate: typedef float length; length _val;; 非我们所愿的数据绑定情况在两个参数第一次被编译器看到时，仍然会发生。上面的两个 length 类型 都被 resolve 成 global typedef 了。 这样一来，后续在去 nested - typedef length，就会导致编译器报错并定义最早的绑定不合法。 所以，把嵌套的 typedef 放到 class 起始处吧。 3.2 Data Member Layoutclass Point3d\tpublic: //...\tprivate: float x; static ListPoint3d* *freeList; float y; static const int chunkSize=250; float z;; non-static data member 在 class object 中的排列顺序和其被声明的顺序一样。 任何中间介入例如freeList和chunkSize的static数据成员 都不会被放进对象的布局之中。 在上述例子中，每一个Point3d的对象由3个float组成，次序是x,y,z static数据成员存放在程序的数据段中，属于整个类，不属于某个对象。 C++ Standard要求，在同一个access section（也就是private,public,protected等区段）中，只需要满足**“较晚出现的数据成员在对象中有较高的地址”**即可。 即在同一个acess section中，次序按照声明的次序，但是不一定连续，可能因为齐位调整(alignment)或者编译器自动合成的一些内部使用的数据成员，如虚函数表指针vptr插入到这些数据成员到中间。 （传统的编译器会把vptr放到所有明确声明的数据成员最后，当然也有编译器放在对象的最前端。总之C++ Standard 对这种布局很宽松啦） 对于不同access section的情况： class Point3d\tpublic: //...\tprivate:\t//一个acess section float x; static ListPoint3d* *freeList;\tprivate:\t//另一个acess section float y; static const int chunkSize=250;\tprivate //另一个acess section float z;; 大小和组成同先前的一样。排列顺序由编译器决定。 主流想法是：把一个以上的 access section 连锁在一起，按照声明顺序形成连续区块。 Access section 的多寡没有额外负担。8个section中的8个member 和1个 section 中的8个 member 大小一样。 拓展 一个能判断谁先出现在 class object中的 template function。 (两个 member 都是不同的 access section 中第一被声明者，此函数就可以用来判断哪一个 section 先出现) template class class_type, class data_type1, class data_type2 char* access_order(data_type1 class_type::*mem1, data_type2 class_type::*mem2) assert (mem != mem2 ); return mem1 mem2 ? member 1 occurs first : member 2 occurs first access_order(Point3d::z , Point3d::y);//class_type == Point3d//data_type1 == data_type2 == float 3.3 Data Member的存取Point3d origin;origin.x = 0.0; 下面来根据根据不同情况分析 x 的存取成本。 分析前的一个问题 Point3d origin, *pt = origin;origin.x = 0.0;pt-x = 0.0; 通过 origin 存取和 通过 pt 存取 有什么差别吗？ 稍后会回答。 Static Data Members 前面讲过，每一个static成员只存在一个实体，存放在程序的data segment数据段中，被视为一个global变量（只在class存在范围内可见） origin.chunkSize=250;\t//这样调用，内部转化为：//Point3d::chunkSize=250;\tpt-chunkSize=250;\t//这样调用，内部转化为：//Point3d::chunkSize=250; 通过 member selection operators（“.”运算符）对 静态成员变量进行操作只是语法上的简便操作。实际上static-member 并不在 class 对象中。所以存取 static member 并不需要通过 class 对象。 chunksize是继承来的member 各种复杂关系，比如虚基类的虚基类那里继承而来。。。 不会发生任何变化。static-member 仍然在栈里等待着。 static data member 通过函数调用 一种可能的转化（不同标准不同处理） foobar().chunkSize=250;\t//这样调用，内部转化为：//(void)foobar();//Point3d.chunkSize = 250; 取静态成员变量地址 因为 static member 不内含在 class 对象里，取其地址不会得到指向对应 class member 的指针，而会得到指向其本身数据类型的指针。 Point3d::chunkSize; //得到 const int* 类型的内存地址 //而不是Point3d::*类型的地址（指向类对象成员的指针）。 对于静态成员冲突： 如果一个程序里定义了两个类，两个类都声明了一个static成员，且两个static成员同名，那么都存放在程序的数据段中时会引起同名冲突。 编译器会暗中对每一个static成员编码，得到一个独一无二的程序识别代码(一起扔到某个表格之类的东西里)，这种手法叫name-mangling（不同编译器编码不同）。主要做两件事： 1、一种算法，推导出独一无二的名称 2、推导出的名称能够还原(万一编译系统（或环境工具）必须与使用者交谈，那么那些独一无二的名称 可以轻易被推导回原来的名称) Nonstatic Data Member non-static成员存在于每一个对象中，必须通过显示的或者隐式的对象才能对non-static成员进行存取。 只要程序员在成员函数里直接处理non-static成员，隐式的对象就会出现（它就是被编译器隐藏的家伙）。 Point3d::translate(const Point3d pt)\tx+=pt.x;\ty+=pt.y;\tz+=pt.z;//内部转化为：(编译器在参数列表上加了this指针)Point3d::translate(Point3d *const this,const Point3d pt) //第一个参数 this 是隐藏的！\tthis-x+=pt.x;\t//this指针就是上述的隐式的对象\tthis-y+=pt.y;\tthis-z+=pt.z; implicit class object 由 this 指针表达。 对 nonstatic data member 进行存取操作时，编译器会要求 class object 的起始地址 + offset(data member)偏移地址 。 origin.y = 0.0;//即origin + (Point3d::y-1); -1是为了让系统区分指向成员变量的指针中，空指针和指向第一个变量的指针（两者都是0） nonstaic 成员变量的offset在编译期就能得知。即使该 member 属于 base class subobject（继承来的子内容）。因此存取效率和 C struct 成员 或独立类中的 成员 是一样的。 虚拟继承 Point3d origin;Point3d *pt = origin;origin.x=0.0;pt-x=0.0; 虚拟继承使 base class subobject 存取 class members 增加了新的间接性。 （指针的间接性 + virtual vptr 间接性） 当然，x 在作为 struct 成员，独立类成员、普通继承（非virtual）成员的效率都相同。但在作为我们当前讨论的 virtual base class 时，存取速度会稍慢。 这时就回到了该节开头的那个问题：以上两个存取方式有什么重大差别？ 答案：当Point3d为子类，继承过一个 virtual base class，而 member（如x）又属于这个虚基类时，差别就会很大： pt由于间接性，不能确定指向哪一种 class type ，于是在编译期就无从知晓该成员的偏移位置。所以这个存取操作被转移到了运行期（通过额外的间接索引来解决）。 origin 不会存在pt的问题，他的类型很明确，即 Point3d class。即使它继承自虚基类，成员偏移量也能够在编译期固定。 戏份更多的编译器甚至能通过 origin 静态解决掉对x的存取操作。 3.4 继承与 Data MemberCPP继承模型中，一个子类对象表现出来的东西，是 derived class member 和 base class member 的总和。但这两者的排列顺序并没有明确规定。 通常 base class members 先出现，属于virtual base class 的部分除外。 class Point2d\tpuiblic: //functions\tprivate: float x,y;class Point3d\tpuiblic: //functions\tprivate: float x,y,z; 下面我们将在以上两个独立类之间的关系上做文章，分别讨论：“单一继承且不含 virtual function”、“单一继承并含virtual functions”、“多重继承”、“虚拟继承”的情况。 先看下独立类时的状态（non-virtual function） 和 C struct 完全一样 只要继承不要多态现在从Point2d派生出Point3d，于是Point3d将继承x和y坐标的一切（包括数据实体和操作方法），使Point无论2d或3d都可以共享数据本身和数据的处理方法。 一般而言，非虚拟继承并不会增加空间或存取时间上的额外负担。 class Point2d\tpublic: Point2d(float x=0.0,float y=0.0):_x(x),_y(y); float x()return _x; float y()return _y; void x(float newX) _x=newX; void y(float newY) _y=newY; void operator+-(const Point2d rhs) _x += rhs.x(); _y += rhs.y(); //...\tprotected: float _x,_y;;class Point3d:public Point2d\tpublic: Point3d(float x=0.0,float y=0.0,float z=0.0): Point2d(x,y),_z(z); float z()return _z; void z(float newZ) _z=newZ; void operator+-(const Point3d rhs) Point2d::operator+=(rhs); _z += rhs.z(); //...\tprotected: float _z;; 普通继承的好处是负责坐标点的程序代码能够局部化，同时能够表现出两个 class 的紧密关系。即使两个类独立出来，也不需要改变声明和使用。 但这种设计有两个坑： 这种继承关系需要选择某些函数作为 inline 函数，否则就会出现相同操作的函数重复出现。 如示例中的 operator + 和 constructor 函数： Point3d object 的初始化和加法操作，需要部分point2d 和 部分 point3d 作为成本。 将一个类拆分成两层或者更多层的类时，为了表现”类体系的抽象化“而造成空间膨胀。 以 concrete 类为例 class Concrete\tprivate: int val; char c1; char c2; char c3;; 空间分析（32bit）：val - 4byte , c1 , c2 ,c3 各占用 1byte；齐位要求：4+3→8byte 这个案例中如果有以下应用场景：将 concrete 分裂成三层结构 class Concrete1\tprivate: int val; char bit1;;class Concrete2:public Concrete1\tprivate: char bit2;;class Concrete3:public Concrete2\tprivate: char bit3;; 空间膨胀喽：三次齐位要求造成内存为 8+4+4 16 byte 不要想当然认为 concrete::nonstatic data member bit2 会填补 concrete1的空间。齐位填充会提前发生。 那么这种提前填充，或者说没有把子类和父类子对象填充在一起的设计用意何在呢？ 看看这个例子： Concrete2 *pc2;Concrete1 *pc1_1 , *pc1_2; //这俩可以指向上述三种classes object。 发生下述操作时： *pc1_2 = *pc1_1; 应该执行一个默认的 memberwise 复制操作，来一个一个复制 Concrete1的member 。 如果pc1_1 指向一个 Concrete2 object 或 Concrete3 object 的话，上述指针赋值操作应将复制内容指定为 Concrete1 subobject。 但如果子类成员和父类子对象捆绑在一起，来填补空间的话，就会发生意外： //pc1_1和pc2:既有基类子对象，又有自身成员属性。但两者绑定在了一起//pc1_2pc1_1 = pc2; //令 pc1_1 指向 Concrete2 对象*pc1_1=*pc1_2; // pc1_1 的 derived class subobject 会被覆盖，使bit2被覆盖产生非预期 上述操作会把Concrete1对象逐对象拷贝，包括原本应该padding的三个字节，于是实际pc1_1指向的Concrete2对象的bit2会被覆盖掉，出现一个无法确定的值。 下图为绑定后的过程 ： 在子类中的 base class subobject 的原样性被破坏后，会导致 copy 时 Concrete 1 的子对象复制给 Concrete2， 破坏了 Concrete 2 (捆绑后) 的成员。 加上多态多态嘛，处理一个坐标点而不在乎它是 Point2d 还是 Point3d ，在继承关系中提供一个 virtual function 接口。 class Point2d\tpublic: Point2d(float x=0.0,float y=0.0):_x(x),_y(y); float x()return _x; float y()return _y; void x(float newX) _x=newX; void y(float newY) _y=newY; //修改1：加上z的保留空间，当前什么也没做，2d的z点返回0.0也是合理的(只是为扩展性存在) virtual float z()return 0.0; virtual void z(float) //修改2：设定下面的运算符操作为virtual virtual void operator+=(const Point2d rhs) _x += rhs.x(); _y += rhs.y(); //...\tprotected: float _x,_y;; 既然多态，导入一个 virtual 接口才显得合理。 void foo(Point2d p1,Point2d p2)\t//...\tp1+=p2; //p1 可能是2d，可能是3d\t//... Point3d： class Point3d:public Point2d\tpublic: Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z); float z()return _z; void z(float newZ) _z=newZ; //修改：参数改成const Point2d rhs（原来是Point3d） void operator+=(const Point2d rhs) Point2d::operator+=(rhs); _z += rhs.z(); //...\tprotected: float _z;;//修改后最大的好处就是可以把operator+=运用在一个Point3d对象和Point2d对象上Point2d p2d(2.1,2.2);Point3d p3d(3.1,3.2,3.3);p3d+=p2d;//得到的p3d新值为(5.2,5.4,3.3) 两个 z() member function 和 operator+()运算符 都成了 virtual function 每一个Point3d class object 内含一个额外的 vptr member（from Point2d） 面向对象的弹性会带来相应的实现负担： 导入一个和Point2d有关的虚函数表，存放声明的虚函数地址，还有支持runtime type identification相关的东西。 每一个类对象要加一个虚函数表指针vptr，提供执行期的链接，使得每一个对象都能找到相应的虚函数表。 构造函数需要为vptr提供初始值，让它指向类对应的虚函数表。这可能意味着所有派生类和基类的构造函数都要重新设定vptr的值。 这些操作都是编译器偷偷做出的。 析构函数需要消除vptr。vptr很可能已经在派生类析构函数中被设定为派生类的虚函数表地址，析构函数的调用次序反向的，从派生类到基类。 负担程度视“被处理的Point2d objects 的个数和生命期”而定。同时也要考虑“多态设计取得的收益”。 vptr位置问题 编译器领域有一个讨论点：vptr 放置在 class object 的哪个位置。 放在尾端 Struct no_virts\tint d1,d2;;class has_virts:public no_virts\tpublic: virtual void foo(); //...\tprivate: int d3;no_virts *p = new has_virts; 好处：与 base class C struct 对象布局相兼容。 上例中，带有虚函数的继承布局（vptr在尾端） 放开头 vptr 在 class object 前端，对于多重继承场景，通过指针(指向类成员)调用虚函数有帮助： class object 起始点开始测量计算的 offset 不需要在运行期准备了；与 class vptr 间的 offset 也不需要在运行期准备。 缺点：丧失了C语言兼容性。 老实说，这种兼容无关痛痒，谁会在 C struct 上派生出多态 class 呢？ 多重继承 自然多态（natural polymorphism）:单一继承中，父类和子类转换很自然，因为它们的继承对象起始地址相同，所以父类指针指向子类对象时，不需要编译器参与调整地址，效率很高。 non-virtual 基类下如果存在一个子类有 virtual function，就会失去单一继承的自然多态。这时，子类转为基类，就需要编译器介入来调整地址（因为vptr插入到了 class object 的起始处)。 多重继承中，子类和基类的关系并不那么“自然”。 class Point2d\tpublic: //有虚函数，所以Point2d对象中有vptr\tprotected: float _x,_y;;class Point3d\tpublic: //...\tprotected: float _z;;class Vertex\tpublic: //有虚函数，所以Vertex对象中有vptr\tprotected: Vertex *next;;class Vertex3d:public Point3d,public Vertex\tpublic: //...\tprotected: float mumble;; 对于这种多重派生对象，将其地址指定给最上层的 base class 指针时，情况和单一继承相同（父子指向相同地址，成本只有指定地址的操作）。 后续子类的地址指定操作，则需要手动调整地址。 Vertex3d v3d;Vertex *pv;Point2d *p2d;Point3d *p3d;\t//Point3d的定义看回上一小节pv=v3d;\t//内部转化为：pv=(Vertex*)(((char*)v3d)+sizeof(Point3d)); //Point3d 包含 Point 2d。p2d=v3d;\t//这两个操作只需要简单地拷贝地址就行了p3d=v3d;\t//因为Point2d和Point3d和Vertex3d的对象起始地址都相同Vertex3d *pv3d;Vertex *pv;pv=pv3d;//不能简单地转换成下面这样，因为如果p3d为0，那么将获得sizeof(Point3d)的值，这是错误的pv=(Vertex*)(char*)v3d+sizeof(Point3d);\t//错误//应该加个条件判断应付空指针情况，如果是引用则不需要加这个判断pv=pv3d ? (Vertex*)(char*)v3d+sizeof(Point3d):0;\t//正确 C++ Standard 并未要求Vertex3d 中的 base class Point3d 和 Vertex 有特定排列顺序。 CFront 和许多编译器，按照声明顺序排列继承的基类：Point3d subobject + Vertex subobject + Vertex 3d subobject 依次存储。 （加上虚拟继承就不一样了） 存取第二层以上的基类的 data member ，只是一个简单的 offset 运算。 虚拟继承虚拟继承的应用场景很狭窄，几乎是为解决多重继承的重复副本而生的。 //多重继承class ios//...;class istream:public ios//...;class ostream:public ios//...;class iostream:public istream,public ostream//...;//虚拟继承class ios//...;class istream:virtual public ios//...;class ostream:virtual public ios//...;class iostream:public istream,public ostream//...; iostream 继承 istream 和 ostream 时，只需要一个 ios subobject。解决方法即虚继承。 虚拟继承的实现需要将 两个基类各自维护的一个 ios subobject 折叠成一个由共同子类维护的单一 subobject，同时保存好基类和子类各自的指针(引用)间的多态指定操作。 Class 继承体系出现 virtual base class subobject 后，会分割成两部分： 不变区域：这里的数据不管后续继承的变化如何，拥有固定 offset （从 object 开头），可直接存取。 共享区域：即virtual base class subobject 部分的数据，其位置随着每次的派生操作都会有变化，只能间接存取。 各编译器对间接存取的实现技术不同。 以下是三种 v-base-class-s 的间接存取策略。 指针实现 class Point2d\tpublic: //...\tprotected: float _x,_y;;class Vertex:public virtual Point2d\tpublic: //...\tprotected: Vertex *next;;class Point3d:public virtual Point2d\tpublic: //...\tprotected: float _z;;class Vertex3d:public Vertex,public Point3d\tpublic: //...\tprotected: float mumble;; 一般的布局策略是先安排好派生类中不变的部分，再建立共享部分。cfront编译器会在每一个派生类对象中安插一些指针，每个指针指向一个虚基类。要存取继承得来的虚基类成员，可以使用相关指针间接完成。 void Point3d::operator+=(const Point3d rhs)\t_x+=rhs._x;\t_y+=rhs._y;\t_z+=rhs._z;;//在cfront的策略下，这个运算符会被内部转化为：//c++伪码_vbcPoint2d-_x += rhs_vbcPoint2d-_x;\t//vbc 即virtual base class_vbcPoint2d-_y += rhs_vbcPoint2d-_y;_z+=rhs._z;//一个派生类和基类的实例之间的转换：Point2d *p2d=pv3d;//在cfront的实现模型下，会变成：//c++伪码Point2d *p2d=pv3d？pv3d-_vbcPoint2d:0; 每一个对象必须针对每一个虚基类背负一个额外的指针，但是我们希望每一个类对象的大小是固定的，不因为其虚基类的数量而变化。 解决方法： 1、微软的编译器里会引入虚基类表（类似于虚函数表），在继承虚基类的子类对象中，通过一个虚基类表指针指向虚基类表（虚基类指针存放在这些表格中）。2、在虚函数表中放置虚基类的offset（而不是地址）。 (作者实现时，将虚基类偏移地址和虚函数入口混杂在一起，通过正负值索引区分虚函数表中的地址：正数索引到虚函数，负数所引导虚基类) 下图显示了这种base class offset实现模型： void Point3d::operator+=(const Point3d rhs)//这里_vptr_Point3d[-1]存放的是虚基类距离对象起始地址的offset//this是对象起始地址，所以加起来就是虚基类的subobject(this+_vptr_Point3d[-1])-_x += (rhs + rhs._vptr_Point3d[-1])-_x;(this+_vptr_Point3d[-1])-_y += (rhs + rhs._vptr_Point3d[-1])-_y;_z+=rhs._z; ;//为了可读性，没有做类型转换，也没有先执行对效率有帮助的地址预先计算操作 这种功能的成本只会在member使用的过程中消耗，所以属于局部性成本（虽然本身有点昂贵）。 示例： Point2d *p2d=pv3d;//在上述实现模型下变成：Point2d *p2d=pv3d?pv3d+pv3d-_vptr_Point3d[-1]:0; 每有一层虚拟继承，间接存取的层次就会加一层（三层继承，就要通过三个 virtual base class 指针进行三次间接存取）。我们希望每次存取时间都是固定的，不因为虚拟派生的深度而改变。 通过拷贝操作取得所有嵌套虚基类指针，将之放到子类对象中，这样就不用间接存取了，用空间换时间。下图显示了这种模型的实现： 区分 非多态的 class object 存取继承而来的 virtual base class 的成员： Point3d origin;...origin._x; 可直接被优化为直接存取，在这次存取和下一次存取的过程中间，对象类型不可改变。 如同对象调用虚函数可以在编译器完成。 一般而言，虚基类最有效的一种运用方式就是：一个抽象的虚基类，没有任何数据成员。 3.5 对象成员的效率1、直接存取对象成员和使用inline的Get和Set函数存取对象成员经过优化后效率一样。2、除了虚拟继承情况外，1中的效率一样（包括单一继承的情况）。随着虚拟继承层数增加，1中存取对象的时间增大。 3.6指向数据成员的指针#include pch.h#include iostreamusing namespace std;class Point3d public: ~Point3d(); void static getOffsetOfZ() printf(%d , Point3d::z);\t//8 //因为同一个acess section里的成员要按声明次序排列，z前面有x和y //一个float是4 bytes，这里是8说明vptr放在尾端，如果是放在头端这里的输出应该是12 bytes cout Point3d::z endl;\t//1,因为Point3D没有定义操作，所以编译器这里自 // 己偷偷进行转化，输出结果就为1 //... protected: static Point3d origin; float x, y, z;\t;int main() Point3d::getOffsetOfZ(); 实际上 offset 往往比 正常地址位置 多1，也就是说，如果vptr放在对象头端，三个坐标值在对象布局中的offset分别是1,5,9；如果vptr放在对象尾端，三个坐标值在对象布局中的offset分别是5,9,13。 （原因和3.3中non-static成员中-1的原因一样）：为了区别一个类数据成员类型的指针是空指针和指向第一个offset为0的成员时的情形. 理解了指向成员变量的指针后，就可以明确下 Point3d::z 和 origin.z 的差别了。 取 nonstatic data member 的地址：得到它在类中的 offset 取 绑定在特定实例对象身上的成员地址： 得到它在内存中的真正 address origin.z 减 z 偏移量 同时 加 1 ，即origin起始地址 origin.z 返回类型为 float* 而不是 float Point3d::* 在多重继承下，如果要将第二个或者后继的基类指针和一个“与派生类对象绑定”的成员结合起来，会在偏移量的问题上变得比较复杂： #include pch.h#include iostreamusing namespace std;struct Base1 int val1; ;struct Base2 int val2; ;struct Derived :Base1, Base2 ;void func1(int Derived::*dmp, Derived *pd) //第一个参数期待传入的是指向 Derived的成员 的指针\t//但是如果传进来的是指向 基类的成员的 指针呢？\tprintf(%d , pd-*dmp);\t//-858993460void func2(Derived *pd) int Base2::* bmp = Base2::val2; //注意这里特意设置为 base2指针而非base1 pointer\tprintf(%d , bmp); //0，pffset为0没问题(注意，这里算上偏移量，bmp为0+1=1)\t//但是在Derived中，val2的offset是4 (额，offset便是4+1=5)\tfunc1(bmp, pd);int main() Derived d;\tfunc2(d); 当 (指向base2成员) 变量的bmp被作为func1()的第一个参数时，它的值就必须因介入的Base1 class的大小而调整，否则pd-*dmp将存取到Base1::val1，而不是希望的Base1:val2，要解决这个问题，必须经过以下过程： //经由编译器内部转换func1(bmp+sizeof(Base1),pd);//还要防范bmp==0func1(bmp?(bmp+sizeof(Base1)):0 ,pd);"},{"title":"effective cpp","path":"/wiki/cpp/effective cpp.html","content":"前言：拖了好久的巨坑。不是很深，打算大火猛烹，一口气翻完星空cpp（effective c++），为开学和另一本蓝书做准备。不过我买的那本星空模糊的不行，盗版的感觉。阅读体验还不如pdf+pad。 还有就是学习知识后及时复习。除了 温故知新 可为师也 外，还因为人是真的很健忘的 好吧。 另：由于目前在学英语的转型期，会有很多半英半汉的别扭语句。首先这不是为了装逼，其次如果阅读体验实在不佳可以换其他的blog，不要浪费时间。 @[TOC] 第一章：Accustoming Yourself to C++1.视C++为一个语言联邦（federation of languages） C++作为一个多重泛型编程语言，斟酌选择使用其某一部分是很有必要的。 如上所言，今天的C++早已超过了C with class 的要求，它的延伸性非常高——因为它是一个“语言联邦”。联邦包含四部分： C语言 ：C的基础模块。blocks、statemnts、preprocessor、built-in data types、array、pointers等都是和C语言同气连枝。 Object-Orientd C++ ：面向对象的编程。即C with class，功能包括继承、封装、多态 Template C++ ：cpp的泛型编程(generic programming) 部分。它的背后有TMP(metaprogramming)模板元编程的思路，是很强大的编程范型。 STL ：containers,iterators,algorithms 和 function objects 由template程序库 —— STL 统筹配合，共同发挥作用。 在追求高效编程时，这四部分的规则往往有所分歧。这也是为什么要根据需求考虑这四部分，从而达到最佳效率。 例如：同样的按值传递(pass by value)和按引用传递(pass-by-reference), 前者对C语言和STL两部分更加使用，而后者在面向对象和泛型编程时则更加高效（尤其Template），这是由于user-defined 构造和析构函数 的存在。 2.尽量以const，enum，inline 替换 #define 单纯常量，用const或enums 来替代 #define 函数宏，改用内联函数(inline)替换 #define 一言蔽之，这是用 编译器的处理 替代 预处理器的处理。 原因： 宏定义的常量由预处理处理，这意味着编译器看不到他。编译器看不到，意味着宏常量一旦出错，在追踪它时会给你造成不小麻烦。（看不到的原因：宏常量没有进入记号式调试器(symbolic debugger)和记号表(symbol table)） 对于浮点常量，define 直接替换可能导致目标码(object code)出现多份浮点数，导致数据冗余。 常量定义式通常被放在头文件内。 三类场景 class专属常量 确保这个常量只有一个实体，有必要加上static状态，即class{static const type}。 如果需要取地址编译器有定义式要求，可以在类外提供定义式： const typename classname: : 名称; (这里可以赋值) 如果编译器不允许初值设定,可以放弃static const 改用枚举类型作为补偿：class{enum {num = 5}; int array_1[num];}，使其成为记号名称 Define由于作用域封装性原因，有很大局限性。 enum hack ​ 可以用enum实现常量定义，它相比cosnt也更像#define。 enum能帮助常量实现阻止其他指针和引用指向的约束。 eunm不会导致非必要内存分配。 取const地址合法； 取enum不合法，取define常量同样不合法。 宏函数 用template inline 替代define #define MAX(a,b) f((a)(b)?(a):(b)) //选择较大值作为f函数的参数 替换为 templatetypename Tinline void MAX(const Ta,const Tb)f(ab?a:b) ; 3.尽可能使用const 在任何可行的场景声明const提醒编译器，也提醒你自己。 编译器强制实施 biwwise constness，编写程序时要利用conceptual constness 灵活实现目的。 const 和 non-const 成员函数有同样实现时，把两份实现合并成一份，且只允许令non-const调用const。 细节注意： const的位置：在星号 ‘*’ 左边是指针常量指向内容不可改变；在右边则是常量指针本身不可改变。 迭代器的const用法是静态迭代器：const_iterator。 多数情况，函数返回一个常量值能够防止客户操作出意外。 对于 const 成员函数的操作有两种态度： bitwise(physical） constness: const 成员函数不能修改对象的任何成员变量，一个bit都不行。 conceptual（logical） constness: const 成员函数可以通过mutable修改对象的某些bit。 面对 non-cosnt 和const 两种类型都有需求，而在实现上完全重叠的情况时，合并。 示例： Class TextBlock public: const char operator[](std::size_t position) const #罗里吧嗦一大堆东西 return text[position]; char operator[](std::size_t position) const #罗里吧嗦一大堆东西 return text[position]; private: std::string text; 更改为： const char operator[](std::size_t position) const #罗里吧嗦一大堆东西 return text[position];//const类型的实现，将由non-const 借助调用 char operator[](std::size_t position) const return const_castchar( //2.调用完成后移除const static_castconst TextBlock(*this) //1.为*this 添加const [position]; //同时帮助operator[]调用const版本 ); 提醒大家：反之用 non-const 去实现的话，const调用是很危险[^2]的。 [^2]: const里包含解const操作，即const_cast 会打破金身，带来风险。 4.使用对象前初始化它 对内置对象你要手动初始化，克服懒惰。 构造函数用成员初值列(member initialization list) 的方法初始化成员变量（初始化顺序对应其声明顺序）， 构造函数里用 “” 赋值 仅仅是赋值操作(assignment) ，与初始化是两码事 用 local static 对象(函数内对象)替换 non-local static 来避免 Object_1 使用另一个“未经初始化”的Object_2 来初始化自己。 我们来着重解释下第三点。 存在周期和程序一样的对象不多。static、global、in-namespace 的对象都属于此。函数内静态对象称为local static（ local 是相对于函数而言），其余为non-local static。 C++对两个编译单元内的静态对象互相初始化的行为，并无明确定义。这就需要我们在编写程序时留份心。 示例如下： class Server public: size_t numDisks() const; extern Server tfs; //extern 意味着要到另一个编译单元。 这里tfs还没有初始化 这里我们设想Server作为服务端，对提供给客户的tfs对象，在自己的类构造函数里有一个极其优雅的初始化操作。可一旦用户使用该对象先于它的初始化操作，就会出现非常Crazy的后果。就像下面这样： class Userpublic: Init(params) //初始化操作 size_t disks = tfs.numDisks();//在此编译单元使用 tfs 。 User temp(params); //这个初始化调用，可能变成万恶之源。 改进： //Server端：Server:: Server tfs static Server tfs; return tfs;//先搞个函数初始化好，成为local static对象↑//User端：User::Init(params)size_t disks = tfs().numDisks() ; //这里调用tfs()函数，返回初始化的对象User temp()static User td; return td; //同Server 替换对象 第二章 : Constructors, Destructors, and Assignment Operators5.了解C++偷偷编写调用的那些函数 编译器会为类创建默认构造函数、拷贝构造函数、析构函数 和 拷贝赋值函数。 你自己声明相关函数，不管有参没参，编译器都不会插手这件事情。 class nameobject\tpublic:\tnameobject(string name , const Tvalue): name(this-name),value(this-value);private:\tstring name;\tconst T value;; string newdog(Persephone);\tstring olddog(Satch);\tnameobjectintp(newdog,2);\tnameobjectints(olddog,36);\tp=s; //What happened in P member？ CPP编译器会拒绝编译13行的拷贝赋值。因为你得自己定义。 base class 声明拷贝赋值为 private 权限，编译器会拒绝为继承它的子类生成拷贝赋值。 子类继承拷贝赋值操作是为了处理base class元素。这一元素却是私人权限，编译器无能为力。 实际上，这些自动生成的函数只有在被调用且没有实现时，才会被编译器创建出来（给你擦屁股喽）。 6.明确拒绝不想使用，而编译器自动生成的函数 拒绝 Compiler 自动生成的函数： 你可以将对应成员函数声明为 private 且不予实现； 继承特定的base class copy构造函数和copy assignment（赋值）函数 很容易因为调用被编译器创建出来。但有些场景你会反感这种“帮倒忙”的行为。看看怎么明确拒绝吧。 将copy 函数声明为private，并实现为空。 调用的话会获得连接错误（linkage error）。但member函数和friend函数调用还是可以调用它。 源码中的 ios_base , basic_ios , sentry 都有这种花招出现。 继承特定的 base class 。 这种方法能把连接错误转移到编译期。 class Uncopyable protected: Uncopyable() ~Uncopyable() private: Uncopyable(const Uncopyable); Uncopyable operator=(const Uncopyable); 以 private 类型继承它，不要犹豫。 尝试拷贝它的子类时，编译期会尝试自动生成copy函数，但base class的出现使编译器转向调用 base class 的函数，然后被 private 权限拒绝。 7.为多态基类声明virtual析构函数 polymorphic（多态）性质的 base class 应该声明一个 virtual 析构函数。 即：class 中出现了virtual 就要有virtual析构 Class只有在作为 base class 的需求和具备多态性质时，才声明 virtual 析构函数。 这两点是同一问题的两个角度 以上两种情况的 virtual 当然可以用 pure virtual 纯虚析构函数 实现 纯虚析构会使该 base class 抽象化。这能督促其 derived class 主动实现完成虚析构。 这里需要一个概念： factory function 工厂函数：返回一个base class 指针,指向新生成的 derived class 对象。 PS：为了避免泄露内存，返回指针指向的对象必须在heap上，由此使用后务必Delete掉。 **问题场景：**子类继承父类后，子类对象接收了一个父类的指针，并由父类指针删除。这会导致局部销毁而内存泄漏：继承的父类部分销毁而子类部分未被销毁（子类析构函数没有调用）。 解决方法： 父类本身的析构函数设为virtual 或 pure virtual。 子类要拒绝继承non-virtual析构函数的父类。 一些原理： pure virtual 纯虚析构的运作方式：最深层派生（辈分最小的）derived class 的析构先被调用，然后逐个调用其 base class。编译器会为子类的析构函数中，创建一个对父类纯析构实现的调用（实现需要自己写）。 virtual 函数的实现，要求对象携带一些信息，从而在运行时能 准确调用我们需要的那个 virtual。这份信息由 vptr(virtual table pointer) 指针 指出。这个小家伙指向一个由函数指针构成的数组，即 vtbl(virtual table) 。每个有 virtual 函数的 class 都有一个相应的vtbl。 所以当对象调用virtual函数， 实际函数取决于该对象的 vptr 所指向的 vtbl。通过 vtbl 编译器会找到合适的函数指针。 **使用 virtual 函数 会带来更大的内存占用。**vptr 作为指针，不可避免会占用内存。而且 vptr 占用的空间和其他语言也不同（C甚至没有 vptr ），所以移植性也不好。 反例：并非所有base class 都有多态性质。像 STL 和 string，它们没有设计用来“通过 base class 接口来处理 derived class 对象”，它们不需要 virtual 析构函数。相信我。 8.别让异常从析构函数这溜走 析构函数不能发生异常。一旦有可能发生异常的情况，析构函数也要能捕捉到，停止异常的传播或结束程序。 class 应该提供一个普通函数（非析构），帮助使用者对某个操作函数运行期间的异常作出反应。 一个示例：DBConnection( 数据库连接类 ) class DBConnection public: ... static DBConnection create(); //省略不要参数，该函数返回DBConnection对象 void close(); //关闭联机 很自然的做法：创建一个管理DBC资源的 class ，在该 class 的析构函数中 调用close。 类似这样： class DBManage //DBM 和 DBC 都在服务端。（虚拟场景）public: ... ~DBManage() db.close(); ; private: DBConection db;; 对于用户： //开辟一个blockDBConn dbc(DBConnection::create()) ; 当然，以上是建立在调用close()成功的基础上。 如果调用导致异常，析构仍然会传播异常，引出无法驾驭的麻烦。 两个思路解决： close()抛出异常，结束程序 —— 通过调用abort() DBConn::~DBConn() try db.close(); catch(...) // 记录失败日志。 std::abort(); 吞下这个异常 —— 记录信息，然后跳过它继续“正常运行” DBConn::~DBConn() try db.close(); catch(...) //记录失败日志。 不过这两种方法不能主动对异常情况做出反应。 这里解决方案是，重新设计DBM接口，使它增加一个主动反应的函数，这个函数的控制权给用户。 //class DBManage::public: void close()db.close(); close = true; ... ~DBManage() if(!closed) try db.close(); catch(...) //记录失败日志； ; private: DBConection db; bool closed; 所以到最后，用户和“资源类” 成为了双保险，以尽最大努力解决析构函数抛出的异常。 9.绝不在构造和析构过程中调用virtual function Base class 不要在构造和析构过程中调用virtual function，因为这类调用不能与子类里面的实现完成呼应。 解决方法：你可以用 non-virtual 函数传参的方法，代替父类函数根据不同子类信息实现类似功能的需求 Base class 调用的所有函数尽量服从统一约束。否则为了封装性你会牺牲安全性。（错误更加隐蔽） 原因： 子类对象创建后，首先进行父类构造函数。在父类成分完成初始化之前，该子类的数据状态始终视为父类（即使是dynamic_cast 或其他 runtime type information 检测也是相同结果）。当然，这个状态下，子类成分完全没有初始化。Derived class is not derived class until its construction finished. 根据构造顺序，即使调用 virtual function，编译器也不会选择调用子类函数。因为子类还没有完成初始化。 纯虚函数的存在甚至不能让程序完成连接 —— 是的，它在父类中。 对于上面的“封装性”，也就是第二点，这里给出错误示范： class testpublic: test() init(); virtual void vir_func() const = 0;private: void init() ... vir_func(); 对于这种多态需求的解决方案的示例（构造函数传参）： class base public: explicit base(const string information)non_vir_func( information ); void non_vir_func(const string information) const ; //货真价实的 non-virtual()class deprived:public base public: deprived(const content):base( str(content) ); //初始化序列，传参给父类构造函数（有参） private: static string str(content); //这里利用了string初始化,不让他指向为初始化的类内其他成员 10. 让 operator 返回一个 引用(reference to) *this 赋值操作符返回一个 reference to *this。 class Widget() public: ... Widget operator+=(const Widget rhs) ... return *this; Widget operator=(int rhs) ... return *this; 这是为了让自定义类型能完成连续操作。 类似 x = y = z = 15 ; 11. 在 operator 中处理“自我赋值” 确保当对象自我赋值时 operator 有正常行为。 确定任何函数操作多个对象，且多个对象为同一对象时的情况，行为仍然正确。 //错误示范：Widget Widget：：operator=(const Widget rhs) delete pb; pb = new Bitmap(*rhs.pb); return *this;//相同对象会导致pb指向一个已经删除的对象。 解决思路： identity test Widget Widget：：operator=(const Widget rhs) if(this == rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this; 这样做的坏处就是即使判断通过，pb在 new 操作时还会不可避免的遇到异常（内存不足或bitmap的copy构造）。然后pb指向原地址，即已经删除的那块内存。 exception safety Widget Widget：：operator=(const Widget rhs) Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; 因为pOrig的副本存在，new操作即使失败，pb指向的原地址仍然存在，之后正常delete。 copy and swap 方法一： class Widget ...void swap(Widget rhs); //*this 和 参数 rhs 交换;Widget Widget::operator=(const Widget rhs) Widget temp(rhs); //rhs数据的副本 swap(temp); //副本 temp 和 *this 交换 return *this; 方法二： Widget Widget::operator=(Widget rhs) //这里是形参，pass by value //直接传过来副件 swap(temp); //副本 temp 和 *this 交换 return *this; 12.复制对象时勿忘其每一个成分 Copy 函数 必须保证复制 本 class 内所有成员变量 和 所有 base class 成分。 1.复制所有local member varaible 2.调用所有 base class 的 适当 的 copy 函数 不要尝试以copy函数实现另一个copy函数。用第三个函数来实现两者共同功能。 Copy函数 必须保证复制 本 class 内所有成员变量 和 所有 base class 成分 写好copy函数后，一旦class 内的成员变量有改动（增加），你的copy函数就要随之相应的更改。否则就会导致 copy 副本初始化工作不完整，产生不必要麻烦。 当 derived class 继承父类后，copy 函数不能只考虑自己。因为随同拷贝的还有隐藏的 base class 成分。这一成分需要你同主动实现 derived class的 copy 函数一样，去主动实现 base class 的copy函数。 这里给出一个示例： class derive::public base //继承父类 public: derive(const derive rhs); derive operator= (const derive rhs); private: int value;derive::derive(const derive rhs):value(rhs.value) ... derivederive::operator=(const derive rhs) ... value = rhs.value; return *this; 不够全面。应当如下： derive::derive(const derive rhs):value(rhs.value),base(rhs) //base 成分 ... derive::operator=(const derive rhs) ... base::operator=(rhs); //base 成分 value = rhs.value; return *this; 不要尝试以coping函数实现另一个coping函数 从copy assignment 调用 copy constructor 不合理：你在构造一个已经存在并完成初始化工作的对象。同时这会影响对象的结构。 从copy constructor 调用 copy assignment 不合理：对一个还没有完成构造的对象赋值，没有任何意义。 毫无疑问，以上两个选择是为了节省代码。这一点可用第三方函数来实现，让两者共同调用该函数。 第三章：Resource Management13.用对象管理资源 秉承“RAII”理念，利用对象初始化资源。 RALL：Resource Acquisition is Initialization 资源获取时，即是初始化时。 对象的构造函数能获得资源，析构函数能释放资源。 RALL classes 有两个经典类：auto_ptr 和 tr1:: shared_ptr 。 前者的复制动作会使被复制对象指向null，后者 copy 能同时指向一个对象 场景：你希望在某个函数作用域内获得资源（比如利用factory function)，并在资源使用完成后的某个位置delete掉它。一旦申请和删除资源的中间环节出现问题，删除操作会被完全无视，而造成内存泄漏。 解决：为确保申请的资源能够被及时释放，有两种方法可循。 在对象的析构函数自动调用机制。 这里可以参考下面的 Mutex 对象 利用两个 pointer-like (类指针) 对象,你也可以称之为智能指针。 以下，利用 investment 类来举个例子。 class Investment{...} auto_ptr : auto_ptrInvestment pInv(createInv()); //createInv()即 Inv类的工厂函数，返回资源 多个 auto_ptr 指向同一对象会导致重复释放，从而产生意料之外的错误。 auto_ptr 这家伙过于忠诚，一旦 auto_ptr 间发生 copy 操作， copy 类指针指向原内容，被 copy 的原指针被设为 NULL 。 auto_ptrInvestment pInv2(pInv1); //p2 exist , p1 nullpInv1 = pInv2; // p1 exist , p2 null shared_ptr : TR1 中的一个类指针，属于RCSP型。 RCSP: reference-counting smart pointer RCSP 能提供 garbage collection （回收）， 但因为太单纯，不能打破环状引用：两个没有初始化的RCSP彼此互相指向，他们都以为自己心有所属（处于被使用状态）。 实际上没有专门针对 array 类型的 资源管理类指针。 但你可以考虑Boost里的scoped_array , shared_array ；但我更推荐考虑 STL容器里的 vector。 14.在资源管理类中小心 coping 行为 对于上一条提到过的资源管理类（RAII class），copy 其对象时，一定要同时复制它所管理的资源。 资源的 copy 行为，决定RAII对象的 copy 行为。 两个 RAII class copy 行为：1. 拒绝copy 2. reference counting 场景： RAII对象： //这里有一个类型为 Mutex 的互斥器对象void lock(Mutex* pm); //锁定pm指向的互斥器void unlock(Mutex* pm); //解锁class lock public: explicit lock(Mutex* pm):mutexPtr(pm) lock(mutexPtr); //锁定，获得资源 ~lock() unlock (mutexPtr); //析构自动释放 解锁private: Mutex *mutexPtr; 用户端： Mutex m;// user block lock ml(m); //正常锁定 ...lock ml2(ml); //这种copy要怎样处理？ 处理： 禁止copy ：继承Uncopyable class等方法。 [可参考条款6](## 明确拒绝不想使用，而编译器自动生成的函数) reference-count： 提高该资源的“被引用数”。 将 Mutex* 改为 shared_ptrMutex 实现。 这里注意：shared_ptr 在引用次数为0时，默认delete指向的目标。 而这里我们的释放操作是 unlock 而非 delete。 还好 shared_ptr 允许指定删除器(deleter),在引用次数为0时，调用这个家伙。 deleter 是一个函数函数对象，在该类指针里是第二参数（可有可无） class lock public: explicit lock(Mutex* pm):mutexPtr(pm,unlock) //注意第二参数 lock(mutexPtr.get()); //.get()返回智能指针内部的原始指针副件 // shared_ptr 的自动析构特性帮我们省略了析构函数。所以让编译器生成吧。private: Mutex std::tr1::shared_ptrMutex mutexPtr// Not *mutexPtr; deep coping：深度拷贝。copy 时 ，面对要 copy 的指针时，生成一个指向副件的指针。 转移底部资源拥有权：auto_ptr 那样，拥有权只存在于一个ptr上。 15.在RAII类中提供对原始资源的访问接口 RAII应该提供一个取得它所管理的原始资源的方法，来满足API访问 raw resources 的要求。 对原始资源的访问方法有显式转换和隐式转换两种方法。显式转换更安全，隐式转换更方便。 这里应用上面的 Investment class 例子 对于int daysHeld(const Investment* pi)这样一个函数：它的参数是原始类型，可你的对应资源却被RAII类封装起来，如 shared_ptr ,它将无法作为参数传入函数。 这时我们需要一个方法去取得 RAII 类管理的原始资源。 方法： 显式： shared_ptr 和 auto_ptr 都有一个 get() 成员函数，来执行显式转换。他们能返回指向的原始资源。 实际上，智能指针都重载了指针取值操作符 - 和 * ； 他们会隐式转换到底部原始指针，通过该指针及相应操作符去访问原始类中的成员变量成员函数。 class Fontpublic: FontHandle get() const return f;void changeFontsize(FontHandle f);Font f(getFont()); //factory funcchangeFontsize(f.get()); //good 总是用显式转换来访问，不免麻烦，但安全明白。 隐式：利用隐式类型转换运算符 class: operator type () {return type-static ;} class Fontpublic: ... operator FontHandle() const return f;changeFontSize(f,newFontSize); //nice 隐式转换也会发生在你察觉不到而不希望发生的地方。 FontHandle f2 = f1; //本想 copy Font 对象的 f1销毁后，f2会沦入 dangle 状态，处于未被初始化的情况。 实际上，RAII class 本身的目的不是为封装性服务，它是为了特殊行为：资源释放而服务的。 tr1::shared_ptr 结合十分松散的底层资源封装，获得了真正的封装效果——你很容易搞到该 class 的原始指针，同时其他的 reference-count 元素则被封装的很严实。 这是很理想的 class 。 16.成对使用new和delete时，要采取相同形式 new表达式里使用[ ],相应的 delete 也要用[ ]; 同理，new表达式里没有[ ], 就不要给对应 delete 画蛇添足加[ ]。 这里不讨论new和delete的底层形式。 new的对象，是单一对象还是对象数组？这两个数据类型的内存布局是不一样的。delete和delete[ ]的方式也是不同的。 17.以独立语句将newed对象置入智能指针 以独立语句将newed对象置入智能指针 不独立的话，当函数同时存在多个实参时，C++的实参执行顺序是随机的。一旦new出的对象和初始化智能指针这两个操作中间出现其他参数调用，并发生异常，就会导致 newed 对象自己留在原地不知所措，内存泄漏。 void processWidget(shared_ptrWidget pw, int priority);processWidget(std::tr1::shared_ptrWidget(new Widget),priority()); 上述函数调用中，分三个过程： 调用priority 执行 new Widget 调用shared_ptr 构造函数 一旦 调用priority 操作插在了new Widget 和 调用shared_ptr构造函数 中间并发生异常中断，就没有好果子吃了。 解决：分离语句，把智能指针和其他参数独立。 shared_ptrWidget pw(new Widget);processWidget(pw, int priority()); 第四章：Designs and Declaration18.让接口不易被误用，更容易被正确使用。 一个好的接口：使用时简单易用，难以误用。 简单易用：接口的一致性、内置类型的行为兼容。 难以误用：建立新类型、限制类型操作、束缚对象值、不要让客户涉足资源管理 tr1::shared_ptr 支持定制型删除器( custom deleter )。可防范 DDL 问题，同时也能自动解除互斥锁（[条款14](## 14.在资源管理类中小心 coping 行为）)。 DDL问题：即 cross-DLL problem 。object 在一个DDL中 (Dynamic link library) 中被 new 创建，却在另一个 DLL 内被 delete 销毁。 shared_ptr 能追踪记录应该调用的 DLL 的 delete。 除非有更好的实现，否则就要令你的 types 行为和内置 types 一致。 参考 STL 的设计（像统一的 size（））； 可以放心的是，用户总会有各种奇葩操作，你能做的就是巧妙的解决、避免预想中的问题，让接口达成以上八字效果。 如果你要求客户必须去做某件事，就是在亲手给自己在埋坑——客户很可能忘记这件事情。 以下给出两个例子。 对于一个 Date class ，默认构造参数可能是 Date(int month , int day , int year); 但用户会把日期顺序搞错，会在填写数据时输入这个星球上根本不存在的日期。 许多错误可以用一个 new class 解决。可以称之为一个 type system 。 这里可以用 wrapper types 完成区分。 class Day , class Month , class Year ,三个特定类型来配合 Date 的默认构造函数。 在这个类里，可以定义不同函数来限定范围： class Monthpublic: static Month Jan() return Month(1); ...//这里用了一个技巧：以函数代替对象，来避免了 non-local static 对象初始化次序问题（详见条款4）。 class 设计者希望用户面对从 factory function 取得 Investment* 指针时，用特定的 “class-delete” (比如 getRidOfInvestment )去代替普通的 delete 。 这时，用户 delete Investment 的隐患就产生了。 针对这个隐患，你可以利用返回一个自带绑定删除器的 tr1::shared_ptr 来解决。 把它加入到create Investment()里： std::tr1::shared_ptrInvestment createInvestment() //这个强转很有必要，让编译器通过 std::tr1::shared_ptrInvestment retVal(static_castInvestment*(0), getRidofInvestment); retVal = ... ; //到这里再安排指针 return retVal; 19. 设计 class 犹如设计 type class 设计就是 type 设计。定义 new type 前，考虑以下问题。 维护你的 personal type , 意味着 Overloading (重载) function instruction character (操作符) , 控制内存的分配和归还、定义对象的初始化终结 等等，都需要在你设计语言类型时来考虑。 对于一个严谨的 class type ,下面是你必须要考虑的问题： 新 type 的对象如何创建与销毁？ 考虑各种构造函数和析构函数 、内存分配和释放函数（ operator new , operator new[ ] )的设计。 对象的初始化和对象的赋值 的差别? 这决定了 type 的构造函数 constructor 和赋值操作符 assign 的不同行为。 type 对象被 pass by value 的实现？ 考虑下copy constructor function 。 type 的值域？ 值域意味着约束条件；约束条件意味着要在你的成员函数、赋值和构造函数中需要做相应的范围检查。 而且不要忘记相应的错误检查工作 —— exception specifications 。 type 需要配合某个 inheritance graph 吗？ type 继承了 existed class，那这个 type 就势必会受到 base class 的约束（尤其是virtual non-virtual）；如果你希望其他 class 来继承该 type ，那请你好好考虑该 type 的 inconstructor function is is not VIRTUAL 。 你的新类型允许怎样的类型转换？ 如果希望 type 有隐式转换功能，就得写出专门负责转换的函数（不能是 type conversion operators non-exlicit-one-argument 构造函数）。 如果不希望，将构造函数声明为explicit来避免隐式类型转换吧。 哪些操作符和函数能合理用于 type ？ 问题的答案决定了你将为你的 class 声明的函数，和函数是否为 member 型。 需不需要那些编译器生成的默认函数？ 需要的话 → 参考：Item 6：禁用那些不需要的默认方法 谁可以访问 type 的成员？ 说白了就是权限问题：1.继承关系 2.友元 friends function 3. 一些嵌套关系 type 的 undeclared interface （潜在接口）有哪些？ 这会关系到 异常安全性、效率、资源使用(如动态内存多任务锁定)等。 这些潜在接口将会影响你的实现，有一些约束性的要求。 你的类型有多么通用和普适？ 如果这个 type 倾向于作为一大批 type 的地基，祖宗级地位，那就别定义成 class 了，定义成一个 class template 不香么。 20.多用 const 替换 值传递 （pass by : reference-to-const replace value） 多数情况下用 const 替换 pass by value 提高效率，同时避免 slicing problem。 少数情况是内置类型、STL的迭代器、函数对象。 对于这些数据类型，效率上反而是pass by value 更胜一筹。 替换原因： 对一个体量巨大的 class 来说 ，pass by value 意味着生成一个副本，成本为该 class 的构造函数和析构函数，成员变量，继承的父类数据，甚至遇到嵌套的类（哪怕是 string ）还会成倍复制。这个开支远不及一个 const 来的痛快。 pass by reference 能够避免 slicing problem。当一个 derived 类以值传递方式到达一个 base class 参数上，参数副本只会调用 base class :: constructor 。derived 类对象会被切割掉，无影无踪。 少数情况（ ？)： C++编译器的底层中，references 往往以指针实现出来。这意味着 pass by reference 真正传递的是指针。 内置类型：如果有个对象是内置类型，值传递的内存占用不一定比一个指针差（甚至效率可能更高）。 STL：对象小不意味着 copy constructor 就很轻松。多数 STL 容器的体量只比指针大一点儿，但复制 STL 这种东西，还要承担“复制那些指针指向的每一样东西”的责任，相对指针来说还是比较冗余的。 对于用户自定义类型：即使“内置类型”和“自定义类型”的 underlying representation (底层表述) 完全相同，某些编译器还是会对用户自定义类型特殊对待。 比如：该编译器拒绝把一个只包含 double 数据的对象放入缓存器，却对光秃秃的double类型数据本身敞开大门。这种事情发生时，就有必要用 by reference 消除这种偏见喽。 另外，user-defined class 的扩展性意味着它随时可能变成一个大家伙。这时还是一个指针，即 by reference 更让我们省心。 21. 如果一定要返回对象，别妄想返回它的 reference 一定要 return 一个 object ，大胆用 pass-by value 吧。 情况1： return pointer reference 指向一个 local static object 的同时，又需要多个这样的 object 情况2： 指针引用 指向一个 local stack 对象 或 return reference 指向一个 heap-allocated 以上两种 Crazy 情况会在下文细说，但你的基本功足够的话，应该也能猜出个所以然。 为了表现两种情况的张力，这里需要一个 classical instance： class Rationalpublic: Rational(int numerator = 0, int denominator = 1); ...private: int n,d; //n: numerator (分子) d：denominator (分母) friend const Rational //const：见 item 3 operator*(const Rational lhs const Rational rhs) 情况1： bool operator==(const Rational lhs , const Rational rhs);Rational a,b,c,d;...if((a*b) == (c*d)) //True：乘积相等， Do something boring.else //false:乘积不等， Do something boring more. 此情况能避免调用构造函数，但： const 指向一个 static 数据会导致上述 IF 语句永远为真。因为 a * b 与 c * d 在重载*的情况下指向了同一地址，也就指向了同一静态变量。这个静态变量先是 a * b ，然后被覆盖为 c * d 。 情况2： stack 中的对象在调用 * 乘法运算重载函数后，作为局部变量就已经消失了。const 指向了虚无。 const Rational operator*(const Rational lhs , const Rational rhs) Rational result(lhs.n * rhs.n , lhs.d * rhs.d); return result; heap： const Rational operator*(const Rational lhs , const Rational rhs) //这里的 new 要求分配内存之后，用构造函数来初始化。即使 reference 也没能避免 Rational* result = new Rational(lhs.n * rhs.n , lhs.d * rhs.d); return result; 乍一看很完美。只是需要调用者如履薄冰一样，保证 delete 掉每个对象。 可看看这个应用： Rational w,x,y,z; w = x * y * z; //operator*(operator*(x,y),z); 这意味着嵌套进去的 operator* 函数返回的指针将被迅速使用，然后在急不可耐中消失，最后内存泄漏。 **所以综上所述：**stack 和 heap 都在 *operator 上摔了个狗啃泥。 pass by value 意味着返回值的构造成本和析构成本。但请相信 C++ ，它会允许编译器实现优化，在保证行为相同的情况下尽量改善产出码效率，这样来看，你的程序将在原油行为的基础上，执行的比预期要快一些。 22.将成员变量声明为 private protected 不能比 public 更有封装性。 成员变量声明为 private 。 这意味着客户访问数据的一致性 、 可细微划分访问控制、约束条件的保证、充分的class作者实现弹性。 privated member variable: 语法一致性 ：成员变量都声明为 private 权限了，访问它只能靠 public 成员函数了。所以所有接口的使用都不用考虑加不加括号的问题——都是函数，加就是了。 强调权限 ：public 权限的成员变量意味着每个人都可以对它指手画脚。只有通过函数访问 private member variable 时，才能实现“不准访问”、“只读访问”、“读写访问”等等。 封装性：Public 意味着不封装，几乎等价于不可改变（除非以破坏用户码为代价）。 即使使用 protected 权限，面对子类的狂轰滥炸，你仍然很难改变这个 protected member variable 的一切。所以在这个角度上，它的意义和 public 相差不大（两种权限 : private 和 其他）。 通过函数访问这个成员变量，就好像搞一个黑盒——即使以某个计算替换掉这个成员变量，也没有关 系。将成员变量隐藏在成员函数背后，能为“所有可能的实现”提供弹性: 这可使得成员变量被读或被写时轻松通知其它对象、能够验证class的约束条件及函数的前提和事后状态、能够在多线程环境中运行同步控制等等。 23.用 non-member 、 non-friend 替换 member 函数 Replace member function by non-member 、non-friend function. 可以增加封装性、弹性 ( packaging flexibility ) 、扩充性。 这个 item 下，封装性是核心。 封装性强意味着弹性大：越多的数据被封装，即可访问数据的代码越少，我们也就越能自由地改变对象数据。 item 22 提到成员变量应是 private 。如果不这样做，就意味着无限量的函数可以访问它们，也就毫无封装性可言了。实际上，一个 member function 可以访问 private variable ，还可以任意取用 private function 、 enums 、typedefs 等等。而 non-member 则什么都干不了。这意味着两种函数功能相同时，后者封装性更大。（friend function 的权利和member function 大差不差，所以它的封装性也不大）。 基于对封装性重要性的认识，来看以下例子： clss WebBrowser public: void clearCache(); void clearHistory(); void removeCookies(); ...; 对于这样一个类，同时执行以上三个函数的实现方法有两种： member function: void class WebBrowser::clearEverything()//调用三个函数 ... non-member function: void clearBrowser(WebBrowser wb) wb.clearCache(); wb.clearHistory(); wb.removeCookie(); non-member 函数的封装性比 member 函数要高，并且有更大的封装弹性，进而存在更低的编译依赖度，增加WebBrowser 的可延伸性。 实际上，面向对象守则要求：数据以及操作数据的那些函数应该捆绑在一块。 这意味着认可 member function is better choice. 这是一个误解。 因为该守则的目的是要求数据尽可能被封装，与实际选择恰恰相反。 注意：强调封装性的 non-member function 同样可以是另一个 class 的 menber 。 上面的 clearBrowser 可以是某 utility class 的一个 static member function 。只要它不是 WebBrowser 的一部分或 friend func，就不会影响封装性。 namespace： 不过相比成为 static memer func ，更自然的选择是让 non-member function （clearBrowser） 和对应的 class （WebBrowser） 位于同一个 namespace 中。 namespace WebBrowserStuff class WebBrowser ... ; void clearBrowser(WebBrowser wb); 同时你也可以用 namespace 配合 #incluede 实现分离式编程，保证封装性的同时让客户按需所取。 //webbrowser.h 头文件内namespace WebBrowserStuff class WebBrowser ... ; ... //WebBrowser 核心//webbrowser_bookmarks.h 头文件内namespace WebBrowserStuff class WebBrowser ... ; ...//书签相关便利函数//webbrowser_cookies.h 头文件内namespace WebBrowserStuff class WebBrowser ... ; ...//cookie相关便利函数 As shown above , 需要啥功能，#include 就是了。 namespace 相比 class 的优势： 移植性：namespace 可跨越多个源码， class 不能。 分离性：通常用户用到的功能只有一部分。配合头文件编写同一命名空间的函数，能达到解耦效果。 扩展性：用户有其他需求，在命名空间内加个头文件就是了。新函数和旧有函数一样可用且作为一个整体。 这里多一句嘴： 这也是 C++ 标准程序库的组织方式：不是一个庞大的C++StandardLibrary头文件和包含着std namespace 的每一样东西，而是数十个头文件各自负责自己的部分（,等）。 这种分割方式是 class function 力所不及的，它必须整体定义。 24.若所有参数都要类型转换，那就用 non-member 函数 如果你需要为某个函数的所有参数进行类型转换，这个函数就必须是 non-member 参数包括被 this pointer 指向的那个隐含参数。 class 支持隐式类型转换本身比较危险，但有些例外情况：像建立一个数值 class ，你往往需要 类似 int 转 double 那样的 隐式转换。 下面以有理数类 Rational class 为例： class Rational public: Rational (int numerator = 0, int denominator = 1); int numerator() const; int denominator() const;private: ... 隐式转换的实现形式有 member function 、non-member function 或 non-member friend 函数。 面向对象的角度来看，我们应该把 operator* 扔到 class 内(尤其在你忘掉 item 23 的情况下)，像这样： class Rational public: ... const Rational operator* (const Rational rhs) const; 它的实现有其合理性，但也会遇到一些麻烦： Rational ondEighth(1,8);Rational oneHalf(1,2);Rational result = oneHalf * oneEighth;result = result * oneEighth;//no question ↑result = oneHalf * 2; //okay equal to : oneHalf.operator*(2);result = 2 * oneHalf; //wrong equal to : 2.operator*(oneHalf); 式子1都发生了隐式类型转换（没有涉及 explicit constructor function)， 式子2却没能顺利完成： 混合式算术中，整数2没有对应的 class ，更没有相应的 operator* member-function 。 (这种情况下，compiler 还会尝试寻找替代的 non-member function，但本例同样没有) 式子1通过编译时，编译器对2的操作大概如下： //编译器知道参数类型Rational虽然和int不符，但只要调用构造函数就有机会完成一切。const Rational temp(2); result = oneHalf * temp;//如果 Rational constructor 为 explicit ，两式没有一个能通过编译。 结论： 只有当参数位于 parameter list 时，才能正常进行隐式类型转换 —— 类似式子1； 而情况类似 The object that called-member-function belong to 的参数 —— 类似式子2， 即 this 指针指向的那个隐藏参数是不可以进行隐式转换的。 explicit 能保持相关函数的一致性，让式子1和式子2都编译失败。 **更好的解决方式：**non-member function ：允许编译器在每一个实参上执行 implicit type conversion。 师承上例： const Rational operator*(const Rational lhs, const Rational rhs) return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); 这对上面的式子都适用。 最后的问题是 operator* 是否有必要成为 class 内的 friend function。 答案是没这个必要（至少在类似情况）：因为该重载函数凭借 class-public interface 就能完成任务，不需要冒着破坏封装性的风险。 member function 的反面是 non-member function ，而非 friend func 。 25.试着写出一个不抛异常的 swap 函数 如果 std::swap 对于你的类型来说是低效的，请提供一个 swap成员函数。并确保你的 swap不会抛出异常。 如果你提供一个成员 swap，请同时提供一个调用成员 swap 的非成员 swap。对于类（非模板），还要特化 std::swap。 调用 swap 时，请为 std::swap 使用一个 using declaration，然后在调用 swap 时不使用任何 namespace 限定条件。 为用户定义类型完全地特化 std 模板没有什么问题，但是绝不要试图往 std 中加入任何全新的东西。 前言： 特化是 template c++ 的知识。 模板的全特化和偏特化都是在已经定义的模板基础之上的，不能单独存在。 特化根据模板参数是否全部特化而分作 全特化 和偏特化。 偏特化： 类模板支持偏特化，函数模板没有偏特化[^3]。 (偏特化使用很灵活，可以是限定参数的数据类型，比如int；也可以是限定参数的数据传输方式，比如引用、指针；等等） 编译器调用顺序：全特化偏特化通用模板 [^3]: 函数有重载特性，因此在某些场景下，特化会产生一些预期之外的结果。—详见 。 swap本身： swap 函数最初由 STL 引入，已经成为异常安全编程的关键函数， 同时也是解决自赋值问题的通用机制。 标准程序库中的 swap 算法 namespace std templatetypename T void swap(T a, T b) T tmp(a); a = b; b = tmp; 可以看出，只要 T 支持 coping 就能完成 swap。 但这种 coping 方式未免有些简单粗暴。 类的swap（配合member swap） 有时对自定义类型而言 std::swap 并不高效。 比如采用 pimpl idiom 设计的类中，只需要交换实现对象的指针即可： class WidgetImpl;class Widget // pimpl idiom 的一个类 WidgetImpl *pImpl; // 指向Widget的实现（数据） public: Widget(const Widget rhs);; namespace std template // 模板参数为空，表明这是一个全特化 void swapWidget(Widget a, Widget b) swap(a.pImpl, b.pImpl); // 只需交换它们实体类的指针 上述代码是不能编译的，因为 pImpl 是私有成员！所以，Widget 应当提供一个 swap 成员函数或友元函数。 惯例上会提供一个成员函数： class Widget public: void swap(Widget other) //member func using std::swap; swap(pImpl, other.pImpl); ;//接着我们继续特化std::swap，在这个通用的 swap 中调用那个成员函数：namespace std template\tvoid swapWidget(Widget a, Widget b) a.swap(a,b); //调用成员函数 上述实现与STL容器是一致的：提供共有 swap 成员函数， 并特化std::swap 来调用那个成员函数。 类模板swap（配合 non-member function） 如果 class 涉及到 template ，情况会不大一样。按照上例照猫画虎的写一下： templatetypename Tclass WidgetImpl ... ; templatetypename Tclass Widget ... ; //之前的 class namespace std templatetypename T // swap后的尖括号表示这是一个特化，而非重载。 // swap中的类型列表为template中的类型列表的一个特例。 void swapWidgetT (WidgetT a, WidgetT b) swap(a,b); 这里涉及到编译器特点：不允许偏特化 function template 。如果你非要偏特化，可以考虑用 overload 来实现同样功能。 namespace std templatetypename T // 注意swap后面没有尖括号，这是一个新的模板函数。 // 由于当前命名空间已经有同名函数了，所以算函数重载。 void swap(WidgetT a, WidgetT b) //这时就需要配合 non-member function 了 a.swap(a,b); 又遇到了问题： 这里重载了 std::swap，相当于在 std 命名空间添加了一个函数模板。而 C++ 标准中是不允许添加新的 templates （包括 funtion 或 class 等）。 C++ 标准中，客户只能特化 std 中的模板，但不允许在 std 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为。 不再使用特化重载版的 non-member-func ，将原本的 non-member func 转移到其他 namespace （不一定非得是 global 啊）。 namespace WidgetStuff templatetypename T class Widget ... ; templatetypename T void swap(WidgetT a, WidgetT b) a.swap(a,b); 任何地方在两个 Widget 上调用 swap时，C++根据其 argument-dependent lookup 会找到 WidgetStuff 命名空间下的 swap。 那么似乎 class 的 swap 也只需要在同一命名空间下定义 swap 函数，而不必特化 std::swap。 但是！有人喜欢直接写std::swap(w1, w2)，特化 std::swap可以让你的类更加健壮,更加稳定。 所以定义 class 专属 swap 后，特化一下 std::swap 吧。 编译器调用swap templatetypename Tvoid doSomething(T obj1, T obj2) using std::swap; // 使得 std::swap 在该作用域内可见 swap(obj1, obj2); // 现在，编译器会帮你选最好的Swap 从用户角度来看，好像 swap 函数调用以后会面临选择的困难。但C++ 的 name lookup rules (包括 argument-dependent lookup)能确保找到 global 作用域或 T 所在命名空间的任何 T 专属的 swap。编译器会偏爱专属版 swap 的，std::swap 只是一个最后选项而已。 最好不要画蛇添足一个额外修饰符：std::swap，这会让编译器只认 std 内的 swap ，这也是为什么你需要把专属类的 std::swap 进行特化的原因。 总结： 当然了，如果默认 swap 实现不会对你的 class template 有任何影响，就不用再费这番心思了。 如果在效率上确实不足，那就考虑以下事情： 提供一个public swap成员函数，让它高效的置换你的类型的两个对象值，并且这个swap函数绝不能抛出异常。 在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数。 如果你在编写一个class而非class template，为你的class特化std::swap。并令它调用你的swap成员函数 调用 swap 前，记得包含一个using 声明式，让 std::swap 在函数范围内可见。调用 swap 时不需要添加 namespace 修饰，编译器会帮你完成查找。 成员版 swap 不要抛出异常。你需要帮助 class class template 提供 exception safety 保障。 非成员版通常不会有这个问题：如 swap 默认版本的 coping 有着不错的稳定性，基于对内置类型的操作也往往不会出现异常。 第五章：Implementation26. 尽可能延后变量定义式的出现时间 尽可能延后变量定义式的出现时间，增加程序清晰度的同时改善效率。 定义变量或类型，构造析构函数会在 control flow 到达时产生成本，即使你未曾使用。 用例子来看看所谓“延后”的思路： //原版encrypt(string password); //加密赋值函数string encryptPassword(string password) sring encrypted; //if(一些密码要求判断) return encrypted; 定义时机延后：需要时再去构造析构 string encryptPassword(string password) //if(一些密码要求判断) string encrypted;//放到if后 encrypted = password; encrypt(encrypted); return encrypted; 目前成本：encrypted 的 default constructor function ，copy assignment function 赋值时机”提前”：尽量在定义时就对变量完成初始化，不要浪费成本 string encryptPassword(string password) //if(一些密码要求判断) string encrypted(password);//直接初始化 encrypt(encrypted); return encrypted; 总结： 避免无意义的 default constructor； 延后定义到使用变量（给它初值实参）的前一刻 还有循环问题：同一变量在循环使用变量的选择。 两种情形： 情形A：(变量类型)定义于循环外 Widget w;for(int i = 0;i n; ++i) w = i... 成本：1 构造函数 + 1 析构函数 + n 复制操作 情形B：(变量类型)定义于循环内 for(int i = 0;i n; ++i) Widget w(i...); 成本： 1 构造函数 + 1 析构函数 结论： 选择A： class 的赋值成本低于一组 构造+析构 func n比较大 正在处理代码中的 performance-sensitive code 否则选择B。 27.少做转型操作 尽量避免转型，防止意外；避免 dynamic_casts ，防止拉低效率。 如果实现需要转型，尽量寻找无需转型的替代品 转型如果必要，尽量把它隐藏在函数背后 不要让 user 把转型放到自己的 code 里，call it 就是了。 尽量用 C++ 风格 转型，去替代旧式转型。 C++ style 的 cast 操作更有辨识度，且分工清楚，易于排错。 四种转型： const_cast ：cast away the constness, 移除对象常量性。 dynamic_cast : safe downcasting ，安全向下转型，继承方面。 reinterpret_cast : 低级转型，不可移植。结果取决于编译器。 static_cast ：强迫隐式转换，只是不能把 const 转为 non-const。 任何一个类型转换都会令编译器编译出运行期间执行的代码。并且由于计算器体系结构中，数据结构的底层表述不同，int 转 double 的过程比我们想象的会复杂一点。 两个注意： 转型操作的移植性很低 class Base ...class Derived: public Base ...;Derived d;Base* pb = d; //implicit conversion ： Derived* → Base* base 指针指向 derived 对象导致隐式转换，实现的方式是：在运行期施行一个偏移量（offset）到Derived指针上，来取得要求的 Base* 值。 这意味着，一个对象可能有一个以上的地址：Derive* 指向它的地址和 Base* 指向他的地址就有所不同。一旦使用多重继承，这种情况还会频繁发生。 而对象的布局方式和地址计算方式由编译器决定，这就意味着，转型操作的底层实现会在不同平台有所不同，移植性堪忧。 不熟练的转型操作容易想当然，导致程序似是而非 这里用两个例子来看看 static_cast 和 dynamic_cast 的错误示例： static_cast //需求是：derived类要首先重写base.virtual，//并且重写的第一步：调用base.function() 父类某个函数class window virtual void onResize() ... ;class specialWindow:public Window public: virtual void onResize() static_castwindow(*this).onResize(); //this转为window再调用onRize() 这个程序的思路很好，只是似是而非的地方是，强转后调用的window::onResize(),其对象是一个window副本，而不是真正的父类。如果这个函数内有一些变量操作，就相当于改动副本的数据，再眼睁睁看着它销毁，剩下未经变动的原 base class ，竹篮打水一场空。 //更自然的方法：virtual void specialwindow:: onResize() window::onResize(); dynamic_cast 首先，使用这个转换类型，意味着要用一个 base pointerreference 来执行 derived function 。 这种情况有两种思路：使用类型安全容器 或 endue base class with virtual function。 延续上面的例子，假设 specialwindow 具有独一无二的 blink 功能（以函数呈现）。 类型安全容器：在容器（as usual to shared_ptr）中存储指向 derived class 对象的指针，直接消除Using base interface to handle object 的需要。 //实际上这个方法看起来有点臭屁，因为它把条件直接改了。但它毕竟是强于要类型转换的原需要typedef vectortr1::shared_prtSpecialWindow VPSW;VPSW winPtrs;...for( VPSW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter) (*iter)-blink(); 这种方法使用类型转换就是下面的样子： typedef vectortr1::shared_ptrwindow VPW;VPW winPtrs;for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end();++iter) if(SpecialWindow* psw = dynamic_castSpecialWindow*(iter-get())) psw-blink(); Anyway，受限于容器类型要求，这两种方法都不能处理“指向所有window派生类”的指针，除非你甘愿用多种容器且都具备 type-safe。 令父类使用虚函数 (在 base class 内提供 virtual 函数做各个derive class 做的事） class Windowpublic: virtual void blink() class SpecialWindow:public Window...//虚函数重写不赘述了typedef vectortr1::shared_ptrwindow VPW;VPW winPtrs;for(.../*同上1*/ ) (*iter)-blink(); 这种方法支持多种类型的派生类。 注意必须避免 cascading dynamic_casts ，一连串的强转 for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end();++iter) if(SpecialWindow1 * psw1 = dynamic_castSpecialWindow1*(iter-get()))... else if(SpecialWindow2 * psw2 = dynamic_castSpecialWindow2*(iter-get()))... ... 这种功能用 virtual function 平替即可。 结论：少做转型，能替就替。除非你应对的是 int 转 double 这种无伤大雅、简洁明了的操作。 28.避免返回handles指向对象内部成分 避免返回 handles( references , 迭代器 , pointer) 指向对象内部。 遵守它，提高封装性，让 const member function 没有忘记 const 的初衷。 同时把“空指针”、”空引用”的概率降到最低。 Talk is cheap ,show me the code: class Point //坐标点public: Point(int x,int y); void setX(int val); void setY(int val);class recData point top_left; point low_right;class recTangle ... Point upperLeft()const return pData-top_left; Point lowerRight()const return pData-low_right;private: tr1::shared_ptrrecData pData; 以上例子非常自然，一个坐标点 - 一个包含两个坐标点的矩形类 - 一个包含矩形类指针和点位接口的类。 实际上这里出现了矛盾： 封装性：你把返回点位的函数设为 const 保持封装性的同时，又把私密成员变量毫无保留的 return 了出去。rectangle . lowerRight().setX(num) 类似这种实现会完全破坏封装性。 dangling handles：handle本身所指向的对象不存在了，指向了虚空。 这一矛盾在本例中没有出现。简单说，你让 static handle 指向一个局部对象，对象销毁后，handle的状态就是 dangling handles 了。 解决： Add const to the function which return private member variable. This can’d avoid “dangling handles” phenomenon. Avoid using that function about returning varible as far as possible. 反思： 成员变量的封装性 小于等于 “ 返回其 reference 的函数“的访问级别。 本例中的成员变量表面是 private，实际是public：由 public-member-function导致的。 const member function 传出一个引用，引用所指数据和对象自身有关系，而且被存在对象之外，调用者就可以有恃无恐的修改这个数据。 bitwise constness 的一个表现。 29.为“异常安全”努力是非常值得的 即使当异常被抛出时，异常安全的函数不会泄露资源，也不允许数据结构被恶化。这样的函数提供基本的，强烈的，或者不抛出保证。 强烈保证经常可以通过 copy-and-swap 被实现，但是强烈保证并非对所有函数都可用。 一个函数通常能提供的保证不会强于他所调用的函数中最弱的保证。 异常安全是指当异常发生时： 不会泄漏资源， 也不会使系统处于不一致的状态。 通常有三个异常安全级别：基本保证、强烈保证、不抛异常保证： 基本保证。抛出异常后，对象仍然处于合法（valid）的状态。但不确定处于哪个状态。 所有对象内部前后一致。 强烈保证 : 成功便成功，失败则恢复到原状态。 如果抛出了异常，程序的状态没有发生任何改变。就像没调用这个函数一样。 不抛异常(nothrow)保证。这是最强的保证，函数总是能完成它所承诺的事情而绝不抛出异常。 内置类型上的操作都提供了 nothrow 保证。 一个抛出异常的场景 现在实现一个菜单类，可以设置它的背景图片，提供切换背景计数，同时提供线程安全。 class Menu Mutex m; Image *bg; int changeCount;public: void changeBg(istream sr);; changeBg 用来改变背景图片，可能是这样实现的： void Menu::changeBg(istream src) lock(mutex); delete bg; ++ changeCount; bg = new Image(src); unlock(mutex); 因为 C++ 继承自C，完全避免抛异常是不可能的。比如申请内存总是可能失败的，如果内存不够就会抛出 “bad alloc” 异常。加入 new Image(src) 抛出异常， 那么异常安全的两个条件都会破坏： mutex 资源被泄露了。没有被 unlock。 Menu 数据一致性被破坏。首先 bg 变成了空，然后 changeCount 也错误地自增了。 通常来讲提供强烈保证是不困难的。首先我们把资源都放到智能指针里去，通常 shared_ptr 比 auto_ptr 更加符合直觉， 这样可以保证资源不被泄露；再调整 ++changeCount 的位置来保证异常发生后对象仍然一致。 一个好的状态变更策略是：只有当某种事情（比如背景变更）已经发生了，才去改变某个状态来指示它发生了。 class Menu shared_ptrImage bg; ...;void Menu::changeBg(istream src) Lock m1(m); bg.reset(new Image(src)); ++changeCont; 智能指针的 reset 是用来重置其中的资源的，在其中调用了旧资源的 delete。 这时如果 new Image 发生了异常，便不会进入 reset 函数，因而 delete 也不会被调用。 事实上，上述代码并不能提供完美的强烈保证，比如Image构造函数中移动 了istream src 的读指针然后再抛出异常，那么系统还是处于一个被改变的状态。 这是一种对整个系统的副作用，类似的副作用还包括数据库操作，因为没有通用的办法可以撤销数据库操作。 不过这一点可以忽略，我们暂且认为它提供了完美的强烈保证。 copy swap 范式 一个叫做 “copy and swap” 的设计策略通常能够提供异常安全的强烈保证。当我们要改变一个对象时，先把它复制一份，然后去修改它的副本，改好了再与原对象交换。 为了更好地示例这个过程，我们将 Menu 的实现改变一下，采用 “pimpl idiom” 把它的实现放在 MenuImpl 中。 class Menu ...private: Mutex m; std::shared_ptrMenuImpl pImpl;;Menu::changeBg(std::istream src) using std::swap; Lock m1(mutex); std::shared_ptrMenuImpl copy(new MenuImpl(*pImpl)); copy-bg.reset(new Image(src)); ++copy-changeCount; swap(pImpl, copy); 这样我们的操作都是在 copy 上的，发生任何异常都不会影响到当前对象。只有改好了之后我们才 swap 它们。 swap 应当提供不抛异常的异常安全级别。 连带影响 void Menu::changeBg(istream src) ... f1(); f2(); 因为其它的函数调用例如 f1() 一旦不提供强烈的保证，那么整个函数不可能提供强烈的保证（因为 changeBg 无法修复 f1 造成的资源泄漏和不一致性）。 如果函数只操作局部性状态，就能提供更好的保证。如果函数对非局部性数据有连带影响，不可控因素就会成倍增加。 例如：如果f1() 修改了数据库，这个动作发生以后，便没有什么操作可以取消复原 —— 用户可能已经看到了新改动。 这意味着盲目追求最佳安全保证不是一个灵活的方式。 效率问题 copyswap 的关键在于副本，而副本意味着耗用可能巨大的空间和时间，以及费劲心力带来的复杂度。所以退而求其次选择基本保证 并不丢人。 一个函数的异常安全级别不会高于它调用的所有函数中安全级别最低的那个。这也是为什么我们为什么要为自己的函数提供强烈的安全保证， 一旦某个函数不具备异常安全性，最终整个系统都是不安全的。“一颗老鼠屎，坏了一锅粥。”是也 当你写新的代码或修改原有代码时，考虑如何让它具备异常安全性： 一马当先的是“通过对象管理资源( item 13)”，来阻止内存泄漏。 之后坚持三个“异常安全保证”中的一种，来贯彻在自己的每一行代码。 最后将你的思路写成文档，为用户和维护人员着想。 函数的 异常安全性保证 是可见接口的一部分，请慎重选择。 理论上，你最好选择需求场景下安全程度最高的代码。 30.了解 inlining 的里里外外 将大多数 inlining 限制在小型、频繁调用的函数身上。 这能让日后的调试过程和 binary upgradability 更容易，最小化代码膨胀，提高程序速度。 function template出现在头文件，不意味着就要用 inline 形式。 注意点： inline 帮助编译器免除函数调用成本，对 inline function 的每一个调用以函数本体替换。牺牲的是增加的目标码(object code) 大小。 机器内存有限，inline function 反而会因为太大的程序体积造成额外的 paging 和 降低的 instruction cache hit rate。（当然了，inline 函数本体小的话反而会比函数调用的 object code 更小，产生相反的良性效果） inline 本身可说可不说。编译器可能偷偷声明 inline （比如 一部分class member function），你也可以按你的想法要求编译器这样做（virtual 即使要求也没有用，它需要等待到运行期）。 一个误区：inline function 在头文件内，template 也在头文件里。但function templates 不一定是 inline。 函数指针的调用通常不会被 inline 允许。 编译器 inline 的过程，首先要生成一个 outlined 函数本体，再通过指针指向那些函数。函数指针有时会扰乱编译器的这一操作。 构造函数和析构函数的 inline 比表面看起来复杂的多。这哥俩不适合 inline 。 class Basepublic: ……private: std::string bm1, bm2;;class Derived: public Base public: Derived()//Derived构造函数 ……private: std::string dm1, dm2, dm3;; 看起来是个空构造函数，人畜无害。实际上…… 在编译器处理下可能是这个样子： Derived::Derived()//概念实现 Base::Base(); try dm1.std::string::string();//构造dm1 catch(……) Base::~Base();//销毁base class部分 throw;//抛出异常 try dm2.std::string::string(); //构造dm2 catch(……) dm1.str::string::~string();//销毁dm1 Base::~Base(); throw; try dm3.std::string::string(); catch(……) dm2.std::string::~string(); dm1.std::string::~string(); Base::~Base(); //实际代码会更精致复杂 由此可知，inline constructordeconstructor 的不明智（编译器自己可能会直接拒绝 inline）。 你得随时评估 inline 函数的冲击力。 inline function 不能随着程序库升级而升级。一旦 inline function 被改变，所有的客户端程序都要重新编译。而 non-inline function 只需要客户端重新连接。 综上结论：慎重 inline。正常流程是先不要 inline （除非契合度太高），把所有函数写完再根据二八法则观察是否有 inline 的需求。 80-20经验法则：程序往往将八成执行时间花在二成代码上。 31.将文件间的编译依存关系降至最低 程序库头文件应该以“完整且仅有声明式”的形式存在。 该原则无论涉及 template 都适用。 实现依存性最小化的思想：相依于声明式，不要相依于定义式。 基于思想的两个手段：Handle class 和 Interface class 。 场景： class Personpublic: Person(const stringname ,const Date birthday, const Address addr); string name() const; Date theBirthDate; Address theAddress; 显然这个 class 不能编译。你还得提供 composition 数据类型的定义(实现)：string，Date，Address这种。 而这种类型定义通常在头文件里：#include 。 这会导致一个问题：Person 定义文件和 Person 内含文件形成了一种编译依存关系（compilation dependency）。在高编译依存关系下，一旦内含在 class 中的类型被重新编译(包括类型定义文件中的头文件改动)，其他所有同一文件中包含的头文件都要进行编译，甚至波及那些使用了 Person class 的文件。这将导致非常夸张的蝴蝶效应。 降低编译依存关系的一个手段：将对象实现细目隐藏于一个指针背后 把 Person 分割为两个 class ，一个只提供接口，一个负责接口后的具体实现。 #includestring //string 不参与前置声明，准确来说它是个内置 typedef ，真正的声明比较复杂。#includememory //不要误会，这里是为了共享指针才引入//前置声明class PersonImpl;class Date;class Address;class Person //Person 分半:此Person class负责接口声明public: Person(const stringname ,const Date birthday, const Address addr); string name() const; Date theBirthDate; Address theAddress;private: //Person 分半：负责实现的那 个Person class 取名为 PersonImpl tr1::shared_ptrPersonImpl pImpl; //主角登场了 class 只内含一个指针成员，来指向实现类。 这种设计称为 pimpl idiom （pointer to implementation） 这样一来，Person 客户与类型具体实现分离了，class的实现修改也不需要客户端重新编译，并且保证了封装性。 这就是“接口与实现分离”的妙处。 结论： 能使用object reference object pointer 可以完成任务，就不要用 objects 。 可以只靠一个类型声明式就定义出指向这个类型的 reference pointer 。 尽量以 class 声明式替换 class 定义式 要用到某个 class 时，不一定非要这个 class 的定义。 class Date;Date today();void clear(Date d); 声明对应函数而无需定义 Date ，听起来很神奇。 后续在调用相应函数时，对应类型 Date 的定义就需要提前曝光了。 有可能一个函数库有数百个函数声明，用户弱水三千而独取一瓢。这时将 class 定义式从函数声明所在头文件转移到函数调用的客户文件，就可以将“不必要的类型定义”带来的与客户端之间的编译依存性去掉。 为声明式和定义式提供不同的头文件 声明和定义分离的设计需要两个头文件。一个用于声明式，一个用于定义式。两个文件要保持一致性，一个随另一个改变而改变(此时是否会想起 .h 和 .cpp 两个文件类型)。 承接上述 Data 例子： #include datefwd.h //Data 在.h头文件里声明而未定义Date today();void clear(Date d); 这里可参考标准程序库 header file 。这个家伙内含各组件声明式。其对应定义分布在其他不同头文件内：,,, 另外， 也说明了一个事实：这个准则既适用于 template ，也适用于 non-template。 可以将只含声明式的头文件提供给 template （有些 build environment 允许定义式在头文件内，也有一些定义式放在非头文件内）。 这里 C++有个关键字：export，允许将 template 声明式和定义式分割在不同文件内。不过支持它的编译器很少，这里不赘述。 Handle classes 和 Interface classes Handle classes ：使用 pimpl idiom 的 class。 这种 class 有两种发挥作用的场景： 将该 class 的所有函数转交给对应实现类，并让实现类完成真正工作。 #include Person.h // 我们正在实现Person class，所以必须#include其class定义式#include PersonImpl.h // 我们也必须#include PersonImpl的class定义式，否则无法调用 // 其成员函数； // 注意，PersonImpl有着和Person完全相同的成员函数，两者接口完全相同。Person::Person(const std::string name, const Date birthday, const Address addr)\t:pImpl(new PersonImpl(name, birthday, addr))std::string Person::name() const\treturn pImpl-name(); 妙极！Person constructor 通过 new 调用 PersonImpl constructor ，以及 Person::name 函数内调用 PersonImpl::name ，这是很值得关注的地方。 让Person 成为 Handle class 不会改变它本该做的事，只会改变它做事的方式。 令 Person 成为一种特殊的 abstract base class ，即 Interface class。 abstract class 意味着此君往往没有成员变量，也没有构造函数，只剩些 virtual 析构函数和一组 pure virtual 函数。 一个针对 Person 的 Interaface class ： class Personpublic: virtual ~Person(); virtual string name() const =0; virtual string birthDate() const =0; virtual string address() const =0; 该 class 不能具现出实体。用户通常会调用类似 derived class 的构造函数来完成具现化。这个函数即 factory class 或 virtual constructor 。它们会返回指针，指向动态分配的对象（这个对象支持 interface class 的接口）。 函数实现范例： static:class Personpublic:... //同上//factory func ↓ static tr1::shared_ptrPerson //返回一个shared_ptr ，指向一个新person， create(const string name, //利用参数初始化 const Date birthday. const Address addr); ...; 有了这个 class ，支持 Interface class 接口的具象类(concrete class) 必须被定义出来，而且真正的构造函数需要被调用。这一切都在 virtual 构造函数实现代码（当然包括create）的所在文件内发生。 像这样： class RealPerson : public Person public: RealPerson(const std::string name,const Date birthday, const Address addr) : theName(name),theBirthDate(birthday),theAddress(addr) virtual ~RealPerson() std::string name() const; std::string birthDate() const; std::string address() const;private: std::string theName; Date theBirthDate; Address theAddress;; RealPerson 下的 Person::create: std::tr1::shared_ptrPerson Person::create( const std::string name,const Date birthday, const Address addr) return std::tr1::shared_ptrPerson(new RealPerson(name,birthday,addr)); RealPerson 演示了从interface class 继承接口，然后实现接口所覆盖的函数。 当然，实际情况中的 Person::create 定义实现会创建不同类型的 derived class 对象，来完成额外参数值等任务。 结论：Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性（compilation dependencies）。当然它牺牲的是：使你在运行期降低速度，同时对每个对象付出更多内存。 Handle class： 动态分配的额外开销：成员函数必须通过 implementation pointer 取得对象数据，从而为访问增加一层间接性。但同时这也导致访问对象消耗的内存必须增加 i-pointer 的大小。 bad_alloc 异常(内存不足)：implementation pointer 必须初始化（在 Handle class constructor 内)，来指向动态分配得到的 implementation object 。 Interface class： virtual 成本：每个函数都是 virtual ，意味着每次 function-called 都要增加一个 indirect jump 成本。 vptr 指针成本：Virtual 意味着 Interface class 的派生对象必须有一个 vptr，这个指针可能会增加存放对象的内存大小。 无论 Handle class 还是 Interface class，一旦脱离 inline 函数都很难有所作为。哥俩用来隐藏实现细节（像函数本体）的设计正好契合 inlined function body 应该被置于头文件的设计。 最后忠告：额外成本不是放弃这二位的理由。像 virtual function 一样，如果比起运行速度文件大小，你更关注classes 之间的耦合性的话，就用这 Handle class 和 Interface class 代替 concrete class 吧。 第六章：Inheritance and Object-Oriented Design32.public 继承意味着 is-a 关系 public 继承意味着 is-a 关系。 适用于base class 的每一件事也一定适用于 derived class 身上。 因为每一个 derived class object 也是一个 base class object。 public 继承的 derived class object 与其父类对象能发生隐式类型转换，即子类对象可以代替父类对象。但反之不行。两者是一般化和具象化的区别。 误区：理想塑模关系和逻辑上的关系可能不大一样： class Birdpublic: virtual void fly(); ...class Penguin:public Bird ... 企鹅是鸟，鸟会飞，但企鹅并不会飞 —— 这是不严谨的表述在逻辑上的硬伤。 **解决：**使用 virtual 编译期解决:更完善的继承体系 //细化，使逻辑上更严谨class Bird...class FlyingBird:public Bird //利用FlyingBird public: virtual void fly();class Penguin:public bird ... //企鹅压根就没有飞翔的函数 实际上，有时需求压根就不需要区分这个鸟会飞还是不会飞。（也许注意点在鸟嘴和鸟翅上） 这表明，没有完美的设计，只有完美的满足需求。根据场景，选择最佳设计。 运行期解决：运行期出错 //表述没问题，但针对企鹅，视企鹅本身为一个例外void error(const string msg);class Penguin:public Bird virtual void fly() error( Error Happened !); 我们知道“好的接口应防止无效代码通过编译”，那就在编译期拒绝他吧。 实际上，”正方形是矩形“的例子也很有代表性。 正方形是矩形没有任何问题，应该用 public inherit 明确表示 is-a 关系。但正方形四条边相同，更新一条边时其余边同步更新的特性和矩形则大为不同。这种差异在 is-a 关系中是灾难性的。也是违反直觉的事情。 is-a 外，还有 is implementation in terms of 和 has-a 关系。 33.避免掩盖继承而来的名称 derived class 名称会覆盖 base class ；这和 public 继承理念格格不入。 可以通过 using 声明式或转交函数让被覆盖的名称重见天日。 内层作用域名称会遮掩外围作用域的名称。对于继承来说，则是 derived class 作用域嵌套在 base class 作用域内。 class Base public: virtual void mf1() = 0; virtual void mf1(int); void mf3(); void mf3(double);class Derived :public Basepublic: virtual void mf1(); void mf3(); 这个实现很离谱。你用 public 继承是 is-a 关系，而这些重载函数又明确划分了子类和父类的界限。 编译器明面上在阻止这件事（防止建立 new derived class 同时无意间继承远房的 base class）。 而你却在冒 compiler 之大不讳 (is-a)。 名称遮掩规则没有改变。子类的mf1() , mf3() 都会彻底覆盖父类的同名函数。 Derived d;d.mf1(); //derived::mf1();d.mf1(6); //error hiding 虽然参数类型不同，但还是被遮盖了d.mf3(); //derived::mf2();d.mf3(6); //error hiding 需求1：子类无参同名函数覆盖父类无参同名函数，但也要继承父类同名带参函数。 解决：using 声明式 class Derived:public Basepublic: using Base::mf1;//Base class 内名为mf1和mf3的所有东西 using Base::mf3;//在 Derived scope 全部可见且public virtual void mf1(); //定义 ...//mf3同理d.mf1(); //derived::mf1();d.mf1(6); //base::mf1(6); 需求2：只想继承无参同名函数。 解决：forwarding function （转交函数) class Base ... //同上class Derived:private Base //private 继承，这东西类似 has-a 而非 is-apublic: virtual void mf1() Base::mf1(); //转交函数，暗自成为 inline ...d.mf1(); //调用 derived::mf1，但实际上还是 base::mf1d.mf1(6); //error inline 转交函数的另一个用途是为不支持 using 的老旧编译器提供一种方法，将继承名称汇入子类 scope 内。 34.区分接口继承和实现继承 接口继承和实现继承不同。 public 继承下，derived class 总是继承 base class 接口 区分不同接口，使之各司其职。 pure virtual function只负责接口继承。 impure virtual function 负责指定 接口继承 和 默认实现继承。 non-virtual function 具体指定接口继承以及强制性实现继承(不可更改)。 public 继承 严格来说分为两部分： function interface inheritance (函数接口继承) function implementation (函数实现) 设计一个 class ，往往你有三种可能的需求： 子类只继承成员函数接口（函数声明）； 子类同时继承函数的接口和实现，但希望能 override 这些继承的实现。 子类同时继承函数的接口和实现；但不允许 覆写任何东西。 class Shapepublic:\tvirtual void draw() const = 0;\tvirtual void error(const std::string msg);\tint objectID() const;; class Rectangle: public Shape...;class Ellipse: public Shape...; pure virtual function ：让 derived class 只继承函数接口 virtual void draw() const = 0; 实际上，你可以为 pure virtual function 提供一份定义，作为 base class (Shape) 的实现代码。只需要在调用时明确指出其 class 名。这种实现能提供一种机制：为 impure virtual 函数提供更安全的默认实现。 impure virtual function ：让 derived class 同时继承接口和实现，并允许 override 。 这个接口表示：每个 class 可以自由定义自己的错误处理函数；但如果你不想写任何东西，该函数将退回到 base class 来实现(默认版本)。 但这会带来一个问题： 如果 derived class 应该重新定义对应 impure function ，而程序员又忘记了在 class 里写上定义，这就会导致函数在无意间正常运行了 base::function() 。这不是你想要的结果。 解决：切断 virtual func-interface 和 默认实现 的连接 class Airplanepublic:\tvirtual void fly(const Airport destination) = 0; //采用纯虚函数只提供接口 ...protected:\tvoid defaultFly(const Airport destination) ... //缺省行为。并且访问方式是protected。\t; 这样，impure 就变成了 pure 。只提供飞机飞行接口。 原来的默认实现以独立函数的姿态出现。 //希望使用默认实现的 model Aclass ModelA:public Airplanepublic: virtual void fly(const Airport destination) defaultFly(destination); ...//自己实现的 model Bclass ModelB:public Airplanepublic: virtual void fly(const Airport destination) ... //自己实现吧 ... 当然，粗心的程序员直接剪切code segment 还是会引发问题。但安全性至少高了一些。 有些人反对用不同的函数提供接口和实现。如果实在感觉别扭，你可以利用上文提到过的，pure virtual 的默认实现。 //希望使用同一函数默认实现的 model Aclass ModelA:public Airplanepublic: virtual void fly(const Airport destination) Airplane::fly(destination); ...//B不变。 non-virtual function ：令 derived class 继承函数接口和一份强制性实现 int objectID() const; 强制性，也可以理解为“invariant greater than specialization”。它绝对不能被重新定义。 两个常见错误： 将所有函数声明为 non-virtual 首先 non-virtual 析构会带来问题。其次你没必要太担心 virtual function 的效率成本。任何 class 打算作为 base class，都得有好多 virtual 。不要忘记80-20法则。 将所有成员函数声明为virtual 这属于矫枉过正。对于某些函数，它就是不该被重新定义。要有坚定的立场。 35.考虑virtual函数以外的选择 virtual 函数的替代方案有 NVI 方法和不同形式的 Strategy 设计模式。 NVI（non-virtual Interface） 方法属于特殊形式的 Template Method 设计模式 实现从 member function 更换为 class 外部函数，会导致无法访问 class 内部的 non-public 成员。 除非你愿意降低封装性使用 friend tr1::function 对象的行为像一般函数指针，但它能接纳与 target signature 兼容的所有 callable entities 。 兼容性强大：函数参数和函数返回值的隐式转换。 class GameCharacterpublic: virtual int healthValue() const; //省略实现 ... 计算游戏角色的血量。血量有不同计算方法，而同一方法又可能适用于不同人物。 virtual 当然是很好的选择。但下面会提供几种思路供参考，来尽量避开 virtual func 的使用。 NVI 手法实现 Template Method 模式 该方法主张 virtual 函数应该几乎全是 private ，最好保留 Healthvalue 为 public 成员函数，但让它成为 non-virtual ，并调用一个 private virtual 函数。 class GameDCharacterpublic: int healthValue() const // non-virtual : a wrapper ... //事前工作 int retVal = doHealthValue(); //核心工作 ...//事后工作 return retVal; ...private: virtual int doHealthValue() const //被转移到此 ... //默认算法，计算健康指数 ; 客户能通过 public non-virtual 成员函数间接调用 private 函数，即NVI（non-virtual interface）手法，是Template Method 设计模式的表现形式之一。 这个 non-virtual 可称之为 virtual 函数的 wrapper 。 优点： 事前工作和事后工作有很大的弹性：能够设置不同条件场景。 NVI 手法允许 derived class 重新定义 private virtual 函数（实现）。 ”重新定义“ 意味着函数如何完成 ，由 derived class 决定。 “调用 virtual ”意味着函数何时被完成，由 base class 决定。 注意： NVI手法下，没必要 virtual 函数必须是 private。有些场景下 derived class 在 virtual 函数实现内必须调用 base class 的对应同名兄弟。为了使之合理， virtual 就只能是 protected 了。 遇到多态 base class 的 析构函数，你甚至得是 public。 基于 Function Pointers 的 Strategy 模式 NVI手法只是对 public virtual 函数的一个修饰。Strategy 设计将使 人物的healthvalue 与人物本身毫无关系，相互独立。 可以猜出来：每个人物的构造函数接收一个函数指针，指向哪个健康计算函数，就是哪个喽。 class GameCharacter;// foward declaration//主角之一：健康计算的默认算法int default_Health_Calc(const GameCharacter gc);class GameCharacterpublic: typedef int (*Health_calc_func)(const GameCharacter); explicit GameCharacter(Health_calc_func hcf = default_Health_Calc) :healthFunc(hcf) //默认参数↑ int healthValue() const //返回血量（返回前通过指针调用一次函数） return healthFunc(*this); ... private: Health_calc_func healthFunc; //主角之二：函数指针 它和普通 virtual function 相比，弹性很大： 同一人物类型的不同对象，仍然可以有不同健康计算函数： class GameCharacter //同上 ; int loseHealthQuickly(const GameCharacter);int loseHealthSlowly(const GameCharacter); //不同血量计算 class EvilBadGuy :public GameCharacter //构造函数同character：作为接口插入函数指针 explicit EvilBadGuy(Health_cala_func hcf = default_Health_Calc) :GameCharacter(hcf) ;void test() EvilBadGuy ebg1(loseHealthQuickly); //相同类型人物，不同血量计算 EvilBadGuy ebg2(loseHealthSlowly); 已知人物的健康计算函数，可以在运行期变更。 GameCharacter::set_Health_Calc //作为接口，随时替换定义。 健康计算函数不再是 GameCharacter 继承体系内的成员函数。 这些计算函数没有访问 class 的内部 non-public 成分。 问题：如果你需要 class 内的 non-public 信息进行精确计算，就会产生问题。 当你需要平替 class 内的成分为 class 外部的等价成分（如 non-member non-friend 函数 另一个 class 的non-friend 成员函数）时都会引发争议。 解决：弱化class封装 non-member → friend 为实现的某一部分提供 public 访问函数 它的优点(灵活性)相对缺点（封装性潜在降低），需要看你的使用场景。 基于tr1::function 的Strategy 模式 哎呀，函数指针看起来终归有些苛刻而死板。改用函数指针为 tr1::function 对象，能舍去很多约束。 这东西兼容性很强。只要 signature 和需求端匹配，其他的都可以商量变通。 class GameCharacter;int defaultHealthCala(const GameCharacter gc); class GameCharacter public: ... //其余部分同上 //只是将函数指针改为了function模板，其接受一个const GameCharacter参数，并返回int typedef tr1::functionint(const GameCharacter) HealthCalcFunc; //以 int 为例，返回兼容int的everything，接收兼容GC的everything （隐式转换） explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) :healthFunc(hcf) private: HealthCalcFunc healthFunc;; 仅仅是 private 的载体改变了：函数指针 →tr1::function 。 下面看看它发挥的作用。 class GameCharacter //同上;class EvilBadGuy :public GameCharacter //载体改变，其他如假包换。;class EyeCandyCharacter :public GameCharacter //构造函数类似EvilBadGuy ; //下面是不同类型的健康计算函数，来突出 tr1::function 的兼容性//1.类型不同的普通函数 short calcHealth(const GameCharacter);//2.函数对象，用来计算健康指数struct HealthCalculator int operator()(const GameCharacter)const ;//3.一个类：提供一个成员函数，用以计算健康class GameLevel public: float health(const GameCharacter)const;;void test() //人物1，其使用calcHealth()函数来计算健康指数 EvilBadGuy ebg1(calcHealth); //人物2，其使用HealthCalculator()函数对象来计算健康指数 EyeCandyCharacter ecc1(HealthCalculator()); //人物3，其使用GameLevel类的health()成员函数来计算健康指数 GameLevel currentLevel; EvilBadGuy ebg2(std::tr1::bind(GameLevel::health, currentLevel, _1)); 人物1,2的那种隐式转换你已经司空见惯。下面我们来看 ebg2 —— 人物3 GameLevel::health 宣称自己接收一个参数。但它实际上有一个第二参数：this指针(GameLevel 类型) GameCharacter 构造函数真正只接受单一参数。 如果你使用 GameLevel::health 作为ebg2 的健康计算函数，你得说服 GameCharacter 接受它： 让GameLevel::health 可以通过绑定，让它不接收两个参数↓ 将 currentLevel 绑定为GL对象，让他在每次“GameLevel::health被调用来计算 ebg2健康”时使用。 这就是 tr1::bind 的工作了 —— 它表明：ebg2 的健康计算函数应该总是以 currentLevel 作为 GL对象。 (OK,这里 cuttrentLevel 作为一个 GameLevel 载体，作用被具现化、框定了) _1: 当为ebg2 调用 GameLevel::health 时系以 cuttrentLevel 作为 GameLevel 对象。 综上，这种兼容性还是很吸引人的。 传统古典 Strategy 模式 将健康计算函数做成一个分离体系中的 virtual 成员函数。 UML图如下，意义如下： GameCharacter是一个继承体系的根类，其派生类有EvilBadGuy、EyeCandyCharacter HealthCalcFunc是一个继承体系的根类，其派生类有SlowHealthLoser、FastHealthLoser 每一个GameCharacter对象都内含一个指针，指向于一个来自HealthCalcFunc继承体系中的对象 Code： class GameCharacter;class HealthCalcFunc //计算健康指数的类 public: virtual int calc(const GameCharacter gc)const ; HealthCalcFunc defaultHealthCalc;class GameCharacter public: explicit GameCharacter(HealthCalcFunc* hcf = defaultHealthCalc):pHealthCalc(hcf) int healthValue() return pHealthCalc-calc(*this); private: HealthCalcFunc* pHealthCalc;; 这个设计提供：“将一个现成的健康算法纳入使用”的渠道 —— 为 HealthCalcFuc 继承体系添加一个 derived class 即可。 总结：替换 virtual 函数的四中方法 使用non-virtual interface 方法，以 public non-virtual 成员函数 包裹 较低访问性(private ptotected) 的 virtual 函数。 将 virtual 函数替换为“函数指针成员变量” 这是 Strategy 设计模式一种表现形式。 将 virtual 函数替换为 tr1::function 成员变量。极强的兼容性。 这也是 Strategy 设计模式一种表现形式。 将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。 Strategy 设计模式的传统设计手法。 36.绝不重新定义继承的 non-virtual 函数 绝不重新定义继承的 non-virtual 函数 看看例子吧： // 正常情况class Bpublic: void mf(); ...;class D:public B...;D x;B *pB = x;pB - mf();//经由该指针调用\tB::mfD *pD = x;pD - mf();//经由该指针调用B::mf//重新定义class Bpublic: void mf(); ...;class D: public Bpublic: void mf(); //遮掩了B:mf; ...D x;B *pB = x;pB - mf();//调用B::mfD *pD = x;pD - mf();//调用D::mf **原因：**non-virtual 都是静态绑定（statically bound），而virtual 函数是动态绑定（dynamically bound） 静态：pb 作为 pointer to B ，调用的 non-virtual 函数永远是 B 所定义的版本。 动态：如果 mf 是 virtual function ，不论是通过 pointer-to-B或 p-to-A ,都是调用 D::mf，因为两者指向的都是 D 对象。 这样一来，一个D对象既可能表现 D object 行为，也可能表现 B object 行为。决定因素不在对象自身，而在指向该对象的指针的类型。 **理念冲突：**public 继承意味着 is-a 关系；non-virtual 意味着 invariant greater than specialization 。 适用于 B 对象的每一件事，也适用于 D 对象，因为每个 D对象都是一个 B对象。 B 的子类一定继承 mf 函数接口的实现，因为 mf 是一个 non-virtual B 此时却要覆盖掉 mf 两者冲突。 37.绝不重新定义继承来的默认参数 绝不重新定义继承来的默认参数 默认参数值都是静态绑定。 virtual 函数是动态绑定。 如 item 36所言，继承 non-virtual 而重新定义并不合理。所以只需讨论 virtual 函数问题。 下面解释下静态动态绑定： statically bound:被声明时所采用的类型。 //一个描述几何形状的classclass Shape public: enum ShapeColorRed,Green,Blue; //所有函数都必须提供一个函数用来绘制自己 virtual void draw(ShapeColor color=Red)const=0; //red ...;class Rectangle:public Shape public: //注意这里对缺省参数的改变，糟糕透了 virtual void draw(ShapeColor color=Green)const; //green ...;class Circle:public Shape public: virtual void draw(ShapeColor color)const; //不指定参数 用户以对象调用时必须指定参数 : 因为静态绑定下，这个函数并不从base继承缺省参数值 用户以引用调用时可以不指定参数 : 因为动态绑定下，这个函数会从base继承缺省参数值 dynamically bound： Shape* ps; //静态类型为Shape*，没有动态类型Shape* pc=new Circle;\t//静态类型为Shape*，动态类型为Circle*Shape* pr=new Rectangle;//静态类型为Shape*,动态类型为Rectangle*//注意上述三个指针，不论他们真正指向什么，他们的静态类型都不会变//动态类型则可以在程序执行过程中改变（通常是赋值引起）ps = pc;ps = pr;//动态类型改变 virtual 函数则是动态绑定：调用一个 virtual 函数，调用哪一份 function code ，取决于 *this 的动态类型。 问题： // Shape* pr=new Rectangle;pr-draw(); pr 的动态类型为 Rectangle* ，调用的应是 Rectangle 的 virtual function draw。但由于 pr 的静态类型是 Shape* ，所以默认参数值来自 Shape class 而非 Rectangle class ，参数为 Red 而非 Green。 这不是我们想要的结果。 这是 C++ 为了保证运行期效率的表现。默认参数是动态绑定的话，编译器必须有某种办法在运行期为 virtual 函数决定适当的参数默认值。这会比目前的“编译器决定”机制更慢更复杂。 解决： 单纯的让子类 virtual function 和 父类一致，会导致代码重复和相依性（with dependencies），牵一发而动全身。 更好的解决方法可参考NVI手法： class Shape public:\tenum ShapeColor Red, Green, Blue ;\tvoid draw(ShapeColor color = Red) const // 如今它是non-virtual doDraw(color); // 调用一个virtual ...private:\tvirtual void doDraw(ShapeColor color) const = 0; // 真正的工作在此处完成;class Rectangle: public Shape public:\t...private:\tvirtual void doDraw(ShapeColor color) const; // 注意，不须指定缺省参数值\t...; 令 base class 内的 public non-virtual function 调用 private virtual 函数，后者可被 derived class 重新定义。 non-virtual 绝对不能被子类覆写，所以该设计理论上让 draw function 默认参数始终为 Red。 38.Model “has-a” or “is-implemented-in-terms-of”through composition 复合(composition)的意义和 public 继承完全不同 在 application domain ，复合意味着 has-a 。在 implementation ，复合意味着 is-implemented-in-terms-of （根据某物实现）。 复合表示一种类型关系：某种类型的对象内包含另一种类型的对象。 //composition (很多同义词： layering , containment , aggregation , embedding)class Address ...;class PhoneNumber ...;class Person public: ...private: string name; Address address; PhoneNumber voice Number; 如同 public 意味着 is-a 一样，复合意味着两种关系：has-a 和 is-implemented-in-terms-of 。这两种关系对应两种 domains 。 application domain: 人，汽车，视频画面等。 implementation domain: 缓冲区，互斥器，查找树等。可以理解为应用域的微观实现细节。 has-a 和 is-a 的区分： Person class 有地址，电话号码。但显然不是 is-a 所指的人是个电话，人是个号码这样。即 has-a。 is-implementation-in-terms-of 和 is-a： “根据某物实现出”：举一个例子，你把自行车改造成了巡洋舰(这里忽略改造细节)，自行车作为巡洋舰的主体，实现了巡洋舰的功能。这是 is-i-in-terms-of 的效果了。这时你不能说这艘巡洋舰是自行车，反过来更不行。 这里强调一个 “reuse” 效果，表现就是 composition 复用。 真正的例子：你要手搓一个 set template ，秉承就地取材（根据某物实现）的精神，你准备以 list 容器为主体。 templateclass T //list 应用于 setclass Setpublic: bool member(cosnt T item) const; void insert(const T item); void remove(const T item); ...private: listT rep; //主体，承载 set 类数据//实现templatetypename Tbool setT::member(const T item) return find(rep.begin(),rep.end(),item) != rep.end();... 从这个例子中初见端倪，is-imp-in-terms-of 强调的是实现域，has-a 强调的是应用域。 39.明智审慎的使用 private 继承 private 继承意味着 is-implemented-in-terms-of 。 这通常比复合的级别低，更适用于子类需要访问 protected 父类成员，或者重新定义继承的 virtual 函数时。 private inheritance 可以完成空白基类(empty base)优化。 这对“对象尺寸最小化”的开发需求来说很重要。 private inheritance 不意味着 is-a： item 32 呈现 is-a关系时(public inherit)提到编译器在必要时允许 Student 类偷偷转换为 Person 。而 private 继承则不行。 private inheritance 意味着所有继承成员是 private 。 对于 private 继承的意义： private inherit 纯粹是一种实现技术：作为实现细节，由子类继承来使用父类中的现成的某些特性。 这种现成特性的利用就是 is-implementation-in-terms-of 。 复合的意义也是这样，但尽量用复合，必要时才用 private inheritance：即当牵扯到 protected member 和virtual function 这些麻烦家伙时。还有一种空白基类的优化技术要利用 private 继承。 例子：Widgets class，一个窗口类 //Widget 需要借助 Timer 记录成员函数调用次数class Timerpublic: explicit Timer(int tickFrequency); virutal void onTick() const; ...; private inherit： class Widget:private Timerprivate: //public 破坏封装性，误导用户 virtual void onTick() const; ... composition： class Widget private: class WidgetTimer:public Timer public: virtual void onTick() const; WidgetTimer timer;//这个设计涉及 public inherit ， composition，同时导入了新 class 两个注意点： 封装性让我们希望 derived class 不能修改 base class 里的关键函数（onTick） 但 derived 可以重新定义virtual func，private继承也不行。 而如果你用上面的 composition 来实现，这一要求将得到实现。 (Allocate a new class (called “WidgetTimer” ) public inheriting Timer as private member in Widget .) (Then , derived class inheriting Widget can’t modify that virtual function .) 降低编译依存性 Widget 继承 Timer ，编译 Widget时 Timer 定义就必须可见，于是就不可避免的#includeTimer.h。 如果 WidgetTimer 定义放到 Widget 外，取而代之的是把指向定义的指针放在 Widget 里，这样你就只需要一个简单声明和一个指针就够了。 这样的解耦性(decoupling)操作非常重要，尤其对于大型系统。 神秘主角：empty base 既然是 empty base ，就不要有任何东西。 按理说它不该占用任何内存。而 C++ 有一个准则：独立对象都必须有非零大小。 like this： class empty ;class Hold_An_Intprivate: int x; Empty e; 实际情况是，sizeof（Hold_An_Int） sizeof（int）。 多数编译器中，sizeof(empty) 1。 面对大小为0的独立对象 empty，c++ 会偷偷插入一个 char 到空对象里。 但这样一来，齐位需求（alignment）会要求编译器再加入一些 padding，扩大到一个 int 等。 不过既然要求是独立对象，那就不独立好了，就可以为0了。 class Hold_An_Int:private Emptyprivate: int x; sizeof（Hold_An_Int） sizeof（int），效果达到了。这就是所谓的EBO（empty base optimization）。 EBO 一般只在单一继承下才行。 现实情况下，EBO的 empty class 并不是真的 empty。里面往往有一些 unary_function , binary_function 。这些东西是用户自定义的函数对象，用来被继承（是否想起了 is-implementation-in-terms-of）。 说完EBO，请允许我在最后多一句嘴：composition 混合了 public 继承和复合的设计看起来很复杂，但可行性依然非常高。相对于这个思路，“明知而审慎”的使用 private inherit 是值得你考虑的事情。 40.明智审慎的使用多重继承(judiciously) 多重继承比单一继承复杂。 这可能导致歧义性，以及对 virtual 继承的需求。 virtual 继承会增加大小、速度、初始化复杂度等成本。 如果 virtual base classes 不带任何数据 多重继承适用于特定的应用场景。 例如” public 继承某个 interface class “ 和 “private 继承某个协助实现的 class“ 两项组合 下面来逐个分析： 继承带来的歧义性 同名函数 有着相同函数checkout()不同实现的两个 class A和B，被一个 derived class 多重继承（同时继承两个 class ），该子类调用checkout时，编译器会考虑两个函数对调用的匹配程度（类似 resolving 重载函数调用那样），该例两个调用匹配程度相同。为此你必须指出调用哪个函数：C.A::checkout()。 钻石继承 (菱形继承) class File...;class InputFile:public File...;class OutFile:public File...;class IOFile:public InputFile, public OutputFile ...; 继承体系出现一个以上的相同路线（上例有两条），就要考虑：是否打算让 base class 的成员在每一条路径都被复制一遍。 如果回答为是，就意味着收束子类(IOFile)将有两份一模一样的代码段（成员变量，成员函数）。逻辑上来说，IOFile object 只需要一份就够了，不该重复。 C++默许了两种方法： 重复几份：如上例一样。 只保留一份：virtual 继承： class InputFile:virtual public File...;class OutFile:virtual public File...; virtual 的成本 场景需求当然是 virtual 继承多一点。但这不意味着你碰到多重继承便要 virtual 。 virtual 继承对象 往往有更大的体积，访问 virtual base class member-variable 时，速度也更慢。 virtual base class 初始化规则比起 non-virtual 更为复杂且不直观。 1.derived class 若选择 virtual inherit base class 而需要初始化，必须清楚知晓 base class 的所有相关成分，不管继承有多远。 2.新的 derived class 加入继承体系中，也就意味着必须承担 base class 的初始化责任。 成本这么大，怎样看待 virtual base class 呢？（v-inherit） 1.非必要不用 virtual base class。能用 non-virtual 就用。 2.必须使用 virtual base class ，那就避免在其中放置数据。 多重继承的适用范例 一个 model 人的 C++ interface class。 class IPerson public: virtual ~IPerson(); virtual std::string name() const = 0; virtual std::string birthDate() const =0; ;//no doult ：这玩意儿需要实体化，也就是下面的 factory function//factory function,根据一个独一无二的数据库ID创建一个Person对象 std::tr1::shared_ptrIPerson makePerson(DatabaseID personIdentifier); DatabaseID askUserForDatabaseID(); //从使用者手上取得数据库IDDatabaseID id(askUserForDatabaseID()); std::tr1::shared_ptrIPerson pp(makePerson(id));//object Interface class IPerson 的具现化工作在 factory function 里，意味着 f-function 需要定义具现化 derived class 。我们用 CPerson 充当 derived class 。这时恰好有个 PersonInfo 有现成的元素使用）： class PersonInfo public: explicit PersonInfo(DatabaseID pid); virtual ~PersonInfo(); virtual const char* theName()const; //const char*有点老套，不过这不是重点 virtual const char* theBirthDate() const; private: virtual const char* valueDelimOpen() const; //这个东西是标明字符串起始点和结束点的 return [ ; virtual const char* valueDelimClose() const; //以特殊字符串为界（默认[]，可自定义） return ] ;;const char* PersonInfo::theName() const //保留缓冲区给返回值使用：static，自动初始化为“全0” static char value[Max_Formatted_Field_Value_Length]; //写入起始符号 std::strcpy(value, valueDelimOpen()); //将value内的字符串附到这个对象的name成员变量中 //写入结尾符号 std::strcat(value, valueDelimClose()); return value; theName 调用 valueDelimOpen 产生字符串起始符号 → 产生 name 值 → 调用 valueDelimClose。 valueDelimOpen 和 valueDelimClose 都是 virtual funciton ，所以 theName 返回的结果不仅取决于 PersonInfo，也取决于从 PersonInfo 派生下去的 class 。 这里使用基于 private 继承的 is-implemented-in-terms-of 方法。 class Cperson: public IPerson, private PersonInfo //info 是 in terms 功能要求public: //iperson 是 具现工作 要求 explicit Cperson(DatabaseID pid): PersonInfo(pid) virtual std::string name() const return PersonInfo::theName(); virtual std::string birthDate() const return PersonInfo::theBirthDate(); private: const char* valueDelimOpen() const return ; const char* valueDelimClose() const return ; ; 以 CPerson 为主体，利用 Private PerosnInfo 实现出 IPerson 的接口完成具现化工作。 7.Templates and Generic Programming41.了解隐式接口和编译期多态 class 和 template 都支持接口和多态 对 class 而言 : 接口是显式的，以函数签名为中心；多态是通过 virtual function 发生在运行期。 对 template 而言：接口是隐式的，以有效表达式为中心；多态是通过 template 具现化函数重载发生在编译期。 这一章开始进入模板和泛型编程。这需要我们以另一个思路来考虑。 首先来区分不同接口在函数多态上的不同： 显式接口： class Widget public: Widget(); virtual ~Widget(); virtual std::size_t size() const; virtual void normalize(); virtual swap(Widget other); ; void doProcessing(Widget w) if (w.size() 10 w != someNastyWidget) Widget temp(w); temp.normalize(); temp.swap(w); 接口定义由函数的签名式构成（函数名称，参数类型，返回类型）。 上例 public 接口中的 constructor ,size,swap…… ，当然包括各种类型、常量性。 接口定义在源码中清晰可见 基于 virtual 函数的运行期多态 运行期根据 object 的动态类型决定调用哪一个函数。 隐式接口： templatetypename T void doProcessing(T w) if (w.size() 10 w != someNastyWidget) T temp(w); temp.normalize(); temp.swap(w); 接口定义基于需求有些约束。 看看条件语句，可以知道 t 必须提供 size member function，必须支持 operator ！ 等。 以上的“必须”可以通过 operator overloading 有所改观： 以 size 为例，T 类型对象可以单纯从 base class 继承，并且返回类型X不一定非要是 int —— 你只需要让X和10一起支持 operator 就行（甚至X可以发生隐式转换达到这一目的）。 对象(本例为 w )支持的接口，由 template 执行在对象本身时的操作决定。 需要用到什么，compiler 就在编译期具现化什么。 对象的函数调用发生在编译期。 编译期会让这种多态以多个重载函数的形式实现。 42.了解 typename 的双重意义 作为 template 参数，class 和 typename 可互换 typename 能够标识嵌套从属类型名称。 不能再 base class list 或 member initialization list 内作为 base class 修饰符。 关于第二点： templatetypename Cvoid print2nd(const C container) // 打印容器内第二个元素 // 注意这不是有效C++代码 if (container.size() = 2) C::const_iterator iter(container.begin()); // 取得第一元素的迭代器 ++iter; // 将iter移往第二元素 int value = *iter; // 将该元素复制到某个int std::cout value; // 打印那个int 从属名称: template 内，包含模板参数的名称。 嵌套从属名称：从属名称在 class 内呈嵌套状。(模板类中的模板成员) 嵌套从属类型名称：具备以上属性的同时，指涉了某类型。 示例：C::const_iterator int（非从属名称） typename的另一重要用法：证明一个名称是嵌套从属类型名称 而不是变量 或者其他什么东西。 所以上面的代码需要更正： if (container.size() = 2) typename C::const_iterator iter(container.begin()); //精髓 typename 例外情况： templatetypename Tclass Derived: public BaseT::Nested // 1.base class list中不允许“typename”public: explicit Derived(int x) : BaseT::Nested(x) // 2.mem.init.list中不允许“typename” typename BaseT::Nested temp; // 3.嵌套从属类型名称满足： ... // 既不在base class list中也不在mem.init.list // 作为一个base class修饰符需加上typename ...; 最后：typename 在不同编译器上有不同规则。它在移植性方面有一些无伤大雅的问题。 43.学习处理模板化基类的名称 编译器看不到模板父类的成员，有三种方法处理这种情况。 模板全特化 对 调用继承模板类函数 的冲击： templatetypename T1class Class_Apublic:\tvoid send1(T1 var);;template typename T1class Class_B:public Class_A T1 public:\tvoid send2(T1 var) send1(var); //编译错误，调用模板基类内函数失败; Class_B 继承 Class_A后，调用 A 的函数理所应当，但编译发生错误：编译器看不到模板父类的成员。 更准确的说，即使看到了也无济于事：模板中的全特化会让原模板类造成编译器的错觉，所以干脆假装看不见喽。 （CPP compiler 秉持着 “早发现早治疗” 的语法检测原则 : 与其在 template 实参具现化时，不如在 parsing 子类模板定义式 时） 全特化示例： templateclass Class_AType_1 //特化模板类，类型为Type_1时的模板类public:\tvoid send3(Type_1 var); // 该特化类中压根不存在send1函数; 继承在 template CPP 中不像 Object Oriented CPP 那样畅通无阻了。 解决方法： base class 函数调用前加上 “this-” void Class_B:: send2(T1 var) this-send1(var); using 声明式 template typename T1class Class_B:public Class_A T1 public:\tusing Class_AT1::send1; void send2(T1 var) send1(var); ; 指明调用函数的所在区域 void Class_B:: send2(T1 var) Class_AT1::send1(var); 如果被调用的是 virtual 函数，上述的 explicit qualification 会关闭 “virtual 绑定行为”。 总结： 三个方法本质相同：让编译器知道，base class template 的所有特化版本都能支持我们需要的普通接口。 如果你对编译器保证，却不那么做，编译器也不会让你通过的。 44.将与参数无关的代码抽离 template Template生成多个classes与多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可以消除，做法是以函数参数或者class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀，也可以降低，做法是让带有完全相同二进制表述(binary representations)的具现类型(instantiation types)共享实现码。 template 使用不当可能会导致 code bloat ，让二进制码呈现一批雷同的代码，浪费空间。 这需要你洞悉函数的共同部分，抽离那些个性的部分。 不过面向对象的设计中，重复部分可以通过肉眼看出来； template 设计中则需要提前考虑可能的重复。 template class T, size_t nclass SquareMatrixpublic: void Invert();;int main() SquareMatrixint, 10 a; SquareMatrixint, 5 b; 这会具现化两份 invert 函数。两个函数除了常量5和10，其他部分完全相同。 为了减少代码冗余，你会想建立一个函数（类实现）。 templatetypename Tclass SquareMatrixBasepublic: SquareMatrixBase(size_t n,T* pMem) : size(n),pDate(p) void Invert(size_t n) void setDataPtr(T* ptr)pData = ptr;private: T* pData; size_t size;; 两种继承：栈和堆 栈： template class T, size_t nclass SquareMatrix: private SquareMatrixBaseTpublic: SquareMatrix() : SquareMatrixBaseT(n,data) void Invert() this-Invert(n); private: T data[n * n]; //你也可以用 T*[pData]指向矩阵内容; 堆： template class T, size_t nclass SquareMatrix: private SquareMatrixBaseTpublic: // //将基类的 数据指针 设为NULL SquareMatrix() : SquareMatrixBaseT(n,0),data(new T[n*n] ) this-setDatePtr(data.get();) //将指向该内存的指针存起来，将它的副本交给基类 ... void Invert() this-Invert(n); private: boost::scoped_arrayT data;; 成员函数可以用 inline 方式调用 base class 版本（如 invert），并且不同对象有着不同类型：double,5和double,10共同调用 base 成员函数的同时，前者部分不会跑到后者部分中去。 一方面，尺寸专属版函数可能比这种共享版有更好的代码。 （尺寸专属版中，尺寸本身是个编译器常量，于是常量的广传达到最优化，把它们折进被生成指令中成为直接操作数等） 另一方面：不同大小矩阵共享单一版本 invert ，可减少执行文件大小，降低程序的 working set 大小，强化指令高速缓存区内的 locality of reference 。 相反的两个作用，要靠亲自上机 test 来确定哪方面占主导地位。 至于对象大小，你可以把 上面最近的版本（与矩阵大小无关的函数版本）扔到 base class 里，这会增加每一个对象的大小 。例如每个 derived class 有一个指针成员指向 base class 内的数据。这会让每个 derived class 增加至少一个指针的大小，但能通过代码重复来获得更有条理的结构 当然你可以尝试令一个 base class 贮存一个 protected 指针指向矩阵数据（即使丧失封装性）。这样 delete 一个指针的判断又会让人伤脑筋。不过有一点毋庸置疑 : 越精密的做法意味着越复杂。 最后：这个 item 只讨论 non-type template parameters 的膨胀。 type parameters 也会带来膨胀，像一些平台对于同一模板的 int 和 long 不会合并 导致两个版本的成员函数产生。 多数平台上，所有指针类型有着相同的二进制表述，因此template 持有指针类型的名称，应对每一个成员使用同一份底层实现。 最后：多重继承确乎有其独特的应用场景，并且确实好用。但在大部分情况下，有单一继承可以实现的设计，为了让程序更好理解和简洁，还是使用单一继承更好。 45.运用成员函数模板接受所有兼容类型 使用成员函数模板可以生成接受所有兼容类型的函数。 如果你为泛化拷贝构造或泛化赋值声明了成员模板，你依然需要声明常规拷贝构造函数和拷贝赋值运算符。 智能指针是行为像指针而具备一些特性的类指针对象。这种对象在 STL的迭代器中有所应用。 但智能指针的类型转换需要手动设计，相比之下内置指针的好处就是支持各种隐式转换。 class Top;class Middle: public Top;class Bottom: public Middle; 内置指针： Top *p1 = new Bottom;const Top *p2 = p1; 智能指针转换： templatetypename Tclass SmartPtr public: explicit SmartPtr(T* realPtr); ..;SmartPtrToppt1 = SmartPtrMiddle(new Middle);SmartPtrToppt2 = SmartPtrBottom(new Bottom);SmartPrtconst Top pct2 = pct1; 这是由于，模板继承关系的两个类型，在具现化以后的对象不会有继承关系。 在编译器看来 SmartPtr 和 SmartPtr 是完全不同的两个类 。 用 Middle 初始化 Top 需要重载 SmartPtr 的构造函数。层级的增加伴随着重载构造函数的增加，理论上是没有穷尽的。这时 需要为 SmartPtr 写一个 template 构造模板。即所谓的 member function template templatetypename Tclass SmartPtrpublic: templatetypename U SmartPtr(const SmartPtrU other); //为了生成 copy 构造函数 对任何类型，根据 SmartPtrU 可以生成一个 SmartPtrT : 后者的构造函数可以接收前者参数。两者类型是同一个 template 的不同具现体。这可称作 generalized copy construactor function . 为了支持隐式转换,构造函数未加入 explicit 。 不过这种转换有风险（比如子类转成父类），需要一些约束： templatetypename Tclass SmartPtrpublic: templatetypename U SmartPtr(const SmartPtrU other ) //other 的 heldPtr 初始化 this 的 heldPtr :heldPtr(other.get())... //这里能够发生隐式类型转换 T* get() const return heldPtr; ...private: T* heldPtr; //SmartPtr 的原始指针 借助 原始指针 的转型操作 来完成SmartPtr的隐式转换。 同时 member function template 的作用不止构造函数，还有对赋值操作的支持。 用 tr1::shared_ptr 作为范例： templateclass T class shared_ptrpublic: templateclass Y explicit shared_ptr(Y *p); //构造，来自兼容内置指针。 templateclass Y //泛化构造函数 shared_ptrshared_ptrY const r; //或shared_ptr templateclass Y explicit shared_ptr operator=(shared_ptrY const r); //或weak_ptr templateclass Y explicit shared_ptr(auto_ptrY r); //或auto_ptr templateclass Y shared_ptr operator=(shared_ptrY const r); //赋值 tempalteclass Y //兼容 shared_ptr shared_ptr operator=(auto_ptrY r); //和 auto_ptr; 泛化构造函数支持隐式转换，其他构造函数则不然（加上explicit）。 另外，auto_ptr 的特性不支持 const 。 事实上，成员函数模板不会改变C++的规则。C++规则讲：如果你没有声明拷贝构造函数，那么编译器应该生成一个。 所以Y = T时拷贝构造函数不会从成员函数模板实例化，而是会自己生成一个。 这时你如果想控制 copy 构造函数的一切，那就同时声明 泛化copy构造函数和正常copy构造函数吧。（这同样适用于赋值) templateclass Tclass shared_ptrpublic: shared_ptr(shared_ptr const r); templateclass Y shared_ptr(shared_ptrY const r); shared_ptr operator=(shared_ptr const r); templateclass Y shared_ptr operator=(shared_ptrY const r);; 46.需要类型转换时，可为模板定义非成员函数。 阿萨德 问题： item 24 描述过 non-member 函数在所有实参身上的隐式类型转换。在这里，我们将 Rational类型和operator*模板化了： templatetypename Tclass Rational public: Rational(const T numerator = 0, const T denominator = 1); const T numerator() const; const T denominator() const; ; templatetypename Tconst RationalT operator*(const RationalT lhs, const RationalT rhs) 模板化以后，理所应当的认为它应该支持混合式算术运算： Rationalint oneHalf(1, 2); // OKRationalint result = oneHalf * 2; // Error! 实际上这并不能通过编译 : template 在实参推导过程中不会进行隐式类型转换。 编译器不能像 item 24 那样知道我们调用哪个函数。template 下它们在寻找具现化出来的在被名为 operator 的函数时，会因为 T 的偏差而受阻。 上例来说，编译器通过第一参数 oneHalf 发现模板参数T是 Rational 后，应该把 2 隐式转换为 Rational 与 oneHalf 对应。但 template 场景这种情况不能出现。 模板推导和函数调用是两个过程： 隐式类型转换发生在函数调用时，而在函数调用之前编译器需要实例化一个函数。而在模板实例化的过程中，编译器无从推导T的类型。 解决: 发挥 friend 的另一个功能：template class 内的 friend 声明式可以指涉某个特定函数。 类模板不再依赖实参推导，编译器可以在 class Rational具现化时得知 T。 templatetypename Tclass Rational public: friend const Rational operator*(const Rational lhs, const Rational rhs);;templatetypename Tconst RationalT operator*(const RationalT lhs, const RationalT rhs) 在 Rational 中声明的 friend 没有添加模板参数T，这是一个简便写法，它完全等价于： friend const RationalT operator*(const RationalT lhs, const RationalT rhs); 通过编译后，operator* 通过编译，class Rational被具现化出来。friend 函数 operator* 被自动声明出来。于是进入函数调用过程，支持隐式类型转换。 通过编译后，链接还会出错。 虽然在类中声明了 friend operator*，编译器却不会实例化该声明对应的函数定义。 由于函数是我们自己声明的，编译器认为我们有义务自己去定义那个函数。 templatetypename Tclass Rational public: friend const Rational operator*(const Rational lhs, const Rational rhs) return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); ; 总结： 为了对所有参数支持隐式类型转换，operator* 需要声明为非成员函数； 为了让编译器推导出模板参数，operator* 需要在类中声明； 为了函数自动具现化，需要在类中声明非成员函数并令其为 friend； 声明的函数的同时我们有义务给出函数定义，所以在函数定义也应当放在 friend 声明中。 特殊场景： 如 item30 所说，定义在类定义中的函数是 inline 函数。 如果 operator* 函数体变得很大，那么 inline 函数就不再合适了，这时我们可以让 operator* 调用外部的一个辅助函数： templatetypename T class Rational;templatetypename Tconst RationalT doMultiply(const RationalT lhs, const RationalT rhs); templatetypename Tclass Rationalpublic: friend RationalT operator*(const RationalT lhs, const RationalT rhs) return doMultiply(lhs, rhs); ; 编译器可能有把 template 定义式放到头文件里的要求。你可以在头文件内定义helper template ,这里用 doMultiply 举例： templatetypename Tclass RationalT doMultiply(const RationalT lhs, const RationalT rhs) return RationalT(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()) ; doMultiply 作为模板，像本文最开始的 operator* 一样不支持混合式乘法。但它只负责被 operator* 调用。而 operator* 负责隐式转换，确保两个对象能被相乘，传递给适当的 doMultiply template 具现体，完成乘法操作。 47.使用traits classes 表现类型信息 traits classes 使关于类型的信息在编译期间可用。它们使用模板和模板特化实现。 结合重载，traits classes 使得执行编译期类型 if…else 检验成为可能。 迭代器分类： 最简单的迭代器是输入迭代器（input iterator）和输出迭代器（output iterator）， 它们只能向前移动，可以读取写入它的当前位置，但只能读写一次。比如 ostream_iterator 就是一个输出迭代器。 比它们稍强的是前向迭代器（forward iterator），可以多次读写它的当前位置。 单向链表（slist，STL 并未提供）和 TR1 哈希容器的迭代器就属于前向迭代器。 双向迭代器（bidirectional iterator）支持前后移动，支持它的容器包括 set, multiset, map, multimap。 随机访问迭代器（random access iterator）是最强的一类迭代器，可以支持 +, - 等移动操作，支持它的容器包括 vector, deque,string 等。 对于上述五种迭代器，C++ 提供了五种 Tag 来标识迭代器的类型，它们之间是 ”is-a” 的关系： struct input_iterator_tag ;struct output_iterator_tag ;struct forward_iterator_tag: public input_iterator_tag ;struct bidirectional_iterator_tag: public forward_iterator_tag ;struct random_access_iterator_tag: public bidirectional_iterator_tag ; STL有一工具性 template 名为 advance ，用来将指定迭代器移动给定距离。 templatetypename IterT, typename DistTvoid advance (IterT iter, DistT d); 移动距离通常是不断执行 ++ – 。只有随机访问迭代器能 + 。 templatetypename IterT, typename DistTvoid advance(IterT iter, DistT d) if (iter is a random access iterator) iter += d; // use iterator arithmetic // for random access iters else if (d = 0) while (d--) ++iter; // use iterative calls to else while (d++) --iter; // ++ or -- for other // iterator categories 这里的关键是取得类型信息，让条件判断语句得以执行。 traits 的意义就是让你在编译期间取得类型信息。 Traits 不是关键字或者预定构件 ； 它是一种技术，需要在面对内置类型和用户自定义类型时的表现一样好。 对内置类型的要求意味着 traits 不能借助类来实现。 下面通过针对迭代器的 traits 来探索这种技术（这种 template 在标准程序库中并不少见）。 iterator_traits 将会标识 IterT 的迭代器类别：针对该类型，在 struct iterator_traits内一定声明 typedef 作为 iterator_category 来确认分类。 iterator_traits 的实现包括两部分： 用户定义类型的迭代器 以 deque 寄存器为例： template ... // template params elidedclass deque public: class iterator public: typedef random_access_iterator_tag iterator_category; :; 然后在全局的 iterator_traits 模板中响应 typedef 那个用户类型中的 Tag，以提供全局和统一的类型识别。 templatetypename IterTstruct iterator_traits typedef typename IterT::iterator_category iterator_category;; 基本数据类型指针 指针嵌套不了 typedef 。iterator_traits 可以针对指针类型提供一个偏特化版本(partial template specialization)。 templatetypename IterT // partial template specializationstruct iterator_traitsIterT* typedef random_access_iterator_tag iterator_category; //指针类似随机访问迭代器 ...; 总结一下 trait class ： 确认若干可能取得的类型相关信息。 对迭代器而言是取得其 catagory 为该信息起一个名称 本例中的 iterator_category 提供一个 template 和一组特化版本(iterator_traits) ，包含希望支持的类型相关信息。 我们已经用 iterator_traits 提供了迭代器的类型信息，是时候给出 advance 的实现了。 templatetypename IterT, typename DistTvoid advance(IterT iter, DistT d) if (typeid(typename std::iterator_traitsIterT::iterator_category) == typeid(std::random_access_iterator_tag)) //这里仍然有缺陷 ... 上述实现其实并不完美，if 语句中的条件（IterT类型）在编译时就已经决定，它的判断却推迟到了运行时（显然是低效的）。 编译器条件判断语句的实现，需要为不同的 iterator 提供不同的方法，然后在 advance 里调用它们。 所谓“提供不同方法”即重载。 对于传过来的实参，哪一个重载件最匹配就调用哪一个。这正是一个针对类型的编译器条件语句。 templatetypename IterT, typename DistTvoid advance(IterT iter, DistT d) doAdvance(iter, d,typename std::iterator_traitsIterT::iterator_category()); // 随机访问迭代器templatetypename IterT, typename DistTvoid doAdvance(IterT iter, DistT d, std::random_access_iterator_tag) iter += d; // 双向迭代器templatetypename IterT, typename DistTvoid doAdvance(IterT iter, DistT d, std::bidirectional_iterator_tag) if (d = 0) while (d--) ++iter; else while (d++) --iter; // 输入迭代器templatetypename IterT, typename DistTvoid doAdvance(IterT iter, DistT d, std::input_iterator_tag) if (d 0 ) throw std::out_of_range(Negative distance); // see below while (d--) ++iter; 这里利用 doAdvance 的重载版本，让 Advance 调用它们并额外传递一个对象来区分迭代器。 不同迭代间存在 “is-a” 继承关系，能够让适用于父类的迭代器同时使用子类的迭代器。 最后总结如何使用 traits class： 建立一组重载函数（身份像劳工）或函数模板（例如doAdvance），彼此间的差异只在于各自的traits参数，令每个函数实现码与其接受之traits信息相应和。 建立一个控制函数（身份像工头）或函数模板（例如Advance），它调用上述那些劳工函数并传递 traits class 所提供的信息。 啊，除了针对迭代器的 Traits ，标准程序库里还有 char_traits 用来保存字符类型的相关信息，以及numeric_limits 用来保存数值类型相关信息(比如数值类型的最大值和最小值)。 tr1 也导入了很多新的 traits classes 来提供类型信息。 48.认识元编程 Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期。 这能帮助实现早期错误侦测和更高的执行效率。 TMP 可被用来生成“based on combinations of policy choices”的客户定制代码，也可用来避免生成对特殊类型并不适合的代码 模板元编程（Template Metaprogramming，TMP）就是利用模板来编写template-based C++程序并使其运行于编译期的过程。 模板元程序（Template Metaprogram）是由C++写成的，运行在编译器中的程序。当程序运行结束后，它的输出仍然会正常地编译。 C++并不是为模板元编程设计的，但自90年代以来，模板元编程的用处逐渐地被世人所发现（不是发明）。 好处： 模板编程提供的很多便利在面向对象编程中很难实现； 程序的工作时间从运行期转移到编译期，可以更早发现错误，运行时更加高效。 在设计模式上，可以基于不同的策略，自动组合而生成具体的设计模式实现。 将运行期程序转移到编译期的功能非常优秀。以 item 47 中 advance( )为例： 运行期转移到编译期能降低可执行文件大小； 能够避免不必要的静态类型检查错误 在 typeid-based 条件判断语句的 advance 函数内，会出现不能编译的情况：设想以下advance::iterator, int中的这条语句： iter += d; 即使 list::iterator 是双向迭代器，不支持+=运算，也就是不会运行该死的+=算术运算，编译期仍然会提醒类型错误，”iterator 不支持 + 运算符” 。 元编程的威力： TMP 是图灵完全（turing-comlete）的，可以利用它 声明变量、执行循环、编写和调用函数等等。 但它的使用风格和普通 C++ 完全不同。 TMP 主要是个函数式语言。用正常 c++ 的阶乘循环函数举例： TMP 没有真正的循环构件，它是靠递归完成类似功能。 templateunsigned nstruct Factorial enum value = n * Factorialn-1::value ;;templatestruct Factorial0 enum value = 1 ;; void test() coutFactorial5::value; //5! = 120 TMP以 recursive tepmlate instantiation 取代循环，每个具现体都有自己的一份 value ，每个 value 有自己“ 循环“的适当值。 最后： 总结一下 TMP 的实际应用场景： 确保量纲正确。在科学计算中，量纲的结合要始终保持正确。比如一定要单位为 ”m” 的变量和单位为 ”s” 的变量相除才能得到一个速度变量（其单位为”ms”）。 使用 TMP 时，编译器可以保证这一点。因为不同的量纲在 TMP 中会被映射为不同的类型。 优化矩阵运算。比如矩阵连乘问题，TMP 中有一项表达式模板的技术，可以在编译期去除临时变量和合并循环。 可以做到更好的运行时效率。 自定义设计模式的实现。设计模式往往有多种实现方式，而一项叫基于策略设计的 TMP 技术可以帮你创建独立的设计策略，而这些设计策略可以以任意方式组合。生成无数的设计模式实现方式。 往小场景里说： 运行期转移到编译器的效率提升 完成“不能在运行期实现的功能” 都令人印象深刻。 第八章：Customizing new and delete49.了解 new-handler 的行为 set_new_handler 允许客户指定一个当内存分配请求不能被满足时可以被调用的函数。 nothrow new 作用有限，因为它仅适用于内存分配，随后的 constructor 调用可能依然会抛出 exceptions。 new-handler 登场： new 申请内存失败时会抛出 bad alloc 异常，此前会调用一个由 std::set_new_handler() 指定的错误处理函数new-handler。 “new-handler” 函数通过 std::set_new_handler() 来设置，std::set_new_handler() 定义在中： namespace std typedef void (*new_handler)(); //定义出一个指针指向函数（new 失败时所调用） new_handler set_new_handler(new_handler p) throw();//尾端的 throw 是一份异常明细 //表示该函数不抛出任何异常 使用示例： void outOfMem() std::coutUnable to alloc memory; std::abort();int main() std::set_new_handler(outOfMem); int *p = new int[100000000L]; 当 new 申请内存失败时，它会不断调用 new-handler 函数，直到找到足够内存。 总结一下 new-handler 的作用： 使更多内存可用； 这是为了让下一次内存分配可能成功。(可能程序开始就分配了大块内存供此使用) 安装一个新的 ”new-handler”； 当前new-handler失效后可以替换为另一个更有效的。（可以修改自己的成员来增强下次调用） 卸载当前 ”new-handler”； 将 null 传给set_new_handler。（没有安装 new-handler 会导致内存分配不成功时抛出异常） 抛出 bad_alloc（或它的子类）异常； 这个异常不会被 new 捕捉，而是传输到申请内存的地方。 不返回，可以 abort 或者 exit 。 重载 operator new： 了解完 new-handler ，来考虑下面对不同类型时的处理情况。 std::set_new_handler 设置的是全局的 bad_alloc 的错误处理函数，C++并未提供类型相关的 bad_alloc 异常处理机制。 但你可以在 class 内重载 new 和 new-handler ，用完在改回去就是了。 以 Widget 类为例： class Widgetpublic: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc);private: static std::new_handler current;; // 静态成员需要定义在类的外面，具体看 item 2std::new_handler Widget::current = 0; //初始化std::new_handler Widget::set_new_handler(std::new_handler p) throw() std::new_handler old = current; current = p; return old;//替换使用完毕后 归还原指针 关于 abort, exit, terminate 的区别：abort 会设置程序非正常退出，exit 会设置程序正常退出，当存在未处理异常时C++会调用 terminate， 它会回调由 std::set_terminate 设置的处理函数，默认会调用 abort。 operator new 的工作分为三个步骤： 调用 std::set_new_handler，把 Widget::current 设置为全局的错误处理函数； 调用全局的 operator new 来分配真正的内存； 如果分配内存失败，Widget::current 将会抛出异常； 不管成功与否，都卸载 Widget::current，并安装调用 Widget::operator new 之前的全局错误处理函数。 成功申请内存后由 widget 析构函数恢复，失败后由 new 函数本身处理。 RAII类 class NewHandlerHolder //资源处理类，帮助其他类实现 new-handlerpublic: explicit NewHandlerHolder(new_handler nh): handler(nh) //取得目前的new-hander ~NewHandlerHolder() set_new_handler(handler); //释放private: new_handler handler; NewHandlerHolder(const HandlerHolder); // 禁用拷贝构造函数 见 item 14 const NewHandlerHolder operator=(const NewHandlerHolder); // 禁用赋值运算符;//于是 Widget::operator new 的实现其实非常简单：void * Widget::operator new(size_t size) throw(bad_alloc) NewHandlerHolder h(set_new_handler(currentHandler));//返回原new-h来记录，使用现在的nh return ::operator new(size); // 调用全局的new，抛出异常或者成功 // 函数调用结束，恢复 global new-handler 在客户端使用情况是这样的： void outofMem();Widget::set_new_handler(outOfMem); // 设定outOfMem为Widget的new-handingWidget* pw1 = new Widget; // 如果内存分配失败调用outOfmemstd::string* ps = new std::string; // 如果内存分配失败调用global new-hanlding函数Widget::set_new_handler(0); // 设定Widget的new-handing为nullWidget* pw2 = new Widget; // 如果内存分配失败，立刻抛出异常 仔细观察上面的代码，很容易发现自定义 ”new-handler” 的逻辑其实和 class 本身是无关的。我们可以把这些逻辑抽取出来作为一个 template base class (功能类）： 你只需要让template部分确保每一个 class 获得一个不同的 currentHandler 成员变量 templatetypename Tclass NewHandlerSupportpublic: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc);private: static std::new_handler current;; templatetypename Tstd::new_handler NewHandlerSupportT::set_new_handler(std::new_handler p) throw() std::new_handler old = current; current = p; return old; templatetypename Tvoid * NewHandlerSupportT::operator new(std::size_t size) throw(std::bad_alloc) NewHandlerHolder h(std::set_new_handler(current)); return ::operator new(size);//将每一个 currentHandler 初始化为nulltemplatetypename Tstd::new_handler NewHandlerSupportT::current = 0; 实际上该 base class 从未使用参数T。那没什么影响。只是由于成员变量 current 是 static，需要我们为不同 class 依次定制 currentHandler 副本。类型T只是用来区分不同 derived class ， 有了这个模板基类后，给 Widget 添加 ”new-handler” 支持只需要 public 继承即可： class Widget: public NewHandlerSupportWidget ... ; 子类继承一个模板化的 base class ,同时后者以前者为类型参数。 这个有点绕弯弯的技术称作：curiously recurring template pattern CRTP 。 关于nothrow： 1993 年之前 C++ 的 operator new 在失败时会返回 null 而不是抛出异常。如今的 C++ 仍然支持这种 nothrow 的operator new： Widget *p1 = new Widget; // 失败时抛出 bad_alloc 异常assert(p1 != 0); // 这总是成立的if(p1 == 0) ... //这个测试一定失败Widget *p2 = new (std::nothrow) Widget; 如果分配 widget 失败，返回0if(p2 == 0) ... // 可能成功，失败时 p2 == 0 “nothrow new” 只适用于内存分配错误。而构造函数也可以抛出的异常，这时它也不能保证是 new 语句是 ”nothrow” 的。 50.了解 new 和 delete 的合理替换时机 有很多正当的编写 new 和 delete 的自定义版本的理由，包括改进性能，调试 heap（堆）用法错误，以及收集 heap（堆）用法信息。 列举一下替换默认 new 和 delete 的场景： 用来检测运用上的错误。 自行定义的 new 能够超额分配内存，用额外空间放置特定的 byte pattern（即 signature）。delete 能够得以检查上述签名是否原封不动。不动说明分配区某个时间发生了 overrun 或 underrun，delete 此时可以记录这个指针。 提高效率 编译器自带的 new 和 delete 要处理长时间执行程序和各种需求，大小块内存和各种分配形态。这意味着 自带 new 和 delete 会有着强大的兼容性，同时不会对某个需求有太多的倾向。所以定制版 new 和 delete 会比自带的更有效率。 收集动态分配内存的使用信息。 在继续自定义 new 之前，你可能需要先自定义一个 new 来收集地址分配信息，比如动态内存块大小是怎样分布的？分配和回收是先进先出 FIFO 还是后进先出 LIFO？ 为了增加分配和归还速度 定制分配器针对特定类型和固定尺寸能够有更好的效果。像Boost::Pool 为了降低默认内存管理器的额外开销 弥补默认分配器的非最佳齐位(suboptimal alignment) 将不保证对齐的new替换为对齐的版本，可能导致程序效率大幅提升。 将相关对象集中 如果指定某个数据结构往往一起使用，而你有希望处理这些数据时，将“内存页错误”（page fault）的频率降至最低，那么为此数据结构创建另一个heap就有意义，这样它们就可以被成簇集中在尽可能少的内存页（page）上。见条款52。 完成非传统行为 有时希望operator new和delete做编译器提供的缺省版本没做的事情，如将C API封装成C++ API，将归还内存覆盖为0 重写示例： 自定义一个 operator new 很容易的，比如实现一个支持越界检查的 new： static const int signature = 0xDEADBEEF; // 边界符typedef unsigned char Byte; void* operator new(std::size_t size) throw(std::bad_alloc) // 多申请一些内存来存放占位符 size_t realSize = size + 2 * sizeof(int); // 申请内存 void *pMem = malloc(realSize); if (!pMem) throw bad_alloc(); // 写入边界符 *(reinterpret_castint*(static_castByte*(pMem)+realSize-sizeof(int))) = *(static_castint*(pMem)) = signature; // 返回真正的内存区域 return static_castByte*(pMem) + sizeof(int); 其实上述代码是有一些瑕疵的： operator new 应当不断地调用new handler，上述代码中没有遵循这个惯例； 齐位要求（alignment）： 许多 computer architectures 体系结构下，不同的类型被要求放在对应的内存位置。比如 double 的起始地址应当是 8 的整数倍，int的起始地址应当是 4 的整数倍。上述代码可能会引起运行时硬件错误。 起始地址对齐。C++要求动态内存申请的起始地址对所有类型来说都是字节对齐的，new 和 malloc 都遵循这一点，然而我们返回的地址偏移了一个int。这将造成程序崩溃或执行速度变慢。到此为止你已经看到了，实现一个 operator new 很容易，但实现一个好的 operator new 却很难。 齐位和内存管理器有关。你可以浏览一下不同内存管理器来重新连接，到开放源码中去找（如 boost 程序库的 Pool）。 51.编写 new 和 delete 时固守常规 operator new 应该包含一个设法分配内存的无限循环，如果它不能满足一个内存请求，应该调用 new-handler，还应该处理零字节请求。class-specific（类专用）版本应该处理对比预期更大的区块的请求。 operator delete 如果收到一个空指针应该什么都不做。class-specific（类专用）版本应该处理比预期更大的区块。 如题，下面说明所谓 new 和 delete 的常规标准： 返回值必须正确：申请成功返回内存地址，申请失败就要调用 new-handling 函数。 具备重复申请内存的能力：在每次失败后调用 new-handling 函数。 只有当指向 new-handling 函数的指针是 null，operator new 才会抛出异常 申请大小为零时也应返回合法的指针。 示例：一个 non-member operator new 。 void * operator new(std::size_t size) throw(std::bad_alloc) if(size == 0) size = 1; while(true) // 尝试申请 void *p = malloc(size); // 申请成功,直接返回 if(p) return p; // 申请失败，获得new handler new_handler h = set_new_handler(0); set_new_handler(h); if(h) (*h)(); else throw bad_alloc(); 1.申请大小为0时，示例给出的解决方法是把大小改为1。虽然笨但是有效。 2.重复申请内存的能力即死循环 while(true) 。 3.调用 new-handling 函数的方法略微有些笨拙：设为null，利用返回值返回旧函数指针，再返回原样。 (因为没有办法直接取得 new-handling 指针，只能通过 set_new_handler 找出它) member operator new function 在继承时的问题： 自定义 new 函数会被 derived class 继承。但这个函数的需求往往只针对特定 class ，而非它的所有 derived class 。为防止不必要的麻烦，可以根据大小不同来判断： class Base public: static void* operator new(std::size_t size) throw(std::bad_alloc); ...;class Derived: public Base // 假设Derived未声明operator new ... ;Derived* p = new Derived; // 这里调用的是Base::operator new//为防止不必要的麻烦，可以根据大小不同来判断：void* Base::operator new(std::size_t size) throw(std::bad_alloc) if (size != sizeof(Base)) // 如果大小错误， return ::operator new(size); // 令标准的operator new起而处理。 ... // 否则在这里处理。 不用担心 size=0 的情况，编译器会依据 C++ “独立对象必须有非零大小”。(插入一个 char 等) 另外对于 array 内存分配的 class new，需要实现 operator new[ ] 。写它的时候只需要注意一点：分配一块 未加工内存 (raw memory) 。 你不能知道 array 里的元素对象有多大，也不能计算出个数。并且动态分配的 arrays 可能需要额外空间来存放元素个数。 至于 operator delete 相比于new，实现delete的规则要简单很多。唯一需要注意的是 C++ 保证了delete 一个 NULL总是安全的，你尊重该惯例即可。 non-member 版本: void operator delete(void *rawMem) throw() if(rawMem == 0) return; //面对空指针，do nothing # 不是空指针 ， 归还 rawmemory 所指内存 member delete 版本： 多加一个检查删除数量的动作：这是处理定制 class new 将大小有误的分配行为转交给::operator new执行。一旦出现这种情况转而调用对应的 ::operator delete 执行。 class Basepublic: static void* operator new(std::size_t size) throw(std::bad_alloc); static void operator delete(void* rawMemory,size_t size) throw(); ...;void Base::operator delete(void* rawMemory,size_t size) throw() if(rawMemory == 0) return ; if(size != sizeof(Base)) ::operator delete(rawMemory); return; #到这里，正常归还rawMemory所指内存 return; 1.注意上面的检查的是 rawMem 为空，size 是不会为空的。 2.其实 size 实参的值是通过调用者的类型来推导的（如果没有虚析构函数的话）： Base *p = new Derived; // 假设Base::~Base不是虚函数delete p; // 传入`delete(void *rawMem, std::size_t size)`的`size == sizeof(Base)`。 3.如果 Base::~Base() 声明为 virtual，则上述 size 就是正确的 sizeof(Derived)。 这也是为什么Item 7 指出析构函数一定要声明 virtual。 52.写了 placement new 就要写 placement delete 在编写一个 operator new 的 placement 版本时，确保同时编写 operator delete 的相应的 placement 版本。否则，你的程序可能会发生微妙的，断续的 memory leaks（内存泄漏）。 当你声明 new 和 delete 的 placement 版本时，确保不会无意中覆盖这些函数的常规版本。 阐述定义： placement new： 广义上的 ”placement new” 指的是拥有额外参数的 operator new。 狭义上通常是专指指定了位置的 new(std::size_t size, void *pmemory) throw()，用于 vector 申请 capacity 剩余的可用内存。 问题场景： Widget* pw = new Widget; 这个语句会调用两个函数： Widget 的 operator new ，Widget 的 默认构造函数 当内存申请成功，而接收内存的默认构造函数抛出异常时，需要及时取消分配恢复原样，否则就会内存泄漏。 分配的责任不在用户身上，而在 C++ 运行期系统上：对于一个正常的 operator new，系统会调用默认的 delete function。对于 user-defined operator new , 系统如果找不到对应 delete 就会跳过删除操作从而产生问题。 示例： class Widgetpublic: ... static void* operator new(size_t size,ostream logStream) throw(bad_alloc); /*static void* operator delete(void* pMemory size_t size) throw();*/ //默认delete，反面教材 void* operator delete(size_t size,ostream logStream) throw(); //placement new ... 但客户还可能直接调用 delete p，这时 C++ 运行时不会把一个普通指针解释为 ”placement delete”。 所以在 Widget 中不仅要声明 ”placement delete”，还要声明一个正常的 delete。 placement delete 只有在“伴随 placement new 调用而触发构造函数”出现异常时才会被寻找调用。 Widgetpublic: static void* operator new(std::size_t size, std::ostream log) throw(std::bad_alloc); static void operator delete(void *mem, std::ostream log); static void operator delete(void *mem) throw(); Widget() throw 1; ; 这样，无论是构造函数抛出异常，还是用户直接调用 delete p，内存都能正确地回收了。 覆盖问题： 在Item 33中提到，类中的名称会隐藏外部的名称，子类的名称会隐藏父类的名称。 所以当你声明一个 ”placement new ” 时： class Basepublic: static void* operator new(std::size_t size, std::ostream log) throw(std::bad_alloc);;Base *p = new Base; // Error!Base *p = new (std::cerr) Base; // OK 普通的 new 将会抛出异常，因为 ”placement new” 隐藏了外部的 ”normal new”。 同样道理，derived class 中的 operator new 会掩盖 global 版本和继承而得的 operator new 版本。 class Derived: public Basepublic: static void* operator new(std::size_t size) throw(std::bad_alloc);;Derived *p = new (std::clog) Derived; // Error!Derived *p = new Derived; // OK 这是因为子类中的 ”normal new” 隐藏了父类中的 ”placement new”，虽然它们的函数签名不同。 但 Item 33 中提到，按照 C++ 的名称隐藏规则会隐藏所有同名（name）的东西，和签名无关。 覆盖解决： 解决前观察 global 作用域的 operator new： void* operator new(std::size_t) throw(std::bad_alloc); // normal newvoid* operator new(std::size_t, void*) throw(); // placement newvoid* operator new(std::size_t, const std::nothrow_t) throw(); // 见 Item 49 非必要情况，请确保这些函数在你的 user-defined operator new 之外还可以正常使用。如果类内有一般性需求， 在创建自定义的 ”new” 时，也要声明这些签名的 ”new” 并调用全局的版本。 为了方便，我们可以为这些全局版本的调用声明一个父类 StandardNewDeleteForms： class StandardNewDeleteForms public: // normal new/delete static void* operator new(std::size_t size) throw(std::bad_alloc) return ::operator new(size); static void operator delete(void *pMemory) throw() ::operator delete(pMemory); // placement new/delete static void* operator new(std::size_t size, void *ptr) throw() return ::operator new(size, ptr); static void operator delete(void *pMemory, void *ptr) throw() return ::operator delete(pMemory, ptr); // nothrow new/delete static void* operator new(std::size_t size, const std::nothrow_t nt) throw() return ::operator new(size, nt); static void operator delete(void *pMemory, const std::nothrow_t) throw() ::operator delete(pMemory); ; 然后在用户类型 Widget 中 using StandardNewDeleteForms::newdelete 即可使得这些函数都可见： class Widget: public StandardNewDeleteForms // inherit std formspublic: using StandardNewDeleteForms::operator new; using StandardNewDeleteForms::operator delete; static void* operator new(std::size_t size, std::ostream log) throw(std::bad_alloc); // 自定义 placement new static void operator delete(void *pMemory, std::ostream logStream) throw(); // 对应的 placement delete; 第九章：Miscellany53.不要轻易忽视编译器的警告 严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取无任何警告的荣誉。 不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原来倚赖的警告信息有可能消失。 编译器的警告可能给出很重要的信息,例如: class Bpublic: virtual void f() const; ...;class D:public Bpublic: virtual void f(); ...; 由于 B 中的 f() 是 const 成员函数,而D中的f() 是非const,因此D::f()是对B::f() 的 override 而非重新声明,编译器通常会给出”warning: D:f() hides virtual B::f()“的警告,这个警告其实包含两层意思: D并没有重新声明virtual void f() const,因而它继承了B的virtual void f() const实现. 由于D声明了virtual void f(),它是对virtual void f() const的重写,由于名称遮掩,将不能通过D类型对象来调用virtual void f() const. 因此,会出现以下情况(见注释): B b;D d;B* pb=b;pb-f(); //调用的是B::f()pb=d;pb-f(); //调用的仍然是B::f() ! 不管怎么说，面对警告信息时，你一定要清楚的了解它的真实含义，然后才可以选择性的处理或者忽略。 不同编译器有不同警告标准,因而不能依赖编译器来指出错误. 警告信息天生和编译器相关，不同的编译器有不同的警告标准。所以，草率依赖编译器为你指出错误，并不可取。一些老旧的编译器面对同样的问题可能半句抱怨都没有。 54.让自己熟悉包括TR1在内的标准程序库详情看书 55.让自己熟悉boost详情看书"},{"title":"高数和408的一些理解","path":"/wiki/NOTE/高数和408的一些理解.html","content":"树 性质 所有结点度数之和+1(根节点) n(总结点数) 初始归并段要增加几个0 ①nnk+n0 ②nknk+1 二叉树：n0n2+1 叶节点数 度为2的结点数+1 ①nn0+n1+n2 ②nn1+2n2+1 ①所有种类结点的和n总结点数 ②结点数 x 度数 的和 +1(根节点) n总结点数 (小括号)：默认向上取整 二叉排序树(查找树) BST **查找：**Olog2(n) 次数不超过深度。 左根右 目的不是排序，而是提高插入、删除、查找的速度。 插入： 插入后从上往下，最后的位置一定是叶节点。从根开始比较，小就往左，大就往右，最后一定是叶子结点。 删除： 叶节点不动； 有一个左右子树，则子树替换被删结点。 有两个子树，用直接中序后继(前驱)替换。 平衡二叉树 AVL 定义：平衡因子1。 **查找：**Olog2(n) 次数不超过深度。 旋转：删除看个头，插入向上找 插入： ①和BST一样。 ②若插入后破坏平衡，则向上找到最近的最小不平衡树(祖先)。 根据不平衡祖先和插入节点的相对位置进行（LL、RR、LR、RL）旋转。 删除： ①和BST一样。 ②若删除后破坏平衡，则向上找到最近的最小不平衡树(祖先)Z。 根据Z的个头最高的孩子X，与X个头最高的孩子Y，X和Y的相对位置进行（LL、RR、LR、RL）旋转。 最多次数：满二叉树 最少次数：N11 , N22, NnNn-2+Nn-1+1 B树 B-tree **定义：**平衡因子为0，外部节点为null，叶子节点指内部节点最后一层。(终端结点同叶子结点) BST、AVL都是内存里小数据量检索。B树更适合大量数据（涉及硬盘）的检索。结点是硬盘，节点内部从硬盘读入内存后看到。 m阶 根的关键字：[1,m-1] 非根关键字：[(m2)-1,m-1] 从阶数一半开始 子树是关键字个数+1。 查找：循环查找：①（磁盘里操作）比较后找到左右子树的结点，从磁盘读入内存。②（内存里操作）结点内部找目标关键字（折半或顺序） 插入： ①定位：根据BST查找算法，找到外部节点的NULL的位置。 （书里的原话是，查找到叶子节点NULL后，再定位到父结点） ②插入：插入后检查结点是否在[(m2)-1,m-1]。若个数大于m-1，进行分裂。 ③分裂：根据(m2)的位置分成左中右三部分。 中间位置的关键字插入父节点（左右子树分别为左部分右部分结点）。 左部分结点保留原结点。 右部分节点作为父结点的新右子树。 (m2)是上取整。 构建B树时，要增加子树只能通过分裂。 分裂后父节点必增加一个关键字。 增加后超越上限（m2），则继续分裂。 删除： 根据被删元素是—— 非终端结点：用前驱或后继替代。 删除非叶结点元素最终都转换成删除叶结点元素。（用叶节点给被删父节点填坑） 终端结点：根据被删关键字结点的个数—— (m2)-1：删完不低于下限，直接删。 (m2)-1:删完低于下限。 从不满足关键字个数的结点视角看： 那个孤零零的结点的视角： ①有兄弟够借：父下来，兄上去。 被删结点相邻的兄弟关键字个数(m2)-1，以右兄弟为例，让被删结点后继即父结点关键字加入自己的节点，而后继的后继填补父结点关键字原位置。 左右兄弟都可以借。 后继 即双亲节点的关键字，后继的后继 即右兄弟最左边的关键字。 左兄弟则是前驱和前驱的前驱。 (原因是要保证有序的性质) ②左右兄弟都不够借：父下来，同合并 此时左右兄弟的关键字都(m2)-1或无， ，合并为一个子结点。 左右兄弟都可以合并。（左前驱右后继）合并时要带上子树。带子树的位置你观察关键字顺序就能知道在哪。 合并后的双亲节点一定少了一个关键字，成为两个合并结点的中间关键字了。 若双亲节点合并后，减少一个关键字导致(m2)-1，则继续循环这一步（判断兄弟够借或不够借） **高度：**logm(n+1) hlog(m2)((n+1)2)+1 B+树 适用于数据库检索。 两层：分为目录层（分支）和数据层（叶子） 关键字重复：非叶节点只负责索引（即指针），没有数据地址。所以查找就像坐电梯直达目标叶子节点。 两个头指针：根节点一个指针，叶子节点一个指针。 关键字和子树个数相等：一个关键字对应一个子树的最大元素。故关键字个数是m2, 比B树+1。 B+随机+顺序都支持。B仅支持随机 小根堆 **定义：**完全二叉树（叶子必须从左到右连续排列）。任一节点其左右孩子。 节点i的左孩子：2i 右孩子：2i+1 父节点:(i2) 下取整 非叶子结点：1~(n2) **输出：**输出堆顶元素后，将堆底元素送入堆顶，再慢慢下坠。 **删除：**同输出。 **插入：**先放堆底，再逐步上升。 调整：普通数组变成根堆：从下往上看。 将n除以二 向下取余，找到最后一个非叶节点。开始从后往前遍历所有非叶结点，不符合大小关系的就和孩子交换。 空间几何旋转面：[平面曲线]绕[平面直线]，绕x轴则x不动，另外一个变平方和。柱面：定直线为母线，定曲线为准线 平面：点+截距截距式点+法向量点法式 直线：点+方向向量对称式 参数方程 曲面积分已知曲面的法向量用方向余弦表示是n (cosα,cosβ,cosγ)。其中α是n与x轴(yoz面)的角度，β是与y轴(xoz面)，γ是与z轴(xoy面)。 而法向量用代数表示是n(-Zx,-Zy,1) (当曲面为zz(x,y)时) 第一类曲面积分，求的是曲面表面的面积，也可以看作是高度为1的曲面薄片的质量。方法是将三个方向的曲面面积投影到一个面上。 (利用梯度得到法向量，法向量与z轴的角度γ即xoz 和 yoz平面与投影面xoy的角度γ) 一个平面dS和另一个投影平面(如xoy)的夹角，即该平面切平面与对应坐标面的夹角，即切平面法向量与对应坐标轴的夹角。 侧边斜边 cosγ 法向量nz轴，即dSdxdy cosγ。 而cosγ cosn , z (n·z)|n|·|z| $$d\\sigma dS \\cdot \\cos\\langle \\vec{n}, z轴 \\rangle dS\\cdot\\frac{\\vec{n}\\cdot z}{|\\vec{n}|\\cdot|{z轴}|} dS\\cdot\\frac{(-Z_y,-Z_y,1)\\cdot(0,0,1)}{\\sqrt{(-Z_x)^2+(-Z_y)^2+(1)^2}\\cdot\\sqrt{0+0+1^2}}$$ 故dS 1cosγ dxdy 。$$dxdy dS\\cdot\\cos\\gamma \\frac{1}{\\cos\\gamma}dxdy dS S\\iint\\limits_{D} \\sqrt{Z_x^2+Z_y^2+1} , dxdy$$ 第二类曲面积分，求的是单位时间截面通过的流体质量。 设流体密度为1，v是速度 s是面积，则 mρvts ，(vt是高，s是截面面积，故vts V即体积 ,mρV)方法同样是投影转换坐标，和第一类曲面积分类似，dydz dScosα (此时dSdxdy 1cosγ) dxdy(cosαcosγ) ，此时由曲面法向量的代数表示得cosαcosγ -Zx。故dydz -Zx dxdy。同理dzdx -Zy dxdy。 备注：解决第二类曲面还可以利用高斯公式和斯托克斯公式。高斯要求曲面光滑+空间封闭(P对x偏导，Q对y偏导，R对z偏导, 积分微元统一为dV)，斯托克斯则是将闭合曲线积分问题转换为以该曲线为边界的第二类曲面积分问题(公式+转换投影+二重积分)。 多播ip 多播数据报，目的地址是 Ipv4 D 类地址，1110 开头，即 224 到 239。 分两种：本局域网的硬件多播 + 互联网的多播。 局域网硬件多播中，mac 地址 只有 23 位能用作多播地址， 所以 ip 地址映射到 mac 时，只有后 23 位能保留。 这意味着映射不是一对一的。 PPP咱们目前用的手机流量，就是数据链路层的点对点 ppp 协议。提到 ppp，就想起两个模块：link control protocols 和 net control protocol 。一个网络层协议对应一个 NCP。 ppp 首尾定界符：0X7Eppp 面向字节，不需要序号确认，点对点不需要 csma 协议，所以没有最短帧长限制（2 匸 v），即 0-1500B 链接过程：链路静止➡️链路建立➡️Lcp 协商成功进入鉴别状态➡️鉴别成功进入网络层协议状态，配置 Ncp➡️链路打开状态（此时可以通信了） CSMA（介质访问）csmaca: 信道预约（监听）隐蔽站：DIFS+RTS+［SIFS+CTS+（SIFS+数据帧+SIFS+ACK）］ csmacd:边发边听。二进制退避算法：0 到 2 τr。 （ r 是 2 的 k 次方-1k 为重传次数。） k 最高为 10，到第 16 次不成功则放弃发送。 最短帧长：2 τ v（10Base 是 64B，51.2 微秒） 2 τv RTT x V （往返时延 x 数据传播速率） 往返时延而非单程时延的原因：冲突信号需要从冲突点返回发送方 A 才能被检测到(边打边听)。 16 是个神奇数字。rip16 也是不可达 争用期：发送 64B(512b)的时间。 （端到端往返时间2τ，又称为碰撞窗口） 10Mbits 以太网是 51.2 微秒 的发送时间。 注意是bit位，不是按字节B。 100Mbit 是 5.12 微秒。同时会减少网段长度。 神奇的 fancy 公式：2 的 n 次方 -1。 它是：1.csmacd 协议回避算法的最大退避时间。（第 n 次退避）2.连续 ARQ 协议 gbn 的发送窗口上限。（n 比特对帧编号）3.满二叉树的结点数（高度为 n） TCP UDP IP MAC 首部长度TCP 首部长度 20～60B。(4位数据偏移字段 即首部长度，单位 4B，最大 15x4) UDP 首部长度 8B (2 2 2 2) —————以太网 MAC 帧：首部长度：18B（不算前导码） 8 B 前导码（7 B 前同步码+1 帧开始定界符） 6 目的地址6 源地址2 交付协议类型4FCS 检验码 数据：46-1500，（46 时为帧最小长度 46+1864B） ————ip 数据报首部长度 20B(可变长) 三单位 4B 1B 8B总长度 16 位 10BASE和传输介质T 是双绞线(Twisted)，F 是光纤(fiber)，数字是同轴电缆(cable) 双绞线： 局域网+传统电话网，绞合减少相邻导线干扰，加上屏蔽层 适用于模拟传输（放大器）+数字传输(中继器) 光纤： 光脉冲。 全反射特性。 长距离：单模光纤。直径小到一个波长，光会始终向前不反射。（用于半导体激光） 短距离：多模光纤。光源为发光二极管。 同轴电缆： 强屏蔽性：内导体（铜芯）+屏蔽层+塑料外层 信道平均(实际)数据传输速率 信道利用率×信道带宽(最大数据传输速率)”, 发送周期内发送的数据量发送周期 BGP OSPF IGMPBGP：分为内部BGP协议(内部)和外部BGP协议(自治系统之间)，iBGP内部会话，eBGP外部会话打开、更新、保活、通知(open,update,keepalive,notification) OSPF：1.问候分组(hello)2.(数据库)描述分组3.(链路)状态分组：请求、更新、确认 IGMP：传递多播信息协议字段值为2，D类IP地址（前缀为1110，即224~239），局域网硬件多播时取后23位，还能互联网多播 边界对齐边界对齐有两个要求：1.整体struct是最大变量对齐值整数倍；2.每个成员要按类型大小对齐(char1 short2 int 4)，或者说其地址对类型大小取余0 拥塞窗口我的意思是，拥塞控制窗口收到一个确认，才增加一个MSS。比如慢开始为1，不超过拥塞控制初始阈值时，第一轮RTT发送1个MSS，发送方收到一个确认则拥塞窗口cwnd增长为2。第二轮RTT发送2个MSS，期间收到两个确认序号，2+2 4。第三轮RTT发送4个MSS，期间收到四个确认序号，4+48。 这个期间，拥塞窗口cwnd是一个一个增长的，例如第三轮是4+1+1+1+1 8，收到一个接收方确认ack+1，而不是直接从cwnd4收到一个累计确认直接到8。 例子：cwnd 1，ssthresh 16。发送方发送序号为 1-1000 的数据段（1 个 MSS）。接收方收到后，回复 ACK 1001。这个ACK 1001就是一个累计确认，它确认了1-1000这段数据。发送方收到ACK 1001后，知道1-1000已被确认。此时，“已发送但未确认” 的窗口为空。根据慢开始算法，因为有一个 MSS 的数据被确认，所以cwnd增加 1，变为 2。发送方现在可以发送 2 个 MSS 的数据，即 1001-2000 和 2001-3000。接收方收到这两个数据段后，回复 ACK 3001。这个ACK 3001也是一个累计确认，它确认了1-3000这段数据（包括了之前的1-1000）。发送方收到ACK 3001后，知道又有两个MSS 的数据（1001-2000 和 2001-3000）被确认了。因此，cwnd会连续增加两次，从2变为4。 逻辑地址映射到物理地址计算机为提升效率或保障安全，将“地址转换”作为“前置准备步骤”，与“最终是否真的读写数据”解耦。（故地址转换过程与cache无关。） 地址转换过程:转换一个主存逻辑地址，根据硬件分成虚拟页号和页内偏移量offset，根据虚拟页号找到页表对应的页表项，先看有效位是否为1。 如果为1直接把页表项里的物理页号和逻辑地址中的offset组合成为物理地址。 如果为0，不看物理页号（没有意义），启动缺页中断程序，查页表项的外存物理地址，通过置换算法分配物理页框，把外存物理页调入内存并修改页表项的有效位、访问位等。处理程序完成之后，重新执行发生缺页的指令，得到访问页的物理地址。 —————— 需要转换地址但不需要访问的情况（不需要修改cache） CPU指令预取（最常见）：提前转地址，但指令可能被“丢弃” 内存保护与权限检查：转地址是为了“验证合法性”，而非“读写数据” 如果转换之后需要读写，则更新cache内容。 ——————注:由于容量相差较大——主存与外存的信息传输单位是 “页”page 或 “段”主存与cache的信息传输单位是 “块” block。 实际上:cache 块 cache 行。硬盘 块 cluster 簇。 向量组向量组是解决线性方程组的工具。向量组的线性关系与线性方程组的对应如下: 设有两个向量组A和B。A是mn矩阵，B是mt矩阵。X即线性表示的系数，是n*t矩阵。（即系数矩阵，即[k1k2……kn]。每个k对应B中一个列向量由A线性表示的系数） 1.向量组间的线性关系，对应非齐次线性方程AXB。 1️⃣AXB有解，A可通过系数矩阵X线性表示B2️⃣如果无解，即B中至少有一个向量无法由A的向量线性组合得到 判断依据:有没有解通过看A矩阵与AB增广矩阵的秩是否相等。 注:1.如果两个向量组等价，即相互线性表示，这意味着三秩相等。2.B可退化成单个向量b，即向量组A是否可以线性表示b的问题。 2.向量组A自身内部的线性关系，对应齐次线性方程组。即AX0。1️⃣如果有唯一零解，就是向量组a线性无关，只能让k1k2……kn0。2️⃣如果无穷多解就是线性相关。 上述对应关系的核心是“秩”，而初等行变换是求矩阵秩的关键工具。因此两者是分析线性关系与方程组解的分析工具。 关键路径、最短路径(dijkstra,floyd)关键路径： 拓扑排序+逆拓扑 ete→lteetv→ltv dijkstra: 1.每次从未标记的节点中,选择距离出发点最近的节点，收录到最优路径集合S中2.计算刚加入路径集合的节点A的所有邻近节点B的距离 (不包含标记的节点)若(节点A的距离+节点A到节点B的边长) 节点B的距离，就更新节点B的距离和前面点。 开始默认无穷，罗列顶点，分为第一轮第二轮第三轮，每一轮集合S增加一个顶点，该顶点不再延伸(后面几轮空白)。 floyd n行邻接矩阵表示带权有向图。沿对角线n轮十字架，每轮对角线a[i] [i]不变(否则自己指向自己了)，对角线之外的元素值与十字架行列之和比较，小则替换。 Floyd可以求带负权边但不带负环图的多源最短路径 曼彻斯特编码归零内部不跳变。 归零外部不跳变，两个固定样子；非归外部零跳变，用跳变表示 01 曼彻斯特内部跳变，作为时钟信号。 曼彻斯特外部不跳变，两个固定样子；差分曼彻斯特外部用跳变表示 01。 DHCP、ICMP、ARPDHCP发现 提供 请求 确认报文 发现：源0 目255 提供：源服务器地址，目255 请求：源0 目255 确认：源服务器地址，目255 ICMP:(网际报文控制协议) 用于报告差错和异常情况。 分为差错报告报文和询问报文。差错报告报文：5个类型：终点不可达、源点抑制、时间超过、参数问题、改变路由（重定向）4个不发送:ICMP报文自己、后续分片、多播地址、特殊地址的不发。 询问报文：回送请求(和回答)时间戳请求(和回答)地址掩码请求(和回答)路由器询问(和报告) ARP（地址解析协议） ARP请求分组 （广播） ARP响应分组（单播） ARP看到了IP地址，所以说网络层 NAT看到了端口，所以是传输层 MAC无法跨网络：主机想把IP分组发送到另一个网络，要用ARP找到网关（相邻路由器）的硬件MAC地址。而且路由器不会转发广播帧（ARP查询帧）。网关会把自己的MAC回复给主机。后续的传播任务交给路由器就好了。 中途源地址和目的地址会改变。 磁道（柱面(磁道),磁头(盘面),扇区 ） 一个扇区的平均访问时间：寻道时间+旋转延迟时间+传输时间 Tsmxn+s m每跨越一个磁道耗时 s启动磁臂时间 Tr r x12 r一秒几转 TtbrN b读写字节数，N一个磁道的字节 IEEE浮点数 阶码全0 尾数非0尾数非零、阶码全0时属于「非规格化数」， 隐藏位为 0 且指数为-126而非 0-127。 可以理解成“隐藏位的1 乘到阶码上了”。 隐藏位右移(除二)走，阶码+1位（乘二） 目的是让最大的非规格化数 0.f×2^-126 （尾数23位全1），恰好能和最小规格化数 1.0×2^-126 无缝衔接，不会出现数值断层。 0f1 阶码全1，尾数为0 正无穷大 阶码全1，尾数非0 无定义NaN 阶码全0，尾数全0 就是0（正负零） 阶码全0，尾数非0 非规格化数 规格化浮点数运算时，需要规格化：确保尾数的最高位刚好在小数点之前。 左规：运算结果尾数的最高数位不是有效位，即0.000……的形式，进行左规。 尾数左移一位，阶码-1 （可能多次） 右规：运算结果尾数的有效位进到小数点前面时，右规。即1.xxx的形式，相加时最高进一位，故右规只需一次。 尾数右移一位，阶码+1（可能溢出） 运算： 对阶 ①小阶向大阶看齐 ②移位：左减右加（注意负数是算术移位，右移同符号位） 尾数加减 隐藏位要还原到尾数 尾数规格化 舍入 ①0舍1入: 若舍弃部分的最高位是 0 → 直接舍去这部分，保留的最低位不变（“0 舍”）； 若舍弃部分的最高位是 1 → 舍去这部分的同时，给保留的最低位加 1（“1 入”）； ②恒置1 溢出判断 10,xxx 下溢出（按机器零处理） 01,xxx 上溢出 kmpnext数组：当前位置不匹配时的最长公共前缀。 如果数组从1开始则需要整体+1,如果从0开始不需要。 模式串与主串匹配的公共前缀，显然不包括不匹配位置。所以是从当前位置往前看。 不匹配时，让数组和自己位置的next数组元素的模式串位置比较。 下面这个例子就是下标从1开始 要求那个next数组（有些叫next-val数组）： 1.必须先求模式串S 每一个字符前面的那个字符串的最大公共前后缀长度，将这一系列长度存成一个数组，求出来的每个长度其实就是和模式串每一个对应位置上做比较的下标 。 例如：模式串是 ABACABC 的最长公共前后缀长度数组为： 我们将最长公共前后缀长度记作LCPSF，现在从模式串第一个字符A开始，A的前面字符串为null，所以A之前的子串的LCPSF是0；来到B，B的前面字符串是A，A是单独的字符不存在公共前后缀，所以长度也是0；来到A，A前面的子串是AB，LCPSF为0；来到C，C前面的子串是ABA，LCPSF为1；来到A，A前面的子串是ABAC，LCPSF为0；来到B，B之前子串为ABACA，LCPSF为1；来到C，C前面子串为ABACAB，LCPSF为2；到此这个最长公共前后缀数组就出来了【0,0,0,1,0,1,2】将这个数组从第二个值开始每个值加1【0,1,1,2,1,2,3】就是将要和子串对应位置比较的下标 2.求得模式串最长公共前后缀的数组T【n】后，把模式串每个位置上的字符与这个数组存的下标对应字符作比较： 上面求出了下标数组【0,1,1,2,1,2,3】现在来和模式串ABACABC每个位置作比较求最终next-val数组： next-val数组第一个数直接为0。 next-val第二数：模式串第二个字符为B，对应的下标数组第二个数是1，那就是将模式串的第1个字符和B相比较，A!B,所以直接将下标数组第二个数1作为next-val数组第二个数的值 第三个数：模式串第三个字符为A，对应下标数组第三个数为1，取其作为下标，找到模式串第1个字符为A，AA，那取next-val的第一个数做为next-val第三个数的值，也就是0 。。。。。以此类推，模式串每一个位置的字符和对应下标位置的数相等就取next-val中对应的数填到next-val中当前位置，不等就直接取当前下标数组的值填到next-val当前位置中 注意，这里所有序号，包括模式串和下标数组的数，第一个位置都是1，而不是常用的0开始 序号 1 2 3 4 5 6 7 模式串 A B A C A B C 下标数组 0 1 1 2 1 2 3 next-val 0 1 0 2 0 1 3 序号： 1 2 3 4 5 6 7 模式串 A B A C A B C 下标数组 0 1 1 2 1 2 3 next-val 0 1 0 2 0 1 3 中缀转前后缀转前缀：符号移动到自己范围左括号的左边 转后缀：符号移动到自己范围右括号的右边 并查集红黑树并查集 每个子集合是一棵树，有一个根节点和一堆元素（叶子）。 元素下标为元素名。 元素值： 正值表示自己所属集合根结点的下标。 负值表示节点总数，自己是一个子集合的根 find(S,x):返回集合S中单元素x所在集合的根节点下标值。 O(n) 优化后→O(log2n) →压缩路径→O(a(n)) Initial(S)：把S的每个元素初始化为只有一个单元素的集合 O(n^2^) 优化后→O(nlog2n) →压缩路径→O(a(n)) Union(S,root1,root2):S的两个子集合root2加入root1 S的子集合root2的元素值改为root1的下标。 原本root2元素值是负值，即作为子集合根，所在集合的元素个数。 红黑树 性质： 1.根叶黑 2.黑路同 3.不红红（不相邻） 结论： 1.黑高为h的红黑树至少有2^h^-1个内部结点。 有n个内部结点的红黑树高度 h 2log2(n+1) 2.根到叶节点最长路径不大于最短路径2倍 3.新节点：根染黑 非根染红 各种性能指标 进程调度单位： cpu利用率，系统吞吐量，周转时间，等待时间，响应时间 笔记本 计算机网络： 速率、带宽、吞吐量、时延（发送传播处理排队）、时延带宽积、往返时延、信道利用率 流水线吞吐率、流水线加速比 磁盘： 一个扇区的平均访问：寻道时间+旋转延迟时间+数据传输时间 (柱面(磁道)、盘面（磁头）、扇面) 计组性能指标： CPI：执行一条指令的时钟周期数 CPU执行时间、吞吐量、响应时间、MIPS、FLOPS 计组第一章，笔记本上也有。 数据结构： 时间复杂度、 ASL(访问成功失败) ,散列表 排序算法稳定性 CRC校验码、海明码、二进制除法ip 数据报首部检验和udp 校验和 码分复用"}]