[{"title":"这是文章标题","path":"/2026/01/26/2021/","content":"文章正文"},{"title":"权限、用户、角色、配置文件","path":"/wiki/mysql/权限、用户、角色、配置文件.html","content":"用户管理用户信息在哪里默认数据库有四个： information_schema mysql performance_schema sys 其中 “mysql” 数据库有一个表名为user，存储着用户信息。 通常默认有四个用户： root ,mysql.infoschema,mysql.session,mysql.sys 。 ubuntu 或 debian 用户还会有个maint用户。 debian-sys-maint中Debian系统对MySQL维护用的，可以理解为通过系统的某个“非常规”程序对Mysql进行备份恢复等行为时，改程序所使用的用来登录Mysql的账户。 具体作用是重启及运行mysql服务，不过有一个安全问题：该用户的权限和ROOT是一样的，并且密码可以在etc某个文件中找到，这需要对账户进行一些限制。 root 的权限最高，顾名思义为“根”，拥有最高权限，创建其他用户，它不能没有。 user 的联合主键用户信息里两个列很关键：host 和 user。 host : 主机，用来区分用户的连接段。 user : 用户名，区分用户 user 表的主键有两个：host和user，即联合主键。 所以不同连接段允许有重名用户出现，就像不同作用域能够有重名变量一样。 创建、修改、删除创建用户指令： CREATE USER 用户名 [@主机名称] [IDENTIFIED BY 密码] #[]为可选 tips： 该语句可以同时创建多个用户。 用户名参数由用户和主机名构成。 需要有CREATE权限，新账户什么权限都没有。 修改 UPDATE mysql.user set user = wang5 where user = li4 [and host = xxx]flush privileges;# 刷新权限，否则登陆时仍然是原本的用户信息 修改用户就是直接操作 user 表。 修改完需要fs; 删除 两个方法：DROP 和 DELETE (user 表里删)。 DROP DROP USER user,[user].... #user即用户名参数，可包含 hostDROP USER li4; # 默认删除host为%的用户DROP USER li4@localhost; DELETE DELETE FROM mysql.user WHERE Host=hostname AND User = username;#必须有 host ，联合主键的两个字段，才能唯一确定一条记录。FLUSH PRIVILEGES; #立即生效。 DELETE 删除会有系统信息残留。DROP 指令能同时删去 mysql.user 表和 mysql.db 表内容。 设置当前用户密码1. 使用ALTER USER命令来修改当前用户密码 ALTER USER USER() IDENTIFIED BY new_password; 2. 使用SET语句来修改当前用户密码 SET PASSWORD=new_password; 修改其他用户密码1. 使用ALTER语句来修改普通用户的密码 ALTER USER user [IDENTIFIED BY 新密码] [,user[IDENTIFIED BY 新密码]]…; 2. 使用SET命令来修改普通用户的密码 SET PASSWORD FOR username@hostname=new_password; 密码过期关键词 EXPIRE 你可以通过ALTER和CREATE 时 手动设置用户密码过期，这样用户可以登入数据库，但无法查询。除非重新设置密码。 你也可以修改系统全局变量 Default password lifetime 。改变量默认为0，即不过期。设置为N代表密码生存期，N天后密码必须修改，否则将自动过期。 密码重用关键词 INTERVAL 、REUSE 分两类：时间和更改数量 时间（周期）：修改后密码不能用最近N天时间使用过的密码相同。 更改数量 ：修改后密码与最近N个密码不能相同。 系统变量：password_history , password_reuse_interval 权限管理show privileges; #查看权限 CREATE和DROP权限，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 SELECT、INSERT、UPDATE和DELETE权限允许在一个数据库现有的表上实施操作。 SELECT权限只有在它们真正从一个表中检索行时才被用到。 INDEX权限允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。 CREATE ROUTINE权限用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用来执行保存的程序。 GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。 FILE权限使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。 授予权限GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’]; 该权限如果发现没有该用户，则会直接新建一个用户。 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost; 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限 GRANT ALL PRIVILEGES ON *.* TO joe@% IDENTIFIED BY 123; 授予权限的原则 权限控制主要是出于安全因素，因此需要遵循以下几个经验原则： 1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 2、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。 3、为每个用户设置满足密码复杂度的密码。 4、定期清理不需要的用户，回收权限或者删除用户。 查看权限 查看当前用户权限 SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER(); 查看某用户的全局权限 SHOW GRANTS FOR user@主机地址; 收回权限注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。 收回权限命令 REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址; 举例 #收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@%; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost; 注意：须用户重新登录后才能生效 权限表user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。 这些字段可分为四类： 范围列： host : 表示连接类型 % 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 机器名 通过制定网络中的机器名进行的TCP方式的连接 ::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1 localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。 user : 表示用户名，同一用户通过不同方式链接的权限是不一样的。 password ：mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字 段。 权限列：是否拥有一些特定权限 安全列 ：加密，表示用户，验证用户身份。 资源控制列：限制用户使用的资源。共4个字段。 ①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。 查看字段： DESC mysql.user; 查看用户, 以列的方式显示数据： SELECT * FROM mysql.user \\G; 查询特定字段： SELECT host,user,authentication_string,select_priv,insert_priv,drop_priv FROM mysql.user; db表 用户列 db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。 权限列 Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。 结构查看： DESCRIBE mysql.db; tables_priv 和 column_priv 表 tables_priv 表：对表设置操作权限 columns_priv 表 ：对表的某一列设置权限 。 procs_priv 表procs_priv 表可以对存储过程和存储函数设置操作权限 上面几个表都在 database → mysql 里，想看自己 DESC 去。 角色角色的创建、删除和权限操作创建角色 CREATE ROLE role_name[@host_name] [,role_name[@host_name]]... 角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。 给角色赋予权限 GRANT privileges ON table_name TO role_name[@host_name]; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称 SHOW PRIVILEGES\\G 查看角色的权限 SHOW GRANTS FOR role_name; 只要你创建了一个角色，系统就会自动给你一个“USAGE”权限，意思是连接登录数据库的权限。 回收角色的权限 REVOKE privileges ON tablename FROM rolename; 删除角色 DROP ROLE role [,role2]... 注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。 角色和用户给用户赋予角色 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。 GRANT role [,role2,...] TO user [,user2,...]; 查询当前已激活的角色 SELECT CURRENT_ROLE(); 激活角色 方式1：使用set default role 命令激活角色 SET DEFAULT ROLE ALL TO kangshifu@localhost; 方式2：将activate_all_roles_on_login设置为ON SET GLOBAL activate_all_roles_on_login=ON; 这条 SQL 语句的意思是，对所有角色永久激活。 撤销用户的角色 REVOKE role FROM user; 设置强制角色(mandatory role) 方式1：服务启动前设置 [mysqld] mandatory_roles=role1,role2@localhost,r3@%.atguigu.com 方式2：运行时设置 SET PERSIST mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后仍然有效SET GLOBAL mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后失效 配置文件**文件里会定义许多组(用 [ ] 括起来)，组下边可以定义启动选项。**通常称组为标签。 [server]#具体启动选项option1 #不需要选项值：True / False 类型option2 = value2 #需要选项值 ： 键值对 类型[mysqld]...[mysqld_safe]...[client]... 配置文件中不同选项组是给不同的启动命令使用的。 有两个选项组比较特别： [server]组的启动选项作用于所有服务器程序 [client]组的启动选项作用于所有客户端程序。 像mysql这个启动命令，就会调用 [mysql] 和 [client] 两个组 tips： [mysql-‘版本号’]：只适用于特定版本的专用选项组 两个组里出现重复配置项，以最后一个为准。 一个选项既出现在命令行，又出现在配置文件里，以命令行为准。 如 defaults-extra-file 和 defaults-file 本身就是为了指定配置文件路径的。"},{"title":"存储过程函数","path":"/wiki/mysql/存储过程函数.html","content":"[Stored Procedure Stored Function] [TOC] 存储过程定义一组预先经过编译的SQL语句： 执行过程：存储过程预先存储在 MySQL 服务器上。执行时，客户端向服务器端发出调用命令，服务器端会将这一系列 Stored SQL 语句全部执行。 语法分析：创建： CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) [characteristics ...] BEGIN存储过程体END 分类： 没有参数（无参数无返回） 仅仅带 IN 类型（有参数无返回） 仅仅带 OUT 类型（无参数有返回） 既带 IN 又带 OUT（有参数有返回） 带 INOUT（有参数有返回） 注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。 参数意义 IN ：当前参数为输入参数，也就是表示入参； 读取参数值。 默认为 IN ，表示输入参数。 OUT ：当前参数为输出参数，也就是表示出参； 执行完成后，调用客户端可以读取参数返回值。 INOUT ：当前参数既可以为输入参数，也可以为输出参数。 形参类型：可以是 MySQL数据库中的任意类型。 约束条件：characteristics 创建存储过程时指定的约束条件 LANGUAGE SQL | [NOT] DETERMINISTIC | CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA | SQL SECURITY DEFINER | INVOKER | COMMENT string LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。 [NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。 1.DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同输入得到相同输出。 2.NOT DETERMINISTIC表示结果是不确定 的，相同输入可能得到不同输出。 (如果没有指定任意一个值，默认为NOT DETERMINISTIC) { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使用SQL语句的限制。 1.CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句； 2.NO SQL表示当前存储过程的子程序中不包含任何SQL语句； 3.READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； 4.MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 (默认情况下，系统会指定为CONTAINS SQL) SQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。 1.DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程； 2.INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 (如果没有设置相关的值，则MySQL默认指定值为DEFINER) COMMENT string ：注释信息，用来描述存储过程 省略：如果函数体里仅仅一条SQL 语句，则可以省略 BEGIN 和 END 结束标记：DELIMITER DELIMITER $ # look at this!CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...] BEGINsql语句1; #为了避免和函数体里的分号混淆sql语句2; END $ # Wowwwww! 避免使用反斜杠（\\）字符 ：因为反斜线是MySQL的转义字符。 调用 存储过程必须使用CALL语句调用，并且存储过程和数据库相关， 执行其他数据库中的存储过程，需要指定数据库名称，例如 CALL dbname.procname。 CALL 存储过程名(实参列表) IN 场景 CALL sp1(值); OUT 场景 SET @name;CALL sp1(@name);SELECT @name; 注意：OUT 输出参数，还要配合 SELECT [求得的字段] INTO @变量 FROM…… 来给参数变量赋值， 同时在调用时给 OUT 参数 赋值。 INOUT 场景 SET @name=值;CALL sp1(@name);SELECT @name; 示例： 创建调用过程 DELIMITER // CREATE PROCEDURE `add_num`(IN n INT) BEGIN #定义+赋值DECLARE i INT; DECLARE sum INT;SET i = 1; SET sum = 0; #进入循环WHILE i = n DO SET sum = sum + i; SET i = i +1; END WHILE; #产出结果SELECT sum;END //DELIMITER ;#第2个存储过程CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)... CALL调用过程 CALL CountProc (101, @num);CALL add_num(50); 查看发挥结果 SELECT @num; 如果使用了DBMS： Navicat ，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号， 不需要再进行 DELIMITER 的操作。 调试SQL没有IDE，你只能通过SELECT一个一个实验排查。 效果比较好处： 简化操作，提高了sql语句的重用性，减少了开发程序员的压力 减少操作过程中的失误，提高效率 减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性 和视图、函数的对比： 它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。 和视图的不同 视图是虚拟表 ，通常不对底层数据表直接操作， 存储过程是程序化的 SQL，可以直接操作底层数据表,相比于面向集合的操作方式，能够实现一些更复杂的数据处理。 和函数的不同 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于 函数，存储过程是 没有返回值 的。 存储函数应用语法分析：创建： CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回值类型 [characteristics ...] BEGIN函数体 #函数体中肯定有 RETURN 语句 END 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数RETURNS type 语句表示函数返回数据的类型； RETURNS子句只能对FUNCTION做指定,对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。 characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。 函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。 调用 在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。 换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。 区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。 SELECT 函数名(实参列表) 示例 创建 CREATE FUNCTION email_by_name()RETURNS VARCHAR(25) DETERMINISTIC CONTAINS SQL BEGINRETURN (SELECT email FROM employees WHERE last_name = Abel);END // DELIMITER ; DELIMITER // CREATE FUNCTION count_by_id(dept_id INT) RETURNS INT LANGUAGE SQL NOT DETERMINISTIC READS SQL DATA SQL SECURITY DEFINER COMMENT 查询部门平均工资 BEGINRETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id); END // DELIMITER ; 调用 SELECT email_by_name()SET @dept_id = 50; SELECT count_by_id(@dept_id); 注意：若在创建存储函数中报错 you might want to use the less safe log_bin_trust_function_creators variable 有两种处理方法： 方式1：加上必要的函数特性 [NOT] DETERMINISTIC”和“CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA 方式2： mysql SET GLOBAL log_bin_trust_function_creators = 1; 两者对比 关键字 调用语法 返回值 应用场景 存储过程 PROCEDURE CALL 存储过程() 0或多个 更新 存储函数 FUNCTION SELECT 函数() 只能是一个 返回一个查询结果 存储函数可以放在查询语句中使用，存储过程不行。 存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，存储函数不行。 存储过程和函数的查看、修改、删除查看MySQL存储了存储过程和函数的状态信息，用户可以通过3种方法查看： SHOW CREATE语句 SHOW CREATE PROCEDURE | FUNCTION 存储过程名或函数名#举例SHOW CREATE FUNCTION test_db.CountProc \\G SHOW STATUS语句 SHOW PROCEDURE | FUNCTION STATUS [LIKE pattern] 这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。 在information_schema.Routines 表中查看 SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=存储过程或函数的名 [AND ROUTINE_TYPE = PROCEDURE|FUNCTION];#数据库中存在（函数和过程）名称相同的情况，指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。 修改 这里的修改指：不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。 ALTER PROCEDURE | FUNCTION 存储过程或函数的名 [characteristic ...] characteristic 指定存储过程或函数的特性，其取值信息与[创建存储过程、函数时的取值信息] 不同。 CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA | SQL SECURITY DEFINER | INVOKER | COMMENT string CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。 NO SQL ，表示子程序中不包含SQL语句。 READS SQL DATA ，表示子程序中包含读数据的语句。 MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。 DEFINER ，表示只有定义者自己才能够执行。 INVOKER ，表示调用者可以执行。 COMMENT ‘string’ ，表示注释信息 修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。 两个语句的结构一样，语句中的所有参数也一样。 示例： ALTER PROCEDURE CountProcMODIFIES SQL DATASQL SECURITY INVOKER ; 修改后查询 SELECT specific_name,sql_data_access,securtiy_typeFROM information_schema.ROUTINESWHERE routine_name = CountProc AND routine_type = PROCEDURE; 查询结果：访问数据权限和安全类型改变。 删除DROP PROCEDURE | FUNCTION [IF EXISTS] 存储过程或函数的名#IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告 拓展对于存储过程的使用争议： 优点 **存储过程可以一次编译多次使用。**存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。 **可以减少开发工作量。**将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰。 **存储过程的安全性强。**我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。 可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。 良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。 缺点基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？ 阿里开发规范【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。存储过程虽然有诸如上面的好处，但缺点也是很明显的。 可移植性差：存储过程不能跨数据库移植 比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。 调试困难：只有少数 DBMS 支持存储过程的调试。 对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。 存储过程的版本管理很困难：比如数据表索引发生变化了，可能会导致存储过程失效。 我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。 它不适合高并发的场景：高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方 式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就 不适用了。"},{"title":"杂项","path":"/wiki/mysql/杂项.html","content":"管理用户mysql用户的账号和信息都存在名为mysql的MYSQL数据库中。 mysql数据库有一个 USER 表，存放着账户和密码。 USE mysql;SELECT user FROM user; CREATE USER ben IDENTIFIED BY your_password; IDENTIFIED BY 为纯文本。MYSQL会自动在保存到user表前对密码进行加密，作为散列表指定口令。 GRANT和INSERT也可以添加用户。 重命名： RENAME USER ben TO bforta; #bforta是个用户 删除： DROP USER bforta; 更改密码 SET PASSWORD FOR bforta = PASSWORD(new_passw); 设置访问权限: #查看用户账号权限SHOW GRANTS FOR user_name;#赋予权限GRANT SELECT ON crashcourse.* TO bforta;# crashcourse是个表，*即全部，表中全部内容都有了只读的访问权限#撤销权限REVOKE SELECT ON crashcourse.* FROM bforta; 适用范围 整个服务器：GTANT ALL 和 REVOKE ALL 整个数据库： 例如 ON database.* 特定表：例如 ON database.table 特定列 特定存储过程 权限类型：“太鸡儿多了，自己去看文档或者google好了” 提前授权: GRANT 和 REVOKE 的账户必须已经存在，但对象没有这种要求。 所以可以在创建数据库之前授权。更加安全。 坏处是删掉数据库后权限仍然存在，需要手动清理，否则可能影响下次创建。 一些维护的东西数据库维护 ANALYZE TABLE :检查表键 CHECK TABLE ：检查很多表属性。 日志文件 错误日志:hostname.err 查询日志:hostname.log 二进制日志:hostname-bin 缓慢查询日志:hostname-slow.log 1.都在data目录里了 2.- - log命令符能更改这些文件的名字。 陌生关键字ACTION ASENSITIVE CONVERT ENUM FORCE GOTO KILL LINES MOD NUMERIC OPTIMIZE OPTION OUTFILE PURGE RELEASE RESTRICT STARTING START_JOIN TERMINATED SPATIAL SONAME SCHEMA VARYING USAGE SQLEXCEPTION STATE WARNING"},{"title":"必知必会","path":"/wiki/mysql/必知必会.html","content":"10.2 尚硅谷mysql基础篇看完就忘了。基础的语法内容需要一定的代码量，最近我会多敲敲mysql。 SQL背景： 最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的 形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂， 但可读性更强。SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。 表连接区分内连接、外连接 inner join 内连接：满足交集。 outer join : 左右外连接。 内外连接即交并集的关系。 自连接 、 非自连接 自连接：对某个表来说，自己和自己的数据进行匹配。 非自连接：非自连接要借助外表。 联结连接区分联结、高级联结 等值联结（内部联结）： SELECT *FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id 多表联结： SELECT *FROM orderitems,prodacts,vendors WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 2005 自联结（自己和自己的两个表进行联结），即自连接 自然联结：如下 NATRUAL JOIN 外部联结 LEFT RIGHT JOIN (内连接，外连接) 组合查询：UNION 子查询 表查询区分等值查询、非等值查询 等值查询：过滤条件里是否为数值上的相等关系 非等值：BETWEEN ON，模糊查询 相关（关联）查询、非相关（非关联）查询 关于关联子查询： 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联。因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。 题目示例：不相关子查询：查询员工中工资大于本公司平均工资的员工的last_name,salary和其department_id 相关子查询：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id PS：公司平均工资和该员工的个人信息没有关系，即不相关。部门和该员工的个人部门有关，相关。 另：多表查询是个很大的范围，用到两个表以上的查询就是多表查询。 函数区分单行函数、多行（分组、聚合）函数 单行函数 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以嵌套 参数可以是一列或一个值、 多行函数 聚合函数作用于一组数据，并对一组数据返回一个值 表连接的新语法自然连接： 类似 SQL92 中的等值连接：自动查询两张连接表中所有相同的字段来进行等值连接 在SQL92标准中： SELECT employee_id,last_name,department_name FROM employees e JOIN departments d ON e.`department_id` = d.`department_id` AND e.`manager_id` = d.`manager_id`; 在 SQL99 中你可以写成： SELECT employee_id,last_name,department_name FROM employees e NATURAL JOIN departments d; #所有相同的字段自动等值查询 USING连接 SQL99支持使用 USING 指定数据表里的同名字 进行等值连接。USING只能配合JOIN一起使用。 区别于自然连接 ，USING 指明了相同的字段名称，同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。 SELECT employee_id,last_name,department_name FROM employees e JOIN departments d USING (department_id); SELECT employee_id,last_name,department_name FROM employees e ,departments d WHERE e.department_id = d.department_id; 上面两者效果相同。 这里 using 取代了 WHERE 的作用，并且形式上更简洁。 表连接的约束条件可以有三种方式：WHERE, ON, USING WHERE：适用于所有关联查询 ON ：只能和JOIN一起使用，只能写关联条件。 虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。 USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致 只能表示关联字段值相等 N张表关联时的效率问题： #n张表关联，需要n-1个关联条件 #查询员工姓名，基本工资，部门名称 SELECT last_name,job_title,department_name FROM employees,departments,jobs WHERE employees.department_id = departments.department_id AND employees.job_id = jobs.job_id; SELECT last_name,job_title,department_name FROM employees INNER JOIN departments INNER JOIN jobs ON employees.department_id = departments.department_id AND employees.job_id = jobs.job_id 我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重。 在许多 DBMS 中，也都会有最大连接表的限制。 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。 来源：阿里巴巴《Java开发手册》 优化sql查询语句的思路：一次查询返回多个需要的column 注意 DISTINCT ， IS NOT NULL 的情况。 FROM 后的表和别名更容易维护扩展。 实际上，很多 WHERE 处的过滤条件，都可以通过在 FROM 处改动来替换 例子： 无别名 SELECT *FROM employees WHERE employee_id = ANY( SELECT manager_id FROM employees WHERE department_id = (SELECT department_id FROM employees GROUP BY department_id ORDER BY salary DESC LIMIT 0,1 ) ) 有别名 SELECT last_name, department_id, email, salaryFROM employees WHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees e,( SELECT department_id,AVG(salary) avg_sal FROM employees GROUP BY department_id ORDER BY avg_sal DESC LIMIT 0,1) dept_avg_sal WHERE e.department_id = dept_avg_sal.department_id )"},{"title":"用户的创建、修改和删除","path":"/wiki/mysql/用户的创建、修改和删除.html","content":"用户管理用户信息在哪里默认数据库有四个： information_schema mysql performance_schema sys 其中 “mysql” 数据库有一个表名为user，存储着用户信息。 通常默认有四个用户： root ,mysql.infoschema,mysql.session,mysql.sys 。 ubuntu 或 debian 用户还会有个maint用户。 debian-sys-maint中Debian系统对MySQL维护用的，可以理解为通过系统的某个“非常规”程序对Mysql进行备份恢复等行为时，改程序所使用的用来登录Mysql的账户。 具体作用是重启及运行mysql服务，不过有一个安全问题：该用户的权限和ROOT是一样的，并且密码可以在etc某个文件中找到，这需要对账户进行一些限制。 root 的权限最高，顾名思义为“根”，拥有最高权限，创建其他用户，它不能没有。 user 的联合主键用户信息里两个列很关键：host 和 user。 host : 主机，用来区分用户的连接段。 user : 用户名，区分用户 user 表的主键有两个：host和user，即联合主键。 所以不同连接段允许有重名用户出现，就像不同作用域能够有重名变量一样。 创建、修改、删除创建用户指令： CREATE USER 用户名 [@主机名称] [IDENTIFIED BY 密码] #[]为可选 tips： 该语句可以同时创建多个用户。 用户名参数由用户和主机名构成。 需要有CREATE权限，新账户什么权限都没有。 修改 UPDATE mysql.user set user = wang5 where user = li4 [and host = xxx]flush privileges;# 刷新权限，否则登陆时仍然是原本的用户信息 修改用户就是直接操作 user 表。 修改完需要fs; 删除 两个方法：DROP 和 DELETE (user 表里删)。 DROP DROP USER user,[user].... #user即用户名参数，可包含 hostDROP USER li4; # 默认删除host为%的用户DROP USER li4@localhost; DELETE DELETE FROM mysql.user WHERE Host=hostname AND User = username;#必须有 host ，联合主键的两个字段，才能唯一确定一条记录。FLUSH PRIVILEGES; #立即生效。 DELETE 删除会有系统信息残留。DROP 指令能同时删去 mysql.user 表和 mysql.db 表内容。 设置当前用户密码1. 使用ALTER USER命令来修改当前用户密码 ALTER USER USER() IDENTIFIED BY new_password; 2. 使用SET语句来修改当前用户密码 SET PASSWORD=new_password; 修改其他用户密码1. 使用ALTER语句来修改普通用户的密码 ALTER USER user [IDENTIFIED BY 新密码] [,user[IDENTIFIED BY 新密码]]…; 2. 使用SET命令来修改普通用户的密码 SET PASSWORD FOR username@hostname=new_password; 密码过期关键词 EXPIRE 你可以通过ALTER和CREATE 时 手动设置用户密码过期，这样用户可以登入数据库，但无法查询。除非重新设置密码。 你也可以修改系统全局变量 Default password lifetime 。改变量默认为0，即不过期。设置为N代表密码生存期，N天后密码必须修改，否则将自动过期。 密码重用关键词 INTERVAL 、REUSE 分两类：时间和更改数量 时间（周期）：修改后密码不能用最近N天时间使用过的密码相同。 更改数量 ：修改后密码与最近N个密码不能相同。 系统变量：password_history , password_reuse_interval 权限管理show privileges; #查看权限 CREATE和DROP权限，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。 SELECT、INSERT、UPDATE和DELETE权限允许在一个数据库现有的表上实施操作。 SELECT权限只有在它们真正从一个表中检索行时才被用到。 INDEX权限允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。 ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。 CREATE ROUTINE权限用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用来执行保存的程序。 GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。 FILE权限使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。 授予权限GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’]; 该权限如果发现没有该用户，则会直接新建一个用户。 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost; 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限 GRANT ALL PRIVILEGES ON *.* TO joe@% IDENTIFIED BY 123; 授予权限的原则 权限控制主要是出于安全因素，因此需要遵循以下几个经验原则： 1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 2、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。 3、为每个用户设置满足密码复杂度的密码。 4、定期清理不需要的用户，回收权限或者删除用户。 查看权限 查看当前用户权限 SHOW GRANTS; # 或 SHOW GRANTS FOR CURRENT_USER; # 或 SHOW GRANTS FOR CURRENT_USER(); 查看某用户的全局权限 SHOW GRANTS FOR user@主机地址; 收回权限注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。 收回权限命令 REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址; 举例 #收回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@%; #收回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost; 注意：须用户重新登录后才能生效 权限表user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。 这些字段可分为四类： 范围列： host : 表示连接类型 % 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 机器名 通过制定网络中的机器名进行的TCP方式的连接 ::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1 localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。 user : 表示用户名，同一用户通过不同方式链接的权限是不一样的。 password ：mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字 段。 权限列：是否拥有一些特定权限 安全列 ：加密，表示用户，验证用户身份。 资源控制列：限制用户使用的资源。共4个字段。 ①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。 查看字段： DESC mysql.user; 查看用户, 以列的方式显示数据： SELECT * FROM mysql.user \\G; 查询特定字段： SELECT host,user,authentication_string,select_priv,insert_priv,drop_priv FROM mysql.user; db表 用户列 db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。 权限列 Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。 结构查看： DESCRIBE mysql.db; tables_priv 和 column_priv 表 tables_priv 表：对表设置操作权限 columns_priv 表 ：对表的某一列设置权限 。 procs_priv 表procs_priv 表可以对存储过程和存储函数设置操作权限 上面几个表都在 database → mysql 里，想看自己 DESC 去。 角色角色的创建、删除和权限操作创建角色 CREATE ROLE role_name[@host_name] [,role_name[@host_name]]... 角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。 给角色赋予权限 GRANT privileges ON table_name TO role_name[@host_name]; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称 SHOW PRIVILEGES\\G 查看角色的权限 SHOW GRANTS FOR role_name; 只要你创建了一个角色，系统就会自动给你一个“USAGE”权限，意思是连接登录数据库的权限。 回收角色的权限 REVOKE privileges ON tablename FROM rolename; 删除角色 DROP ROLE role [,role2]... 注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。 角色和用户给用户赋予角色 角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。 GRANT role [,role2,...] TO user [,user2,...]; 查询当前已激活的角色 SELECT CURRENT_ROLE(); 激活角色 方式1：使用set default role 命令激活角色 SET DEFAULT ROLE ALL TO kangshifu@localhost; 方式2：将activate_all_roles_on_login设置为ON SET GLOBAL activate_all_roles_on_login=ON; 这条 SQL 语句的意思是，对所有角色永久激活。 撤销用户的角色 REVOKE role FROM user; 设置强制角色(mandatory role) 方式1：服务启动前设置 [mysqld] mandatory_roles=role1,role2@localhost,r3@%.atguigu.com 方式2：运行时设置 SET PERSIST mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后仍然有效SET GLOBAL mandatory_roles = role1,role2@localhost,r3@%.example.com; #系统重启后失效 配置文件**文件里会定义许多组(用 [ ] 括起来)，组下边可以定义启动选项。**通常称组为标签。 [server]#具体启动选项option1 #不需要选项值：True / False 类型option2 = value2 #需要选项值 ： 键值对 类型[mysqld]...[mysqld_safe]...[client]... 配置文件中不同选项组是给不同的启动命令使用的。 有两个选项组比较特别： [server]组的启动选项作用于所有服务器程序 [client]组的启动选项作用于所有客户端程序。 像mysql这个启动命令，就会调用 [mysql] 和 [client] 两个组 tips： [mysql-‘版本号’]：只适用于特定版本的专用选项组 两个组里出现重复配置项，以最后一个为准。 一个选项既出现在命令行，又出现在配置文件里，以命令行为准。 如 defaults-extra-file 和 defaults-file 本身就是为了指定配置文件路径的。"},{"title":"约束","path":"/wiki/mysql/约束.html","content":"约束定义为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制 实体完整性（Entity Integrity） ： 同一个表中，不能存在两条完全相同无法区分的记录 域完整性（Domain Integrity） ： 年龄范围0-120，性别范围“男女” 引用完整性（Referential Integrity） 例如：员工所在部门，在部门表中要能找到这个部门 用户自定义完整性（User-defined Integrity） 例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。 定义建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束是表级的强制规定。 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束。 分类 根据约束数据列的限制，约束可分为： 单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据 根据约束的作用范围，约束可分为： 分类 位置 支持的约束类型 是否可以起约束名 作用范围 列级约束 列的后面 语法都支持，但外键没有效果 不可以 只能作用在一个列上 表级约束 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果） 可以作用在多个列上， 不同约束属性： NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束* FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果。 #information_schema数据库名（系统库） #table_constraints表名称（专门存储各个表的约束） SELECT * FROM information_schema.table_constraints WHERE table_name = 表名称; 不同约束NOT NULL非空约束，规定某个字段不能为空 默认所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 非空约束只能针对列，不能组合非空 空字符串’’不等于NULL，0也不等于NULL 添加 CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL ); 修改 alter table 表名称 modify 字段名 数据类型 not null; 删除 #去掉not null，相当于修改某个非注解字段，该字段允许为空 #1.alter table 表名称 modify 字段名 数据类型 NULL;#2.alter table 表名称 modify 字段名 数据类型; UNIQUE唯一约束，规定某个字段在整个表中是唯一的 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 mysql 会给唯一约束的列上默认创建一个唯一索引。** 添加 唯一约束 create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名) ); 组合约束 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, unique key(字段列表) )#字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的 ); 修改 #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的#方式1：alter table 表名称 add unique key(字段列表);#方式2： alter table 表名称 modify 字段名 字段类型 unique; 删除 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。 ALTER TABLE table_name DROP INDEX index_column; 注意：可以通过 show index from 表名称 来查看表的索引。 PRIMARY KEY主键(非空且唯一)约束 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 主键约束对应着表中的一列或者多列（复合主键） 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 MySQL的主键名总是PRIMARY**，就算自己命名了主键约束名也没用。 ** 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引 能够根据主键查询的，就根据主键查询，效率更高。 如果删除主键约束了，主键约束对应的索引就自动删除了。 不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性 添加 唯一约束 #列级模式 create table 表名称( 字段名 数据类型 primary key, #不要忘了，一个表最多一主键 字段名 数据类型, 字段名 数据类型 );#表级模式 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段名) ); 组合约束 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段); 修改 ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表);#字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键 create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段 ); 删除 ALTER TABLE 表名称 drop primary key; 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。 AUTO_INCREMENT 自增列 一个表最多只能有一个自增长列 当需要产生唯一标识符或顺序值时，可设置自增长 自增长列约束的列必须是键列（主键列，唯一键列） 自增约束的列的数据类型必须是整数类型 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 ​ 赋值为具体值。 添加 create table 表名称( 字段名 数据类型 primary key auto_increment, #必须是键列 字段名 数据类型 unique key not null, #一表最多一自增列 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, );create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值, primary key(字段名) ); 修改 alter table 表名称 modify 字段名 数据类型 auto_increment; 删除 alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 扩展： MySQL 8.0新特性：自增变量的持久化 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENTmax(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 test: (创建的数据表中包含自增主键的id字段) MySQL 5.7版本中， 语句如下： INSERT INTO test1 VALUES(0),(0),(0),(0); mysql SELECT * FROM test1;+----+| id |+----+| 1 | | 2 | | 3 | | 4 |+----+4 rows in set (0.00 sec) 再删再插 DELETE FROM test1 WHERE id = 4; INSERT INTO test1 VALUES(0); 结果： mysql SELECT * FROM test1;+----+| id | +----+| 1 | | 2 | | 3 | | 5 | +----+ 从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。 删除id为5的记录，结果如下： DELETE FROM test1 where id=5; 重启数据库，重新插入一个空值,在插入，结果则会变成： | id | +----+| 1 | | 2 | | 3 | | 4 | #应该是6！+----+4 rows in set (0.00 sec)#自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。 当数据库重启时，该计数器会被初始化 但在8.0版本中的结果： mysql SELECT * FROM test1;+----+| id |+----+| 1 | | 2 | | 3 | | 6 | +----+4 rows in set (0.00 sec) 此之谓“自增主键持久化” FOREIGN KEY 外键约束限定某个表的某个字段的引用完整性 定义 主表和从表父表和子表 主表（父表）：被引用的表，被参考的表 从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。 特点 从表的外键列，必须引用参考主表的主键或唯一约束的列 因为被依赖被参考的值必须是唯一的 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名 例如 student_ibfk_1;），也可以指定外键约束名。 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表 删表时，先删从表（或先删除外键约束），再删除主表 当主表的记录被从表参照时，主表的记录将不允许删除 如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 在“从表”中指定外键约束，并且一个表可以建立多个外键约束 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误。 例如：都是表示部门编号，都是int类型。 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。 但是索引名是外键的约束名。（根据外键查询效率很高） 删除外键约束后，必须手动删除对应的索引 添加 create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型 );create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT 外键约束名称] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) ); #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列 修改 一般情况下，表与表的关联都是提前设计好了的，因此会在创建表的时候就把外键约束定义好。 如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，这时就要用修改表的方式来补充定义。 ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx]; 总结： 约束关系是针对双方的 添加了外键约束后，主表的修改和删除数据受约束 添加了外键约束后，从表的添加和修改数据受约束 在从表上建立外键，要求主表必须存在 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除 约束等级 Cascade方式 ：在父表上updatedelete记录时，同步updatedelete掉子表的匹配记录 Set null方式 ：在父表上updatedelete记录时，将子表上匹配记录的列设为null 注意子表的外键列不能为not null No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行updatedelete操作 Restrict方式 ：同no action， 都是立即检查外键约束 Set default方式 （在可视化工具SQLyog中可能显示空白）： 父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别。如果没有指定等级，就相当于Restrict方式。 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式 删除 第一步先查看约束名和删除外键约束 SELECT * FROM information_schema.table_constraints WHERE table_name = 表名称;#查看某个表的约束名 ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; 第二步查看索引名和删除索引。（注意，只能手动删除） SHOW INDEX FROM 表名称; #查看某个表的索引名 ALTER TABLE 从表名 DROP INDEX 索引名; 扩展 建外键约束，操作会受到限制，从语法层面受到限制。 例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。 不建外键约束，操作不受限制，要保证数据的引用完整性 ，只能依靠程序员的自觉 。 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。 所以， MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。 所以即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。 6.10 阿里开发规范 [ 强制 ]不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。 外键与级联更新适用于 单机低并发 ，不适合分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。 CHECK 检查约束作用 检查某个字段的值是否符号xx要求，一般指的是值的范围 注意：mysql5.7不支持 MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告 但是MySQL 8.0中可以使用check约束了。 举例说明： create table employee( eid int primary key, ename varchar(5), gender char check (男 or 女) ); insert into employee values(1,张三,妖);mysql select * from employee; +-----+-------+--------+| eid | ename | gender | +-----+-------+--------+| 1 | 张三 | 妖 | +-----+-------+--------+1 row in set (0.00 sec) CREATE TABLE temp( id INT AUTO_INCREMENT, NAME VARCHAR(20), age INT CHECK(age 20), #哇啊哦 PRIMARY KEY(id) ); age tinyint check(age 20) sex char(2) check(sex in(‘男’,’女’)) DEFAULT 默认值约束添加 create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, # Ohhhhhhhh);create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 not null default 默认值,#1 字段名 数据类型 not null default 默认值,#2 primary key(字段名), unique key(字段名) ); 修改 alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 删除了 #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了 alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 删除 alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束 几个面试问题 面试1、为什么建表时，加** not null default ‘’ 或 default 0 ​ 答：不想让表中出现null值。 面试2、为什么不想要** null 的值 答: 不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通 常返回null。 效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0 面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？ 答：在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。 面试4、并不是每个表都可以任意选择存储引擎？ 外键约束（FOREIGN KEY）不能跨引擎使用。 MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来 保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不 能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。"},{"title":"视图","path":"/wiki/mysql/视图.html","content":"对象 描述 表(TABLE) 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 数据字典 就是系统表，存放数据库相关信息的表 系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看 约束 (CONSTRAINT) 执行数据校验的规则，用于保证数据完整性的规则 视图(VIEW) 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据 索引(INDEX） 用于提高查询性能，相当于书的目录 存储过程 (PROCEDURE) 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调 存储函数 (FUNCTION) 用于完成一次特定的计算，具有一个返回值 触发器 (TRIGGER) 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的 视图是一种 虚拟表 ，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。 视图，是向用户提供基表数据的另一种表现形式。小型项目的数据库可以不使用视图，但是在大型项目中，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。 当我们创建好一张视图之后，还可以在它的基础上继续创建视图。 创建视图CREATE [OR REPLACE] [ALGORITHM = UNDEFINED | MERGE | TEMPTABLE] VIEW 视图名称 [(字段列表)] AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION] CREATE VIEW 视图名称 AS 查询语句 查看视图#语法1：查看数据库的表对象、视图对象SHOW TABLES;#语法2：查看视图的结构DESC / DESCRIBE 视图名称;#语法3：查看视图的属性信息SHOW TABLE STATUS LIKE 视图名称\\G#执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。#语法4：查看视图的详细定义信息SHOW CREATE VIEW 视图名称; 更新视图MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。 SELECT ename,tel FROM emp_tel WHERE ename = 孙洪亮; UPDATE emp_tel SET tel = 13789091234 WHERE ename = 孙洪亮;DELETE FROM emp_tel WHERE ename = 孙洪亮 修改方式1：使用CREATE OR REPLACE VIEW 子句修改视图 CREATE OR REPLACE VIEW empvu80 (id_number, name, sal, department_id) ASSELECT employee_id, first_name || || last_name, salary,department_id FROM employees WHERE department_id = 80; 说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。方式2：ALTER VIEW ALTER VIEW 视图名称 AS 查询语句 删除DROP VIEW IF EXISTS 视图名称; 删除视图只是删除视图的定义，并不会删除基表的数据。 基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。 不可更新的视图要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如 下情况时，视图不支持更新操作： 在定义视图的时候指定了“ALGORITHM TEMPTABLE”，视图将不支持INSERT和DELETE操作； 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 ​ UNION 等，视图将不支持INSERT、UPDATE、DELETE； 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE； 视图定义基于一个 不可更新视图 或 常量视图。 虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的 数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。 优缺点： 优点： 操作简单 减少数据冗余 数据安全 适应灵活多变的需求 能够分解复杂的查询逻辑 缺点： 如果实际数据表的结构变更了，我们就需要及时对 相关的视图进行相应的维护。 对于嵌套的视图，维护会变得比较复杂，可读性不好 ，容易变成系统的潜在隐患。 因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。 实际项目中，如果视图过多，会导致数据库维护成本的问题。"},{"title":"游标和触发器","path":"/wiki/mysql/游标和触发器.html","content":"游标**（或光标）**定义游标是一种 能够对结果集中的每一条记录进行定位（像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一条记录 ），并对指向的记录中的数据进行操作的数据结构。 游标让 SQL这种面向集合的语言有了面向过程开发的能力。 特点： 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。 这里游标充当指针的作用,通过操作游标来对数据行进行操作. 游标必须在声明处理程序之前被声明 相对的，变量和条件则必须在声明游标和处理程序之前被声明。 使用过程使用游标一般分4步，不同DBMS细节不同。 声明游标 mysql(还有SQL Server，DB2 和 MariaDB) DECLARE cursor_name CURSOR FOR select_statement; Oracle 或者 PostgreSQL DECLARE cursor_name CURSOR IS select_statement; select_statement:要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据， 所以这里要通过SELECT 语句，返回一个用于创建游标的结果集。 打开游标 定义好游标之后，使用游标前必须先打开游标。 打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。 OPEN cursor_name 使用游标 使用即通过它来获取数据 FETCH cursor_name INTO var_name [, var_name] ...#这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，#游标指针指到下一行。 注意： 如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。 var_name必须在声明游标之前就定义好。 游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 关闭游标 CLOSE cursor_name 使用完游标后需要关闭掉该游标 。下次还要使用就要重新打开游标。 游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。 示例创建存储过程“get_count_by_limit_total_salary()”， 声明IN参数 limit_total_salary，DOUBLE类型； 声明 OUT参数total_count，INT类型。 函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。 DELIMITER // CREATE PROCEDURE get_count_by_limit_total_salary( IN limit_total_salary DOUBLE,OUT total_count INT)BEGINDECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资 DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值 DECLARE emp_count INT DEFAULT 0; #记录循环个数 #定义游标 DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;#打开游标 OPEN emp_cursor; REPEAT #使用游标（从游标中获取数据） FETCH emp_cursor INTO cursor_salary; SET sum_salary = sum_salary + cursor_salary; SET emp_count = emp_count + 1; UNTIL sum_salary = limit_total_salary END REPEAT; SET total_count = emp_count; #关闭游标 CLOSE emp_cursor; END // DELIMITER ; 总结 优点：为逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 缺点：比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理。 建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率 触发器应用场景有 2 个或者多个相互关联的表，如商品信息和库存信息 分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。 这样一来，我们就必须把这两个关联的操作步骤同步写到程序里面。可对数据进行手动维护时，很容易忘记其中的一步 ，导致数据缺失。 这时可以使用触发器：创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。 定义 MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。 所谓事件就是指 用户的动作或者触发某项行为。 如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。 当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。 使用 触发器不能更新或覆盖；为了修改一个触发器，必须先删再建。 使用触发器 insert 触发器 在insert触发器代码内，可引用一个名为new的虚拟表，访问被插入的行； 在before insert触发器内，new中的值也可以被更新(允许更改被插入的值)； delete 触发器 在delete触发器代码内，可以引用一个名为old的虚拟表，访问被删除的行； old中的值全都是只读的，不能更新； update 触发器 在update触发器代码内，可以引用一个名为old的虚拟表访问以前(update语句前)的值，引用一个名为new的虚拟表访问新更新的值； 在before update触发器中，new中的值可能也被更新(允许更改将要用于update语句中的值)； old中的值全都是只读的，不能更新； 另外的 tips ： 创建触发器可能需要特殊的安全访问权限，但触发器的执行是自动的。如果insert、update或delete语句可以执行，则相应触发器也能执行； 应该用触发器来保证数据的一致性(大小写、格式等)；优点在于它总是进行这种处理，而且是透明的进行，与客户机应用无关； 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改记录到另一个表非常容易； MySQL触发器不支持call语句，即不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 创建CREATE TRIGGER 触发器名称BEFORE|AFTERINSERT|UPDATE|DELETE ON 表名 FOR EACH ROW 触发器执行的语句块; 表名 ：表示触发器监控的对象。 BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。 INSERT|UPDATE|DELETE ：表示触发的前提事件。 查看查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。 查看当前数据库的所有触发器的定义 SHOW TRIGGERS\\G 查看当前数据库中某个触发器的定义 SHOW CREATE TRIGGER 触发器名 从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。 SELECT * FROM information_schema.TRIGGERS; 删除DROP TRIGGER IF EXISTS 触发器名称; 触发器作为数据库对象之一，也适用于DROP删除。 示例DELIMITER // CREATE TRIGGER salary_check_trigger BEFORE INSERT ON employees FOR EACH ROW BEGIN DECLARE mgrsalary DOUBLE; SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id; IF NEW.salary mgrsalary THEN SIGNAL SQLSTATE HY000 SET MESSAGE_TEXT = 薪资高于领导薪资错误; END IF; END // DELIMITER ; 一个注意点：如果在子表中定义了外键约束，并且外键指定了ON UPDATEDELETE CASCADESET NULL子句，此 时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE和DELETE语句定义的触发器并不会被激活。 优缺点 优点： 触发器可以确保数据的完整性。 触发器可以帮助我们记录操作日志 触发器还可以用在操作数据前，对数据进行合法性检查。 缺点： 触发器最大的一个问题就是可读性差 因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统维护是非常有挑战的。 #创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败update demo.membermaster set memberdeposit=20 where memberid = 2; ERROR 1054 (42S22): Unknown column aa in field list 这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力 相关数据的变更，可能会导致触发器出错。 特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。 拓展：MySQL 8.0的新特性**—**全局变量的持久化在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。 例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现： SET GLOBAL MAX_EXECUTION_TIME=2000; 但使用SET GLOBAL语句设置的变量值只会临时生效 : 即数据库重启 后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。 例如：设置服务器的最大连接数为1000： SET PERSIST global max_connections = 1000; MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。"},{"title":"这是分页标题","path":"/wiki/stellar/index.html","content":"nihao!"}]