
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>NOTE：线性代数3b1b - Fancy 的小宇宙</title>

  
    <meta name="description" content="博客的这个数学语言太难用了，改半天显示不好。 可参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_59298585&#x2F;article&#x2F;details&#x2F;142888232    前言：  一个很久之前截的B站评论: @？ 很多人学不懂线代(高代)的原因是，线性代数这门课本质上来说是 具体-抽象-再具体 的回旋过程首先从线性方程组开始讲起，讨论矩阵，方阵的性质然后再由矩阵上升到线性空间上的线性映">
<meta property="og:type" content="website">
<meta property="og:title" content="线性代数3b1b">
<meta property="og:url" content="https://back2zer0.github.io/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b/">
<meta property="og:site_name" content="Fancy 的小宇宙">
<meta property="og:description" content="博客的这个数学语言太难用了，改半天显示不好。 可参考：https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_59298585&#x2F;article&#x2F;details&#x2F;142888232    前言：  一个很久之前截的B站评论: @？ 很多人学不懂线代(高代)的原因是，线性代数这门课本质上来说是 具体-抽象-再具体 的回旋过程首先从线性方程组开始讲起，讨论矩阵，方阵的性质然后再由矩阵上升到线性空间上的线性映">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.emojiall.com/images/240/twitter/1f416.png">
<meta property="article:published_time" content="2026-01-28T02:30:31.813Z">
<meta property="article:modified_time" content="2026-01-28T02:30:31.813Z">
<meta property="article:author" content="Fancy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.emojiall.com/images/240/twitter/1f416.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="https://www.emojiall.com/images/240/twitter/1f416.png">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"Website","@id":"https://back2zer0.github.io/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b/","author":{"@type":"Person","name":"Fancy","sameAs":[],"image":"https://www.emojiall.com/images/240/twitter/1f416.png"},"name":"线性代数3b1b","description":"\n博客的这个数学语言太难用了，改半天显示不好。\n可参考：https://blog.csdn.net/m0_59298585/article/details/142888232\n\n\n\n前言：\n\n一个很久之前截的B站评论:\n@？\n很多人学不懂线代(高代)的原因是，线性代数这门课本质上来说是 具体-抽象-再具体 的回旋过程首先从线性方程组开始讲起，讨论矩阵，方阵的性质然后再由矩阵上升到线性空间上的...","url":"https://back2zer0.github.io/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b/"}</script>
  
</head>
<body>



<div class="l_body content" id="start" layout="page" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="https://picgo-1398775008.cos.ap-guangzhou.myqcloud.com/beaker-svgrepo-com.svg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b"><div class="main">NOTE</div><div class="sub normal cap">为学日益，为道日损</div><div class="sub hover cap" style="opacity:0"> fancy</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item" title="认知" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item active" title="技术" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="生活" href="/life/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="更多" href="/more/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/wiki/" placeholder="在技术专栏中搜索..."></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<widget class="widget-wrapper doc-tree post-list"><div class="widget-body fs14"><a class="link active" href="/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b/#start"><span class="toc-text">线性代数3b1b</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="link" href="/wiki/NOTE/Crash%20Course%20CS/"><span class="toc-text">Crash Course CS</span></a><a class="link" href="/wiki/NOTE/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"><span class="toc-text">程序是怎么跑起来的</span></a><a class="link" href="/wiki/NOTE/%E9%AB%98%E6%95%B0%E5%92%8C408%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"><span class="toc-text">高数和408的一些理解</span></a><a class="link" href="/wiki/NOTE/%E8%8B%B1%E8%AF%AD%E9%9A%8F%E7%AC%94/"><span class="toc-text">英语随笔</span></a><a class="link" href="/wiki/NOTE/script/"><span class="toc-text">script</span></a><a class="link" href="/wiki/NOTE/Vim%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="toc-text">Vim 学习笔记</span></a></div></widget>

<widget class="widget-wrapper post-card"><div class="widget-header dis-select"><span class="name">更多：看闲书</span></div><div class="widget-body"><a class="item wiki" href="/wiki/cpp/effective%20cpp/"><span class="title">C++</span><span class="excerpt">关于CPP的一些笔记。</span></a><a class="item wiki" href="/wiki/algorithm/%E8%83%8C%E5%8C%85DP/"><span class="title">那段学算法的日子</span><span class="excerpt">AcWing和Leetcode，还有一些比赛题目。</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">文档</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/NOTE/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03b1b/">NOTE</a></div>
<div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2026-01-28T02:30:31.813Z">2026-01-28</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>线性代数3b1b</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>博客的这个数学语言太难用了，改半天显示不好。</p>
<p>可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59298585/article/details/142888232">https://blog.csdn.net/m0_59298585/article/details/142888232</a></p>
</blockquote>


<p><strong>前言：</strong></p>
<blockquote>
<p>一个很久之前截的B站评论:</p>
<p>@？</p>
<p>很多人学不懂线代(高代)的原因是，线性代数这门课本质上来说是 具体-抽象-再具体 的回旋过程首先从线性方程组开始讲起，讨论矩阵，方阵的性质然后再由矩阵上升到线性空间上的线性映射线性变换，在研究线性映射和线性变换时又会通过和数域K的联系再具体化到矩阵所以入门学习矩阵的时候，很容易迷失在处处严谨的证明细枝未节里，从而没法把握核心的思路与研究目的;</p>
<p>而矩阵没学好，后面的线性空间更难理解，因为线性空间研究往往是再具体化到矩阵上来进行的</p>
<p>所以我建议朋友们学习高代(线代)的时候，在初期就把这门课当作一门外语来学在矩阵部分对每一条定理每一个命题都把他当作单词吃透当你带着扎实的矩阵功底去接触线性空间的时候，马上如拨云见日般。你也会很快感受到代数学具体抽象再具体的魅力。</p>
<p>@吸猫群众QAQ:</p>
<p>数无形时少直觉，形少数时难入微，数形结合百般好。越学习越惊叹于古人的智慧，三百多年的科学史，孕育出了多少绝妙的思想。想到了年纪轻轻却在数学体系不完善的年代创造出微积分，用古老的几何证明法得出若干现在仍被奉为真理的几大定律，却在晚年困惑于神与世界本质的思辨中的牛顿;还有靠现有的数学工具以及其绝妙的思维创造出广义相对论，以一人之力颠覆了人类对空间和时间这两个玄妙概念的理解，在晚年试图创造出可以解释世界的终极定理却终究敌不过时间的爱因斯坦;还有那些出于对一个奇怪的物理现象的探究，却揭示出一个光怪陆离，极度违背常识，连创始人都无法理解，却又无数次被证实是正确的理论的一众量子力学的奠基人们。人类文明的智慧闪光真的令人叹为观止，或许无尽岁月之后，有足够辨析能力的另一个文明看到或许已经灭绝的人类残存的信息，也会惊叹或惋惜于这个文明曾经的智慧吧。</p>
<p>@卧三：</p>
<p>我所理解的秩，是在某个维度下所固定的条件个数，比方说，三维空间我们有x，z，y三个线性无关的条件，三个条件对应着秩为3，即秩为3时我们可以确定空间的一个点。对应此时我们只有唯一解，即为R(A) &#x3D; n ，假如三维空间中，我们秩为2 即为R(A) &lt; n ,我们们只有两个量假设x，y是固定的或者说已知的，此时我们将会有一个平面的点z不确定的点。所以我们将有一个自由变量，即为z方向上的自由变量，我们用一个向量表示这些有的点，则为我们的通解。所以维度 &#x3D; 秩（确定的量）+ 基础解系个数(不确定的量)</p>
</blockquote>
<p>目录：</p>
<p>[TOC]</p>
<h2 id="0-线性代数的“线性”"><a href="#0-线性代数的“线性”" class="headerlink" title="0.线性代数的“线性”"></a>0.线性代数的“线性”</h2><ul>
<li>“线性”的严格定义如下若一个变换工满足两条性质：<strong>齐次性和可加性</strong>。</li>
</ul>
<ol>
<li><p>可加性:<br>$$<br>L(\vec{v} +\vec{w}) &#x3D; L(\vec{v})+L(\vec{w})<br>$$</p>
</li>
<li><p>齐次性（成比例）<br>$$<br>L(c\vec{v}) &#x3D; cL(\vec{v})<br>$$</p>
</li>
</ol>
<p>则称L是线性的。</p>
<blockquote>
<p>从几何角度看，</p>
<p>将<code>i向量</code>固定，移动 <code>j向量</code>，将形成一条直线；</p>
<p>将<code>j向量</code>固定，移动 <code>i向量</code>，将形成另一条直线；</p>
<p>每次移动向量，都是对应基向量的倍数（成比例），而基向量之间可以相加形成新的向量。</p>
<p>可加、可乘（成比例）</p>
<p>如果固定其中一个标量，让另一个标量自由变化，所产生的向量的终点会描出一条直线。</p>
<p><strong>基向量线性组合的向量的集合，被称为给定向量张成的空间(span)</strong></p>
</blockquote>
<ul>
<li><p>线性的词源:出于线性方程组。线性方程组在二维情况下，有形如ax+by&#x3D;c的子方程</p>
<p>所谓线性关系，简单地讲就是比例关系，即两个变量按一定的比例增加或减少。</p>
<p>**这种关系若用图形来表示，就是一条直线，故称线性关系。**这种关系若用方程来表示，就称为线性方程</p>
</li>
<li><p>线性代数 这门学科之所以包含“线性”二字，是因为它主要研究的是**向量空间（或称为线性空间）、线性变换以及线性方程组等概念。**这些概念都涉及到线性关系：</p>
</li>
</ul>
<h2 id="1-线性相关"><a href="#1-线性相关" class="headerlink" title="1.线性相关"></a>1.线性相关</h2><p>可以理解为线性相关意味着停留在这个维度不增维。当一组向量成线性相关时，其中至少有一个向量能由其它向量线性表示</p>
<h2 id="2-基向量"><a href="#2-基向量" class="headerlink" title="2.基向量"></a>2.基向量</h2><p>空间的一组基的严格定义是这样的:张成该空间的一个线性无关向量的集合。</p>
<p>（向量空间的一组基是张成该空间的一个线性无关向量集）</p>
<h2 id="3-线性变换（劲爆）"><a href="#3-线性变换（劲爆）" class="headerlink" title="3.线性变换（劲爆）"></a>3.线性变换（劲爆）</h2><p>严格意义上说，线性变换是将向量作为输入和输出的一类函数。</p>
<p>线性变换是操纵空间的一种手段。</p>
<p>它具备两个性质：</p>
<p><strong>①保持网格线平行且等距分布，②保持原点不动。</strong></p>
<p>这两点性质保证了：只要记录下i帽和j帽变换后的位置，你就能计算出一个坐标为(x,y)的向量变换后的坐标。</p>
<p>令人高兴的是，这种变换只需要几个数字就能描述清楚，这些数字就是变换后基向量的坐标。<strong>线性变换由它对空间的基向量的作用完全决定。</strong></p>
<blockquote>
<p>习惯上，我们将变换后i帽和j帽的坐标作为一个矩阵的列，并且将两列分别与x和y相乘后加和的结果定义为矩阵向量乘积</p>
</blockquote>
<p>这样，矩阵代表一个特定的线性变换。而矩阵与向量相乘，就是将线性变换作用于那个向量。</p>
<p>因此**可以将线性变换看作对空间的挤压伸展。**这是因为其他任意向量都能表示为基向量的线性组合。</p>
<hr>
<p>线性相关时，如果变换后的i帽和变换后的j帽是线性相关的，意味着其中一个向量是另一个的倍数，那么这个线性变换将整个二维空间挤压到它们所在一条直线上。也就是这两个线性相关向量所张成的一维空间。</p>
<p>以这些坐标为列所构成的矩阵为我们提供了一种描述线性变换的语言，而矩阵向量乘法就是计算线性变换作用于给定向量的一种途径。</p>
<p>这里重要的是。<strong>每当你看到一个矩阵时，你都可以把它解读为对空间的一种特定变换。</strong></p>
<p>矩阵相乘：两个变化相互作用，即复合变化。这里可以联想复合函数。</p>
<p><strong>这样也可以解释矩阵的两个性质：</strong></p>
<ol>
<li><p>不具备交换律</p>
<p>AB ≠ BA</p>
<p>也就是为什么矩阵乘法有严格顺序要求。例如 先旋转、再剪切 和 先剪切、再旋转是不同的。</p>
</li>
<li><p>具备结合律</p>
<p>A(BC) 和 (AB)C 三个线性变化的相对顺序不变，</p>
</li>
</ol>
<blockquote>
<p>线性代数中的“剪切”通常指的是剪切矩阵（shear matrix）或剪切变换（shear transformation），这是一种线性变换，它将一个图形沿着某一轴或平面进行倾斜，而不改变图形的大小或形状</p>
</blockquote>
<p>这是通过矩阵在几何上的线性变换，证明矩阵乘法具有结合性的一个实实在在的证明。我真的鼓励你在这种想法上多做尝试，想象两个不同的变换，思考他们依次作用后会发生什么，最后用数值方法计算出矩阵乘积。</p>
<p>4.观察基向量的运算和线性变换，**“缩放再相加”**的过程在变换前后均适用。</p>
<p>对于一个矩阵，用一个元素均为x、y、z这种未知数的向量相乘，得到的新矩阵就是新的基向量。</p>
<p><strong>线性变换矩阵 * 输入向量 &#x3D; 输出向量。</strong></p>
<p>（线性变换和函数的功能是类似的，输入-处理-输出。但变换一词更强调变换本身的过程，也就是几何而非数值上的变化。）</p>
<h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4.行列式"></a>4.行列式</h2><p>不同矩阵代表的线性变换中，有的将空间向外拉伸，有的将空间向内挤压。理解这些线性变换的关键一点，是测量变换对空间拉伸或挤压的程度。也就是<strong>测量一个给定区域面积增大或减小的比例</strong>。</p>
<p>这个特殊的缩放比例，即<strong>线性变换改变面积的比例 , 被称为这个变换的行列式</strong></p>
<p><strong>注意：</strong></p>
<ol>
<li><p>无论一个方格如何变化，对其他大小的方格来说，都会有相同变化。</p>
<blockquote>
<p>这是由“网格线保持平行且等距分布”这一事实推断得出的</p>
</blockquote>
</li>
<li><p>对于不是方格的形状（存在曲线的），可以用很多小方格近似。</p>
<blockquote>
<p>对所有小方格都进行等比例缩放，缩放的越小，精度越高。</p>
</blockquote>
</li>
<li><p>如果一个二维线性变换的行列式为0，说明它将整个平面压缩到一条线，甚至是一个点上。</p>
<blockquote>
<p>表现在几何上就是面积为0，没有面积。     </p>
</blockquote>
<p>这意味着一个矩阵的行列式如果为0，这个矩阵所代表的变换就能将空间压缩到更小的维度上（降维）。</p>
</li>
</ol>
<p><strong>二维空间的行列式负值</strong>：</p>
<p><strong>定向</strong></p>
<blockquote>
<p>行列式有负值。缩放一个负数是什么意思?</p>
<p>这会涉及到一个叫“定向”的概念。</p>
</blockquote>
<ol>
<li><p>如里你将二维空间想象为一张纸，这个变换像是将纸翻转到了另一面。</p>
</li>
<li><p>根据<code>i帽</code>和<code>j帽</code>来考虑。</p>
<p>初始状态下，显然<code> j-hat</code> 在<code> i-hat</code> 左边，形成一个直角。</p>
<p><strong>如果在变换之后，j帽处于i帽的右边，那么空间定向就发生了改变</strong></p>
<blockquote>
<p><code>j 帽</code>就是y轴基向量，<code>i -hat</code> 就是x轴基向量</p>
</blockquote>
</li>
</ol>
<p>我们称类似这样的变换改变了空间的定向。</p>
<p><strong>当空间定向改变的情况发生时，行列式为负。</strong></p>
<p>此时，行列式的绝对值依然表示区域面积的缩放比例。</p>
<blockquote>
<p>比如说，我告诉你由(1,1)和(2,-1)为列的矩阵所代表的线性变换的行列式是-3.</p>
<p>这就是说变换后空间被翻转，并且面积放大为原来的3倍。</p>
</blockquote>
<ul>
<li><strong>负的面积为什么和定向有关？</strong></li>
</ul>
<blockquote>
<p>这里强烈建议看3blue1brown原视频。</p>
<p>《线性代数的本质》行列式 5：05</p>
</blockquote>
<p>当i帽靠近j帽时，空间也被压缩地更严重，这意味着行列式趋近于0；</p>
<p>当i帽与j帽完全重合时，行列式为0。</p>
<p>如果i帽继续沿着这个方向运动，行列式继续减小为负值将是一件很自然的事。</p>
<blockquote>
<p>换一个角度看，二维的压缩，从三维视角看，就是一种旋转。</p>
<p>压缩时，向量<code>j </code>不动，向量 <code>i</code> 逐渐靠近 <code>j</code>。</p>
<p><strong>想象 i 靠近 j ，越过 j 的过程：</strong></p>
<p>二维视角下，以i 和 j 为基 的坐标系接近时压缩，越过时拉伸。</p>
<p><strong>三维视角下，把红向量j当做Z轴，想象绿向量在XOY平面上旋转——</strong></p>
<p><strong>就像一个圆柱绕圆心的Z轴旋转，你只能看到 XoY 这一个侧切面的变化。</strong></p>
</blockquote>
<ul>
<li><strong>三维空间，行列式意味着什么？</strong></li>
</ul>
<p>依然是变换前后的缩放比例，不过这次缩放的是体积。</p>
<p>二维空间，我们考虑的是基向量i 和 j 组成的面积为1的正方形，并观察变换对它的影响。</p>
<p>三维空间，我们考虑的是基向量 i , j , k 组成的体积为1 的立体正方形。</p>
<p><strong>三维空间的行列式负值</strong>：</p>
<p>有一种方法来描述三维空间的定向，那就是“右手定则——</p>
<ul>
<li>右手食指指向i帽的方向；</li>
<li>伸出中指指向j帽的方向；</li>
<li>当你把大拇指竖起来时，它就正好指向k帽的方向。</li>
</ul>
<p>如果线性变换后，你还可以用右手这么做，那么定向没有发生改变，行列式为正。</p>
<p>如果变换后，只能用左手描述了，那就是定向发生了改变，行列式为负。</p>
<p><strong>行列式的求值公式：</strong> ad - bc<br>$$<br>(a+b)(c+d)-ac-bd-2bc &#x3D; ad-bc<br>$$<br>坐标系中， 小正方形凑成的网格面积 减去 平行四边形周围的三角形面积 &#x3D; 平行四边形的面积</p>
<p><strong>行列式的一个性质证明：</strong><br>$$<br>det(M1M2) &#x3D; det(m1) det(m2)<br>$$</p>
<blockquote>
<p>det行列式，M1、M2是矩阵</p>
</blockquote>
<p>数值计算很麻烦。但从几何上理解：</p>
<p><strong>两个相继作用的总的线性变换对空间中几何维度造成的影响等于他们单独作用时造成影响的乘积。</strong></p>
<blockquote>
<p>两次空间放缩引起的面积变化 是 两次单独放缩面积变化  倍数的乘积</p>
</blockquote>
<p>在同一个变换下任何一个图形的拉伸倍率都是一样的，所以M1M2两次变换后的面积倍率结果是一致的。</p>
<blockquote>
<p>注意：det乘det本质不是面积相乘，而是面积倍率相乘。</p>
</blockquote>
<h2 id="5-线性方程组"><a href="#5-线性方程组" class="headerlink" title="5.线性方程组"></a>5.线性方程组</h2><p>用一个式子概括：<br>$$<br>A\vec{x} &#x3D; \vec{v}<br>$$</p>
<p>$$<br>\left(\begin{matrix}1 &amp; 2 &amp; 3 \4 &amp; 5 &amp; 6 \7 &amp; 8 &amp; 9\end{matrix}\right) \left[\begin{matrix}x_1 \x_2 \x_3 \end{matrix}\right] &#x3D;\left[\begin{matrix}a \b \c \end{matrix}\right]<br>$$</p>
<blockquote>
<p>A 是未知数系数的矩阵，<code>x</code> 是未知数向量{x,y,z或x1,x2,x3……}， <code>v</code>是常数向量，如果是齐次的话，v 就是 很多 0 的 向量。</p>
</blockquote>
<p>这个式子阐明了线性方程组问题中优美的几何直观部分：</p>
<p><strong>矩阵A代表一种线性变换，所以 求解Ax&#x3D;v意味着我们去寻找一个向量x，使得它在变换后与v重合。</strong></p>
<blockquote>
<p>这个时候逆矩阵的几何意义也很清晰了！</p>
</blockquote>
<p><strong>当你逆向进行变换时，它实际上对应了另一个线性变换 —— 用<code>v</code>经过线性变换（矩阵）去寻找<code>x</code>。</strong></p>
<blockquote>
<p>也就是等式两边同乘A逆，v逆向进行变换并跟踪x的动向。</p>
</blockquote>
<p>这个线性变换就叫作A^-1^  A的逆矩阵！ </p>
<blockquote>
<p>比如说，如果A是逆时针旋转90度的变换,那么A的逆就是顺时针旋转90度的变换。</p>
<p>总的来说，A逆是满足以下性质的唯一变换：</p>
<p><strong>首先应用A代表的变换，再应用A逆代表的变换，你会回到原始状态。</strong></p>
<p>A逆乘以A等于一个“什么都不做”的矩阵，这个“什么都不做”的变换被称为“恒等变换”</p>
</blockquote>
<p><strong>x和v重合有两种情况：</strong></p>
<ol>
<li>降维，两者变成一条线或一个点从而重合。</li>
<li>不降维，在原有维度（二维、三维）上通过线性变换重合。</li>
</ol>
<p>不降维，即存在唯一解的情况，这时存在A逆。</p>
<blockquote>
<p>A^-1^ 使得应用A变换再应用A逆变换之后，结果与恒等变换无异。</p>
</blockquote>
<p><strong>降维即行列式为 0的情况；</strong></p>
<p>与这个方程组相关的变换将空间压缩到更低的维度上，此时没有逆变换，你不能将一条线“解压缩”为一个平面，也不能将一个点“回溯”成一条线（至少这不是一个函数能做的），你不能进行升维。</p>
<blockquote>
<p>降维会损失信息。</p>
<p>空间坍缩为更低的维度后，变换信息有所丢失，无法得到其逆变换，也就是逆矩阵不存在</p>
</blockquote>
<p>这样就会要求将一个单独的向量变换为一整条线的向量，但是函数只能将一个输入变换为一个输出。</p>
<p><strong>关于列空间（下面理解方程组求解要用）：</strong></p>
<p><strong>所有可能的变换结果(输出向量)的集合 被称为矩阵的“列空间。</strong></p>
<blockquote>
<p>不管是一条直线、一个平面还是三维空间等。</p>
</blockquote>
<p>矩阵的列告诉你基向量变换后的位置，这些**变换后的基向量张成的空间就是所有可能的变换结果 **;</p>
<p>换句话说**，列空间就是矩阵的列所张成的空间。**</p>
<blockquote>
<p>列张成的空间 span of columns↔️列空间 Column space</p>
</blockquote>
<p><strong>0向量一定包含在列空间中。</strong></p>
<blockquote>
<p>因为线性变换要求原点位置不变。</p>
</blockquote>
<p>结合这里的几何特性你可以理解：</p>
<p>对于线性方程组的求解情况——</p>
<ul>
<li>&#x3D;&#x3D;非齐次&#x3D;&#x3D;</li>
</ul>
<ol>
<li><p><strong>增广矩阵r(A,v) 的秩和矩阵的秩r(A) 是否相等：</strong></p>
<ul>
<li><p><code>r(A,v) == r(A)</code>说明 <strong>v 和A在一个维度上</strong> ，至少有一个解</p>
</li>
<li><p><code>r(A,v)  &gt; r(A)</code> :说明 <strong>v 比 A 的维度要高</strong> ，无解</p>
<blockquote>
<p>列空间：列向量张成的空间<code>span</code>，忘记的看第 0 条 。</p>
<p>列空间是所有可能的 A 的列向量的线性组合构成的集合。</p>
<p>假设矩阵 A 是一个 m×n 的矩阵，那么它有 n 个列向量。这些列向量可以看作是 R^m^ (m维空间）中的向量。</p>
<p>如果这些列向量<strong>线性无关</strong>，它们可以张成一个 n 维的子空间，这个子空间就是 A 的列空间。</p>
<p>现在，当我们说向量 v 不在矩阵 A 的列空间中，这意味着没有一种方式通过 A 的列向量的线性组合来得到向量 v。</p>
<p><strong>换句话说，v 向量的维度高于 A，于是不存在一个向量 x 使得 Ax &#x3D; v 成立。</strong></p>
<p>如果我们将 A 的列向量看作是定义了一个平面或者高维空间中的一个超平面，那么 b 就是位于这个平面或超平面之外的点。</p>
</blockquote>
<p>r(A,v)  &gt; r(A) 时，意味着 v 的维度比 A 的维度要高，A经过初等行变换会存在 全 0 行。</p>
<blockquote>
<p>A如果线性相关，则必然存在 全 0 行；</p>
<p>A如果线性无关，但比我们要追踪的 v 向量 少一行，也意味着A、v两者比较时，A下面要补充一个全0行。</p>
<p><strong>总之就是少一个维度。</strong></p>
</blockquote>
<p> r(A) 里存在线性相关的列向量。于是 A 的线性变换相比 v向量 少了一个维度，找不到 x向量 经过低维线性变换 追踪到 v。</p>
</li>
</ul>
</li>
<li><p>在 <code>r(A,v)==r(A)</code> 的情况下，<strong>秩的数量(A)是否和未知数n (x向量)一样</strong>：</p>
<ul>
<li><p>如果一样，说明 <strong>A 和  x 在同一维度</strong>，x可以通过有限线性变化A  与 v重叠，<strong>这时是唯一解。</strong></p>
</li>
<li><p>如果不一样，说明 <strong>A 比 x 维度低</strong> ，x 想与 v 重叠，只能通过“降维”，<strong>这时是无穷多解。</strong></p>
<blockquote>
<p>可以想象，物体投影到平面上只有一个影子；而从投影去猜测物体，物体可以有无限种形状。</p>
<p>同样地，经过降维压缩变换后，能够和低维的 v 重叠的 高维 x 有无穷多种。</p>
<p>例如三维→二维， 立体被压缩成一条线；</p>
<p>例如二维→一维，一条线被压缩成一个点。</p>
<p><strong>都是无穷多解的情况。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>提问：增广矩阵的秩为n时，什么时候有解？</p>
<p>答：增广矩阵在n维度， A在n-1维度时无解。 只有当增广和A都在n维度时 才有解</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;齐次&#x3D;&#x3D;</p>
<p>一定有解。</p>
<blockquote>
<p>n 是 未知数个数。</p>
</blockquote>
<ul>
<li><p>r(A) &#x3D; n ， <strong>A 和 x 在同一维度</strong> ，因为 v 向量是0，x 作为 0 向量，经过任何线性变换都和 v 重叠。</p>
<blockquote>
<p>是的，只有一个 唯一解，那就是0向量。</p>
</blockquote>
</li>
<li><p>r(A) &lt; n ,    <strong>A 比 x 维度低</strong> ，x 想与 0向量 重叠，只能通过线性变换来 “降维”，<strong>这时是无穷多解。</strong></p>
<blockquote>
<p>这无穷多个解不是整个二维平面，而是二维平面&#x2F;三维空间上的一条线，叫做零空间。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>于是不难理解行列式为 0 时的意义：</strong></p>
<p>行列式为0 时，意味着变换前后的面积倍率为0（压缩后面积为0），一定有维度变化。</p>
<p>对线性方程组，表现在齐次上就是无穷多解（线性变换降维），表现在非齐次上要么无解（v 比 A 维度高），要么也无穷多解(线性变换降维)。</p>
<h2 id="6-秩-Rank"><a href="#6-秩-Rank" class="headerlink" title="6.秩 (Rank)"></a>6.秩 (Rank)</h2><p>“秩”代表着变换后空间的维度<br>So the word <strong>“rank”</strong> means <strong>the number of dimensions in the output of a transformation.</strong></p>
<blockquote>
<p>列向量所张成空间的维度（基向量个数）</p>
</blockquote>
<p>举例：</p>
<p>比如说对于2x2的矩阵，它的秩最大为2,意味着基向量仍旧能张成整个二维空间，并且矩阵的行列式不为零</p>
<p>但是对于3x3的矩阵，秩为2意味着空间被压缩了，但是和秩为1的情况相比，压缩并不是那么严重。</p>
<blockquote>
<p>如果一个三维变换的行列式不为零，变换结果仍旧充满整个三维空间，那么它的秩仍为3。</p>
</blockquote>
<p><strong>所以更精确的&#x3D;&#x3D;秩的定义是列空间的维数&#x3D;&#x3D;。</strong></p>
<p>当达到最大值时，意味着秩与列数相等，我们称之为“满秩”</p>
<p><strong>对一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身。</strong></p>
<p>但是对一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上。也就是说会有一系列向量在变换后成为零向量。</p>
<blockquote>
<p>举个例子，如果一个二维线性变换 将 非满秩（秩为1，两个基向量线性相关）平面压缩到一条直线上，那么沿某个不同方向直线上的所有向量就被压缩到原点。</p>
<p>就好像柱子的侧面（直线）经过线性变换（旋转）变成了一个点（底面）。</p>
<p>如果一个三维线性变换将空间压缩到一个二维平面上，同样也会有一整条线上的向量在变换后落在原点。</p>
<p>压缩成二维直线也一样。</p>
</blockquote>
<p><strong>零空间：</strong></p>
<p>变换后落在原点的向量的集合，被称为矩阵的“零空间”或“核。变换后一些向量落在零向量上，而“零空间”正是这些向量所构成的空间</p>
<blockquote>
<p>比如上面例子中那一整条直线就是零空间。</p>
</blockquote>
<p><strong>列空间的概念让我们清楚什么时候存在解，零空间的概念有助于我们理解所有可能的解的集合是什么样的。</strong></p>
<h2 id="7-非方阵矩阵"><a href="#7-非方阵矩阵" class="headerlink" title="7. 非方阵矩阵"></a>7. 非方阵矩阵</h2><p><strong>举例分析</strong></p>
<ul>
<li><p>3x2矩阵：是一个面，但仍然满秩。几何意义是将一个二维空间映射到三维空间上。</p>
<blockquote>
<p>二维空间输入 ，三维空间输出。</p>
</blockquote>
<p>矩阵有两列表明输入空间有两个基向量，有三行表明每一个基向量在变换后都用三个独立的坐标来描述。</p>
</li>
<li><p>2x3矩阵：</p>
<blockquote>
<p>三维空间输入 ，二维空间输出。</p>
</blockquote>
<p>几个基向量说明空间是几维；有两行表明这三个基向量在变换后都仅用两个坐标来描述，所以他们一定落在二维空间中。</p>
</li>
</ul>
<p><strong>解线性方程</strong></p>
<ul>
<li>3×2矩阵解线性方程：3个方程式，2个未知数，将二维空间投射到三维空间，要么无解，要么一个解</li>
<li>2×3矩阵解线性方程：2个方程式，3个未知数，将三维空间压缩成二维空间，要么无解，要么无穷多解</li>
</ul>
<h2 id="8-点乘和线性变换（相当劲爆）"><a href="#8-点乘和线性变换（相当劲爆）" class="headerlink" title="8.点乘和线性变换（相当劲爆）"></a>8.点乘和线性变换（相当劲爆）</h2><p><strong>点乘标准形式：</strong><br>$$<br>\left[\begin{matrix}a \b\end{matrix}\right]\cdot\left[\begin{matrix}c \ d\end{matrix}\right]&#x3D;(a\cdot c)+(b\cdot d)<br>$$<br><strong>点乘几何形式：</strong></p>
<p>二维坐标系里进行演算可知，点乘就是其中一个向量在另一个向量上的投影长度，乘以被<strong>投影</strong>向量长度的成绩。</p>
<hr>
<p>这一章的思想跨度较大（可以说很惊人、很震撼且富有美感），可以配合3b1b的图形化视频食用。</p>
<blockquote>
<p>这里总结一下就是，用一个向量点乘另一个向量，实质上是做了一个线性变换。</p>
<p>点积可以看作是矩阵向量乘法的一个特例，是投影到一维的线性变换。</p>
<p>所以矩阵向量乘法的本质是线性变换。</p>
<p>线性变换的“物质载体“ ，则是其中一个向量扮演的。</p>
</blockquote>
<p><strong>考虑一个问题</strong></p>
<p>&#x3D;&#x3D;为什么点乘的运算过程：<strong>对应坐标相乘并将结果相加，和投影有所联系？</strong>&#x3D;&#x3D;</p>
<p>让我们试着证明一下：</p>
<p>还是老样子，</p>
<ol>
<li><p>前提：<strong>等距分布的点保持等距分布，从而为我们保证线性变换的基础。</strong></p>
<blockquote>
<p>否则线性变换，或者说高维向量在一维空间（数轴）上的投影就不是线性的，而是离散的。</p>
</blockquote>
</li>
<li><p>视角：这些线性变换完全由它对i帽和j帽的变换决定，所以只关注i帽、j帽。</p>
<blockquote>
<p>由 i帽 和 j帽 的变换，可以推出二维向量的变换。这也是以前对线性变换的分析方法，不拘泥于过程，由基向量推其他向量。</p>
<p><strong>（u的坐标体现的是i,j向量的变化，而i,j向量就可以反映其余的改变）</strong></p>
</blockquote>
</li>
</ol>
<p>为什么要找i-hat和j-hat投影在斜数轴上？因为一开始那个把二维变一维的函数作的变换就是投影，而投影后的i-hat和j-hat的位置表示这种投影变换。</p>
<blockquote>
<p>i-hat 和 j-hat 的变换则代表了对应的所有列空间向量的变换。</p>
</blockquote>
<p>定义一个从二维向量到数的线性变换，找到描述这个变换的1x2矩阵</p>
<blockquote>
<p>Projection matrix 投影矩阵 Transformation matrix 变换矩阵。</p>
</blockquote>
<p>所以描述投影变换的1x2矩阵的两列，也就是 <strong>i-hat和j-hat在斜数轴上的投影的值，根据对称性，正好分别是斜数轴u-hat的点的横纵坐标 u<del>x</del> , u<del>y</del> 。</strong></p>
<p>因此<strong>空间中任意向量经过投影变换的结果，也就是投影矩阵与这个向量相乘</strong>。</p>
<blockquote>
<p>也就是投影矩阵[u<del>x</del> , u<del>y</del>]与这个向量[i-hat, j-hat]相乘</p>
</blockquote>
<p>这意味着，当一个二维向量v和另一个1x2的矩阵A 相乘时，<strong>这和基向量与u帽的点积在计算上完全相同。</strong> </p>
<blockquote>
<p>选择u帽长度为1并且落在一维数轴上，主要是为了体现后续u帽和i帽、j帽相互映射的对偶性</p>
</blockquote>
<p>这就是为什么与单位向量的点积可以解读为将向量 v 投影到投影矩阵代表的单位向量 u 所在的直线上所得到的投影长度。</p>
<blockquote>
<p>点积是一种将二维向量投影（降维）成一维向量（数轴）的线性变换。</p>
<p>（高维向量在一维的投影）</p>
</blockquote>
<p>矩阵向量相乘 Matrix-vector product &lt;&#x3D;&#x3D;&gt; 点积 Dot product<br>$$<br>\left[\begin{matrix}u_x &amp; u_y \end{matrix}\right]\left[\begin{matrix}x \y \\end{matrix}\right]&#x3D;u_x \cdot x+u_y \cdot y<br>$$<br>↑等价↓<br>$$<br>\left[\begin{matrix}u_x \u_y \end{matrix}\right]\left[\begin{matrix}x \y \\end{matrix}\right]&#x3D;u_x \cdot x+u_y \cdot y<br>$$</p>
<p>你在任何时候看到一个线性变换，它的输出空间是一维数轴。无论它是如何定义的，空间中会存在唯一的向量v与之相关，就这一意义而言，应用线性变换和与向量v做点积是一样的。</p>
<blockquote>
<p>它是数学中“对偶性”的一个实例。</p>
<ul>
<li><p>你可以说一个向量的对偶是由它定义的线性变换；</p>
</li>
<li><p>一个多维空间到一维空间的线性变换的对偶是多维空间中的某个特定向量</p>
</li>
</ul>
</blockquote>
<p><strong>两个向量点乘，就是将其中一个向量转化为线性变换</strong></p>
<p><strong>有时你就会意识到，不把向量看作空间中的箭头，而把它看作线性变换的物质载体，会更容易理解向量</strong></p>
<p>向量就仿佛是一个特定变换的概念性记号。因为对我们来说，想象空间中的向量比想象整个空间移动到数轴上更加容易。</p>
<hr>
<p><strong>举个例子：</strong><br>$$<br>\vec{x}\times\vec{v}&#x3D;\left[\begin{matrix}1 \ -2 \\end{matrix}\right]\left[\begin{matrix}4 \ 3 \\end{matrix}\right]&#x3D;\left[\begin{matrix}1 &amp; -2 \end{matrix}\right]\left[\begin{matrix}4 \ 3 \\end{matrix}\right]&#x3D;4\times1+3\times(-2)<br>$$<br>将列向量 <code>[1 -2]</code> “横过来“ 看作是线性变换矩阵（Transformation matrix），此时，向量 v 的基向量 i-hat 和 j-hat 由默认的<code>[1,0]</code> ,<code>[0 1]</code> 经过线性变换 (乘变换矩阵) 变成了 <code>[1 0],[0 -2]</code> 。</p>
<blockquote>
<p>这个线性变换的效果，实际上是“降维”，将两个二维基向量压缩成一条线（数轴）了，用点来表示，一个指向<code>+1</code> , 一个指向<code>-2</code>。</p>
</blockquote>
<p><code>[4,3]</code>这个向量跟随基向量一起线性变换（降维），变成了指向<code>-2</code>的向量。</p>
<blockquote>
<p><code>4*(+1 0)</code> 表示 i-hat 长度变成4倍， <code>3 *(0 -2)</code>表示 j-hat 长度变 3 倍，叠加在一起就是 - 2 。</p>
</blockquote>
<ul>
<li>当你完全从数值角度进行计算时，它就是矩阵向量乘法，而点积可以看作是矩阵向量乘法的一个特例。</li>
<li>但从几何角度出发，向量<code>[1  -2]</code>转化为线性变换的载体，使另一个向量<code>[4 3]</code>的基向量变换了，于是 向量<code>[4 3]</code>的基向量线性变换后进行放缩（乘以对应倍率），得到的新向量，数值结果和向量乘法一样。</li>
</ul>
<h2 id="9-叉乘"><a href="#9-叉乘" class="headerlink" title="9.叉乘"></a>9.叉乘</h2><p><strong>叉乘标准形式：</strong><br>$$<br>\left[\begin{matrix}a\b\\end{matrix}\right]\times\left[\begin{matrix}c \ d \\end{matrix}\right]&#x3D;(a\times d)-(b\times c)<br>$$</p>
<p>$$<br>\vec{a}\times\vec{b}&#x3D;\left[\begin{matrix}a1 \ a2 \ a3\end{matrix}\right]\times\left[\begin{matrix}b1 \ b2\b3\end{matrix}\right]&#x3D;\left|\begin{matrix}\widehat{i} &amp; \widehat{j} &amp; \widehat{k}\ a1 &amp; a2 &amp; a3\ b1 &amp; b2 &amp; b3\end{matrix}\right|<br>$$</p>
<blockquote>
<p>i 的余子式 + j 的余子式 + k 的余子式</p>
</blockquote>
<p><strong>叉乘几何意义：</strong></p>
<p>a<del>1</del>b<del>1</del>两个向量分别平移相交成 a<del>2</del>b<del>2</del>，四个向量a<del>1</del>a<del>2</del>b<del>1</del>b<del>2</del>围成的平行四边形的面积就是叉乘的绝对值。</p>
<p>正负性（定向问题）：以<code>a * b</code>为例。如果在二维平面上，a 在 b 右边（b需要经过右旋转到a），那么a*b就是正值。</p>
<p>如果a 在 b 左边（b需要经过左旋转到a），那么a*b就是负值。</p>
<blockquote>
<p>注意：这是说顺序对叉乘有影响。</p>
</blockquote>
<p><strong>几何角度观察定向：</strong> i-hat 在 j-hat 右边，<code>i * j = +1</code> 。那么 a 在 b 右边，<code>a * b = +</code></p>
<blockquote>
<p>基向量的顺序就是定向的基础</p>
</blockquote>
<hr>
<p><strong>行列式的面积和叉乘有很大关系。</strong><br>$$<br>\left[\begin{matrix}a\b\\end{matrix}\right]\times\left[\begin{matrix}c \ d \\end{matrix}\right]&#x3D;\left|\begin{matrix}a &amp; c\ b &amp; d\end{matrix}\right|&#x3D;(a\times d)-(b\times c)<br>$$</p>
<p><code>a,b</code>两个向量相乘 ，你只需要将 a向量作为行列式第一列，b向量作为行列式第二列，然后直接计算行列式。</p>
<p>所以：</p>
<ol>
<li><p>这里可以一个解释行列式性质：交换任意两行，行列式正负性改变。</p>
<p><strong>几何上，两个向量叉乘交换顺序了，定向改变了，向量的基改变了，行列式为负不是很自然的吗？</strong></p>
</li>
<li><p>你可能注意到一点，**当两个向量接近垂直时，他们的叉积最大。**因为此时构成的平行四边形面积最大。</p>
</li>
<li><p><strong>放大其中一个向量3倍，那么叉乘也增大3倍</strong>。从面积上理解也很自然。</p>
</li>
</ol>
<hr>
<p>根据上面的二维向量叉乘，如果让我们猜测三维向量的叉乘，大概是：<br>$$<br>\left[<br>\begin{matrix}<br>u_1 \ v_1 \ w_1<br>\end{matrix}<br>\right]</p>
<p>\times</p>
<p>\left[<br>\begin{matrix}<br>u_2\ v_2 \ w_2<br>\end{matrix}<br>\right]</p>
<p>\times</p>
<p>\left[<br>\begin{matrix}<br>u_3 \v_3 \ w_3<br>\end{matrix}<br>\right]&#x3D;</p>
<p>\left|<br>\begin{matrix}<br>u_1 &amp; u_2  &amp; u_3\ v_1 &amp; v_2 &amp; v_2\w_1 &amp; w_2 &amp; w_3<br>\end{matrix}<br>\right|<br>(这里是错误的猜想)<br>$$<br>输入三个向量，输出一个行列式（数值），这个行列式的数值是三维空间里，三个向量组成的体积。</p>
<blockquote>
<p>虽然这么想很自然，却又<strong>还不是真正的叉积</strong>，但已经很接近了。</p>
</blockquote>
<p><strong>真正的叉积是通过两个三维向量生成一个新的三维向量。</strong></p>
<p>叉积的结果不是一个数，而是一个向量。很奇怪吧？</p>
<p>这个<strong>向量的长度就是平行四边形的面积</strong>，而这个<strong>向量的方向与平行四边形(所在的面)垂直。</strong></p>
<p>垂直方向有两个，至于是哪一个，要靠“<strong>右手定则”：</strong></p>
<ul>
<li>食指指向i帽的方向；</li>
<li>伸出中指指向j帽的方向；</li>
<li>当你把大拇指竖起来时，它就正好指向k帽的方向。</li>
</ul>
<blockquote>
<p>注意：第4节行列式也出现了右手定则。</p>
</blockquote>
<p>&#x3D;&#x3D;这里要证明一件事：<strong>为什么叉积生成的新三维向量有这个性质？</strong>&#x3D;&#x3D;</p>
<p><strong>思路一：直接数值运算</strong></p>
<blockquote>
<p>很直接很暴力，也很麻烦。这不是我们今天要讨论的。</p>
</blockquote>
<p><strong>思路二：几何思路</strong></p>
<blockquote>
<p>前提：<strong>对偶性思想</strong>——上一节点乘用到的思想。</p>
<p>每当你看到一个(多维)空间到数轴的线性变换时，它都与空间中的唯一个向量对应，也就是说应用线性变换和与这个向量点乘等价，数值上说，这是因为这类线性变换可以用一个只有一行的矩阵描述，而它的每一列给出了变换后基向量的位置。</p>
<p>这里的收获在于，每当你看到一个从空间到数轴的线性变换，你都能够找到一个向量，被称为<strong>这个变换的对偶向量</strong>（dual vector），使得应用线性变换和与对偶向量点乘等价。</p>
</blockquote>
<p>叉积的运算同样体现了对偶性思想。</p>
<p>现在，我们将刚刚上面的猜想叉积的第一个向量u看作可变向量，比如(x,y,z)，而v和w保持不变，那么我们就有一个<strong>从三维空间到数轴的函数</strong>了。</p>
<blockquote>
<p>这个函数根据v和w来定义（因变量），输入<code>(x,y,z)</code>（自变量）产生行列式（结果）。</p>
<p>你输入一个向量(x,y,z)，然后通过矩阵的行列式得到一个数，这个向量的第一列是(x, y,z)，其余两列是常向量v和w的坐标。</p>
</blockquote>
<p>$$<br>f\left(<br>\left[<br>\begin{matrix}<br>x \ y \ z<br>\end{matrix}<br>\right]<br>\right)&#x3D;<br>det<br>\left(<br>\left[<br>\begin{matrix}<br>x &amp; v_1 &amp; w_1 \<br>y &amp; v_2 &amp; w_2 \<br>z &amp; v_3 &amp; w_3<br>\end{matrix}<br>\right]<br>\right)<br>$$</p>
<p>$$<br>变量variable&#x3D;<br>\vec{u}&#x3D;<br>\left[<br>\begin{matrix}<br>x \ y \ z<br>\end{matrix}<br>\right]</p>
<p>&amp; \vec{v} &#x3D;<br>\left[<br>\begin{matrix}<br>v_1 \ v_2 \ v_3<br>\end{matrix}<br>\right]</p>
<p>&amp; \vec{w} &#x3D;<br>\left[<br>\begin{matrix}<br>w_1 \ w_2 \ w_3<br>\end{matrix}<br>\right]<br>$$</p>
<blockquote>
<p>这里将向量写作矩阵的列，而<strong>教科书中大多将向量写作矩阵的行</strong>。两种结果没有差异，因为转置不改变行列式的值。这里选择按列处理向量是为了更加直观。</p>
</blockquote>
<p>这个函数的几何意义是，对于任一输入的向量(x, y,z), 考虑由它和v与w确定的<strong>平行六面体,得到它的体积，然后根据定向确定符号。</strong></p>
<blockquote>
<p><strong>这个函数是线性的</strong>，由行列式性质可知：</p>
<p>行列式就是三个向量所夹的平行六面体的体积。这个平行六面体的底面积是定下来的，所以如果高是线性的体积就是线性的。</p>
</blockquote>
<p>一旦知道它是线性的，你就知道<strong>可以通过矩阵乘法来描述</strong>这个函数。</p>
<p>即<strong>这个函数从三维空间到一维空间的每个线性变换，都存在一个1x3矩阵来代表这个变换。</strong>	</p>
<blockquote>
<p>对偶性告诉我们，你可以将这个1*3矩阵立起来，并且将整个变换看作与这个特定向量的点积。</p>
</blockquote>
<p>$$<br>\overbrace{<br>\left[<br>\begin{matrix}<br>? \ ? \ ?<br>\end{matrix}<br>\right]<br>}^{神秘1\times3矩阵}</p>
<p>\left[<br>\begin{matrix}<br>x \ y \ z<br>\end{matrix}<br>\right]&#x3D;</p>
<p>\overbrace{<br>\left[<br>\begin{matrix}<br>p_1 \ p_2 \ p_3<br>\end{matrix}<br>\right]<br>}^{这是\vec{p}}</p>
<p>\left[<br>\begin{matrix}<br>x \ y \ z<br>\end{matrix}<br>\right]&#x3D;</p>
<p>det<br>\left(<br>\left[<br>\begin{matrix}<br>x &amp; v_1 &amp; w_1 \<br>y &amp; v_2 &amp; w_2 \<br>z &amp; v_3 &amp; w_3<br>\end{matrix}<br>\right]<br>\right)<br>$$</p>
<p>我们要找的就是这个特殊的三维向量——我称之为p向量。由上式可知，p与其他任一向量(x,y,z)的点积等于一个3x3矩阵的行列式。</p>
<p><strong>对于这个式子，有两种理解角度：计算和几何</strong></p>
<ul>
<li><p>计算</p>
<p>上式经过点乘：<br>$$<br>p1\cdot x+p2\cdot y+p3\cdot z&#x3D;\begin{matrix}x(v2\cdot w3-v3\cdot w2)+ \y(v3\cdot w1-v1\cdot w3)+ \z(v1\cdot w2-v2\cdot w1)\end{matrix}<br>$$<br>所以很明显可以看出，我们要找的 p向量 的值就藏在右边的<code>v</code>和<code>w</code>坐标的线性组合中。<br>$$<br>\vec{p}&#x3D;\left[\begin{matrix}p1 \ p2 \ p3\end{matrix}\right]&#x3D;\begin{cases}p1 &#x3D; v2\cdot w3-v3\cdot w2 \p2&#x3D;v3\cdot w1-v1\cdot w3 \p3&#x3D;v1\cdot w2-v2\cdot w1\end{cases}<br>$$</p>
<blockquote>
<p>点积本是上是替换掉了原有的基向量，而叉积的行列式定义中有三个基向量正好可以用点积操作替换掉。</p>
</blockquote>
<p>像这样合并x、y和z前面的常数项，和把i帽、i帽和k帽放进矩阵第一列进行计算，然后合并各项前面的系数没有区别。</p>
<blockquote>
<p>把i帽、i帽和k帽放进矩阵第一列进行计算，正是老师根据教科书，叫我们死记硬背的叉积公式！</p>
</blockquote>
<p><strong>在矩阵中插入i帽、j帽和k帽不过是在传递一个信号，告诉我们应该把这些系数解读为一个向量的坐标。</strong></p>
<p>好了，推导结束了。总结一下：</p>
<p><strong>当你将向量p和某个向量<code>(x,y,z)</code>点乘时，所得结果等于一个由<code>(x,y,z)</code>和v与w确定的平行六面体的有向体积，数值上是一个3x3矩阵的行列式，这个行列式第一列为(x,y,z)，其余两列为v和w的坐标。</strong></p>
<blockquote>
<p>这是计算角度的总结。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>让我们从几何角度看看，什么样的向量p才能满足这一特殊性质 ?</p>
</blockquote>
<ul>
<li><p>几何</p>
<ul>
<li><p>对于点积，向量p与其他向量的点积的几何解释，是将其他向量投影到p上，然后将投影长度与p的长度相乘。</p>
</li>
<li><p>而对于叉积，上文中我们用一个线性函数来代表它。</p>
<p>我们找到的线性函数对于给定向量的作用，也就是 p 作为一个 1x3矩阵，代表着一个线性变换；这个线性变换<strong>将向量投影到垂直于v和w的直线上，然后将投影长度与v和w张成的平行四边形的面积相乘。</strong></p>
<blockquote>
<p>这和<code>(x,y,z</code>) 与 <code>垂直于v和w且长度为平行四边形面积的向量</code>点乘是同一回事。</p>
</blockquote>
</li>
</ul>
<p>首先获得由v和w确定的平行四边形的面积，乘以向量(x,y,z)在垂直于平行四边形方向上的分量(不是(x,y,z)的长度，是投影)，我们就可以得到这个平行六面体的体积，</p>
<blockquote>
<p>总结一下就是底面积(v,w)乘高(p投影)。</p>
</blockquote>
<p>更重要的是，如果你选择了合适的向量方向(点积为正)就会与(x,y,z)、v和w满足右手定则的情况相吻合。</p>
<p><strong>这意味着我们找到了这个p，使得p与和某个向量(x,y,z)点乘时，所得结果等于和上面计算得来的3x3矩阵的行列式是一致的。</strong></p>
<p>这就是我们要找的，计算和几何得出的同一个向量 p 。</p>
</li>
</ul>
<h2 id="10-基变换"><a href="#10-基变换" class="headerlink" title="10.基变换"></a>10.基变换</h2><p>同一个向量，在基向量不同的坐标系，会有不同的表达方法。这就像不同的语言，虽然我们都在关注空间中的同一个向量，但是我们可以用不同的语言和数字来描述它。不同的基向量，坐标轴的方向与网格间距会有所不同。</p>
<p>于是一个很自然的问题：&#x3D;&#x3D;如何在不同坐标系之间进行转化?&#x3D;&#x3D;</p>
<p>假设你的朋友詹妮弗自己建立了一个坐标系，第一个基向量b1 &#x3D; (2,1) , 第二个基向量b2&#x3D;  (-1,1)</p>
<blockquote>
<p>在她的坐标系中，这两个向量的坐标为(1,0)和(0,1)</p>
</blockquote>
<p>对于向量[-1 2] ，她的坐标系里，这个向量是-1乘以b1加上2乘以b2。</p>
<blockquote>
<p>此时，坐标系背后的“网格”也发生了变化，不再是由基向量(1,0)、(0,1)构成的正方形，而是由(2,1)、(-1,1)构成的平行四边形。</p>
<p>所以她的坐标轴的方向和网络间距会有所不同。</p>
</blockquote>
<p>从我们的角度来看，b1的坐标为(2，1)，b2的坐标为(-1，1)，所以实际上，我们可以直接计算-1乘以b1加上2乘以b2，因为它们都是在我们的坐标系中表示的。计算后得到的是[-4 1] 的向量。</p>
<p>这里发生的过程，也就是<strong>用某个向量的特定坐标与她的基向量数乘，这不就是矩阵向量乘法吗？</strong></p>
<blockquote>
<p>这个矩阵的列代表的是用我们的语言表达的詹妮弗的基向量。</p>
</blockquote>
<p>一个矩阵的列为詹妮弗的基向量,这个矩阵可以看作一个线性变换。</p>
<blockquote>
<p>它将我们的基向量i帽和j帽，也就是我们眼中的(1, 0)和(0,1)变换为詹妮弗的基向量，也就是她眼中的(1,0)和(0，1)</p>
</blockquote>
<p>&#x3D;&#x3D;这里有一个疑惑：&#x3D;&#x3D;<br>$$<br>Our ; grid \longrightarrow Jennifer’s;grid \\left(\begin{matrix}2 &amp; -1 \ 1 &amp; 1\end{matrix}\right)\Jennifer’s;language \longleftarrow Our ; language<br>$$<br>从几何上说，这个矩阵将我们的网格变换为詹妮弗的网格,</p>
<p>但是从数值上说，这是用她的语言来描述转化为用我们的语言来描述。</p>
<p>让我们恍然大悟的是，把它看作将我们对詹妮弗的向量的误解，也就是<strong>在我们的坐标系中具有相同坐标的向量，变成她真正想要表示的向量。</strong></p>
<p>&#x3D;&#x3D;那么反方向呢？&#x3D;&#x3D;</p>
<p>我们的坐标系中的<code>(3，2)</code>的向量，怎么得到詹妮弗坐标系中的<code>(5\3, 1\3)</code></p>
<p>之前的基变换矩阵是从詹妮弗的语言转化到我们的语言，那<strong>我们对矩阵取个逆不就好了 ！</strong></p>
<blockquote>
<p>记住一点，一个变换的逆是一个新的变换,他讲对应的变换逆向进行。</p>
</blockquote>
<p>以上就是如何在坐标系之间对单个向量的描述进行相互转化。</p>
<p><strong>总结</strong>：一个矩阵的列代表的是詹妮弗的基向量，却是用我们的坐标来描述；对于一个向量，这个矩阵将她的语言描述转化为我们的语言描述。逆矩阵则相反。</p>
<hr>
<p><strong>向量并不是唯一用坐标表示的东西。线性变换同样要用坐标向量表示。</strong></p>
<blockquote>
<p>这就涉及到了基向量问题(看待坐标的视角)</p>
</blockquote>
<p>考虑某个线性变换，譬如逆时针旋转90你我用矩阵代表它的时候，我们是在跟踪i帽和j帽的去向。</p>
<blockquote>
<p>i帽在变换后处于坐标(0，1)  而j帽在变换后处于坐标(-1，0)。</p>
<p>这些坐标也就成为了矩阵的列</p>
</blockquote>
<p>$$<br>\left(\begin{matrix}0 &amp; 1 \ -1 &amp; 0\end{matrix}\right)<br>$$</p>
<p>但是这种表示与我们对基向量的选择密切相关。因为我们跟踪的是i帽和j帽,并且是在我们自己的坐标系中记录它们的去向。</p>
<p>&#x3D;&#x3D;而詹妮弗如何描述同样的空间90°旋转呢?&#x3D;&#x3D;</p>
<p>你可能会尝试只将旋转矩阵的列转化为用詹妮弗的语言描述——因为这些列代表的是i帽和j帽的去向。</p>
<p>但是这些列代表的仍然是我们的基不是她的基。而詹妮弗想要的矩阵需要代表她的基向量的去向,也就是用她的语言描述。<br>$$<br>\overbrace{\left[\begin{matrix}-1 \ 2\end{matrix}\right]}^{Vector;in;Jannifer’s;language}\longrightarrow\overbrace{\underbrace{\left[\begin{matrix}2 &amp; -1 \ 1 &amp; 1\end{matrix}\right]}<em>{基变换矩阵}\left[\begin{matrix}-1 \ 2\end{matrix}\right]<br>}^{Same;vector;in;our;langugae}\longrightarrow<br>\quad\overbrace{\underbrace{\left[\begin{matrix}0 &amp; -1 \ 1 &amp; 0\end{matrix}\right]}</em>{变换矩;in;our;language}\left[\begin{matrix}2 &amp; -1 \ 1 &amp; 1\end{matrix}\right]\left[\begin{matrix}-1 \ 2\end{matrix}\right]}^{变换后向量;in;our;language}<br>$$</p>
<p>$$<br>\left[\begin{matrix}0 &amp; -1 \ 1 &amp; 0\end{matrix}\right]\left[\begin{matrix}2 &amp; -1 \ 1&amp; 1\end{matrix}\right]\left[\begin{matrix}-1 \ 2\end{matrix}\right]\longrightarrow\overbrace{\underbrace{\left[\begin{matrix}2 &amp; -1 \ 1 &amp; 1\end{matrix}\right]^{-1}}_{基变换矩阵的逆}\left[\begin{matrix}0 &amp; -1 \ 1 &amp;0\end{matrix}\right]\left[\begin{matrix}2 &amp; -1 \ 1 &amp; 1\end{matrix}<br>\right]\left[\begin{matrix}-1 \ 2\end{matrix}\right]}^{变换后向量;in;Jannifer’s;language}<br>$$</p>
<p>因为我们能够对詹妮弗语言描述的任一向量做同样的事: </p>
<p>&#x3D;&#x3D;基变换 → 线性变换 → 基变换的逆&#x3D;&#x3D;</p>
<p><strong>这三个矩阵的复合给出的就是用詹妮弗语言描述的线性变换矩阵</strong>。</p>
<p>它接收用詹妮弗语言描述的向量，并输出用詹妮弗语言描述的变换后的向量。</p>
<p>所以，如果詹妮弗用这个矩阵与她的坐标系中的一个向量相乘，结果就是在她的坐标系中描述的该向量旋转90°的结果。</p>
<p>总结：每当你看到这样一个表达式:A逆乘以M乘以A*(P^-1^AP &#x3D; B),这就<strong>暗示着一种数学上的转移作用</strong>。</p>
<blockquote>
<p>中间的矩阵代表一种你所见的变换，而外侧两个矩阵代表着转移作用，也就是视角上的转化。</p>
<p><strong>矩阵乘积仍然代表着同一个变换，只不过是从其他人的角度来看的。</strong></p>
</blockquote>
<p><strong>基变换两个应用实例：</strong></p>
<p>1.特征值与特征向量</p>
<p>2.相似对角化。</p>
<h2 id="11-特征值和特征向量"><a href="#11-特征值和特征向量" class="headerlink" title="11.特征值和特征向量"></a>11.特征值和特征向量</h2><ul>
<li>&#x3D;&#x3D;引言&#x3D;&#x3D;</li>
</ul>
<p>首先，考虑二维空间中的某个线性变换：<br>$$<br>\left[\begin{matrix}3 &amp; 1 \0 &amp; 2\end{matrix}\right]<br>$$</p>
<blockquote>
<p>它将基向量i帽变换到坐标(3,0)，j帽变换到坐标(1,2)</p>
</blockquote>
<p>我们关注它对一个特定向量的作用，并且考虑这个向量张成的空间，也就是通过原点和向量尖端的<strong>直线</strong>。<br>大部分向量在变换中都离开了其张成的空间；</p>
<blockquote>
<p>所以如果向量正好落在这条直线上，感觉更像是巧合。不过，某些特殊向量的确留在它们张成的空间里，意味着矩阵对它的作用仅仅是拉伸或者压缩而已，如同一个标量。</p>
</blockquote>
<p>在这个例子中，&#x3D;&#x3D;基向量i帽&#x3D;&#x3D;就是这样一个特殊向量。i帽张成的空间是x轴，i帽变成了原来的3倍，仍然留在x轴上。</p>
<blockquote>
<p>此外，因为线性变换的性质，x轴上的任何其他向量都只是被拉伸为原来的3倍，因此也就留在它们张成的空间里。</p>
</blockquote>
<p>有一个略显隐蔽的&#x3D;&#x3D;向量(-1,1)&#x3D;&#x3D;，它在变换中也留在自己张成的空间里，最终被拉伸为原来的2倍；</p>
<blockquote>
<p>同上，线性性质暗示着，处在它所张成的对角线上的其他任何一个向量，也仅仅被拉伸为原来的2倍。</p>
</blockquote>
<p>所以你猜到了吗？<strong>这两个保持在自己的span的特殊向量就被称为特征向量。每个特征向量都有一个所属的值，被称为“特征值”, 即衡量特征向量在变换中拉伸或压缩比例的因子。</strong></p>
<p>如果特征向量是负值1&#x2F;2 ，意味着这个向量被反向，并且被压缩为原来的1&#x2F;2。</p>
<p><strong>重点在于，它仍然停留在它张成的直线上，并未随着线性变换发生旋转。</strong></p>
<blockquote>
<p>特征向量的一个应用：三维空间旋转。</p>
<p>例如一个立方体，旋转的话，如果你能找到这个旋转的特征向量，那么你找到的就是旋转轴。这种情况下，相应的特征值必须为1，因为旋转不缩放任何一个向量。</p>
</blockquote>
<p>旋转的应用告诉我们：</p>
<p>对于任一矩阵描述的线性变换，你可以通过将矩阵的列看作变换后的基向量来理解它。但今天我们学习了特征向量，那么在不依赖于特定坐标系（基向量变化）的前提下，一种更较好且常用的的理解方式就是特征向量和特征值。</p>
<blockquote>
<p>对于一个矩阵A有两种理解方式 一种理解方式是基于坐标系的，认为矩阵的每一个列向量是线性变换后的基向量；另一种理解方式使用特征向量和特征值。</p>
</blockquote>
<ul>
<li>&#x3D;&#x3D;概念&#x3D;&#x3D;</li>
</ul>
<p>$$<br>\overbrace{A}^{变换矩阵};\vec{v}&#x3D;\lambda\overbrace{\vec{v}}^{特征值} \<br>\quad\searrow\quad\swarrow\\quad;特征向量<br>$$</p>
<blockquote>
<p><code>矩阵向量乘积 = 向量数乘</code> 。因此求解矩阵A的特征向量和特征值，实际上就是求解使得这个等式成立的向量v和数λ。</p>
</blockquote>
<p>想理解这个式子，首先要解决乘积类型不同的问题。</p>
<p>所以我们首先将等号右侧重写为某个矩阵向量乘积，让 λ 当成某个矩阵。</p>
<blockquote>
<p><strong>其中，矩阵的作用效果是将任一向量乘以 λ，这个矩阵的列代表着变换后的基向量，而每个基向量仅仅与λ相乘</strong><br><strong>所以这个矩阵的对角元均为λ，其余位置都是0。</strong></p>
</blockquote>
<p>无非是 λE，乘以一个单位矩阵E。</p>
<p>我们就能将等号右侧的东西移到左侧，然后提出因子v<br>$$<br>(A-\lambda I)\vec{v} &#x3D; \vec{0}<br>$$<br>左括号里的矩阵类似于下面这种矩阵<br>$$<br>\left[ \begin{matrix}3-\lambda &amp; 1 &amp; 4\1 &amp; 5-\lambda &amp; 9\2 &amp; 6 &amp; 5-\lambda\end{matrix}\right]<br>$$<br>于是我们可以寻找一个向量v，使得这个新矩阵与v相乘结果为零向量。</p>
<ol>
<li><p><strong>首先是v自己是零向量</strong>。这时等式恒成立。</p>
<blockquote>
<p>这种情况比较无聊，看下面。</p>
</blockquote>
</li>
<li><p><strong>v不是零向量</strong>。这时考虑前面学到的内容，当且仅当矩阵代表的线性变换<strong>将空间压缩到更低的维度时</strong>，才会存在一个非零向量使得矩阵和它的乘积为零向量。</p>
<blockquote>
<p>简单说，非<strong>零向量是有长度滴。线性变换想让它变成一个点，只能通过降维压缩。</strong></p>
</blockquote>
<p><strong>那么考考大家，什么特性的矩阵能降维压缩？——行列式为0的矩阵（压缩完面积为0）。</strong></p>
<p>观察括号式子代表的矩阵，有一个变量λ。在上面那个例子中，λ&#x3D;1时行列式为 0。</p>
<blockquote>
<p>当然，对于其他矩阵，特征值不一定是1，λ取其他值时才能使行列式为零。</p>
<p>这里3b1b的原视频有一个随着λ变化，向量逐渐线性变换的过程，很精彩！</p>
</blockquote>
<p>这个 λ 值保证了概念式子的成立，也就说明此时向量v是A的一个特征向量，在变换中停留在它张成的空间里。</p>
<blockquote>
<p>在这个例子中，v对应的特征值是1，所以它实际上保持不变</p>
</blockquote>
</li>
</ol>
<p><strong>举例说明：</strong><br>$$<br>det<br>\left(\left[\begin{matrix}3 &amp; 1 \0 &amp;2\end{matrix}\right]\right)&#x3D;(3-\lambda)(2-\lambda)&#x3D;0<br>$$<br>还是开头这个例子，求解它的特征值，将对角元减去λ，然后计算行列式。这样我们就得到了一个关于入的二次多项式<code>(3-入)(2-入)</code>。由上面的推论可知，只有行列式为零时，λ 才会是特征值。所以这个矩阵的λ &#x3D; 2 或 λ &#x3D; 3。<br>$$<br>\left[\begin{matrix}3-\lambda &amp; 1 \0 &amp; 2-\lambda\end{matrix}\right]\left[\begin{matrix}x \ y\end{matrix}\right]&#x3D;\left[\begin{matrix}0 \ 0 \end{matrix}\right]<br>$$<br>为了求出属于特征值的特征向量，将 λ 代入到矩阵中，然后求解出在能经过个矩阵的线性变换后成为零的向量。于是得到<code>x+y = 0</code></p>
<blockquote>
<p>你会发现所有的解全部落在由向量(-1,1)张成的对角线上</p>
</blockquote>
<p>与之对应的，就是原始的矩阵[(3,0)，(1,2)]将这些向量拉伸为原来的2倍。</p>
<hr>
<p>&#x3D;&#x3D;三个特征向量的特殊情况&#x3D;&#x3D;</p>
<p><strong>1.二维线性变换不一定有特征向量</strong></p>
<p>比如正交变换：<br>$$<br>\left[\begin{matrix}0 &amp; -1 \-1 &amp; 0\end{matrix}\right]<br>$$<br>它并没有特征向量，因为每一个向量都发生了旋转并离开了其张成的空间。硬去求特征值，会得到 λ^2^+1&#x3D;0 。有两个虚数解而没有实数解。没有实数解表明它没有特征向量。</p>
<blockquote>
<p>扩展：但虚数和复平面有关系。与1相乘在复平面中表现为90度旋转和i是这个二维实向量旋转变换的特征值有所关联。特征值出现复数的情况般对应于变换中的某种旋转大。</p>
<p>具体细节这里不深究了。</p>
</blockquote>
<p><strong>2.剪切变换：</strong><br>$$<br>\left[\begin{matrix}1 &amp; 1 \0 &amp; 1\end{matrix}\right]<br>$$<br>所有x轴上的向量都是属于特征值1的特征向量，因为它们都保持不变</p>
<p>当你将对角元减去入，然后计算行列式,你得到的是 (1-λ)^2^  —— λ 是重根。</p>
<blockquote>
<p>几重根就表明最多对应几个线性无关的特征向量</p>
</blockquote>
<p>这与几何上得到的“所有特征向量均属于特征值1”的结果一致。</p>
<p><strong>3.可能会出现只有一个特征值，但是特征向量不止在一条直线上的情况</strong>:<br>$$<br>\left[\begin{matrix}2 &amp; 0 \0 &amp; 2\end{matrix}\right]<br>$$<br>一个简单的例子是将所有向量变为两倍的矩阵。</p>
<p>唯一的特征值是2，但是平面内<strong>每一个向量都是属于这个特征值的特征向量。</strong></p>
<hr>
<p>&#x3D;&#x3D;如果的基向量都是特征向量，会发生什么？&#x3D;&#x3D;<br>$$<br>\left[\begin{matrix}-1 &amp; 0 \0 &amp; 2\end{matrix}\right]<br>$$<br>比如说，可能i帽变为原来的(-1)倍，j帽变为原来的2倍，将它们的新坐标作为矩阵的列。</p>
<p>注意，它们的倍数-1和2，也就是i帽和j帽所属的特征值，位于矩阵的对角线上，而其他元素均为0。</p>
<p>像这种除了对角元以外其他元素均为0的矩阵被称为对角矩阵,</p>
<p>解读它的方法是，<strong>所有基向量都是特征向量。矩阵的对角元是它们所属的特征值</strong></p>
<p><strong>对角矩阵有很多有趣的性质：</strong></p>
<p>其中一个重要的方面是，<strong>对角矩阵与自己多次相乘的结果更容易计算</strong></p>
<blockquote>
<p>因为对角短阵仅仅让基向量与某个特征值相乘,所以多次应用矩阵乘法，比如100次，也只是将每个基向量与对应特征值的100次幂相乘。</p>
</blockquote>
<p>但这种基向量是特征向量的情况，你可能很难遇到。</p>
<p>如果你的变换有许多特征向量，就像上面有两条的矩阵，<strong>多到你能选出一个张成全空间的集合，那么你就能变换你的坐标系，使得这些特征向量就是基向量</strong></p>
<blockquote>
<p>空间有几维，就找出几个线性无关的特征向量。</p>
<p>二维找两个特征向量，三维找三个。</p>
</blockquote>
<p>所以又想到相似对角化了吗？矩阵A能对角化的充要条件是A有n个线性无关的特征向量!!!</p>
<blockquote>
<p>这里还用到了上一节的基变换。</p>
</blockquote>
<p>基变换矩阵是特征向量构成的，而特征向量是当前空间进行中间矩阵变换时不空间不变化的向量。</p>
<p>所以<strong>把当前空间的变换转换到特征基的空间后，变换就变成了对基的放缩操作，也就是特征值构成的矩阵</strong></p>
<blockquote>
<p>用特征向量作为基向量，变换只对基作伸缩。所以这个新矩阵必然是对角的，并且对角元为对应的特征值</p>
</blockquote>
<p>所以一组基向量(同样是特征向量)构成的集合被称为一组“特征基”</p>
<p>所以如果你要计算这个矩阵的100次幂，更容易的做法是先变换到特征基，在那个坐标系中计算100次幂。然后转换回标准坐标系。</p>
<blockquote>
<p>不是所有变换都能进行这一过程。比如说剪切变换，它的特征向量不够多，并不能张成全空间。但是如果你能找到一组特征基，矩阵运算就会变得非常轻松</p>
</blockquote>
<h2 id="12-抽象向量空间"><a href="#12-抽象向量空间" class="headerlink" title="12.抽象向量空间"></a>12.抽象向量空间</h2><p>向量根本上并不是由一组实数构成，它们的本质其实更具空间性。</p>
<p>从某种意义上说，函数实际上只是另一种向量。函数既满足向量的可加性，又满足成比例。而对向量所能进行的操作不过相加和数乘两种。</p>
<p>所以，最初以空间中的箭头为背景考虑的线性代数的合理概念和解决问题的手段，应该能够原封不动地被我们取出来用于函数。</p>
<p>比如：</p>
<ul>
<li><p>&#x3D;&#x3D;线性变换&#x3D;&#x3D;：函数的线性变换接收一个函数，我并把它变成另一个函数。微积分中的&#x3D;&#x3D;导数&#x3D;&#x3D;满足这个性质。</p>
<blockquote>
<p>关于这点，有时你听到的是“算子”而不是“变换” 。（线性算子）</p>
</blockquote>
<p><strong>注意</strong>：导数既满足可加，又满足成比例。所以<strong>求导是一种线性运算。</strong></p>
</li>
<li><p>&#x3D;&#x3D;基向量&#x3D;&#x3D;：函数空间倾向于无穷维，整个空间包含了任意高次的多项式。</p>
<blockquote>
<p>我们见到的多项式往往是有限项。</p>
</blockquote>
<p>我们要做的是给这个空间赋予坐标的含义，这需要选取一个基。因为多项式已经是数乘x的不同次幂再做加和的形式，所以我们很自然地<strong>取x的不同次幂作为基函数。</strong></p>
<p><strong>基函数举例：</strong><br>$$<br>1x^2+3x+5<br>$$<br>第一个基函数是常函数：b<del>0</del>(x) &#x3D; 1 (5*1&#x3D;5)</p>
<p>第二个基函数是b<del>1</del>(x) &#x3D; x</p>
<p>第三个基函数是b<del>2</del>(x) &#x3D; x^2^</p>
<p>……</p>
<p>基函数在这里起到的作用，和i帽、j帽和k帽在向量(箭头)的世界中起到的作用类似。</p>
<blockquote>
<p>因为多项式的次数可以任意高，所以这个基函数集也是无穷大的。</p>
</blockquote>
<p>上述多项式的坐标就是 5、3、1、0、0、0……</p>
<p>多项式4x^5^-5x^2^的坐标就是0、0、-5、0、0、4，然后加上一串无限长的0。</p>
<p><strong>总的来说，因为每一个多项式都只有有限项，所以它的坐标就是有限长的一串数，再跟上无限长的一串零。</strong></p>
</li>
<li><p>&#x3D;&#x3D;矩阵求导&#x3D;&#x3D;：在这个坐标系中，求导是用一个无限阶矩阵描述的。</p>
<p>你可以用这种方法构建这个矩阵:求每一个基函数的导数，然后把结果放在对应列。<br>$$<br>\begin{matrix}b_0(x)&#x3D;1\b_1(x)&#x3D;x\b_2(x)&#x3D;x_2\b_3(x)&#x3D;x_3\\end{matrix}\qquad\frac{d}{dx}b_0(x)&#x3D;\frac{d}{dx}(1)&#x3D;\left[\begin{matrix}0 \ 0 \ 0 \0\end{matrix}\right]\qquad\frac{d}{dx}b_1(x)&#x3D;\frac{d}{dx}(x)&#x3D;\left[\begin{matrix}1 \ 0 \ 0 \0\end{matrix}\right]\qquad<br>$$</p>
<p>$$<br>\frac{d}{dx}b_2(x)&#x3D;\frac{d}{dx}(x^2)&#x3D;2x&#x3D;\left[\begin{matrix}0 \ 2 \ 0 \0\end{matrix}\right]\qquad\frac{d}{dx}b_3(x)&#x3D;\frac{d}{dx}(x^3)&#x3D;2x&#x3D;\left[\begin{matrix}0 \ 0 \ 3 \0<br>\end{matrix}\right]<br>\qquad\frac{d}{dx}b_4(x)&#x3D;\frac{d}{dx}(x^4)&#x3D;2x&#x3D;\left[\begin{matrix}0 \ 0 \ 0 \4\end{matrix}\right]<br>$$</p>
<p>最终得到一个矩阵：<br>$$<br>\left[\begin{matrix}\ 0 &amp;1 &amp; 0 &amp; 0 &amp; 0\0 &amp;0 &amp; 2 &amp; 0 &amp; 0\0 &amp;0 &amp; 0 &amp; 3 &amp; 0\0 &amp;0 &amp; 0 &amp; 0 &amp; 4\end{matrix}\right]<br>$$</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>乍一看，矩阵向量乘法和求导像是毫不相干的。</p>
<table>
<thead>
<tr>
<th>线性代数</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>Linear transformations 线性变换   <br/></td>
<td>Linear operators线性算子<br/></td>
</tr>
<tr>
<td>Dot products 点积</td>
<td>Inner products 内积</td>
</tr>
<tr>
<td>Eigenvectors 特征向量</td>
<td>Eigenfunctions特征函数</td>
</tr>
</tbody></table>
<ul>
<li>向量空间：</li>
</ul>
<p>我想在这里指出的是，<strong>数学中有很多类似向量的事物，只要你处理的对象集具有合理的数乘和相加概念。</strong></p>
<p>不管是空间中的<strong>箭头、一组数、函数</strong>的集合，还是你定义的其他奇怪东西的集合。线性代数中所有关于向量、线性变换和其他的概念都应该适用于它。<strong>这些类似向量的事物，比如箭头、一组数、函数等，它们构成的集合被称为“向量空间’</strong></p>
<p>针对向量空间，数学家们建立了一系列向量加法和数乘必须遵守的规则，这些规则称为“公理”。</p>
<p><strong>只要你定义的新家伙满足这些规则，那你就可以称它为向量，并运用我们学到的那些线性变换之类的工具。</strong></p>
<blockquote>
<p>在线性代数的现代理论中，果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足八条公理。如果要让所有已经建立好的理论和概念适用于一个向量空间，那么它必须满足这八条公理，类似“入场券”似的东西。</p>
</blockquote>
<p>这些公理并非基础的自然法则，它们是一个媒介。一边连接着你，也就是发现这些结论的数学家，另一边连接着其他人，也就是想要把这些结论应用于新的向量空间的人。只要向量的定义满足这些公理，就能顺利地应用我们发现的的所有关于向量的结论。</p>
<ul>
<li><p>向量不止是某个“熟面孔”</p>
<p>这就是为什么你阅读的每一本教科书都会根据可加性和成比例来定义线性变换，而不是用网格线保持平行且等距分布什么的来定义。即便后者更加直观。</p>
<p>**向量的形势并不重要。**只要尚量相加和数乘的概念遵守以上规则即可。</p>
<blockquote>
<p>**所以对于“向量是什么”这个问题，数学家会直接忽略不作答。**就好像问 3 这个抽象数字是什么含义一样。</p>
</blockquote>
<p>因此，你往往会把你的所有结论抽象地表述出来，也就是说仅仅根据这些公理表述。而不是集中于某一种特定的向量上，<br>像是空间中的箭头或者函数等</p>
</li>
</ul>
<h2 id="13-Cramer法则-克拉默-克莱姆"><a href="#13-Cramer法则-克拉默-克莱姆" class="headerlink" title="13.Cramer法则(克拉默&#x2F;克莱姆)"></a>13.Cramer法则(克拉默&#x2F;克莱姆)</h2><p>计算线性方程组，往往用高斯消元法，而不用克拉默法则。但了解它的几何意义会帮你加深对线性方程组的理解。</p>
<p>一个线性方程组的小例子；<br>$$<br>\left{\begin{aligned}3x+2y&#x3D;-4 \-x+2y&#x3D;-2\end{aligned}\right.<br>$$</p>
<p>**可以把这个方程组看作对<code>[x y]</code>向量的一个已知的矩阵变换:**而且变换后的结果已知 在这里是[-4;-2]<br>$$<br>\left[\begin{matrix}3 &amp; 2\-1 &amp; 2\end{matrix}\right]\left[\begin{matrix}x \ y\end{matrix}\right]&#x3D;\left[\begin{matrix}-4 \ -2\end{matrix}\right]<br>$$</p>
<blockquote>
<p>注意：矩阵的列向量反映了<strong>矩阵是如何变换</strong>的，<strong>分别告诉了你基向量变换后的位置</strong>——也就是求[2,2] [3,-1]坐标系中的[-4，-2]对应到直角坐标系中是多少</p>
</blockquote>
<p>所以问题变成了 哪个输入向量[x,y] 在变换后会成为[-4;-2]。</p>
<blockquote>
<p>由5.线性方程组那一节，<strong>矩阵A代表一种线性变换，所以 求解Ax&#x3D;v意味着我们去寻找一个向量x，使得它在变换后与v重合。</strong></p>
</blockquote>
<p>这里有两种结果，取决于矩阵变换是否降维（行列式是否为0）。</p>
<ul>
<li><p>如果行列式为0，意味着要么任何输入向量都不会变换到给定的输出向量，要么有无数个向量都会变换到给定的向量。</p>
<blockquote>
<p>以二维空间为例。前一种是二维输入向量的空间压缩成了一条线，而输出向量在线之外；后一种是输出向量恰好在线内，所以所有输入向量都满足。</p>
</blockquote>
</li>
<li><p>行列式不为0是我们今天重点探讨的，意味着线性变换后维数依然相同。</p>
<p>每一个输入向量都对应一个输出向量，反之亦然。</p>
</li>
</ul>
<blockquote>
<p>下面是行列式不为0（不降维）的情况。</p>
</blockquote>
<p>来看一个猜想：<br>$$<br>\left[\begin{matrix}x\y<br>\end{matrix}\right]\left[\begin{matrix}<br>1 \ 0\end{matrix}\right]&#x3D;x\longrightarrow T\left(\left[\begin{matrix}x\y \end{matrix}\right]\right)\cdot T\left(\left[\begin{matrix}1\0\end{matrix}\right]<br>\right)&#x3D;x\\left[\begin{matrix}x\y\end{matrix}\right]\left[\begin{matrix}0\1\end{matrix}\right]&#x3D;y\longrightarrow T\left(\left[\begin{matrix}x\y<br>\end{matrix}\right]\right)\cdot T\left(\left[\begin{matrix}0\1\end{matrix}\right]\right)&#x3D;y\T(向量)是指向量线性变换后<br>$$<br>如果这个情况合理的话，我们能很轻松算出[x;y]的解。因为目标向量<code>[-4 -2]</code> ，两个基向量线性变换后的状态(矩阵)都是已知的。</p>
<p><strong>可惜这个猜想是错误的。</strong>&#x3D;&#x3D;对大多数线性变换来说 点积会随着变换而改变。&#x3D;&#x3D;</p>
<blockquote>
<p>比如说，有两个向量大致指向同一个方向，点积为正，变换后被拉远，像这样它们的点积就变成负数了。类似的<br>就算两向量相互垂直 点积为零 比如两个基向量，我们也无法保证它们在变换后依然相互垂直。</p>
</blockquote>
<p>那些不改变点积的矩阵变换，有一个特殊的名字：<strong>正交变换</strong>。</p>
<p>它们使基向量在变换后依然保持单位长度、且相互垂直，可以想成是旋转矩阵， 相当于作刚体运动没有拉伸压缩或变形。</p>
<p>在正交变换中求解非常简单。<strong>因为点积不变，所以已知的输出向量和矩阵的列向量的点积，分别等同于未知输入向量和各个基向量的点积。</strong></p>
<p>举例：<br>$$<br>\left[\begin{matrix}cos(30°) &amp; -sin(30°)\sin(30°) &amp;  cos(30°)\end{matrix}\right]\left[\begin{matrix}x \ y\end{matrix}\right]&#x3D;\left[\begin{matrix}1 \ 2 \end{matrix}\right]\x&#x3D;\left[\begin{matrix}1 \ 2 \end{matrix}\right]\cdot\left[\begin{matrix}cos(30°) \ sin(30°)\\end{matrix}\right]\qquad<br>y&#x3D;\left[\begin{matrix}1 \ 2 \end{matrix}\right]\cdot\left[\begin{matrix}-sin(30°) \  cos(30°)\end{matrix}\right]<br>$$<br>虽然这个思路对大多数线性方程组都不成立，但它给了我们一个方向去思考，有没有另一种对输出向量坐标值的几何解释。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/3f866f3c3b8640e8a7c845be811cf603.png#pic_center" alt="在这里插入图片描述"></p>
<p>这个由第一个基向量i和未知的输入向量「x;y]组成的平行四边形。面积是x轴基向量i 乘以 输入向量 的y值。</p>
<p>于是&#x3D;&#x3D;我们可以用这个平行四边形的面积来表示y值。&#x3D;&#x3D;</p>
<blockquote>
<p>当然面积是有向的。如果向量的v坐标为负，则四边形面积也为负。</p>
<p>（前提是你把基向量i放在第一位来定义平行四边形）</p>
</blockquote>
<p>同样观察由未知的输入向量，和第二基向量j组成的平行四边形。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/f2af9781d6254591b4c525479b38d5e5.png#pic_center" alt="在这里插入图片描述"></p>
<p>以此类比：看三维空间。</p>
<blockquote>
<p>对于向量的z轴坐标，可能你的第一反应是向量在z轴上投影的坐标值，是它与第三个基向量k的点。但……</p>
</blockquote>
<p>更好的方法还是<strong>考虑基向量</strong>：考虑向量与另外两个基向量i和i所组成的平行六面体，底面是由基向量i和i组成的正方形，面积是1。</p>
<p>&#x3D;&#x3D;所以它的体积值等同与它的高 也就是我们这个向量的z坐标&#x3D;&#x3D;</p>
<p><img src="https://i-blog.csdnimg.cn/direct/b89e8fd1271c43cfbd59698767e6ce7f.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/fc0c3398472440dcba92c362047f2c74.png#pic_center" alt="在这里插入图片描述"></p>
<p>同样的，用这个奇怪的方法来描述向量在某一个轴上的坐标值，<strong>可以先考虑向量本身，和除这个轴之外的两个基向量组成的平行六面体，然后其体积就是对应的坐标值。</strong></p>
<blockquote>
<p>另外 我们可以讨论平行六面体体积的&#x3D;&#x3D;有向性&#x3D;&#x3D;，就是之前在行列式视频中提到的右手法则。<strong>于是列向量的顺序就很重要了，坐标的正负性也有了意义。</strong></p>
<p>注意考虑有向面积，这对于我们拓展到高维的计算很有用，也就会明白“为什么变换后行列式是这么算的。</p>
</blockquote>
<p>$$<br>\mathbf{x}&#x3D;det\left(\left[\begin{matrix}\mathbf{x} &amp; 0 &amp; 0 \y &amp; 1 &amp; 0 \z &amp; 0 &amp; 1\end{matrix}\right]\right)\qquad\mathbf{y}&#x3D;det<br>\left(\left[\begin{matrix}<br>x &amp; 0 &amp; 0 \\mathbf{y} &amp; 1 &amp; 0 \<br>z &amp; 0 &amp; 1\end{matrix}\right]\right)\qquad\mathbf{z}&#x3D;det\left(\left[\begin{matrix}x &amp; 0 &amp; 0 \y &amp; 1 &amp; 0 \\mathbf{z} &amp; 0 &amp; 1\end{matrix}\right]\right)<br>$$</p>
<blockquote>
<p><strong>注意加粗。</strong></p>
</blockquote>
<p>好了 为什么要把坐标值和面积或体积联系起来呢？因为当你<strong>做矩阵变换后，平行四边形的面积不一定保持不变，可能成比例增大或减小。</strong></p>
<p>&#x3D;&#x3D;成比例放缩意味着，我们要引入行列式了——&#x3D;&#x3D;</p>
<blockquote>
<p>由4.行列式那一节：<strong>行列式代表测量一个给定区域面积增大或减小的比例</strong></p>
</blockquote>
<p>举个例子(一个新的平行四边形)：<br>$$<br>\left[\begin{matrix}2 &amp; -1\0 &amp; 1\end{matrix}\right]\left[\begin{matrix}x \ y\end{matrix}\right]&#x3D;\left[\begin{matrix}4 \ 2\end{matrix}\right]<br>$$<br>比如 考虑一个新的平行四边形，第一条边是变换后的第一基向量(也就是矩阵的第一列)<code>[2 0</code>]。第二条边是变换后的<code>[x,y]</code> 那它的面积是多大呢？</p>
<blockquote>
<p>变换前的面积是未知输入向量的y坐标值，所以变换后的面积等于<strong>矩阵的行列式</strong>乘以y值</p>
</blockquote>
<p>所以可以用输出的平行四边形面积，除以矩阵的行列式计算出y。<br>$$<br>y &#x3D; \frac{area}{det(A)}<br>$$<br>&#x3D;&#x3D;那怎么求变换后的面积area呢？&#x3D;&#x3D;</p>
<p>因为这是一个线性方程组，我们知道线性变换后的向量<code>[4 2]</code>。</p>
<p><strong>既然我们已知最终变换后的向量,那么 可以构造一个新矩阵</strong> 第一列和我们原先的矩阵相同<code>[2 0]</code>,而第二列是输出向量。 然后取这个新矩阵的行列式——</p>
<p>你看，我们只需使用到变换后的两个向量，也就是矩阵的列向量们和已知输出问量，就能计算得出未知输入向量的y值。方程已经解好一半了。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/18ac7c32941c41b1933a6939dc77c96c.png#pic_center" alt="在这里插入图片描述"><br>$$<br>area &#x3D; \left(\left[\begin{matrix}2 &amp; 4 \0 &amp; 2 \end{matrix}\right]\right)\qquad y &#x3D; \frac{area}{det(A)}<br>$$<br>我们可以用同样方法得到 x 值。</p>
<p>我们之前定义的平行四边形回头来看。</p>
<p>(有向)面积为输入向量的x值 由未知向量和j基向量构成，而变换后的它 由输出向量和矩阵的第二列组成。面积增大的比例是矩阵的行列式，<strong>所以输入向量的x值是新的面积除以变换矩阵的行列式。</strong></p>
<p>于是可以创造一个新矩阵来计算变换后的平行四边形的面积，这个新矩阵第一列为输出向量 第二列和变换矩阵相同。</p>
<p>所以和上面的错误猜想一样，<strong>我们仅使用到输出部分的数值</strong>(这些我们在最初线性方程组里已知的数值) ， **就能解出x值。**是不是很神奇！</p>
<p><strong>这个线性方程组的解法 被称为克莱姆法则</strong></p>
</article>
<div class="article-footer">

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/NOTE/Crash%20Course%20CS/">Crash Course CS</a></div></section></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body beaudar'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="Back2Zer0/blog-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Fancy</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">
<widget class="widget-wrapper ghrepo"><div class="widget-body"><div class="items data-service ds-ghinfo" data-api="https://api.github.com/repos/Back2Zer0/md-CS_Note"><a class="repo" href="https://github.com/Back2Zer0/md-CS_Note" target="_blank" rel="external nofollow noopener noreferrer"><div class="repo-name flex-row"><svg aria-hidden="true" role="img" class="color-icon-primary" viewBox="0 0 16 16" width="1em" height="1em" fill="currentColor" style="user-select:none;overflow:visible"><path fill-rule="evenodd" d="M2 2.5A2.5 2.5 0 014.5 0h8.75a.75.75 0 01.75.75v12.5a.75.75 0 01-.75.75h-2.5a.75.75 0 110-1.5h1.75v-2h-8a1 1 0 00-.714 1.7.75.75 0 01-1.072 1.05A2.495 2.495 0 012 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 011-1h8zM5 12.25v3.25a.25.25 0 00.4.2l1.45-1.087a.25.25 0 01.3 0L8.6 15.7a.25.25 0 00.4-.2v-3.25a.25.25 0 00-.25-.25h-3.5a.25.25 0 00-.25.25z"></path></svg>Back2Zer0/md-CS_Note</div><div class="repo-desc"><span type="text" id="description">&nbsp;</span></div><div class="grid"><div class="flex-row"><svg aria-hidden="true" role="img" class="color-icon-primary" viewBox="0 0 16 16" width="1em" height="1em" fill="currentColor" style="user-select:none;overflow:visible"><path fill-rule="evenodd" d="M8 .25a.75.75 0 01.673.418l1.882 3.815 4.21.612a.75.75 0 01.416 1.279l-3.046 2.97.719 4.192a.75.75 0 01-1.088.791L8 12.347l-3.766 1.98a.75.75 0 01-1.088-.79l.72-4.194L.818 6.374a.75.75 0 01.416-1.28l4.21-.611L7.327.668A.75.75 0 018 .25zm0 2.445L6.615 5.5a.75.75 0 01-.564.41l-3.097.45 2.24 2.184a.75.75 0 01.216.664l-.528 3.084 2.769-1.456a.75.75 0 01.698 0l2.77 1.456-.53-3.084a.75.75 0 01.216-.664l2.24-2.183-3.096-.45a.75.75 0 01-.564-.41L8 2.694v.001z"></path></svg><span type="text" id="stargazers_count"></span></div><div class="flex-row"><svg aria-hidden="true" role="img" class="color-icon-primary" viewBox="0 0 16 16" width="1em" height="1em" fill="currentColor" style="user-select:none;overflow:visible"><path fill-rule="evenodd" d="M5 3.25a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm0 2.122a2.25 2.25 0 10-1.5 0v.878A2.25 2.25 0 005.75 8.5h1.5v2.128a2.251 2.251 0 101.5 0V8.5h1.5a2.25 2.25 0 002.25-2.25v-.878a2.25 2.25 0 10-1.5 0v.878a.75.75 0 01-.75.75h-4.5A.75.75 0 015 6.25v-.878zm3.75 7.378a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm3-8.75a.75.75 0 100-1.5.75.75 0 000 1.5z"></path></svg><span type="text" id="forks_count"></span></div><div class="flex-row data-service ds-ghinfo" index="0" data-api="https://api.github.com/repos/Back2Zer0/md-CS_Note/tags"><svg aria-hidden="true" role="img" class="color-icon-primary" viewBox="0 0 16 16" width="1em" height="1em" fill="currentColor" style="user-select:none;overflow:visible"><path fill-rule="evenodd" d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z"></path></svg><span type="text" id="latest-tag-name">0</span></div></div></a></div></div></widget>


<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E2%80%9C%E7%BA%BF%E6%80%A7%E2%80%9D"><span class="toc-text">0.线性代数的“线性”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3"><span class="toc-text">1.线性相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E5%90%91%E9%87%8F"><span class="toc-text">2.基向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%88%E5%8A%B2%E7%88%86%EF%BC%89"><span class="toc-text">3.线性变换（劲爆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-text">4.行列式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-text">5.线性方程组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%A7%A9-Rank"><span class="toc-text">6.秩 (Rank)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%9D%9E%E6%96%B9%E9%98%B5%E7%9F%A9%E9%98%B5"><span class="toc-text">7. 非方阵矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%82%B9%E4%B9%98%E5%92%8C%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%88%E7%9B%B8%E5%BD%93%E5%8A%B2%E7%88%86%EF%BC%89"><span class="toc-text">8.点乘和线性变换（相当劲爆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8F%89%E4%B9%98"><span class="toc-text">9.叉乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9F%BA%E5%8F%98%E6%8D%A2"><span class="toc-text">10.基变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F"><span class="toc-text">11.特征值和特征向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%8A%BD%E8%B1%A1%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4"><span class="toc-text">12.抽象向量空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Cramer%E6%B3%95%E5%88%99-%E5%85%8B%E6%8B%89%E9%BB%98-%E5%85%8B%E8%8E%B1%E5%A7%86"><span class="toc-text">13.Cramer法则(克拉默&#x2F;克莱姆)</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #beaudar');
  util.viewportLazyload(el, load_beaudar, false);

  function load_beaudar() {
    if (!el) return;
    try {
      el.innerHTML = '';
    } catch (error) {
      console.error(error);
    }
    const script = document.createElement('script');
    script.src = 'https://beaudar.lipk.org/client.js';
    script.async = true;
    for (const key of Object.keys(el.attributes)) {
      const attr = el.attributes[key];
      if (['class', 'id'].includes(attr.name) === false) {
        script.setAttribute(attr.name, attr.value);
      }
    }
    el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>

<script id="MathJax-script" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
